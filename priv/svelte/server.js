var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE, EACH_INDEX_REACTIVE, EACH_IS_CONTROLLED, EACH_IS_ANIMATED, EACH_ITEM_IMMUTABLE, PROPS_IS_IMMUTABLE, PROPS_IS_RUNES, PROPS_IS_UPDATED, PROPS_IS_BINDABLE, PROPS_IS_LAZY_INITIAL, TRANSITION_IN, TRANSITION_OUT, TRANSITION_GLOBAL, TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE, TEMPLATE_USE_SVG, TEMPLATE_USE_MATHML, HYDRATION_START, HYDRATION_START_ELSE, HYDRATION_END, HYDRATION_ERROR, ELEMENT_IS_NAMESPACED, ELEMENT_PRESERVE_ATTRIBUTE_CASE, ELEMENT_IS_INPUT, UNINITIALIZED, FILENAME, HMR, NAMESPACE_HTML, NAMESPACE_SVG, NAMESPACE_MATHML, ATTACHMENT_KEY;
var init_constants = __esm({
  "node_modules/svelte/src/constants.js"() {
    EACH_ITEM_REACTIVE = 1;
    EACH_INDEX_REACTIVE = 1 << 1;
    EACH_IS_CONTROLLED = 1 << 2;
    EACH_IS_ANIMATED = 1 << 3;
    EACH_ITEM_IMMUTABLE = 1 << 4;
    PROPS_IS_IMMUTABLE = 1;
    PROPS_IS_RUNES = 1 << 1;
    PROPS_IS_UPDATED = 1 << 2;
    PROPS_IS_BINDABLE = 1 << 3;
    PROPS_IS_LAZY_INITIAL = 1 << 4;
    TRANSITION_IN = 1;
    TRANSITION_OUT = 1 << 1;
    TRANSITION_GLOBAL = 1 << 2;
    TEMPLATE_FRAGMENT = 1;
    TEMPLATE_USE_IMPORT_NODE = 1 << 1;
    TEMPLATE_USE_SVG = 1 << 2;
    TEMPLATE_USE_MATHML = 1 << 3;
    HYDRATION_START = "[";
    HYDRATION_START_ELSE = "[!";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    ELEMENT_IS_NAMESPACED = 1;
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    ELEMENT_IS_INPUT = 1 << 2;
    UNINITIALIZED = Symbol();
    FILENAME = Symbol("filename");
    HMR = Symbol("hmr");
    NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
    NAMESPACE_SVG = "http://www.w3.org/2000/svg";
    NAMESPACE_MATHML = "http://www.w3.org/1998/Math/MathML";
    ATTACHMENT_KEY = "@attach";
  }
});

// node_modules/svelte/src/escaping.js
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped2 = "";
  let last = 0;
  while (pattern.test(str)) {
    const i = pattern.lastIndex - 1;
    const ch = str[i];
    escaped2 += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped2 + str.substring(last);
}
var ATTR_REGEX, CONTENT_REGEX;
var init_escaping = __esm({
  "node_modules/svelte/src/escaping.js"() {
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
  }
});

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
  }
});

// node_modules/svelte/src/internal/shared/attributes.js
function attr(name, value, is_boolean = false) {
  if (name === "hidden" && value !== "until-found") {
    is_boolean = true;
  }
  if (value == null || !value && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value) || value;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
function clsx2(value) {
  if (typeof value === "object") {
    return clsx(value);
  } else {
    return value ?? "";
  }
}
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i = 0; i < len; i++) {
        var c = value[i];
        if (in_comment) {
          if (c === "/" && value[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c) {
            in_str = false;
          }
        } else if (c === "/" && value[i + 1] === "*") {
          in_comment = true;
        } else if (c === '"' || c === "'") {
          in_str = c;
        } else if (c === "(") {
          in_apo++;
        } else if (c === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c === ":" && name_index === -1) {
            name_index = i;
          } else if (c === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c !== ";") {
                  i++;
                }
                var property = value.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}
var replacements, whitespace;
var init_attributes = __esm({
  "node_modules/svelte/src/internal/shared/attributes.js"() {
    init_escaping();
    init_clsx();
    replacements = {
      translate: /* @__PURE__ */ new Map([
        [true, "yes"],
        [false, "no"]
      ])
    };
    whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
  }
});

// node_modules/svelte/src/internal/shared/utils.js
function is_function(thing) {
  return typeof thing === "function";
}
function is_promise(value) {
  return typeof value?.then === "function";
}
function run(fn) {
  return fn();
}
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function fallback(value, fallback2, lazy = false) {
  return value === void 0 ? lazy ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value;
}
function to_array(value, n) {
  if (Array.isArray(value)) {
    return value;
  }
  if (n === void 0 || !(Symbol.iterator in value)) {
    return Array.from(value);
  }
  const array = [];
  for (const element3 of value) {
    array.push(element3);
    if (array.length === n) break;
  }
  return array;
}
var is_array, index_of, array_from, object_keys, define_property, get_descriptor, get_descriptors, object_prototype, array_prototype, get_prototype_of, is_extensible, noop;
var init_utils = __esm({
  "node_modules/svelte/src/internal/shared/utils.js"() {
    is_array = Array.isArray;
    index_of = Array.prototype.indexOf;
    array_from = Array.from;
    object_keys = Object.keys;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    get_descriptors = Object.getOwnPropertyDescriptors;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    is_extensible = Object.isExtensible;
    noop = () => {
    };
  }
});

// node_modules/esm-env/false.js
var false_default;
var init_false = __esm({
  "node_modules/esm-env/false.js"() {
    false_default = false;
  }
});

// node_modules/esm-env/true.js
var true_default;
var init_true = __esm({
  "node_modules/esm-env/true.js"() {
    true_default = true;
  }
});

// node_modules/esm-env/index.js
var init_esm_env = __esm({
  "node_modules/esm-env/index.js"() {
    init_false();
    init_true();
    init_true();
  }
});

// node_modules/svelte/src/internal/client/constants.js
var DERIVED, EFFECT, RENDER_EFFECT, MANAGED_EFFECT, BLOCK_EFFECT, BRANCH_EFFECT, ROOT_EFFECT, BOUNDARY_EFFECT, CONNECTED, CLEAN, DIRTY, MAYBE_DIRTY, INERT, DESTROYED, EFFECT_RAN, EFFECT_TRANSPARENT, EAGER_EFFECT, HEAD_EFFECT, EFFECT_PRESERVED, USER_EFFECT, WAS_MARKED, REACTION_IS_UPDATING, ASYNC, ERROR_VALUE, STATE_SYMBOL, LEGACY_PROPS, LOADING_ATTR_SYMBOL, PROXY_PATH_SYMBOL, STALE_REACTION, ELEMENT_NODE, TEXT_NODE, COMMENT_NODE, DOCUMENT_FRAGMENT_NODE;
var init_constants2 = __esm({
  "node_modules/svelte/src/internal/client/constants.js"() {
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    RENDER_EFFECT = 1 << 3;
    MANAGED_EFFECT = 1 << 24;
    BLOCK_EFFECT = 1 << 4;
    BRANCH_EFFECT = 1 << 5;
    ROOT_EFFECT = 1 << 6;
    BOUNDARY_EFFECT = 1 << 7;
    CONNECTED = 1 << 9;
    CLEAN = 1 << 10;
    DIRTY = 1 << 11;
    MAYBE_DIRTY = 1 << 12;
    INERT = 1 << 13;
    DESTROYED = 1 << 14;
    EFFECT_RAN = 1 << 15;
    EFFECT_TRANSPARENT = 1 << 16;
    EAGER_EFFECT = 1 << 17;
    HEAD_EFFECT = 1 << 18;
    EFFECT_PRESERVED = 1 << 19;
    USER_EFFECT = 1 << 20;
    WAS_MARKED = 1 << 15;
    REACTION_IS_UPDATING = 1 << 21;
    ASYNC = 1 << 22;
    ERROR_VALUE = 1 << 23;
    STATE_SYMBOL = Symbol("$state");
    LEGACY_PROPS = Symbol("legacy props");
    LOADING_ATTR_SYMBOL = Symbol("");
    PROXY_PATH_SYMBOL = Symbol("proxy path");
    STALE_REACTION = new class StaleReactionError extends Error {
      name = "StaleReactionError";
      message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
    }();
    ELEMENT_NODE = 1;
    TEXT_NODE = 3;
    COMMENT_NODE = 8;
    DOCUMENT_FRAGMENT_NODE = 11;
  }
});

// node_modules/svelte/src/internal/shared/errors.js
function experimental_async_required(name) {
  if (true_default) {
    const error = new Error(`experimental_async_required
Cannot use \`${name}(...)\` unless the \`experimental.async\` compiler option is \`true\`
https://svelte.dev/e/experimental_async_required`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/experimental_async_required`);
  }
}
function invalid_default_snippet() {
  if (true_default) {
    const error = new Error(`invalid_default_snippet
Cannot use \`{@render children(...)}\` if the parent component uses \`let:\` directives. Consider using a named snippet instead
https://svelte.dev/e/invalid_default_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_default_snippet`);
  }
}
function invalid_snippet_arguments() {
  if (true_default) {
    const error = new Error(`invalid_snippet_arguments
A snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`
https://svelte.dev/e/invalid_snippet_arguments`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
  }
}
function lifecycle_outside_component(name) {
  if (true_default) {
    const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
function snippet_without_render_tag() {
  if (true_default) {
    const error = new Error(`snippet_without_render_tag
Attempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.
https://svelte.dev/e/snippet_without_render_tag`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
  }
}
function store_invalid_shape(name) {
  if (true_default) {
    const error = new Error(`store_invalid_shape
\`${name}\` is not a store with a \`subscribe\` method
https://svelte.dev/e/store_invalid_shape`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/store_invalid_shape`);
  }
}
function svelte_element_invalid_this_value() {
  if (true_default) {
    const error = new Error(`svelte_element_invalid_this_value
The \`this\` prop on \`<svelte:element>\` must be a string, if defined
https://svelte.dev/e/svelte_element_invalid_this_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
  }
}
var init_errors = __esm({
  "node_modules/svelte/src/internal/shared/errors.js"() {
    init_esm_env();
  }
});

// node_modules/svelte/src/internal/client/errors.js
function async_derived_orphan() {
  if (true_default) {
    const error = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
function bind_invalid_checkbox_value() {
  if (true_default) {
    const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
  }
}
function component_api_changed(method, component2) {
  if (true_default) {
    const error = new Error(`component_api_changed
Calling \`${method}\` on a component instance (of ${component2}) is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_changed`);
  }
}
function component_api_invalid_new(component2, name) {
  if (true_default) {
    const error = new Error(`component_api_invalid_new
Attempted to instantiate ${component2} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
  }
}
function derived_references_self() {
  if (true_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function each_key_duplicate(a, b, value) {
  if (true_default) {
    const error = new Error(`each_key_duplicate
${value ? `Keyed each block has duplicate key \`${value}\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}
https://svelte.dev/e/each_key_duplicate`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/each_key_duplicate`);
  }
}
function effect_in_teardown(rune) {
  if (true_default) {
    const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
function effect_in_unowned_derived() {
  if (true_default) {
    const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
function effect_orphan(rune) {
  if (true_default) {
    const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
function effect_pending_outside_reaction() {
  if (true_default) {
    const error = new Error(`effect_pending_outside_reaction
\`$effect.pending()\` can only be called inside an effect or derived
https://svelte.dev/e/effect_pending_outside_reaction`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_pending_outside_reaction`);
  }
}
function effect_update_depth_exceeded() {
  if (true_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function hydration_failed() {
  if (true_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function invalid_snippet() {
  if (true_default) {
    const error = new Error(`invalid_snippet
Could not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`
https://svelte.dev/e/invalid_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet`);
  }
}
function props_invalid_value(key2) {
  if (true_default) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key2}={undefined}\` when \`${key2}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
function props_rest_readonly(property) {
  if (true_default) {
    const error = new Error(`props_rest_readonly
Rest element properties of \`$props()\` such as \`${property}\` are readonly
https://svelte.dev/e/props_rest_readonly`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_rest_readonly`);
  }
}
function rune_outside_svelte(rune) {
  if (true_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function state_descriptors_fixed() {
  if (true_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (true_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (true_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (true_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
var init_errors2 = __esm({
  "node_modules/svelte/src/internal/client/errors.js"() {
    init_esm_env();
    init_errors();
  }
});

// node_modules/svelte/src/internal/client/warnings.js
function assignment_value_stale(property, location2) {
  if (true_default) {
    console.warn(`%c[svelte] assignment_value_stale
%cAssignment to \`${property}\` property (${location2}) will evaluate to the right-hand side, not the value of \`${property}\` following the assignment. This may result in unexpected behaviour.
https://svelte.dev/e/assignment_value_stale`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/assignment_value_stale`);
  }
}
function await_waterfall(name, location2) {
  if (true_default) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name}\` (${location2}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
function binding_property_non_reactive(binding, location2) {
  if (true_default) {
    console.warn(
      `%c[svelte] binding_property_non_reactive
%c${location2 ? `\`${binding}\` (${location2}) is binding to a non-reactive property` : `\`${binding}\` is binding to a non-reactive property`}
https://svelte.dev/e/binding_property_non_reactive`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/binding_property_non_reactive`);
  }
}
function console_log_state(method) {
  if (true_default) {
    console.warn(`%c[svelte] console_log_state
%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead
https://svelte.dev/e/console_log_state`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/console_log_state`);
  }
}
function event_handler_invalid(handler, suggestion) {
  if (true_default) {
    console.warn(`%c[svelte] event_handler_invalid
%c${handler} should be a function. Did you mean to ${suggestion}?
https://svelte.dev/e/event_handler_invalid`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/event_handler_invalid`);
  }
}
function hydration_attribute_changed(attribute, html3, value) {
  if (true_default) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html3}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
function hydration_html_changed(location2) {
  if (true_default) {
    console.warn(
      `%c[svelte] hydration_html_changed
%c${location2 ? `The value of an \`{@html ...}\` block ${location2} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_html_changed`);
  }
}
function hydration_mismatch(location2) {
  if (true_default) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location2 ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location2}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (true_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function ownership_invalid_binding(parent, prop2, child2, owner) {
  if (true_default) {
    console.warn(`%c[svelte] ownership_invalid_binding
%c${parent} passed property \`${prop2}\` to ${child2} with \`bind:\`, but its parent component ${owner} did not declare \`${prop2}\` as a binding. Consider creating a binding between ${owner} and ${parent} (e.g. \`bind:${prop2}={...}\` instead of \`${prop2}={...}\`)
https://svelte.dev/e/ownership_invalid_binding`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
  }
}
function ownership_invalid_mutation(name, location2, prop2, parent) {
  if (true_default) {
    console.warn(`%c[svelte] ownership_invalid_mutation
%cMutating unbound props (\`${name}\`, at ${location2}) is strongly discouraged. Consider using \`bind:${prop2}={...}\` in ${parent} (or using a callback) instead
https://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
  }
}
function select_multiple_invalid_value() {
  if (true_default) {
    console.warn(`%c[svelte] select_multiple_invalid_value
%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.
https://svelte.dev/e/select_multiple_invalid_value`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (true_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function state_proxy_unmount() {
  if (true_default) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
function svelte_boundary_reset_noop() {
  if (true_default) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
var bold, normal;
var init_warnings = __esm({
  "node_modules/svelte/src/internal/client/warnings.js"() {
    init_esm_env();
    bold = "font-weight: bold";
    normal = "font-weight: normal";
  }
});

// node_modules/svelte/src/internal/client/dom/hydration.js
function set_hydrating(value) {
  hydrating = value;
}
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    get_next_sibling(hydrate_node)
  );
}
function reset(node) {
  if (!hydrating) return;
  if (get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
function hydrate_template(template) {
  if (hydrating) {
    hydrate_node = template.content;
  }
}
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    if (remove) node.remove();
    node = next2;
  }
}
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (
    /** @type {Comment} */
    node.data
  );
}
var hydrating, hydrate_node;
var init_hydration = __esm({
  "node_modules/svelte/src/internal/client/dom/hydration.js"() {
    init_constants2();
    init_constants();
    init_warnings();
    init_operations();
    hydrating = false;
  }
});

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
var init_equality = __esm({
  "node_modules/svelte/src/internal/client/reactivity/equality.js"() {
  }
});

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag, legacy_mode_flag, tracing_mode_flag;
var init_flags = __esm({
  "node_modules/svelte/src/internal/flags/index.js"() {
    async_mode_flag = false;
    legacy_mode_flag = false;
    tracing_mode_flag = false;
  }
});

// node_modules/svelte/src/internal/shared/warnings.js
function dynamic_void_element_content(tag2) {
  if (true_default) {
    console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag2}">\` is a void element \u2014 it cannot have content
https://svelte.dev/e/dynamic_void_element_content`, bold2, normal2);
  } else {
    console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
  }
}
function state_snapshot_uncloneable(properties) {
  if (true_default) {
    console.warn(
      `%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` \u2014 the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` \u2014 the original value was returned"}
https://svelte.dev/e/state_snapshot_uncloneable`,
      bold2,
      normal2
    );
  } else {
    console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
  }
}
var bold2, normal2;
var init_warnings2 = __esm({
  "node_modules/svelte/src/internal/shared/warnings.js"() {
    init_esm_env();
    bold2 = "font-weight: bold";
    normal2 = "font-weight: normal";
  }
});

// node_modules/svelte/src/internal/shared/clone.js
function snapshot(value, skip_warning = false, no_tojson = false) {
  if (true_default && !skip_warning) {
    const paths = [];
    const copy = clone(value, /* @__PURE__ */ new Map(), "", paths, null, no_tojson);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone(value, /* @__PURE__ */ new Map(), "", empty, null, no_tojson);
}
function clone(value, cloned, path, paths, original = null, no_tojson = false) {
  if (typeof value === "object" && value !== null) {
    var unwrapped = cloned.get(value);
    if (unwrapped !== void 0) return unwrapped;
    if (value instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(value)
    );
    if (value instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(value)
    );
    if (is_array(value)) {
      var copy = (
        /** @type {Snapshot<any>} */
        Array(value.length)
      );
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var i = 0; i < value.length; i += 1) {
        var element3 = value[i];
        if (i in value) {
          copy[i] = clone(element3, cloned, true_default ? `${path}[${i}]` : path, paths, null, no_tojson);
        }
      }
      return copy;
    }
    if (get_prototype_of(value) === object_prototype) {
      copy = {};
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var key2 in value) {
        copy[key2] = clone(
          // @ts-expect-error
          value[key2],
          cloned,
          true_default ? `${path}.${key2}` : path,
          paths,
          null,
          no_tojson
        );
      }
      return copy;
    }
    if (value instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value.toJSON === "function" && !no_tojson) {
      return clone(
        /** @type {T & { toJSON(): any } } */
        value.toJSON(),
        cloned,
        true_default ? `${path}.toJSON()` : path,
        paths,
        // Associate the instance with the toJSON clone
        value
      );
    }
  }
  if (value instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value)
    );
  } catch (e) {
    if (true_default) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
}
var empty;
var init_clone = __esm({
  "node_modules/svelte/src/internal/shared/clone.js"() {
    init_esm_env();
    init_warnings2();
    init_utils();
    empty = [];
  }
});

// node_modules/svelte/src/internal/client/dev/tracing.js
function log_entry(signal, entry) {
  const value = signal.v;
  if (value === UNINITIALIZED) {
    return;
  }
  const type = get_type(signal);
  const current_reaction = (
    /** @type {Reaction} */
    active_reaction
  );
  const dirty = signal.wv > current_reaction.wv || current_reaction.wv === 0;
  const style = dirty ? "color: CornflowerBlue; font-weight: bold" : "color: grey; font-weight: normal";
  console.groupCollapsed(
    signal.label ? `%c${type}%c ${signal.label}` : `%c${type}%c`,
    style,
    dirty ? "font-weight: normal" : style,
    typeof value === "object" && value !== null && STATE_SYMBOL in value ? snapshot(value, true) : value
  );
  if (type === "$derived") {
    const deps = new Set(
      /** @type {Derived} */
      signal.deps
    );
    for (const dep of deps) {
      log_entry(dep);
    }
  }
  if (signal.created) {
    console.log(signal.created);
  }
  if (dirty && signal.updated) {
    for (const updated of signal.updated.values()) {
      if (updated.error) {
        console.log(updated.error);
      }
    }
  }
  if (entry) {
    for (var trace2 of entry.traces) {
      console.log(trace2);
    }
  }
  console.groupEnd();
}
function get_type(signal) {
  if ((signal.f & (DERIVED | ASYNC)) !== 0) return "$derived";
  return signal.label?.startsWith("$") ? "store" : "$state";
}
function trace(label, fn) {
  var previously_tracing_expressions = tracing_expressions;
  try {
    tracing_expressions = { entries: /* @__PURE__ */ new Map(), reaction: active_reaction };
    var start = performance.now();
    var value = fn();
    var time = (performance.now() - start).toFixed(2);
    var prefix = untrack(label);
    if (!effect_tracking()) {
      console.log(`${prefix} %cran outside of an effect (${time}ms)`, "color: grey");
    } else if (tracing_expressions.entries.size === 0) {
      console.log(`${prefix} %cno reactive dependencies (${time}ms)`, "color: grey");
    } else {
      console.group(`${prefix} %c(${time}ms)`, "color: grey");
      var entries = tracing_expressions.entries;
      untrack(() => {
        for (const [signal, traces] of entries) {
          log_entry(signal, traces);
        }
      });
      tracing_expressions = null;
      console.groupEnd();
    }
    return value;
  } finally {
    tracing_expressions = previously_tracing_expressions;
  }
}
function tag(source2, label) {
  source2.label = label;
  tag_proxy(source2.v, label);
  return source2;
}
function tag_proxy(value, label) {
  value?.[PROXY_PATH_SYMBOL]?.(label);
  return value;
}
var tracing_expressions;
var init_tracing = __esm({
  "node_modules/svelte/src/internal/client/dev/tracing.js"() {
    init_constants();
    init_clone();
    init_constants2();
    init_effects();
    init_runtime();
    tracing_expressions = null;
  }
});

// node_modules/svelte/src/internal/shared/dev.js
function get_error(label) {
  const error = new Error();
  const stack2 = get_stack();
  if (stack2.length === 0) {
    return null;
  }
  stack2.unshift("\n");
  define_property(error, "stack", {
    value: stack2.join("\n")
  });
  define_property(error, "name", {
    value: label
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
function get_stack() {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  const stack2 = new Error().stack;
  Error.stackTraceLimit = limit;
  if (!stack2) return [];
  const lines = stack2.split("\n");
  const new_lines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const posixified = line.replaceAll("\\", "/");
    if (line.trim() === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return [];
    }
    if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) {
      continue;
    }
    new_lines.push(line);
  }
  return new_lines;
}
var init_dev = __esm({
  "node_modules/svelte/src/internal/shared/dev.js"() {
    init_utils();
  }
});

// node_modules/svelte/src/internal/client/context.js
function set_component_context(context2) {
  component_context = context2;
}
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
function add_svelte_meta(callback, type, component2, line, column, additional) {
  const parent = dev_stack;
  dev_stack = {
    type,
    file: component2[FILENAME],
    line,
    column,
    parent,
    ...additional
  };
  try {
    return callback();
  } finally {
    dev_stack = parent;
  }
}
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (true_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var context2 = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context2.e;
  if (effects !== null) {
    context2.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context2.x = component2;
  }
  context2.i = true;
  component_context = context2.p;
  if (true_default) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component2 ?? /** @type {T} */
  {};
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
var component_context, dev_stack, dev_current_component_function;
var init_context = __esm({
  "node_modules/svelte/src/internal/client/context.js"() {
    init_esm_env();
    init_errors2();
    init_runtime();
    init_effects();
    init_flags();
    init_constants();
    init_constants2();
    component_context = null;
    dev_stack = null;
    dev_current_component_function = null;
  }
});

// node_modules/svelte/src/internal/client/dom/task.js
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
var micro_tasks;
var init_task = __esm({
  "node_modules/svelte/src/internal/client/dom/task.js"() {
    init_utils();
    init_batch();
    micro_tasks = [];
  }
});

// node_modules/svelte/src/internal/client/error-handling.js
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (true_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (true_default && !effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e) {
        error = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (true_default && error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect2) {
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${effect2.fn?.name || "<unknown>"}`;
  var context2 = effect2.ctx;
  while (context2 !== null) {
    component_stack += `
${indent}in ${context2.function?.[FILENAME].split("/").pop()}`;
    context2 = context2.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: error.stack?.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}
var adjustments;
var init_error_handling = __esm({
  "node_modules/svelte/src/internal/client/error-handling.js"() {
    init_esm_env();
    init_constants();
    init_operations();
    init_constants2();
    init_utils();
    init_runtime();
    adjustments = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/svelte/src/internal/client/reactivity/batch.js
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  var source_stacks = true_default ? /* @__PURE__ */ new Set() : null;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (true_default) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of source2.updated ?? []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            if (update2.error) {
              console.error(update2.error);
            }
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
      if (true_default) {
        for (const source2 of batch.current.keys()) {
          source_stacks.add(source2);
        }
      }
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
    if (true_default) {
      for (
        const source2 of
        /** @type {Set<Source>} */
        source_stacks
      ) {
        source2.updated = null;
      }
    }
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (true_default) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          if ((e.f & (DESTROYED | INERT)) !== 0) continue;
          const ordered_effects = [e];
          let ancestor = e.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j = ordered_effects.length - 1; j >= 0; j--) {
            const e2 = ordered_effects[j];
            if ((e2.f & (DESTROYED | INERT)) !== 0) continue;
            update_effect(e2);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources, marked, checked) {
  if (marked.has(value)) return;
  marked.add(value);
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== void 0) return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked
      )) {
        checked.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0 && (flags2 & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
function eager_flush() {
  try {
    flushSync(() => {
      for (const version of eager_versions) {
        update(version);
      }
    });
  } finally {
    eager_versions = [];
  }
}
function eager(fn) {
  var version = source(0);
  var initial = true;
  var value = (
    /** @type {T} */
    void 0
  );
  get(version);
  eager_effect(() => {
    if (initial) {
      var previous_batch_values = batch_values;
      try {
        batch_values = null;
        value = fn();
      } finally {
        batch_values = previous_batch_values;
      }
      return;
    }
    if (eager_versions.length === 0) {
      queue_micro_task(eager_flush);
    }
    eager_versions.push(version);
  });
  initial = false;
  return value;
}
var batches, current_batch, previous_batch, batch_values, queued_root_effects, last_scheduled_effect, is_flushing, is_flushing_sync, Batch, eager_block_effects, eager_versions;
var init_batch = __esm({
  "node_modules/svelte/src/internal/client/reactivity/batch.js"() {
    init_constants2();
    init_flags();
    init_utils();
    init_runtime();
    init_errors2();
    init_task();
    init_esm_env();
    init_error_handling();
    init_sources();
    init_effects();
    batches = /* @__PURE__ */ new Set();
    current_batch = null;
    previous_batch = null;
    batch_values = null;
    queued_root_effects = [];
    last_scheduled_effect = null;
    is_flushing = false;
    is_flushing_sync = false;
    Batch = class _Batch {
      committed = false;
      /**
       * The current values of any sources that are updated in this batch
       * They keys of this map are identical to `this.#previous`
       * @type {Map<Source, any>}
       */
      current = /* @__PURE__ */ new Map();
      /**
       * The values of any sources that are updated in this batch _before_ those updates took place.
       * They keys of this map are identical to `this.#current`
       * @type {Map<Source, any>}
       */
      previous = /* @__PURE__ */ new Map();
      /**
       * When the batch is committed (and the DOM is updated), we need to remove old branches
       * and append new ones by calling the functions added inside (if/each/key/etc) blocks
       * @type {Set<() => void>}
       */
      #commit_callbacks = /* @__PURE__ */ new Set();
      /**
       * If a fork is discarded, we need to destroy any effects that are no longer needed
       * @type {Set<(batch: Batch) => void>}
       */
      #discard_callbacks = /* @__PURE__ */ new Set();
      /**
       * The number of async effects that are currently in flight
       */
      #pending = 0;
      /**
       * The number of async effects that are currently in flight, _not_ inside a pending boundary
       */
      #blocking_pending = 0;
      /**
       * A deferred that resolves when the batch is committed, used with `settled()`
       * TODO replace with Promise.withResolvers once supported widely enough
       * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
       */
      #deferred = null;
      /**
       * Deferred effects (which run after async work has completed) that are DIRTY
       * @type {Effect[]}
       */
      #dirty_effects = [];
      /**
       * Deferred effects that are MAYBE_DIRTY
       * @type {Effect[]}
       */
      #maybe_dirty_effects = [];
      /**
       * A set of branches that still exist, but will be destroyed when this batch
       * is committed  we skip over these during `process`
       * @type {Set<Effect>}
       */
      skipped_effects = /* @__PURE__ */ new Set();
      is_fork = false;
      is_deferred() {
        return this.is_fork || this.#blocking_pending > 0;
      }
      /**
       *
       * @param {Effect[]} root_effects
       */
      process(root_effects) {
        queued_root_effects = [];
        previous_batch = null;
        this.apply();
        var target = {
          parent: null,
          effect: null,
          effects: [],
          render_effects: [],
          block_effects: []
        };
        for (const root of root_effects) {
          this.#traverse_effect_tree(root, target);
        }
        if (!this.is_fork) {
          this.#resolve();
        }
        if (this.is_deferred()) {
          this.#defer_effects(target.effects);
          this.#defer_effects(target.render_effects);
          this.#defer_effects(target.block_effects);
        } else {
          previous_batch = this;
          current_batch = null;
          flush_queued_effects(target.render_effects);
          flush_queued_effects(target.effects);
          previous_batch = null;
          this.#deferred?.resolve();
        }
        batch_values = null;
      }
      /**
       * Traverse the effect tree, executing effects or stashing
       * them for later execution as appropriate
       * @param {Effect} root
       * @param {EffectTarget} target
       */
      #traverse_effect_tree(root, target) {
        root.f ^= CLEAN;
        var effect2 = root.first;
        while (effect2 !== null) {
          var flags2 = effect2.f;
          var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
          var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
          var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
          if ((effect2.f & BOUNDARY_EFFECT) !== 0 && effect2.b?.is_pending()) {
            target = {
              parent: target,
              effect: effect2,
              effects: [],
              render_effects: [],
              block_effects: []
            };
          }
          if (!skip && effect2.fn !== null) {
            if (is_branch) {
              effect2.f ^= CLEAN;
            } else if ((flags2 & EFFECT) !== 0) {
              target.effects.push(effect2);
            } else if (async_mode_flag && (flags2 & (RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
              target.render_effects.push(effect2);
            } else if (is_dirty(effect2)) {
              if ((effect2.f & BLOCK_EFFECT) !== 0) target.block_effects.push(effect2);
              update_effect(effect2);
            }
            var child2 = effect2.first;
            if (child2 !== null) {
              effect2 = child2;
              continue;
            }
          }
          var parent = effect2.parent;
          effect2 = effect2.next;
          while (effect2 === null && parent !== null) {
            if (parent === target.effect) {
              this.#defer_effects(target.effects);
              this.#defer_effects(target.render_effects);
              this.#defer_effects(target.block_effects);
              target = /** @type {EffectTarget} */
              target.parent;
            }
            effect2 = parent.next;
            parent = parent.parent;
          }
        }
      }
      /**
       * @param {Effect[]} effects
       */
      #defer_effects(effects) {
        for (const e of effects) {
          const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
          target.push(e);
          this.#clear_marked(e.deps);
          set_signal_status(e, CLEAN);
        }
      }
      /**
       * @param {Value[] | null} deps
       */
      #clear_marked(deps) {
        if (deps === null) return;
        for (const dep of deps) {
          if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
            continue;
          }
          dep.f ^= WAS_MARKED;
          this.#clear_marked(
            /** @type {Derived} */
            dep.deps
          );
        }
      }
      /**
       * Associate a change to a given source with the current
       * batch, noting its previous and current values
       * @param {Source} source
       * @param {any} value
       */
      capture(source2, value) {
        if (!this.previous.has(source2)) {
          this.previous.set(source2, value);
        }
        if ((source2.f & ERROR_VALUE) === 0) {
          this.current.set(source2, source2.v);
          batch_values?.set(source2, source2.v);
        }
      }
      activate() {
        current_batch = this;
        this.apply();
      }
      deactivate() {
        if (current_batch !== this) return;
        current_batch = null;
        batch_values = null;
      }
      flush() {
        this.activate();
        if (queued_root_effects.length > 0) {
          flush_effects();
          if (current_batch !== null && current_batch !== this) {
            return;
          }
        } else if (this.#pending === 0) {
          this.process([]);
        }
        this.deactivate();
      }
      discard() {
        for (const fn of this.#discard_callbacks) fn(this);
        this.#discard_callbacks.clear();
      }
      #resolve() {
        if (this.#blocking_pending === 0) {
          for (const fn of this.#commit_callbacks) fn();
          this.#commit_callbacks.clear();
        }
        if (this.#pending === 0) {
          this.#commit();
        }
      }
      #commit() {
        if (batches.size > 1) {
          this.previous.clear();
          var previous_batch_values = batch_values;
          var is_earlier = true;
          var dummy_target = {
            parent: null,
            effect: null,
            effects: [],
            render_effects: [],
            block_effects: []
          };
          for (const batch of batches) {
            if (batch === this) {
              is_earlier = false;
              continue;
            }
            const sources = [];
            for (const [source2, value] of this.current) {
              if (batch.current.has(source2)) {
                if (is_earlier && value !== batch.current.get(source2)) {
                  batch.current.set(source2, value);
                } else {
                  continue;
                }
              }
              sources.push(source2);
            }
            if (sources.length === 0) {
              continue;
            }
            const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
            if (others.length > 0) {
              var prev_queued_root_effects = queued_root_effects;
              queued_root_effects = [];
              const marked = /* @__PURE__ */ new Set();
              const checked = /* @__PURE__ */ new Map();
              for (const source2 of sources) {
                mark_effects(source2, others, marked, checked);
              }
              if (queued_root_effects.length > 0) {
                current_batch = batch;
                batch.apply();
                for (const root of queued_root_effects) {
                  batch.#traverse_effect_tree(root, dummy_target);
                }
                batch.deactivate();
              }
              queued_root_effects = prev_queued_root_effects;
            }
          }
          current_batch = null;
          batch_values = previous_batch_values;
        }
        this.committed = true;
        batches.delete(this);
      }
      /**
       *
       * @param {boolean} blocking
       */
      increment(blocking) {
        this.#pending += 1;
        if (blocking) this.#blocking_pending += 1;
      }
      /**
       *
       * @param {boolean} blocking
       */
      decrement(blocking) {
        this.#pending -= 1;
        if (blocking) this.#blocking_pending -= 1;
        this.revive();
      }
      revive() {
        for (const e of this.#dirty_effects) {
          set_signal_status(e, DIRTY);
          schedule_effect(e);
        }
        for (const e of this.#maybe_dirty_effects) {
          set_signal_status(e, MAYBE_DIRTY);
          schedule_effect(e);
        }
        this.#dirty_effects = [];
        this.#maybe_dirty_effects = [];
        this.flush();
      }
      /** @param {() => void} fn */
      oncommit(fn) {
        this.#commit_callbacks.add(fn);
      }
      /** @param {(batch: Batch) => void} fn */
      ondiscard(fn) {
        this.#discard_callbacks.add(fn);
      }
      settled() {
        return (this.#deferred ??= deferred()).promise;
      }
      static ensure() {
        if (current_batch === null) {
          const batch = current_batch = new _Batch();
          batches.add(current_batch);
          if (!is_flushing_sync) {
            _Batch.enqueue(() => {
              if (current_batch !== batch) {
                return;
              }
              batch.flush();
            });
          }
        }
        return current_batch;
      }
      /** @param {() => void} task */
      static enqueue(task) {
        queue_micro_task(task);
      }
      apply() {
        if (!async_mode_flag || !this.is_fork && batches.size === 1) return;
        batch_values = new Map(this.current);
        for (const batch of batches) {
          if (batch === this) continue;
          for (const [source2, previous] of batch.previous) {
            if (!batch_values.has(source2)) {
              batch_values.set(source2, previous);
            }
          }
        }
      }
    };
    eager_block_effects = null;
    eager_versions = [];
  }
});

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start) {
  let subscribers = 0;
  let version = source(0);
  let stop;
  if (true_default) {
    tag(version, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get(version);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start(() => increment(version)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}
var init_create_subscriber = __esm({
  "node_modules/svelte/src/reactivity/create-subscriber.js"() {
    init_runtime();
    init_effects();
    init_sources();
    init_tracing();
    init_esm_env();
    init_task();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
function get_boundary() {
  return (
    /** @type {Boundary} */
    /** @type {Effect} */
    active_effect.b
  );
}
function pending() {
  if (active_effect === null) {
    effect_pending_outside_reaction();
  }
  var boundary2 = active_effect.b;
  if (boundary2 === null) {
    return 0;
  }
  return boundary2.get_effect_pending();
}
var flags, Boundary;
var init_boundary = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/boundary.js"() {
    init_constants2();
    init_constants();
    init_context();
    init_error_handling();
    init_effects();
    init_runtime();
    init_hydration();
    init_task();
    init_errors2();
    init_warnings();
    init_esm_env();
    init_batch();
    init_sources();
    init_tracing();
    init_create_subscriber();
    init_operations();
    flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
    Boundary = class {
      /** @type {Boundary | null} */
      parent;
      #pending = false;
      /** @type {TemplateNode} */
      #anchor;
      /** @type {TemplateNode | null} */
      #hydrate_open = hydrating ? hydrate_node : null;
      /** @type {BoundaryProps} */
      #props;
      /** @type {((anchor: Node) => void)} */
      #children;
      /** @type {Effect} */
      #effect;
      /** @type {Effect | null} */
      #main_effect = null;
      /** @type {Effect | null} */
      #pending_effect = null;
      /** @type {Effect | null} */
      #failed_effect = null;
      /** @type {DocumentFragment | null} */
      #offscreen_fragment = null;
      /** @type {TemplateNode | null} */
      #pending_anchor = null;
      #local_pending_count = 0;
      #pending_count = 0;
      #is_creating_fallback = false;
      /**
       * A source containing the number of pending async deriveds/expressions.
       * Only created if `$effect.pending()` is used inside the boundary,
       * otherwise updating the source results in needless `Batch.ensure()`
       * calls followed by no-op flushes
       * @type {Source<number> | null}
       */
      #effect_pending = null;
      #effect_pending_subscriber = createSubscriber(() => {
        this.#effect_pending = source(this.#local_pending_count);
        if (true_default) {
          tag(this.#effect_pending, "$effect.pending()");
        }
        return () => {
          this.#effect_pending = null;
        };
      });
      /**
       * @param {TemplateNode} node
       * @param {BoundaryProps} props
       * @param {((anchor: Node) => void)} children
       */
      constructor(node, props, children) {
        this.#anchor = node;
        this.#props = props;
        this.#children = children;
        this.parent = /** @type {Effect} */
        active_effect.b;
        this.#pending = !!this.#props.pending;
        this.#effect = block(() => {
          active_effect.b = this;
          if (hydrating) {
            const comment2 = this.#hydrate_open;
            hydrate_next();
            const server_rendered_pending = (
              /** @type {Comment} */
              comment2.nodeType === COMMENT_NODE && /** @type {Comment} */
              comment2.data === HYDRATION_START_ELSE
            );
            if (server_rendered_pending) {
              this.#hydrate_pending_content();
            } else {
              this.#hydrate_resolved_content();
            }
          } else {
            var anchor = this.#get_anchor();
            try {
              this.#main_effect = branch(() => children(anchor));
            } catch (error) {
              this.error(error);
            }
            if (this.#pending_count > 0) {
              this.#show_pending_snippet();
            } else {
              this.#pending = false;
            }
          }
          return () => {
            this.#pending_anchor?.remove();
          };
        }, flags);
        if (hydrating) {
          this.#anchor = hydrate_node;
        }
      }
      #hydrate_resolved_content() {
        try {
          this.#main_effect = branch(() => this.#children(this.#anchor));
        } catch (error) {
          this.error(error);
        }
        this.#pending = false;
      }
      #hydrate_pending_content() {
        const pending3 = this.#props.pending;
        if (!pending3) {
          return;
        }
        this.#pending_effect = branch(() => pending3(this.#anchor));
        Batch.enqueue(() => {
          var anchor = this.#get_anchor();
          this.#main_effect = this.#run(() => {
            Batch.ensure();
            return branch(() => this.#children(anchor));
          });
          if (this.#pending_count > 0) {
            this.#show_pending_snippet();
          } else {
            pause_effect(
              /** @type {Effect} */
              this.#pending_effect,
              () => {
                this.#pending_effect = null;
              }
            );
            this.#pending = false;
          }
        });
      }
      #get_anchor() {
        var anchor = this.#anchor;
        if (this.#pending) {
          this.#pending_anchor = create_text();
          this.#anchor.before(this.#pending_anchor);
          anchor = this.#pending_anchor;
        }
        return anchor;
      }
      /**
       * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
       * @returns {boolean}
       */
      is_pending() {
        return this.#pending || !!this.parent && this.parent.is_pending();
      }
      has_pending_snippet() {
        return !!this.#props.pending;
      }
      /**
       * @param {() => Effect | null} fn
       */
      #run(fn) {
        var previous_effect = active_effect;
        var previous_reaction = active_reaction;
        var previous_ctx = component_context;
        set_active_effect(this.#effect);
        set_active_reaction(this.#effect);
        set_component_context(this.#effect.ctx);
        try {
          return fn();
        } catch (e) {
          handle_error(e);
          return null;
        } finally {
          set_active_effect(previous_effect);
          set_active_reaction(previous_reaction);
          set_component_context(previous_ctx);
        }
      }
      #show_pending_snippet() {
        const pending3 = (
          /** @type {(anchor: Node) => void} */
          this.#props.pending
        );
        if (this.#main_effect !== null) {
          this.#offscreen_fragment = document.createDocumentFragment();
          this.#offscreen_fragment.append(
            /** @type {TemplateNode} */
            this.#pending_anchor
          );
          move_effect(this.#main_effect, this.#offscreen_fragment);
        }
        if (this.#pending_effect === null) {
          this.#pending_effect = branch(() => pending3(this.#anchor));
        }
      }
      /**
       * Updates the pending count associated with the currently visible pending snippet,
       * if any, such that we can replace the snippet with content once work is done
       * @param {1 | -1} d
       */
      #update_pending_count(d) {
        if (!this.has_pending_snippet()) {
          if (this.parent) {
            this.parent.#update_pending_count(d);
          }
          return;
        }
        this.#pending_count += d;
        if (this.#pending_count === 0) {
          this.#pending = false;
          if (this.#pending_effect) {
            pause_effect(this.#pending_effect, () => {
              this.#pending_effect = null;
            });
          }
          if (this.#offscreen_fragment) {
            this.#anchor.before(this.#offscreen_fragment);
            this.#offscreen_fragment = null;
          }
        }
      }
      /**
       * Update the source that powers `$effect.pending()` inside this boundary,
       * and controls when the current `pending` snippet (if any) is removed.
       * Do not call from inside the class
       * @param {1 | -1} d
       */
      update_pending_count(d) {
        this.#update_pending_count(d);
        this.#local_pending_count += d;
        if (this.#effect_pending) {
          internal_set(this.#effect_pending, this.#local_pending_count);
        }
      }
      get_effect_pending() {
        this.#effect_pending_subscriber();
        return get(
          /** @type {Source<number>} */
          this.#effect_pending
        );
      }
      /** @param {unknown} error */
      error(error) {
        var onerror = this.#props.onerror;
        let failed = this.#props.failed;
        if (this.#is_creating_fallback || !onerror && !failed) {
          throw error;
        }
        if (this.#main_effect) {
          destroy_effect(this.#main_effect);
          this.#main_effect = null;
        }
        if (this.#pending_effect) {
          destroy_effect(this.#pending_effect);
          this.#pending_effect = null;
        }
        if (this.#failed_effect) {
          destroy_effect(this.#failed_effect);
          this.#failed_effect = null;
        }
        if (hydrating) {
          set_hydrate_node(
            /** @type {TemplateNode} */
            this.#hydrate_open
          );
          next();
          set_hydrate_node(skip_nodes());
        }
        var did_reset = false;
        var calling_on_error = false;
        const reset2 = () => {
          if (did_reset) {
            svelte_boundary_reset_noop();
            return;
          }
          did_reset = true;
          if (calling_on_error) {
            svelte_boundary_reset_onerror();
          }
          Batch.ensure();
          this.#local_pending_count = 0;
          if (this.#failed_effect !== null) {
            pause_effect(this.#failed_effect, () => {
              this.#failed_effect = null;
            });
          }
          this.#pending = this.has_pending_snippet();
          this.#main_effect = this.#run(() => {
            this.#is_creating_fallback = false;
            return branch(() => this.#children(this.#anchor));
          });
          if (this.#pending_count > 0) {
            this.#show_pending_snippet();
          } else {
            this.#pending = false;
          }
        };
        var previous_reaction = active_reaction;
        try {
          set_active_reaction(null);
          calling_on_error = true;
          onerror?.(error, reset2);
          calling_on_error = false;
        } catch (error2) {
          invoke_error_boundary(error2, this.#effect && this.#effect.parent);
        } finally {
          set_active_reaction(previous_reaction);
        }
        if (failed) {
          queue_micro_task(() => {
            this.#failed_effect = this.#run(() => {
              Batch.ensure();
              this.#is_creating_fallback = true;
              try {
                return branch(() => {
                  failed(
                    this.#anchor,
                    () => error,
                    () => reset2
                  );
                });
              } catch (error2) {
                invoke_error_boundary(
                  error2,
                  /** @type {Effect} */
                  this.#effect.parent
                );
                return null;
              } finally {
                this.#is_creating_fallback = false;
              }
            });
          });
        }
      }
    };
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/each.js
function set_current_each_item(item) {
  current_each_item = item;
}
function index(_, i) {
  return i;
}
function pause_effects(state2, to_destroy, controlled_anchor) {
  var transitions = [];
  var length = to_destroy.length;
  for (var i = 0; i < length; i++) {
    pause_children(to_destroy[i].e, transitions, true);
  }
  run_out_transitions(transitions, () => {
    var fast_path = transitions.length === 0 && controlled_anchor !== null;
    if (fast_path) {
      var anchor = (
        /** @type {Element} */
        controlled_anchor
      );
      var parent_node = (
        /** @type {Element} */
        anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(anchor);
      state2.items.clear();
      link(state2, to_destroy[0].prev, to_destroy[length - 1].next);
    }
    for (var i2 = 0; i2 < length; i2++) {
      var item = to_destroy[i2];
      if (!fast_path) {
        state2.items.delete(item.k);
        link(state2, item.prev, item.next);
      }
      destroy_effect(item.e, !fast_path);
    }
    if (state2.first === to_destroy[0]) {
      state2.first = to_destroy[0].prev;
    }
  });
}
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var items = /* @__PURE__ */ new Map();
  var first = null;
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  var is_reactive_value = (flags2 & EACH_ITEM_REACTIVE) !== 0;
  var is_reactive_index = (flags2 & EACH_INDEX_REACTIVE) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = hydrating ? set_hydrate_node(
      /** @type {Comment | Text} */
      get_first_child(parent_node)
    ) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback2 = null;
  var each_array = derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array;
  var first_run = true;
  function commit() {
    reconcile(state2, array, anchor, flags2, get_key);
    if (fallback2 !== null) {
      if (array.length === 0) {
        if (fallback2.fragment) {
          anchor.before(fallback2.fragment);
          fallback2.fragment = null;
        } else {
          resume_effect(fallback2.effect);
        }
        effect2.first = fallback2.effect;
      } else {
        pause_effect(fallback2.effect, () => {
          fallback2 = null;
        });
      }
    }
  }
  var effect2 = block(() => {
    array = /** @type {V[]} */
    get(each_array);
    var length = array.length;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length === 0)) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var keys = /* @__PURE__ */ new Set();
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var prev = null;
    var defer = should_defer_append();
    for (var i = 0; i < length; i += 1) {
      if (hydrating && hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */
      hydrate_node.data === HYDRATION_END) {
        anchor = /** @type {Comment} */
        hydrate_node;
        mismatch = true;
        set_hydrating(false);
      }
      var value = array[i];
      var key2 = get_key(value, i);
      var item = first_run ? null : items.get(key2);
      if (item) {
        if (is_reactive_value) {
          internal_set(item.v, value);
        }
        if (is_reactive_index) {
          internal_set(
            /** @type {Value<number>} */
            item.i,
            i
          );
        } else {
          item.i = i;
        }
        if (defer) {
          batch.skipped_effects.delete(item.e);
        }
      } else {
        item = create_item(
          first_run ? anchor : null,
          prev,
          value,
          key2,
          i,
          render_fn,
          flags2,
          get_collection
        );
        if (first_run) {
          item.o = true;
          if (prev === null) {
            first = item;
          } else {
            prev.next = item;
          }
          prev = item;
        }
        items.set(key2, item);
      }
      keys.add(key2);
    }
    if (length === 0 && fallback_fn && !fallback2) {
      if (first_run) {
        fallback2 = {
          fragment: null,
          effect: branch(() => fallback_fn(anchor))
        };
      } else {
        var fragment = document.createDocumentFragment();
        var target = create_text();
        fragment.append(target);
        fallback2 = {
          fragment,
          effect: branch(() => fallback_fn(target))
        };
      }
    }
    if (hydrating && length > 0) {
      set_hydrate_node(skip_nodes());
    }
    if (!first_run) {
      if (defer) {
        for (const [key3, item2] of items) {
          if (!keys.has(key3)) {
            batch.skipped_effects.add(item2.e);
          }
        }
        batch.oncommit(commit);
        batch.ondiscard(() => {
        });
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get(each_array);
  });
  var state2 = { effect: effect2, flags: flags2, items, first };
  first_run = false;
  if (hydrating) {
    anchor = hydrate_node;
  }
}
function reconcile(state2, array, anchor, flags2, get_key) {
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var length = array.length;
  var items = state2.items;
  var current = state2.first;
  var seen2;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value;
  var key2;
  var item;
  var i;
  if (is_animated) {
    for (i = 0; i < length; i += 1) {
      value = array[i];
      key2 = get_key(value, i);
      item = /** @type {EachItem} */
      items.get(key2);
      if (item.o) {
        item.a?.measure();
        (to_animate ??= /* @__PURE__ */ new Set()).add(item);
      }
    }
  }
  for (i = 0; i < length; i += 1) {
    value = array[i];
    key2 = get_key(value, i);
    item = /** @type {EachItem} */
    items.get(key2);
    state2.first ??= item;
    if (!item.o) {
      item.o = true;
      var next2 = prev ? prev.next : current;
      link(state2, prev, item);
      link(state2, item, next2);
      move(item, next2, anchor);
      prev = item;
      matched = [];
      stashed = [];
      current = prev.next;
      continue;
    }
    if ((item.e.f & INERT) !== 0) {
      resume_effect(item.e);
      if (is_animated) {
        item.a?.unfix();
        (to_animate ??= /* @__PURE__ */ new Set()).delete(item);
      }
    }
    if (item !== current) {
      if (seen2 !== void 0 && seen2.has(item)) {
        if (matched.length < stashed.length) {
          var start = stashed[0];
          var j;
          prev = start.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen2.delete(stashed[j]);
          }
          link(state2, a.prev, b.next);
          link(state2, prev, a);
          link(state2, b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen2.delete(item);
          move(item, current, anchor);
          link(state2, item.prev, item.next);
          link(state2, item, prev === null ? state2.first : prev.next);
          link(state2, prev, item);
          prev = item;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current.k !== key2) {
        if ((current.e.f & INERT) === 0) {
          (seen2 ??= /* @__PURE__ */ new Set()).add(current);
        }
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
      item = current;
    }
    matched.push(item);
    prev = item;
    current = item.next;
  }
  let has_offscreen_items = items.size > length;
  if (current !== null || seen2 !== void 0) {
    var to_destroy = seen2 === void 0 ? [] : array_from(seen2);
    while (current !== null) {
      if ((current.e.f & INERT) === 0) {
        to_destroy.push(current);
      }
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    has_offscreen_items = items.size - destroy_length > length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
      if (is_animated) {
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].a?.measure();
        }
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].a?.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (has_offscreen_items) {
    for (const item2 of items.values()) {
      if (!item2.o) {
        link(state2, prev, item2);
        prev = item2;
      }
    }
  }
  state2.effect.last = prev && prev.e;
  if (is_animated) {
    queue_micro_task(() => {
      if (to_animate === void 0) return;
      for (item of to_animate) {
        item.a?.apply();
      }
    });
  }
}
function create_item(anchor, prev, value, key2, index2, render_fn, flags2, get_collection) {
  var previous_each_item = current_each_item;
  var reactive = (flags2 & EACH_ITEM_REACTIVE) !== 0;
  var mutable = (flags2 & EACH_ITEM_IMMUTABLE) === 0;
  var v = reactive ? mutable ? mutable_source(value, false, false) : source(value) : value;
  var i = (flags2 & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);
  if (true_default && reactive) {
    v.trace = () => {
      var collection_index = typeof i === "number" ? index2 : i.v;
      get_collection()[collection_index];
    };
  }
  var item = {
    i,
    v,
    k: key2,
    a: null,
    // @ts-expect-error
    e: null,
    o: false,
    prev,
    next: null
  };
  current_each_item = item;
  try {
    if (anchor === null) {
      var fragment = document.createDocumentFragment();
      fragment.append(anchor = create_text());
    }
    item.e = branch(() => render_fn(
      /** @type {Node} */
      anchor,
      v,
      i,
      get_collection
    ));
    if (prev !== null) {
      prev.next = item;
    }
    return item;
  } finally {
    current_each_item = previous_each_item;
  }
}
function move(item, next2, anchor) {
  var end = item.next ? (
    /** @type {TemplateNode} */
    item.next.e.nodes_start
  ) : anchor;
  var dest = next2 ? (
    /** @type {TemplateNode} */
    next2.e.nodes_start
  ) : anchor;
  var node = (
    /** @type {TemplateNode} */
    item.e.nodes_start
  );
  while (node !== null && node !== end) {
    var next_node = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    dest.before(node);
    node = next_node;
  }
}
function link(state2, prev, next2) {
  if (prev === null) {
    state2.first = next2;
    state2.effect.first = next2 && next2.e;
  } else {
    if (prev.e.next) {
      prev.e.next.prev = null;
    }
    prev.next = next2;
    prev.e.next = next2 && next2.e;
  }
  if (next2 !== null) {
    if (next2.e.prev) {
      next2.e.prev.next = null;
    }
    next2.prev = prev;
    next2.e.prev = prev && prev.e;
  }
}
var current_each_item;
var init_each = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/each.js"() {
    init_constants();
    init_hydration();
    init_operations();
    init_effects();
    init_sources();
    init_utils();
    init_constants2();
    init_task();
    init_runtime();
    init_esm_env();
    init_deriveds();
    init_batch();
    current_each_item = null;
  }
});

// node_modules/svelte/src/internal/client/reactivity/async.js
function flatten(blockers, sync, async2, fn) {
  const d = is_runes() ? derived : derived_safe_equal;
  if (async2.length === 0 && blockers.length === 0) {
    fn(sync.map(d));
    return;
  }
  var batch = current_batch;
  var parent = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  function run3() {
    Promise.all(async2.map((expression) => async_derived(expression))).then((result) => {
      restore();
      try {
        fn([...sync.map(d), ...result]);
      } catch (error) {
        if ((parent.f & DESTROYED) === 0) {
          invoke_error_boundary(error, parent);
        }
      }
      batch?.deactivate();
      unset_context();
    }).catch((error) => {
      invoke_error_boundary(error, parent);
    });
  }
  if (blockers.length > 0) {
    Promise.all(blockers).then(() => {
      restore();
      try {
        return run3();
      } finally {
        batch?.deactivate();
        unset_context();
      }
    });
  } else {
    run3();
  }
}
function run_after_blockers(blockers, fn) {
  var each_item = current_each_item;
  flatten(blockers, [], [], (v) => {
    set_current_each_item(each_item);
    fn(v);
  });
}
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  if (true_default) {
    var previous_dev_stack = dev_stack;
  }
  return function restore(activate_batch = true) {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    if (activate_batch) previous_batch2?.activate();
    if (true_default) {
      set_from_async_derived(null);
      set_dev_stack(previous_dev_stack);
    }
  };
}
async function save(promise) {
  var restore = capture();
  var value = await promise;
  return () => {
    restore();
    return value;
  };
}
async function track_reactivity_loss(promise) {
  var previous_async_effect = current_async_effect;
  var value = await promise;
  return () => {
    set_from_async_derived(previous_async_effect);
    return value;
  };
}
async function* for_await_track_reactivity_loss(iterable) {
  const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
  if (iterator === void 0) {
    throw new TypeError("value is not async iterable");
  }
  let normal_completion = false;
  try {
    while (true) {
      const { done, value } = (await track_reactivity_loss(iterator.next()))();
      if (done) {
        normal_completion = true;
        break;
      }
      yield value;
    }
  } finally {
    if (normal_completion && iterator.return !== void 0) {
      return (
        /** @type {TReturn} */
        (await track_reactivity_loss(iterator.return()))().value
      );
    }
  }
}
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (true_default) {
    set_from_async_derived(null);
    set_dev_stack(null);
  }
}
async function async_body(anchor, fn) {
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var was_hydrating = hydrating;
  var next_hydrate_node = void 0;
  if (was_hydrating) {
    hydrate_next();
    next_hydrate_node = skip_nodes(false);
  }
  try {
    var promise = fn(anchor);
  } finally {
    if (next_hydrate_node) {
      set_hydrate_node(next_hydrate_node);
      hydrate_next();
    }
  }
  try {
    await promise;
  } catch (error) {
    if (!aborted(active)) {
      invoke_error_boundary(error, active);
    }
  } finally {
    boundary2.update_pending_count(-1);
    batch.decrement(blocking);
    unset_context();
  }
}
function run2(thunks) {
  const restore = capture();
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var errored = null;
  const handle_error2 = (error) => {
    errored = { error };
    if (!aborted(active)) {
      invoke_error_boundary(error, active);
    }
  };
  var promise = Promise.resolve(thunks[0]()).catch(handle_error2);
  var promises = [promise];
  for (const fn of thunks.slice(1)) {
    promise = promise.then(() => {
      if (errored) {
        throw errored.error;
      }
      if (aborted(active)) {
        throw STALE_REACTION;
      }
      try {
        restore();
        return fn();
      } finally {
        unset_context();
      }
    }).catch(handle_error2).finally(() => {
      unset_context();
    });
    promises.push(promise);
  }
  promise.then(() => Promise.resolve()).finally(() => {
    boundary2.update_pending_count(-1);
    batch.decrement(blocking);
  });
  return promises;
}
var init_async = __esm({
  "node_modules/svelte/src/internal/client/reactivity/async.js"() {
    init_constants2();
    init_esm_env();
    init_context();
    init_boundary();
    init_error_handling();
    init_runtime();
    init_batch();
    init_deriveds();
    init_effects();
    init_hydration();
    init_each();
  }
});

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
function set_from_async_derived(v) {
  current_async_effect = v;
}
// @__NO_SIDE_EFFECTS__
function derived(fn) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect !== null) {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived ?? active_effect,
    ac: null
  };
  if (true_default && tracing_mode_flag) {
    signal.created = get_error("created at");
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function async_derived(fn, location2) {
  let parent = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent === null) {
    async_derived_orphan();
  }
  var boundary2 = (
    /** @type {Boundary} */
    parent.b
  );
  var promise = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  var should_suspend = !active_reaction;
  var deferreds = /* @__PURE__ */ new Map();
  async_effect(() => {
    if (true_default) current_async_effect = active_effect;
    var d = deferred();
    promise = d.promise;
    try {
      Promise.resolve(fn()).then(d.resolve, d.reject).then(() => {
        if (batch === current_batch && batch.committed) {
          batch.deactivate();
        }
        unset_context();
      });
    } catch (error) {
      d.reject(error);
      unset_context();
    }
    if (true_default) current_async_effect = null;
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    if (should_suspend) {
      var blocking = !boundary2.is_pending();
      boundary2.update_pending_count(1);
      batch.increment(blocking);
      deferreds.get(batch)?.reject(STALE_REACTION);
      deferreds.delete(batch);
      deferreds.set(batch, d);
    }
    const handler = (value, error = void 0) => {
      current_async_effect = null;
      batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value);
        for (const [b, d2] of deferreds) {
          deferreds.delete(b);
          if (b === batch) break;
          d2.reject(STALE_REACTION);
        }
        if (true_default && location2 !== void 0) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(
                /** @type {string} */
                signal.label,
                location2
              );
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        batch.decrement(blocking);
      }
    };
    d.promise.then(handler, (e) => handler(null, e || "unknown"));
  });
  teardown(() => {
    for (const d of deferreds.values()) {
      d.reject(STALE_REACTION);
    }
  });
  if (true_default) {
    signal.f |= ASYNC;
  }
  return new Promise((fulfil) => {
    function next2(p) {
      function go() {
        if (p === promise) {
          fulfil(signal);
        } else {
          next2(promise);
        }
      }
      p.then(go, go);
    }
    next2(promise);
  });
}
// @__NO_SIDE_EFFECTS__
function user_derived(fn) {
  const d = /* @__PURE__ */ derived(fn);
  if (!async_mode_flag) push_reaction_value(d);
  return d;
}
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn) {
  const signal = /* @__PURE__ */ derived(fn);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
function get_derived_parent_effect(derived2) {
  var parent = derived2.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (parent.f & DESTROYED) === 0 ? (
        /** @type {Effect} */
        parent
      ) : null;
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived2) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  if (true_default) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived2)) {
        derived_references_self();
      }
      stack.push(derived2);
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else {
    try {
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived2) {
  var value = execute_derived(derived2);
  if (!derived2.equals(value)) {
    if (!current_batch?.is_fork) {
      derived2.v = value;
    }
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking() || current_batch?.is_fork) {
      batch_values.set(derived2, value);
    }
  } else {
    var status = (derived2.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}
var current_async_effect, recent_async_deriveds, stack;
var init_deriveds = __esm({
  "node_modules/svelte/src/internal/client/reactivity/deriveds.js"() {
    init_esm_env();
    init_constants2();
    init_runtime();
    init_equality();
    init_errors2();
    init_warnings();
    init_effects();
    init_sources();
    init_dev();
    init_flags();
    init_boundary();
    init_context();
    init_constants();
    init_batch();
    init_async();
    init_utils();
    current_async_effect = null;
    recent_async_deriveds = /* @__PURE__ */ new Set();
    stack = [];
  }
});

// node_modules/svelte/src/internal/client/reactivity/sources.js
function set_eager_effects(v) {
  eager_effects = v;
}
function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (true_default && tracing_mode_flag) {
    signal.created = stack2 ?? get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    (component_context.l.s ??= []).push(s);
  }
  return s;
}
function mutate(source2, value) {
  set(
    source2,
    untrack(() => get(source2))
  );
  return value;
}
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (true_default) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (true_default) {
      if (tracing_mode_flag || active_effect !== null) {
        source2.updated ??= /* @__PURE__ */ new Map();
        const count = (source2.updated.get("")?.count ?? 0) + 1;
        source2.updated.set("", { error: (
          /** @type {any} */
          null
        ), count });
        if (tracing_mode_flag || count > 5) {
          const error = get_error("updated at");
          if (error !== null) {
            let entry = source2.updated.get(error.stack);
            if (!entry) {
              entry = { error, count: 0 };
              source2.updated.set(error.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value;
}
function flush_eager_effects() {
  eager_effects_deferred = false;
  var prev_is_updating_effect = is_updating_effect;
  set_is_updating_effect(true);
  const inspects = Array.from(eager_effects);
  try {
    for (const effect2 of inspects) {
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
    }
  } finally {
    set_is_updating_effect(prev_is_updating_effect);
  }
  eager_effects.clear();
}
function update(source2, d = 1) {
  var value = get(source2);
  var result = d === 1 ? value++ : value--;
  set(source2, value);
  return result;
}
function update_pre(source2, d = 1) {
  var value = get(source2);
  return set(source2, d === 1 ? ++value : --value);
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (true_default && (flags2 & EAGER_EFFECT) !== 0) {
      eager_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived2 = (
        /** @type {Derived} */
        reaction
      );
      batch_values?.delete(derived2);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived2, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
        eager_block_effects.add(
          /** @type {Effect} */
          reaction
        );
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
var eager_effects, old_values, eager_effects_deferred;
var init_sources = __esm({
  "node_modules/svelte/src/internal/client/reactivity/sources.js"() {
    init_esm_env();
    init_runtime();
    init_equality();
    init_constants2();
    init_errors2();
    init_flags();
    init_tracing();
    init_dev();
    init_context();
    init_batch();
    init_proxy();
    init_deriveds();
    eager_effects = /* @__PURE__ */ new Set();
    old_values = /* @__PURE__ */ new Map();
    eager_effects_deferred = false;
  }
});

// node_modules/svelte/src/internal/client/proxy.js
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version = state(0);
  var stack2 = true_default && tracing_mode_flag ? get_error("created at") : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(
      /** @type {any[]} */
      value.length,
      stack2
    ));
    if (true_default) {
      value = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value
      );
    }
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path = new_path;
    tag(version, `${path} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path, prop2));
    }
    updating = false;
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          s = with_parent(() => {
            var s2 = state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (true_default && typeof prop2 === "string") {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
        } else {
          set(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version);
            if (true_default) {
              tag(s2, get_label(path, prop2));
            }
          }
        } else {
          set(s, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop2, receiver) {
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        if (true_default && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
          s = with_parent(() => {
            var p = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = state(p, stack2);
            if (true_default) {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
          if (s === void 0) {
            s = with_parent(() => {
              var p = has ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = state(p, stack2);
              if (true_default) {
                tag(s2, get_label(path, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value2 = get(s);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value2, receiver) {
        var s = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => state(UNINITIALIZED, stack2));
              sources.set(i + "", other_s);
              if (true_default) {
                tag(other_s, get_label(path, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has || get_descriptor(target, prop2)?.writable) {
            s = with_parent(() => state(void 0, stack2));
            if (true_default) {
              tag(s, get_label(path, prop2));
            }
            set(s, proxy(value2));
            sources.set(prop2, s);
          }
        } else {
          has = s.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set(s, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set(ls, n + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get(version);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function get_label(path, prop2) {
  if (typeof prop2 === "symbol") return `${path}[Symbol(${prop2.description ?? ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch {
  }
  return value;
}
function is(a, b) {
  return Object.is(get_proxied_value(a), get_proxied_value(b));
}
function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value;
      }
      return function(...args) {
        set_eager_effects_deferred();
        var result = value.apply(this, args);
        flush_eager_effects();
        return result;
      };
    }
  });
}
var regex_is_valid_identifier, ARRAY_MUTATING_METHODS;
var init_proxy = __esm({
  "node_modules/svelte/src/internal/client/proxy.js"() {
    init_esm_env();
    init_runtime();
    init_utils();
    init_sources();
    init_constants2();
    init_constants();
    init_errors2();
    init_tracing();
    init_dev();
    init_flags();
    regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
      "copyWithin",
      "fill",
      "pop",
      "push",
      "reverse",
      "shift",
      "sort",
      "splice",
      "unshift"
    ]);
  }
});

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index ?? 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}
function strict_equals(a, b, equal = true) {
  try {
    if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
      state_proxy_equality_mismatch(equal ? "===" : "!==");
    }
  } catch {
  }
  return a === b === equal;
}
function equals2(a, b, equal = true) {
  if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "==" : "!=");
  }
  return a == b === equal;
}
var init_equality2 = __esm({
  "node_modules/svelte/src/internal/client/dev/equality.js"() {
    init_warnings();
    init_proxy();
  }
});

// node_modules/svelte/src/internal/client/dom/operations.js
function init_operations2() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (true_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function child(node, is_text) {
  if (!hydrating) {
    return /* @__PURE__ */ get_first_child(node);
  }
  var child2 = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ get_first_child(hydrate_node)
  );
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    child2?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(child2);
  return child2;
}
function first_child(fragment, is_text = false) {
  if (!hydrating) {
    var first = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ get_first_child(
        /** @type {Node} */
        fragment
      )
    );
    if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
    return first;
  }
  if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    hydrate_node?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  return hydrate_node;
}
function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    if (next_sibling === null) {
      last_sibling?.after(text2);
    } else {
      next_sibling.before(text2);
    }
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(next_sibling);
  return (
    /** @type {TemplateNode} */
    next_sibling
  );
}
function clear_text_content(node) {
  node.textContent = "";
}
function should_defer_append() {
  if (!async_mode_flag) return false;
  if (eager_block_effects !== null) return false;
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  return (flags2 & EFFECT_RAN) !== 0;
}
function create_element(tag2, namespace, is2) {
  let options = is2 ? { is: is2 } : void 0;
  if (namespace) {
    return document.createElementNS(namespace, tag2, options);
  }
  return document.createElement(tag2, options);
}
function create_fragment() {
  return document.createDocumentFragment();
}
function create_comment(data = "") {
  return document.createComment(data);
}
function set_attribute(element3, key2, value = "") {
  if (key2.startsWith("xlink:")) {
    element3.setAttributeNS("http://www.w3.org/1999/xlink", key2, value);
    return;
  }
  return element3.setAttribute(key2, value);
}
var $window, $document, is_firefox, first_child_getter, next_sibling_getter;
var init_operations = __esm({
  "node_modules/svelte/src/internal/client/dom/operations.js"() {
    init_hydration();
    init_esm_env();
    init_equality2();
    init_utils();
    init_runtime();
    init_flags();
    init_constants2();
    init_batch();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/misc.js
function autofocus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    queue_micro_task(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
function remove_textarea_child(dom) {
  if (hydrating && get_first_child(dom) !== null) {
    clear_text_content(dom);
  }
}
function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          if (!evt.defaultPrevented) {
            for (
              const e of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              e.__on_r?.();
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
      { capture: true }
    );
  }
}
var listening_to_form_reset;
var init_misc = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/misc.js"() {
    init_hydration();
    init_operations();
    init_task();
    listening_to_form_reset = false;
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function listen(target, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (var name of events) {
    target.addEventListener(name, handler);
  }
  teardown(() => {
    for (var name2 of events) {
      target.removeEventListener(name2, handler);
    }
  });
}
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function listen_to_event_and_reset_event(element3, event2, handler, on_reset = handler) {
  element3.addEventListener(event2, () => without_reactive_context(handler));
  const prev = element3.__on_r;
  if (prev) {
    element3.__on_r = () => {
      prev();
      on_reset(true);
    };
  } else {
    element3.__on_r = () => on_reset(true);
  }
  add_form_reset_listener();
}
var init_shared = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js"() {
    init_effects();
    init_runtime();
    init_misc();
  }
});

// node_modules/svelte/src/internal/client/reactivity/effects.js
function validate_effect(rune) {
  if (active_effect === null) {
    if (active_reaction === null) {
      effect_orphan(rune);
    }
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown(rune);
  }
}
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync) {
  var parent = active_effect;
  if (true_default) {
    while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (true_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e2) {
      destroy_effect(effect2);
      throw e2;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var e = effect2;
  if (sync && e.deps === null && e.teardown === null && e.nodes_start === null && e.first === e.last && // either `null`, or a singular child
  (e.f & EFFECT_PRESERVED) === 0) {
    e = e.first;
    if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e !== null) {
      e.f |= EFFECT_TRANSPARENT;
    }
  }
  if (e !== null) {
    e.parent = parent;
    if (parent !== null) {
      push_effect(e, parent);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
      var derived2 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived2.effects ??= []).push(e);
    }
  }
  return effect2;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}
function user_effect(fn) {
  validate_effect("$effect");
  if (true_default) {
    define_property(fn, "name", {
      value: "$effect"
    });
  }
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & EFFECT_RAN) === 0;
  if (defer) {
    var context2 = (
      /** @type {ComponentContext} */
      component_context
    );
    (context2.e ??= []).push(fn);
  } else {
    return create_user_effect(fn);
  }
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function user_pre_effect(fn) {
  validate_effect("$effect.pre");
  if (true_default) {
    define_property(fn, "name", {
      value: "$effect.pre"
    });
  }
  return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
}
function eager_effect(fn) {
  return create_effect(EAGER_EFFECT, fn, true);
}
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function legacy_pre_effect(deps, fn) {
  var context2 = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  var token = { effect: null, ran: false, deps };
  context2.l.$.push(token);
  token.effect = render_effect(() => {
    deps();
    if (token.ran) return;
    token.ran = true;
    untrack(fn);
  });
}
function legacy_pre_effect_reset() {
  var context2 = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  render_effect(() => {
    for (var token of context2.l.$) {
      token.deps();
      var effect2 = token.effect;
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
      token.ran = false;
    }
  });
}
function async_effect(fn) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function template_effect(fn, sync = [], async2 = [], blockers = []) {
  flatten(blockers, sync, async2, (values) => {
    create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
  });
}
function deferred_template_effect(fn, sync = [], async2 = [], blockers = []) {
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var is_async = async2.length > 0 || blockers.length > 0;
  if (is_async) batch.increment(true);
  flatten(blockers, sync, async2, (values) => {
    create_effect(EFFECT, () => fn(...values.map(get)), false);
    if (is_async) batch.decrement(true);
  });
}
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (true_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function managed(fn, flags2 = 0) {
  var effect2 = create_effect(MANAGED_EFFECT | flags2, fn, true);
  if (true_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function branch(fn) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller2 = effect2.ac;
    if (controller2 !== null) {
      without_reactive_context(() => {
        controller2.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null && effect2.nodes_end !== null) {
    remove_effect_dom(
      effect2.nodes_start,
      /** @type {TemplateNode} */
      effect2.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.transitions;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (true_default) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = effect2.ac = null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
function pause_effect(effect2, callback, destroy = true) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    if (destroy) destroy_effect(effect2);
    if (callback) callback();
  });
}
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) {
      transition2.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child2.f & BRANCH_EFFECT) !== 0 && (effect2.f & BLOCK_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function resume_effect(effect2) {
  resume_children(effect2, true);
}
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0) return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transition2.in();
      }
    }
  }
}
function aborted(effect2 = (
  /** @type {Effect} */
  active_effect
)) {
  return (effect2.f & DESTROYED) !== 0;
}
function move_effect(effect2, fragment) {
  var node = effect2.nodes_start;
  var end = effect2.nodes_end;
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    fragment.append(node);
    node = next2;
  }
}
var init_effects = __esm({
  "node_modules/svelte/src/internal/client/reactivity/effects.js"() {
    init_runtime();
    init_constants2();
    init_errors2();
    init_esm_env();
    init_utils();
    init_operations();
    init_context();
    init_batch();
    init_async();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/legacy.js
function capture_signals(fn) {
  var previous_captured_signals = captured_signals;
  try {
    captured_signals = /* @__PURE__ */ new Set();
    untrack(fn);
    if (previous_captured_signals !== null) {
      for (var signal of captured_signals) {
        previous_captured_signals.add(signal);
      }
    }
    return captured_signals;
  } finally {
    captured_signals = previous_captured_signals;
  }
}
function invalidate_inner_signals(fn) {
  for (var signal of capture_signals(fn)) {
    internal_set(signal, signal.v);
  }
}
var captured_signals;
var init_legacy = __esm({
  "node_modules/svelte/src/internal/client/legacy.js"() {
    init_sources();
    init_runtime();
    captured_signals = null;
  }
});

// node_modules/svelte/src/internal/client/runtime.js
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
function set_active_effect(effect2) {
  active_effect = effect2;
}
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
function set_untracked_writes(value) {
  untracked_writes = value;
}
function set_update_version(value) {
  update_version = value;
}
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length = dependencies.length;
      for (var i = 0; i < length; i++) {
        var dependency = dependencies[i];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if ((flags2 & CONNECTED) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (is_updating_effect && effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i = skipped_deps; i < deps.length; i++) {
          (deps[i].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & CONNECTED) !== 0) {
      dependency.f ^= CONNECTED;
      dependency.f &= ~WAS_MARKED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
function update_effect(effect2) {
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (true_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack(effect2.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (true_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (true_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
async function tick() {
  if (async_mode_flag) {
    return new Promise((f) => {
      requestAnimationFrame(() => f());
      setTimeout(() => f());
    });
  }
  await Promise.resolve();
  flushSync();
}
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (true_default) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        var trace2 = get_error("traced at");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== last?.stack) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      var derived2 = (
        /** @type {Derived} */
        signal
      );
      var value = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value = execute_derived(derived2);
      }
      old_values.set(derived2, value);
      return value;
    }
  } else if (is_derived && (!batch_values?.has(signal) || current_batch?.is_fork && !effect_tracking())) {
    derived2 = /** @type {Derived} */
    signal;
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
    if (is_updating_effect && effect_tracking() && (derived2.f & CONNECTED) === 0) {
      reconnect(derived2);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function reconnect(derived2) {
  if (derived2.deps === null) return;
  derived2.f ^= CONNECTED;
  for (const dep of derived2.deps) {
    (dep.reactions ??= []).push(derived2);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      reconnect(
        /** @type {Derived} */
        dep
      );
    }
  }
}
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED) return true;
  if (derived2.deps === null) return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function safe_get(signal) {
  return signal && get(signal);
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function exclude_from_object(obj, keys) {
  var result = {};
  for (var key2 in obj) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  for (var symbol of Object.getOwnPropertySymbols(obj)) {
    if (Object.propertyIsEnumerable.call(obj, symbol) && !keys.includes(symbol)) {
      result[symbol] = obj[symbol];
    }
  }
  return result;
}
function deep_read_state(value) {
  if (typeof value !== "object" || !value || value instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value) {
    deep_read(value);
  } else if (!Array.isArray(value)) {
    for (let key2 in value) {
      const prop2 = value[key2];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
  !(value instanceof EventTarget) && !visited.has(value)) {
    visited.add(value);
    if (value instanceof Date) {
      value.getTime();
    }
    for (let key2 in value) {
      try {
        deep_read(value[key2], visited);
      } catch (e) {
      }
    }
    const proto = get_prototype_of(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key2 in descriptors) {
        const get3 = descriptors[key2].get;
        if (get3) {
          try {
            get3.call(value);
          } catch (e) {
          }
        }
      }
    }
  }
}
var is_updating_effect, is_destroying_effect, active_reaction, untracking, active_effect, current_sources, new_deps, skipped_deps, untracked_writes, write_version, read_version, update_version, STATUS_MASK;
var init_runtime = __esm({
  "node_modules/svelte/src/internal/client/runtime.js"() {
    init_esm_env();
    init_utils();
    init_effects();
    init_constants2();
    init_sources();
    init_deriveds();
    init_flags();
    init_tracing();
    init_dev();
    init_context();
    init_warnings();
    init_batch();
    init_error_handling();
    init_constants();
    init_legacy();
    init_shared();
    is_updating_effect = false;
    is_destroying_effect = false;
    active_reaction = null;
    untracking = false;
    active_effect = null;
    current_sources = null;
    new_deps = null;
    skipped_deps = 0;
    untracked_writes = null;
    write_version = 1;
    read_version = 0;
    update_version = read_version;
    STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
  }
});

// node_modules/svelte/src/attachments/index.js
function createAttachmentKey() {
  return Symbol(ATTACHMENT_KEY);
}
var init_attachments = __esm({
  "node_modules/svelte/src/attachments/index.js"() {
    init_client();
    init_constants();
    init_index_client();
    init_effects();
  }
});

// node_modules/svelte/src/utils.js
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}
function is_void(name) {
  return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
function can_delegate_event(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
function normalize_attribute(name) {
  name = name.toLowerCase();
  return ATTRIBUTE_ALIASES[name] ?? name;
}
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
function is_raw_text_element(name) {
  return RAW_TEXT_ELEMENTS.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    name
  );
}
function sanitize_location(location2) {
  return (
    /** @type {T} */
    location2?.replace(/\//g, "/\u200B")
  );
}
var regex_return_characters, VOID_ELEMENT_NAMES, DELEGATED_EVENTS, DOM_BOOLEAN_ATTRIBUTES, ATTRIBUTE_ALIASES, DOM_PROPERTIES, PASSIVE_EVENTS, STATE_CREATION_RUNES, RUNES, RAW_TEXT_ELEMENTS;
var init_utils2 = __esm({
  "node_modules/svelte/src/utils.js"() {
    regex_return_characters = /\r/g;
    VOID_ELEMENT_NAMES = [
      "area",
      "base",
      "br",
      "col",
      "command",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    DELEGATED_EVENTS = [
      "beforeinput",
      "click",
      "change",
      "dblclick",
      "contextmenu",
      "focusin",
      "focusout",
      "input",
      "keydown",
      "keyup",
      "mousedown",
      "mousemove",
      "mouseout",
      "mouseover",
      "mouseup",
      "pointerdown",
      "pointermove",
      "pointerout",
      "pointerover",
      "pointerup",
      "touchend",
      "touchmove",
      "touchstart"
    ];
    DOM_BOOLEAN_ATTRIBUTES = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "indeterminate",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected",
      "webkitdirectory",
      "defer",
      "disablepictureinpicture",
      "disableremoteplayback"
    ];
    ATTRIBUTE_ALIASES = {
      // no `class: 'className'` because we handle that separately
      formnovalidate: "formNoValidate",
      ismap: "isMap",
      nomodule: "noModule",
      playsinline: "playsInline",
      readonly: "readOnly",
      defaultvalue: "defaultValue",
      defaultchecked: "defaultChecked",
      srcobject: "srcObject",
      novalidate: "noValidate",
      allowfullscreen: "allowFullscreen",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback"
    };
    DOM_PROPERTIES = [
      ...DOM_BOOLEAN_ATTRIBUTES,
      "formNoValidate",
      "isMap",
      "noModule",
      "playsInline",
      "readOnly",
      "value",
      "volume",
      "defaultValue",
      "defaultChecked",
      "srcObject",
      "noValidate",
      "allowFullscreen",
      "disablePictureInPicture",
      "disableRemotePlayback"
    ];
    PASSIVE_EVENTS = ["touchstart", "touchmove"];
    STATE_CREATION_RUNES = /** @type {const} */
    [
      "$state",
      "$state.raw",
      "$derived",
      "$derived.by"
    ];
    RUNES = /** @type {const} */
    [
      ...STATE_CREATION_RUNES,
      "$state.eager",
      "$state.snapshot",
      "$props",
      "$props.id",
      "$bindable",
      "$effect",
      "$effect.pre",
      "$effect.tracking",
      "$effect.root",
      "$effect.pending",
      "$inspect",
      "$inspect().with",
      "$inspect.trace",
      "$host"
    ];
    RAW_TEXT_ELEMENTS = /** @type {const} */
    ["textarea", "script", "style", "title"];
  }
});

// node_modules/svelte/src/internal/client/dev/assign.js
function compare(a, b, property, location2) {
  if (a !== b) {
    assignment_value_stale(
      property,
      /** @type {string} */
      sanitize_location(location2)
    );
  }
  return a;
}
function assign(object, property, value, location2) {
  return compare(
    object[property] = value,
    untrack(() => object[property]),
    property,
    location2
  );
}
function assign_and(object, property, value, location2) {
  return compare(
    object[property] &&= value,
    untrack(() => object[property]),
    property,
    location2
  );
}
function assign_or(object, property, value, location2) {
  return compare(
    object[property] ||= value,
    untrack(() => object[property]),
    property,
    location2
  );
}
function assign_nullish(object, property, value, location2) {
  return compare(
    object[property] ??= value,
    untrack(() => object[property]),
    property,
    location2
  );
}
var init_assign = __esm({
  "node_modules/svelte/src/internal/client/dev/assign.js"() {
    init_utils2();
    init_runtime();
    init_warnings();
  }
});

// node_modules/svelte/src/internal/client/dev/css.js
function register_style(hash2, style) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = /* @__PURE__ */ new Set();
    all_styles.set(hash2, styles);
  }
  styles.add(style);
}
function cleanup_styles(hash2) {
  var styles = all_styles.get(hash2);
  if (!styles) return;
  for (const style of styles) {
    style.remove();
  }
  all_styles.delete(hash2);
}
var all_styles;
var init_css = __esm({
  "node_modules/svelte/src/internal/client/dev/css.js"() {
    all_styles = /* @__PURE__ */ new Map();
  }
});

// node_modules/svelte/src/internal/client/dev/elements.js
function add_locations(fn, filename, locations) {
  return (...args) => {
    const dom = fn(...args);
    var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
    assign_locations(node, filename, locations);
    return dom;
  };
}
function assign_location(element3, filename, location2) {
  element3.__svelte_meta = {
    parent: dev_stack,
    loc: { file: filename, line: location2[0], column: location2[1] }
  };
  if (location2[2]) {
    assign_locations(element3.firstChild, filename, location2[2]);
  }
}
function assign_locations(node, filename, locations) {
  var i = 0;
  var depth = 0;
  while (node && i < locations.length) {
    if (hydrating && node.nodeType === COMMENT_NODE) {
      var comment2 = (
        /** @type {Comment} */
        node
      );
      if (comment2.data === HYDRATION_START || comment2.data === HYDRATION_START_ELSE) depth += 1;
      else if (comment2.data[0] === HYDRATION_END) depth -= 1;
    }
    if (depth === 0 && node.nodeType === ELEMENT_NODE) {
      assign_location(
        /** @type {Element} */
        node,
        filename,
        locations[i++]
      );
    }
    node = node.nextSibling;
  }
}
var init_elements = __esm({
  "node_modules/svelte/src/internal/client/dev/elements.js"() {
    init_constants2();
    init_constants();
    init_hydration();
    init_context();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/events.js
function replay_events(dom) {
  if (!hydrating) return;
  dom.removeAttribute("onload");
  dom.removeAttribute("onerror");
  const event2 = dom.__e;
  if (event2 !== void 0) {
    dom.__e = void 0;
    queueMicrotask(() => {
      if (dom.isConnected) {
        dom.dispatchEvent(event2);
      }
    });
  }
}
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event2);
    }
    if (!event2.cancelBubble) {
      return without_reactive_context(() => {
        return handler?.call(this, event2);
      });
    }
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function event(event_name, dom, handler, capture2, passive2) {
  var options = { capture: capture2, passive: passive2 };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || // @ts-ignore
  dom === window || // @ts-ignore
  dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = event2.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          delegated.call(current_target, event2);
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function apply(thunk, element3, args, component2, loc, has_side_effects = false, remove_parens = false) {
  let handler;
  let error;
  try {
    handler = thunk();
  } catch (e) {
    error = e;
  }
  if (typeof handler !== "function" && (has_side_effects || handler != null || error)) {
    const filename = component2?.[FILENAME];
    const location2 = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
    const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? "capture" : "";
    const event_name = args[0]?.type + phase;
    const description = `\`${event_name}\` handler${location2}`;
    const suggestion = remove_parens ? "remove the trailing `()`" : "add a leading `() =>`";
    event_handler_invalid(description, suggestion);
    if (error) {
      throw error;
    }
  }
  handler?.apply(element3, args);
}
var all_registered_events, root_event_handles, last_propagated_event;
var init_events = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/events.js"() {
    init_effects();
    init_utils();
    init_hydration();
    init_task();
    init_constants();
    init_warnings();
    init_runtime();
    init_shared();
    all_registered_events = /* @__PURE__ */ new Set();
    root_event_handles = /* @__PURE__ */ new Set();
    last_propagated_event = null;
  }
});

// node_modules/svelte/src/internal/client/dom/reconciler.js
function create_fragment_from_html(html3) {
  var elem = document.createElement("template");
  elem.innerHTML = html3.replaceAll("<!>", "<!---->");
  return elem.content;
}
var init_reconciler = __esm({
  "node_modules/svelte/src/internal/client/dom/reconciler.js"() {
  }
});

// node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes_start === null) {
    effect2.nodes_start = start;
    effect2.nodes_end = end;
  }
}
// @__NO_SIDE_EFFECTS__
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment) node = /** @type {Node} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_namespace(content, flags2, ns = "svg") {
  var has_start = !content.startsWith("<!>");
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (!node) {
      var fragment = (
        /** @type {DocumentFragment} */
        create_fragment_from_html(wrapped)
      );
      var root = (
        /** @type {Element} */
        get_first_child(fragment)
      );
      if (is_fragment) {
        node = document.createDocumentFragment();
        while (get_first_child(root)) {
          node.appendChild(
            /** @type {Node} */
            get_first_child(root)
          );
        }
      } else {
        node = /** @type {Element} */
        get_first_child(root);
      }
    }
    var clone2 = (
      /** @type {TemplateNode} */
      node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_svg(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "svg");
}
// @__NO_SIDE_EFFECTS__
function from_mathml(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "math");
}
function fragment_from_tree(structure, ns) {
  var fragment = create_fragment();
  for (var item of structure) {
    if (typeof item === "string") {
      fragment.append(create_text(item));
      continue;
    }
    if (item === void 0 || item[0][0] === "/") {
      fragment.append(create_comment(item ? item[0].slice(3) : ""));
      continue;
    }
    const [name, attributes2, ...children] = item;
    const namespace = name === "svg" ? NAMESPACE_SVG : name === "math" ? NAMESPACE_MATHML : ns;
    var element3 = create_element(name, namespace, attributes2?.is);
    for (var key2 in attributes2) {
      set_attribute(element3, key2, attributes2[key2]);
    }
    if (children.length > 0) {
      var target = element3.tagName === "TEMPLATE" ? (
        /** @type {HTMLTemplateElement} */
        element3.content
      ) : element3;
      target.append(
        fragment_from_tree(children, element3.tagName === "foreignObject" ? void 0 : namespace)
      );
    }
    fragment.append(element3);
  }
  return fragment;
}
// @__NO_SIDE_EFFECTS__
function from_tree(structure, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      const ns = (flags2 & TEMPLATE_USE_SVG) !== 0 ? NAMESPACE_SVG : (flags2 & TEMPLATE_USE_MATHML) !== 0 ? NAMESPACE_MATHML : void 0;
      node = fragment_from_tree(structure, ns);
      if (!is_fragment) node = /** @type {Node} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
function with_script(fn) {
  return () => run_scripts(fn());
}
function run_scripts(node) {
  if (hydrating) return node;
  const is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE;
  const scripts = (
    /** @type {HTMLElement} */
    node.tagName === "SCRIPT" ? [
      /** @type {HTMLScriptElement} */
      node
    ] : node.querySelectorAll("script")
  );
  const effect2 = (
    /** @type {Effect} */
    active_effect
  );
  for (const script of scripts) {
    const clone2 = document.createElement("script");
    for (var attribute of script.attributes) {
      clone2.setAttribute(attribute.name, attribute.value);
    }
    clone2.textContent = script.textContent;
    if (is_fragment ? node.firstChild === script : node === script) {
      effect2.nodes_start = clone2;
    }
    if (is_fragment ? node.lastChild === script : node === script) {
      effect2.nodes_end = clone2;
    }
    script.replaceWith(clone2);
  }
  return node;
}
function text(value = "") {
  if (!hydrating) {
    var t = create_text(value + "");
    assign_nodes(t, t);
    return t;
  }
  var node = hydrate_node;
  if (node.nodeType !== TEXT_NODE) {
    node.before(node = create_text());
    set_hydrate_node(node);
  }
  assign_nodes(node, node);
  return node;
}
function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment();
  var start = document.createComment("");
  var anchor = create_text();
  frag.append(start, anchor);
  assign_nodes(start, anchor);
  return frag;
}
function append(anchor, dom) {
  if (hydrating) {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if ((effect2.f & EFFECT_RAN) === 0 || effect2.nodes_end === null) {
      effect2.nodes_end = hydrate_node;
    }
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
function props_id() {
  if (hydrating && hydrate_node && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.textContent?.startsWith(`$`)) {
    const id = hydrate_node.textContent.substring(1);
    hydrate_next();
    return id;
  }
  (window.__svelte ??= {}).uid ??= 1;
  return `c${window.__svelte.uid++}`;
}
var init_template = __esm({
  "node_modules/svelte/src/internal/client/dom/template.js"() {
    init_hydration();
    init_operations();
    init_reconciler();
    init_runtime();
    init_constants();
    init_constants2();
  }
});

// node_modules/svelte/src/internal/client/render.js
function set_should_intro(value) {
  should_intro = value;
}
function set_text(text2, value) {
  var str = value == null ? "" : typeof value === "object" ? value + "" : value;
  if (str !== (text2.__t ??= text2.nodeValue)) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  init_operations2();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component2, { ...options, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations2();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
function _mount(Component, { target, anchor, props = {}, events, context: context2, intro = true }) {
  init_operations2();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n = document_listeners.get(event_name);
      if (n === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount3 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: () => {
        }
      },
      (anchor_node2) => {
        if (context2) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context2;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context2) {
          pop();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount3);
  return component2;
}
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (true_default) {
    if (STATE_SYMBOL in component2) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}
var should_intro, document_listeners, mounted_components;
var init_render = __esm({
  "node_modules/svelte/src/internal/client/render.js"() {
    init_esm_env();
    init_operations();
    init_constants();
    init_runtime();
    init_context();
    init_effects();
    init_hydration();
    init_utils();
    init_events();
    init_warnings();
    init_errors2();
    init_template();
    init_utils2();
    init_constants2();
    init_boundary();
    should_intro = true;
    document_listeners = /* @__PURE__ */ new Map();
    mounted_components = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/svelte/src/internal/client/dev/hmr.js
function hmr(original, get_source) {
  function wrapper(anchor, props) {
    let instance = {};
    let effect2;
    let ran = false;
    block(() => {
      const source2 = get_source();
      const component2 = get(source2);
      if (effect2) {
        for (var k in instance) delete instance[k];
        destroy_effect(effect2);
      }
      effect2 = branch(() => {
        if (ran) set_should_intro(false);
        Object.defineProperties(
          instance,
          Object.getOwnPropertyDescriptors(
            // @ts-expect-error
            new.target ? new component2(anchor, props) : component2(anchor, props)
          )
        );
        if (ran) set_should_intro(true);
      });
    }, EFFECT_TRANSPARENT);
    ran = true;
    if (hydrating) {
      anchor = hydrate_node;
    }
    return instance;
  }
  wrapper[FILENAME] = original[FILENAME];
  wrapper[HMR] = {
    // When we accept an update, we set the original source to the new component
    original,
    // The `get_source` parameter reads `wrapper[HMR].source`, but in the `accept`
    // function we always replace it with `previous[HMR].source`, which in practice
    // means we only ever update the original
    source: source(original)
  };
  return wrapper;
}
var init_hmr = __esm({
  "node_modules/svelte/src/internal/client/dev/hmr.js"() {
    init_constants();
    init_constants2();
    init_hydration();
    init_effects();
    init_sources();
    init_render();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dev/ownership.js
function create_ownership_validator(props) {
  const component2 = component_context?.function;
  const parent = component_context?.p?.function;
  return {
    /**
     * @param {string} prop
     * @param {any[]} path
     * @param {any} result
     * @param {number} line
     * @param {number} column
     */
    mutation: (prop2, path, result, line, column) => {
      const name = path[0];
      if (is_bound_or_unset(props, name) || !parent) {
        return result;
      }
      let value = props;
      for (let i = 0; i < path.length - 1; i++) {
        value = value[path[i]];
        if (!value?.[STATE_SYMBOL]) {
          return result;
        }
      }
      const location2 = sanitize_location(`${component2[FILENAME]}:${line}:${column}`);
      ownership_invalid_mutation(name, location2, prop2, parent[FILENAME]);
      return result;
    },
    /**
     * @param {any} key
     * @param {any} child_component
     * @param {() => any} value
     */
    binding: (key2, child_component, value) => {
      if (!is_bound_or_unset(props, key2) && parent && value()?.[STATE_SYMBOL]) {
        ownership_invalid_binding(
          component2[FILENAME],
          key2,
          child_component[FILENAME],
          parent[FILENAME]
        );
      }
    }
  };
}
function is_bound_or_unset(props, prop_name) {
  const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
  return !!get_descriptor(props, prop_name)?.set || is_entry_props && prop_name in props || !(prop_name in props);
}
var init_ownership = __esm({
  "node_modules/svelte/src/internal/client/dev/ownership.js"() {
    init_utils();
    init_constants2();
    init_constants();
    init_context();
    init_warnings();
    init_utils2();
  }
});

// node_modules/svelte/src/internal/client/dev/legacy.js
function check_target(target) {
  if (target) {
    component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
  }
}
function legacy_api() {
  const component2 = component_context?.function;
  function error(method) {
    component_api_changed(method, component2[FILENAME]);
  }
  return {
    $destroy: () => error("$destroy()"),
    $on: () => error("$on(...)"),
    $set: () => error("$set(...)")
  };
}
var init_legacy2 = __esm({
  "node_modules/svelte/src/internal/client/dev/legacy.js"() {
    init_errors2();
    init_context();
    init_constants();
  }
});

// node_modules/svelte/src/internal/client/dev/inspect.js
function inspect(get_value, inspector, show_stack = false) {
  validate_effect("$inspect");
  let initial = true;
  let error = (
    /** @type {any} */
    UNINITIALIZED
  );
  eager_effect(() => {
    try {
      var value = get_value();
    } catch (e) {
      error = e;
      return;
    }
    var snap = snapshot(value, true, true);
    untrack(() => {
      if (show_stack) {
        inspector(...snap);
        if (!initial) {
          const stack2 = get_error("$inspect(...)");
          if (stack2) {
            console.groupCollapsed("stack trace");
            console.log(stack2);
            console.groupEnd();
          }
        }
      } else {
        inspector(initial ? "init" : "update", ...snap);
      }
    });
    initial = false;
  });
  render_effect(() => {
    try {
      get_value();
    } catch {
    }
    if (error !== UNINITIALIZED) {
      console.error(error);
      error = UNINITIALIZED;
    }
  });
}
var init_inspect = __esm({
  "node_modules/svelte/src/internal/client/dev/inspect.js"() {
    init_constants();
    init_clone();
    init_effects();
    init_runtime();
    init_dev();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/async.js
function async(node, blockers = [], expressions = [], fn) {
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var was_hydrating = hydrating;
  if (was_hydrating) {
    hydrate_next();
    var previous_hydrate_node = hydrate_node;
    var end = skip_nodes(false);
    set_hydrate_node(end);
  }
  flatten(blockers, [], expressions, (values) => {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(previous_hydrate_node);
    }
    try {
      for (const d of values) get(d);
      fn(node, ...values);
    } finally {
      if (was_hydrating) {
        set_hydrating(false);
      }
      boundary2.update_pending_count(-1);
      batch.decrement(blocking);
    }
  });
}
var init_async2 = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/async.js"() {
    init_async();
    init_batch();
    init_runtime();
    init_hydration();
    init_boundary();
  }
});

// node_modules/svelte/src/internal/client/dev/validation.js
function validate_snippet_args(anchor, ...args) {
  if (typeof anchor !== "object" || !(anchor instanceof Node)) {
    invalid_snippet_arguments();
  }
  for (let arg of args) {
    if (typeof arg !== "function") {
      invalid_snippet_arguments();
    }
  }
}
var init_validation = __esm({
  "node_modules/svelte/src/internal/client/dev/validation.js"() {
    init_errors2();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/branches.js
var BranchManager;
var init_branches = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/branches.js"() {
    init_batch();
    init_effects();
    init_hydration();
    init_operations();
    BranchManager = class {
      /** @type {TemplateNode} */
      anchor;
      /** @type {Map<Batch, Key>} */
      #batches = /* @__PURE__ */ new Map();
      /**
       * Map of keys to effects that are currently rendered in the DOM.
       * These effects are visible and actively part of the document tree.
       * Example:
       * ```
       * {#if condition}
       * 	foo
       * {:else}
       * 	bar
       * {/if}
       * ```
       * Can result in the entries `true->Effect` and `false->Effect`
       * @type {Map<Key, Effect>}
       */
      #onscreen = /* @__PURE__ */ new Map();
      /**
       * Similar to #onscreen with respect to the keys, but contains branches that are not yet
       * in the DOM, because their insertion is deferred.
       * @type {Map<Key, Branch>}
       */
      #offscreen = /* @__PURE__ */ new Map();
      /**
       * Keys of effects that are currently outroing
       * @type {Set<Key>}
       */
      #outroing = /* @__PURE__ */ new Set();
      /**
       * Whether to pause (i.e. outro) on change, or destroy immediately.
       * This is necessary for `<svelte:element>`
       */
      #transition = true;
      /**
       * @param {TemplateNode} anchor
       * @param {boolean} transition
       */
      constructor(anchor, transition2 = true) {
        this.anchor = anchor;
        this.#transition = transition2;
      }
      #commit = () => {
        var batch = (
          /** @type {Batch} */
          current_batch
        );
        if (!this.#batches.has(batch)) return;
        var key2 = (
          /** @type {Key} */
          this.#batches.get(batch)
        );
        var onscreen = this.#onscreen.get(key2);
        if (onscreen) {
          resume_effect(onscreen);
          this.#outroing.delete(key2);
        } else {
          var offscreen = this.#offscreen.get(key2);
          if (offscreen) {
            this.#onscreen.set(key2, offscreen.effect);
            this.#offscreen.delete(key2);
            offscreen.fragment.lastChild.remove();
            this.anchor.before(offscreen.fragment);
            onscreen = offscreen.effect;
          }
        }
        for (const [b, k] of this.#batches) {
          this.#batches.delete(b);
          if (b === batch) {
            break;
          }
          const offscreen2 = this.#offscreen.get(k);
          if (offscreen2) {
            destroy_effect(offscreen2.effect);
            this.#offscreen.delete(k);
          }
        }
        for (const [k, effect2] of this.#onscreen) {
          if (k === key2 || this.#outroing.has(k)) continue;
          const on_destroy = () => {
            const keys = Array.from(this.#batches.values());
            if (keys.includes(k)) {
              var fragment = document.createDocumentFragment();
              move_effect(effect2, fragment);
              fragment.append(create_text());
              this.#offscreen.set(k, { effect: effect2, fragment });
            } else {
              destroy_effect(effect2);
            }
            this.#outroing.delete(k);
            this.#onscreen.delete(k);
          };
          if (this.#transition || !onscreen) {
            this.#outroing.add(k);
            pause_effect(effect2, on_destroy, false);
          } else {
            on_destroy();
          }
        }
      };
      /**
       * @param {Batch} batch
       */
      #discard = (batch) => {
        this.#batches.delete(batch);
        const keys = Array.from(this.#batches.values());
        for (const [k, branch2] of this.#offscreen) {
          if (!keys.includes(k)) {
            destroy_effect(branch2.effect);
            this.#offscreen.delete(k);
          }
        }
      };
      /**
       *
       * @param {any} key
       * @param {null | ((target: TemplateNode) => void)} fn
       */
      ensure(key2, fn) {
        var batch = (
          /** @type {Batch} */
          current_batch
        );
        var defer = should_defer_append();
        if (fn && !this.#onscreen.has(key2) && !this.#offscreen.has(key2)) {
          if (defer) {
            var fragment = document.createDocumentFragment();
            var target = create_text();
            fragment.append(target);
            this.#offscreen.set(key2, {
              effect: branch(() => fn(target)),
              fragment
            });
          } else {
            this.#onscreen.set(
              key2,
              branch(() => fn(this.anchor))
            );
          }
        }
        this.#batches.set(batch, key2);
        if (defer) {
          for (const [k, effect2] of this.#onscreen) {
            if (k === key2) {
              batch.skipped_effects.delete(effect2);
            } else {
              batch.skipped_effects.add(effect2);
            }
          }
          for (const [k, branch2] of this.#offscreen) {
            if (k === key2) {
              batch.skipped_effects.delete(branch2.effect);
            } else {
              batch.skipped_effects.add(branch2.effect);
            }
          }
          batch.oncommit(this.#commit);
          batch.ondiscard(this.#discard);
        } else {
          if (hydrating) {
            this.anchor = hydrate_node;
          }
          this.#commit();
        }
      }
    };
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/await.js
function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var runes = is_runes();
  var v = (
    /** @type {V} */
    UNINITIALIZED
  );
  var value = runes ? source(v) : mutable_source(v, false, false);
  var error = runes ? source(v) : mutable_source(v, false, false);
  var branches = new BranchManager(node);
  block(() => {
    var input = get_input();
    var destroyed = false;
    let mismatch = hydrating && is_promise(input) === (node.data === HYDRATION_START_ELSE);
    if (mismatch) {
      set_hydrate_node(skip_nodes());
      set_hydrating(false);
    }
    if (is_promise(input)) {
      var restore = capture();
      var resolved = false;
      const resolve = (fn) => {
        if (destroyed) return;
        resolved = true;
        restore(false);
        Batch.ensure();
        if (hydrating) {
          set_hydrating(false);
        }
        try {
          fn();
        } finally {
          unset_context();
          if (!is_flushing_sync) flushSync();
        }
      };
      input.then(
        (v2) => {
          resolve(() => {
            internal_set(value, v2);
            branches.ensure(THEN, then_fn && ((target) => then_fn(target, value)));
          });
        },
        (e) => {
          resolve(() => {
            internal_set(error, e);
            branches.ensure(THEN, catch_fn && ((target) => catch_fn(target, error)));
            if (!catch_fn) {
              throw error.v;
            }
          });
        }
      );
      if (hydrating) {
        branches.ensure(PENDING, pending_fn);
      } else {
        queue_micro_task(() => {
          if (!resolved) {
            resolve(() => {
              branches.ensure(PENDING, pending_fn);
            });
          }
        });
      }
    } else {
      internal_set(value, input);
      branches.ensure(THEN, then_fn && ((target) => then_fn(target, value)));
    }
    if (mismatch) {
      set_hydrating(true);
    }
    return () => {
      destroyed = true;
    };
  });
}
var PENDING, THEN;
var init_await = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/await.js"() {
    init_utils();
    init_effects();
    init_sources();
    init_hydration();
    init_task();
    init_constants();
    init_context();
    init_batch();
    init_branches();
    init_async();
    PENDING = 0;
    THEN = 1;
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function if_block(node, fn, elseif = false) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var flags2 = elseif ? EFFECT_TRANSPARENT : 0;
  function update_branch(condition, fn2) {
    if (hydrating) {
      const is_else = read_hydration_instruction(node) === HYDRATION_START_ELSE;
      if (condition === is_else) {
        var anchor = skip_nodes();
        set_hydrate_node(anchor);
        branches.anchor = anchor;
        set_hydrating(false);
        branches.ensure(condition, fn2);
        set_hydrating(true);
        return;
      }
    }
    branches.ensure(condition, fn2);
  }
  block(() => {
    var has_branch = false;
    fn((fn2, flag = true) => {
      has_branch = true;
      update_branch(flag, fn2);
    });
    if (!has_branch) {
      update_branch(false, null);
    }
  }, flags2);
}
var init_if = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/if.js"() {
    init_constants2();
    init_hydration();
    init_effects();
    init_constants();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/key.js
function key(node, get_key, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var legacy = !is_runes();
  block(() => {
    var key2 = get_key();
    if (legacy && key2 !== null && typeof key2 === "object") {
      key2 = /** @type {V} */
      {};
    }
    branches.ensure(key2, render_fn);
  });
}
var init_key = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/key.js"() {
    init_context();
    init_effects();
    init_hydration();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/css-props.js
function css_props(element3, get_styles) {
  if (hydrating) {
    set_hydrate_node(
      /** @type {TemplateNode} */
      get_first_child(element3)
    );
  }
  render_effect(() => {
    var styles = get_styles();
    for (var key2 in styles) {
      var value = styles[key2];
      if (value) {
        element3.style.setProperty(key2, value);
      } else {
        element3.style.removeProperty(key2);
      }
    }
  });
}
var init_css_props = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/css-props.js"() {
    init_effects();
    init_hydration();
    init_operations();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/html.js
function check_hash(element3, server_hash, value) {
  if (!server_hash || server_hash === hash(String(value ?? ""))) return;
  let location2;
  const loc = element3.__svelte_meta?.loc;
  if (loc) {
    location2 = `near ${loc.file}:${loc.line}:${loc.column}`;
  } else if (dev_current_component_function?.[FILENAME]) {
    location2 = `in ${dev_current_component_function[FILENAME]}`;
  }
  hydration_html_changed(sanitize_location(location2));
}
function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
  var anchor = node;
  var value = "";
  template_effect(() => {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (value === (value = get_value() ?? "")) {
      if (hydrating) hydrate_next();
      return;
    }
    if (effect2.nodes_start !== null) {
      remove_effect_dom(
        effect2.nodes_start,
        /** @type {TemplateNode} */
        effect2.nodes_end
      );
      effect2.nodes_start = effect2.nodes_end = null;
    }
    if (value === "") return;
    if (hydrating) {
      var hash2 = (
        /** @type {Comment} */
        hydrate_node.data
      );
      var next2 = hydrate_next();
      var last = next2;
      while (next2 !== null && (next2.nodeType !== COMMENT_NODE || /** @type {Comment} */
      next2.data !== "")) {
        last = next2;
        next2 = /** @type {TemplateNode} */
        get_next_sibling(next2);
      }
      if (next2 === null) {
        hydration_mismatch();
        throw HYDRATION_ERROR;
      }
      if (true_default && !skip_warning) {
        check_hash(
          /** @type {Element} */
          next2.parentNode,
          hash2,
          value
        );
      }
      assign_nodes(hydrate_node, last);
      anchor = set_hydrate_node(next2);
      return;
    }
    var html3 = value + "";
    if (svg) html3 = `<svg>${html3}</svg>`;
    else if (mathml) html3 = `<math>${html3}</math>`;
    var node2 = create_fragment_from_html(html3);
    if (svg || mathml) {
      node2 = /** @type {Element} */
      get_first_child(node2);
    }
    assign_nodes(
      /** @type {TemplateNode} */
      get_first_child(node2),
      /** @type {TemplateNode} */
      node2.lastChild
    );
    if (svg || mathml) {
      while (get_first_child(node2)) {
        anchor.before(
          /** @type {Node} */
          get_first_child(node2)
        );
      }
    } else {
      anchor.before(node2);
    }
  });
}
var init_html = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/html.js"() {
    init_constants();
    init_effects();
    init_hydration();
    init_reconciler();
    init_template();
    init_warnings();
    init_utils2();
    init_esm_env();
    init_context();
    init_operations();
    init_runtime();
    init_constants2();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/slot.js
function slot(anchor, $$props, name, slot_props, fallback_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var slot_fn = $$props.$$slots?.[name];
  var is_interop = false;
  if (slot_fn === true) {
    slot_fn = $$props[name === "default" ? "children" : name];
    is_interop = true;
  }
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, is_interop ? () => slot_props : slot_props);
  }
}
function sanitize_slots(props) {
  const sanitized = {};
  if (props.children) sanitized.default = true;
  for (const key2 in props.$$slots) {
    sanitized[key2] = true;
  }
  return sanitized;
}
var init_slot = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/slot.js"() {
    init_hydration();
  }
});

// node_modules/svelte/src/internal/shared/validate.js
function validate_void_dynamic_element(tag_fn) {
  const tag2 = tag_fn();
  if (tag2 && is_void(tag2)) {
    dynamic_void_element_content(tag2);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag2 = tag_fn();
  const is_string = typeof tag2 === "string";
  if (tag2 && !is_string) {
    svelte_element_invalid_this_value();
  }
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    store_invalid_shape(name);
  }
}
function prevent_snippet_stringification(fn) {
  fn.toString = () => {
    snippet_without_render_tag();
    return "";
  };
  return fn;
}
var init_validate = __esm({
  "node_modules/svelte/src/internal/shared/validate.js"() {
    init_utils2();
    init_warnings2();
    init_errors();
    init_errors();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/snippet.js
function snippet(node, get_snippet, ...args) {
  var branches = new BranchManager(node);
  block(() => {
    const snippet2 = get_snippet() ?? null;
    if (true_default && snippet2 == null) {
      invalid_snippet();
    }
    branches.ensure(snippet2, snippet2 && ((anchor) => snippet2(anchor, ...args)));
  }, EFFECT_TRANSPARENT);
}
function wrap_snippet(component2, fn) {
  const snippet2 = (node, ...args) => {
    var previous_component_function = dev_current_component_function;
    set_dev_current_component_function(component2);
    try {
      return fn(node, ...args);
    } finally {
      set_dev_current_component_function(previous_component_function);
    }
  };
  prevent_snippet_stringification(snippet2);
  return snippet2;
}
var init_snippet = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/snippet.js"() {
    init_constants2();
    init_effects();
    init_context();
    init_hydration();
    init_reconciler();
    init_template();
    init_warnings();
    init_errors2();
    init_esm_env();
    init_operations();
    init_validate();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js
function component(node, get_component, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  block(() => {
    var component2 = get_component() ?? null;
    branches.ensure(component2, component2 && ((target) => render_fn(target, component2)));
  }, EFFECT_TRANSPARENT);
}
var init_svelte_component = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js"() {
    init_constants2();
    init_effects();
    init_hydration();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
function element(node, get_tag, is_svg, render_fn, get_namespace, location2) {
  let was_hydrating = hydrating;
  if (hydrating) {
    hydrate_next();
  }
  var filename = true_default && location2 && component_context?.function[FILENAME];
  var element3 = null;
  if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
    element3 = /** @type {Element} */
    hydrate_node;
    hydrate_next();
  }
  var anchor = (
    /** @type {TemplateNode} */
    hydrating ? hydrate_node : node
  );
  var each_item_block = current_each_item;
  var branches = new BranchManager(anchor, false);
  block(() => {
    const next_tag = get_tag() || null;
    var ns = get_namespace ? get_namespace() : is_svg || next_tag === "svg" ? NAMESPACE_SVG : null;
    if (next_tag === null) {
      branches.ensure(null, null);
      set_should_intro(true);
      return;
    }
    branches.ensure(next_tag, (anchor2) => {
      var previous_each_item = current_each_item;
      set_current_each_item(each_item_block);
      if (next_tag) {
        element3 = hydrating ? (
          /** @type {Element} */
          element3
        ) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag);
        if (true_default && location2) {
          element3.__svelte_meta = {
            parent: dev_stack,
            loc: {
              file: filename,
              line: location2[0],
              column: location2[1]
            }
          };
        }
        assign_nodes(element3, element3);
        if (render_fn) {
          if (hydrating && is_raw_text_element(next_tag)) {
            element3.append(document.createComment(""));
          }
          var child_anchor = (
            /** @type {TemplateNode} */
            hydrating ? get_first_child(element3) : element3.appendChild(create_text())
          );
          if (hydrating) {
            if (child_anchor === null) {
              set_hydrating(false);
            } else {
              set_hydrate_node(child_anchor);
            }
          }
          render_fn(element3, child_anchor);
        }
        active_effect.nodes_end = element3;
        anchor2.before(element3);
      }
      set_current_each_item(previous_each_item);
      if (hydrating) {
        set_hydrate_node(anchor2);
      }
    });
    set_should_intro(true);
    return () => {
      if (next_tag) {
        set_should_intro(false);
      }
    };
  }, EFFECT_TRANSPARENT);
  teardown(() => {
    set_should_intro(true);
  });
  if (was_hydrating) {
    set_hydrating(true);
    set_hydrate_node(anchor);
  }
}
var init_svelte_element = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js"() {
    init_constants();
    init_hydration();
    init_operations();
    init_effects();
    init_render();
    init_each();
    init_runtime();
    init_context();
    init_esm_env();
    init_constants2();
    init_template();
    init_utils2();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
function head(hash2, render_fn) {
  let previous_hydrate_node = null;
  let was_hydrating = hydrating;
  var anchor;
  if (hydrating) {
    previous_hydrate_node = hydrate_node;
    var head_anchor = (
      /** @type {TemplateNode} */
      get_first_child(document.head)
    );
    while (head_anchor !== null && (head_anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    head_anchor.data !== hash2)) {
      head_anchor = /** @type {TemplateNode} */
      get_next_sibling(head_anchor);
    }
    if (head_anchor === null) {
      set_hydrating(false);
    } else {
      var start = (
        /** @type {TemplateNode} */
        get_next_sibling(head_anchor)
      );
      head_anchor.remove();
      set_hydrate_node(start);
    }
  }
  if (!hydrating) {
    anchor = document.head.appendChild(create_text());
  }
  try {
    block(() => render_fn(anchor), HEAD_EFFECT);
  } finally {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(
        /** @type {TemplateNode} */
        previous_hydrate_node
      );
    }
  }
}
var init_svelte_head = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js"() {
    init_hydration();
    init_operations();
    init_effects();
    init_constants2();
  }
});

// node_modules/svelte/src/internal/client/dom/css.js
function append_styles2(anchor, css) {
  effect(() => {
    var root = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root.host ? (
        /** @type {ShadowRoot} */
        root
      ) : (
        /** @type {Document} */
        root.head ?? /** @type {Document} */
        root.ownerDocument.head
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style = document.createElement("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
      if (true_default) {
        register_style(css.hash, style);
      }
    }
  });
}
var init_css2 = __esm({
  "node_modules/svelte/src/internal/client/dom/css.js"() {
    init_esm_env();
    init_css();
    init_effects();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/actions.js
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value?.()) || {});
    if (get_value && payload?.update) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value = get_value();
        deep_read_state(value);
        if (inited && safe_not_equal(prev, value)) {
          prev = value;
          payload.update(value);
        }
      });
      inited = true;
    }
    if (payload?.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}
var init_actions = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/actions.js"() {
    init_effects();
    init_equality();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/attachments.js
function attach(node, get_fn) {
  var fn = void 0;
  var e;
  managed(() => {
    if (fn !== (fn = get_fn())) {
      if (e) {
        destroy_effect(e);
        e = null;
      }
      if (fn) {
        e = branch(() => {
          effect(() => (
            /** @type {(node: Element) => void} */
            fn(node)
          ));
        });
      }
    }
  });
}
var init_attachments2 = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/attachments.js"() {
    init_effects();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/class.js
function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value || prev === void 0) {
    var next_class_name = to_class(value, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key2 in next_classes) {
      var is_present = !!next_classes[key2];
      if (prev_classes == null || is_present !== !!prev_classes[key2]) {
        dom.classList.toggle(key2, is_present);
      }
    }
  }
  return next_classes;
}
var init_class = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/class.js"() {
    init_attributes();
    init_hydration();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/style.js
function update_styles(dom, prev = {}, next2, priority) {
  for (var key2 in next2) {
    var value = next2[key2];
    if (prev[key2] !== value) {
      if (next2[key2] == null) {
        dom.style.removeProperty(key2);
      } else {
        dom.style.setProperty(key2, value, priority);
      }
    }
  }
}
function set_style(dom, value, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value) {
    var next_style_attr = to_style(value, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles?.[0], next_styles[0]);
      update_styles(dom, prev_styles?.[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}
var init_style = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/style.js"() {
    init_attributes();
    init_hydration();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
function select_option(select, value, mounting = false) {
  if (select.multiple) {
    if (value == void 0) {
      return;
    }
    if (!is_array(value)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function init_select2(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
function bind_select_value(select, get3, set2 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  var mounting = true;
  listen_to_event_and_reset_event(select, "change", (is_reset) => {
    var query = is_reset ? "[selected]" : ":checked";
    var value;
    if (select.multiple) {
      value = [].map.call(select.querySelectorAll(query), get_option_value);
    } else {
      var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected
      select.querySelector("option:not([disabled])");
      value = selected_option && get_option_value(selected_option);
    }
    set2(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  });
  effect(() => {
    var value = get3();
    if (select === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    select_option(select, value, mounting);
    if (mounting && value === void 0) {
      var selected_option = select.querySelector(":checked");
      if (selected_option !== null) {
        value = get_option_value(selected_option);
        set2(value);
      }
    }
    select.__value = value;
    mounting = false;
  });
  init_select2(select);
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}
var init_select = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/select.js"() {
    init_effects();
    init_shared();
    init_proxy();
    init_utils();
    init_warnings();
    init_batch();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
function remove_input_defaults(input) {
  if (!hydrating) return;
  var already_removed = false;
  var remove_defaults = () => {
    if (already_removed) return;
    already_removed = true;
    if (input.hasAttribute("value")) {
      var value = input.value;
      set_attribute2(input, "value", null);
      input.value = value;
    }
    if (input.hasAttribute("checked")) {
      var checked = input.checked;
      set_attribute2(input, "checked", null);
      input.checked = checked;
    }
  };
  input.__on_r = remove_defaults;
  queue_micro_task(remove_defaults);
  add_form_reset_listener();
}
function set_value(element3, value) {
  var attributes2 = get_attributes(element3);
  if (attributes2.value === (attributes2.value = // treat null and undefined the same for the initial value
  value ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  element3.value === value && (value !== 0 || element3.nodeName !== "PROGRESS")) {
    return;
  }
  element3.value = value ?? "";
}
function set_checked(element3, checked) {
  var attributes2 = get_attributes(element3);
  if (attributes2.checked === (attributes2.checked = // treat null and undefined the same for the initial value
  checked ?? void 0)) {
    return;
  }
  element3.checked = checked;
}
function set_selected(element3, selected) {
  if (selected) {
    if (!element3.hasAttribute("selected")) {
      element3.setAttribute("selected", "");
    }
  } else {
    element3.removeAttribute("selected");
  }
}
function set_default_checked(element3, checked) {
  const existing_value = element3.checked;
  element3.defaultChecked = checked;
  element3.checked = existing_value;
}
function set_default_value(element3, value) {
  const existing_value = element3.value;
  element3.defaultValue = value;
  element3.value = existing_value;
}
function set_attribute2(element3, attribute, value, skip_warning) {
  var attributes2 = get_attributes(element3);
  if (hydrating) {
    attributes2[attribute] = element3.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element3.nodeName === "LINK") {
      if (!skip_warning) {
        check_src_in_dev_hydration(element3, attribute, value ?? "");
      }
      return;
    }
  }
  if (attributes2[attribute] === (attributes2[attribute] = value)) return;
  if (attribute === "loading") {
    element3[LOADING_ATTR_SYMBOL] = value;
  }
  if (value == null) {
    element3.removeAttribute(attribute);
  } else if (typeof value !== "string" && get_setters(element3).includes(attribute)) {
    element3[attribute] = value;
  } else {
    element3.setAttribute(attribute, value);
  }
}
function set_xlink_attribute(dom, attribute, value) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
}
function set_custom_element_data(node, prop2, value) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  let was_hydrating = hydrating;
  if (hydrating) {
    set_hydrating(false);
  }
  set_active_reaction(null);
  set_active_effect(null);
  try {
    if (
      // `style` should use `set_attribute` rather than the setter
      prop2 !== "style" && // Don't compute setters for custom elements while they aren't registered yet,
      // because during their upgrade/instantiation they might add more setters.
      // Instead, fall back to a simple "an object, then set as property" heuristic.
      (setters_cache.has(node.getAttribute("is") || node.nodeName) || // customElements may not be available in browser extension contexts
      !customElements || customElements.get(node.getAttribute("is") || node.tagName.toLowerCase()) ? get_setters(node).includes(prop2) : value && typeof value === "object")
    ) {
      node[prop2] = value;
    } else {
      set_attribute2(node, prop2, value == null ? value : String(value));
    }
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
    if (was_hydrating) {
      set_hydrating(true);
    }
  }
}
function set_attributes(element3, prev, next2, css_hash, should_remove_defaults = false, skip_warning = false) {
  if (hydrating && should_remove_defaults && element3.tagName === "INPUT") {
    var input = (
      /** @type {HTMLInputElement} */
      element3
    );
    var attribute = input.type === "checkbox" ? "defaultChecked" : "defaultValue";
    if (!(attribute in next2)) {
      remove_input_defaults(input);
    }
  }
  var attributes2 = get_attributes(element3);
  var is_custom_element = attributes2[IS_CUSTOM_ELEMENT];
  var preserve_attribute_case = !attributes2[IS_HTML];
  let is_hydrating_custom_element = hydrating && is_custom_element;
  if (is_hydrating_custom_element) {
    set_hydrating(false);
  }
  var current = prev || {};
  var is_option_element = element3.tagName === "OPTION";
  for (var key2 in prev) {
    if (!(key2 in next2)) {
      next2[key2] = null;
    }
  }
  if (next2.class) {
    next2.class = clsx2(next2.class);
  } else if (css_hash || next2[CLASS]) {
    next2.class = null;
  }
  if (next2[STYLE]) {
    next2.style ??= null;
  }
  var setters = get_setters(element3);
  for (const key3 in next2) {
    let value = next2[key3];
    if (is_option_element && key3 === "value" && value == null) {
      element3.value = element3.__value = "";
      current[key3] = value;
      continue;
    }
    if (key3 === "class") {
      var is_html = element3.namespaceURI === "http://www.w3.org/1999/xhtml";
      set_class(element3, is_html, value, css_hash, prev?.[CLASS], next2[CLASS]);
      current[key3] = value;
      current[CLASS] = next2[CLASS];
      continue;
    }
    if (key3 === "style") {
      set_style(element3, value, prev?.[STYLE], next2[STYLE]);
      current[key3] = value;
      current[STYLE] = next2[STYLE];
      continue;
    }
    var prev_value = current[key3];
    if (value === prev_value && !(value === void 0 && element3.hasAttribute(key3))) {
      continue;
    }
    current[key3] = value;
    var prefix = key3[0] + key3[1];
    if (prefix === "$$") continue;
    if (prefix === "on") {
      const opts = {};
      const event_handle_key = "$$" + key3;
      let event_name = key3.slice(2);
      var delegated = can_delegate_event(event_name);
      if (is_capture_event(event_name)) {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && prev_value) {
        if (value != null) continue;
        element3.removeEventListener(event_name, current[event_handle_key], opts);
        current[event_handle_key] = null;
      }
      if (value != null) {
        if (!delegated) {
          let handle = function(evt) {
            current[key3].call(this, evt);
          };
          current[event_handle_key] = create_event(event_name, element3, handle, opts);
        } else {
          element3[`__${event_name}`] = value;
          delegate([event_name]);
        }
      } else if (delegated) {
        element3[`__${event_name}`] = void 0;
      }
    } else if (key3 === "style") {
      set_attribute2(element3, key3, value);
    } else if (key3 === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element3,
        Boolean(value)
      );
    } else if (!is_custom_element && (key3 === "__value" || key3 === "value" && value != null)) {
      element3.value = element3.__value = value;
    } else if (key3 === "selected" && is_option_element) {
      set_selected(
        /** @type {HTMLOptionElement} */
        element3,
        value
      );
    } else {
      var name = key3;
      if (!preserve_attribute_case) {
        name = normalize_attribute(name);
      }
      var is_default = name === "defaultValue" || name === "defaultChecked";
      if (value == null && !is_custom_element && !is_default) {
        attributes2[key3] = null;
        if (name === "value" || name === "checked") {
          let input2 = (
            /** @type {HTMLInputElement} */
            element3
          );
          const use_default = prev === void 0;
          if (name === "value") {
            let previous = input2.defaultValue;
            input2.removeAttribute(name);
            input2.defaultValue = previous;
            input2.value = input2.__value = use_default ? previous : null;
          } else {
            let previous = input2.defaultChecked;
            input2.removeAttribute(name);
            input2.defaultChecked = previous;
            input2.checked = use_default ? previous : false;
          }
        } else {
          element3.removeAttribute(key3);
        }
      } else if (is_default || setters.includes(name) && (is_custom_element || typeof value !== "string")) {
        element3[name] = value;
        if (name in attributes2) attributes2[name] = UNINITIALIZED;
      } else if (typeof value !== "function") {
        set_attribute2(element3, name, value, skip_warning);
      }
    }
  }
  if (is_hydrating_custom_element) {
    set_hydrating(true);
  }
  return current;
}
function attribute_effect(element3, fn, sync = [], async2 = [], blockers = [], css_hash, should_remove_defaults = false, skip_warning = false) {
  flatten(blockers, sync, async2, (values) => {
    var prev = void 0;
    var effects = {};
    var is_select = element3.nodeName === "SELECT";
    var inited = false;
    managed(() => {
      var next2 = fn(...values.map(get));
      var current = set_attributes(
        element3,
        prev,
        next2,
        css_hash,
        should_remove_defaults,
        skip_warning
      );
      if (inited && is_select && "value" in next2) {
        select_option(
          /** @type {HTMLSelectElement} */
          element3,
          next2.value
        );
      }
      for (let symbol of Object.getOwnPropertySymbols(effects)) {
        if (!next2[symbol]) destroy_effect(effects[symbol]);
      }
      for (let symbol of Object.getOwnPropertySymbols(next2)) {
        var n = next2[symbol];
        if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {
          if (effects[symbol]) destroy_effect(effects[symbol]);
          effects[symbol] = branch(() => attach(element3, () => n));
        }
        current[symbol] = n;
      }
      prev = current;
    });
    if (is_select) {
      var select = (
        /** @type {HTMLSelectElement} */
        element3
      );
      effect(() => {
        select_option(
          select,
          /** @type {Record<string | symbol, any>} */
          prev.value,
          true
        );
        init_select2(select);
      });
    }
    inited = true;
  });
}
function get_attributes(element3) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    element3.__attributes ??= {
      [IS_CUSTOM_ELEMENT]: element3.nodeName.includes("-"),
      [IS_HTML]: element3.namespaceURI === NAMESPACE_HTML
    }
  );
}
function get_setters(element3) {
  var cache_key = element3.getAttribute("is") || element3.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters) return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element3;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) {
      if (descriptors[key2].set) {
        setters.push(key2);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function check_src_in_dev_hydration(element3, attribute, value) {
  if (!true_default) return;
  if (attribute === "srcset" && srcset_url_equal(element3, value)) return;
  if (src_url_equal(element3.getAttribute(attribute) ?? "", value)) return;
  hydration_attribute_changed(
    attribute,
    element3.outerHTML.replace(element3.innerHTML, element3.innerHTML && "..."),
    String(value)
  );
}
function src_url_equal(element_src, url) {
  if (element_src === url) return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element3, srcset) {
  var element_urls = split_srcset(element3.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}
var CLASS, STYLE, IS_CUSTOM_ELEMENT, IS_HTML, setters_cache;
var init_attributes2 = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/attributes.js"() {
    init_esm_env();
    init_hydration();
    init_utils();
    init_events();
    init_misc();
    init_warnings();
    init_constants2();
    init_task();
    init_utils2();
    init_runtime();
    init_attachments2();
    init_attributes();
    init_class();
    init_style();
    init_constants();
    init_effects();
    init_select();
    init_async();
    CLASS = Symbol("class");
    STYLE = Symbol("style");
    IS_CUSTOM_ELEMENT = Symbol("is custom element");
    IS_HTML = Symbol("is html");
    setters_cache = /* @__PURE__ */ new Map();
  }
});

// node_modules/svelte/src/internal/client/timing.js
var now, raf;
var init_timing = __esm({
  "node_modules/svelte/src/internal/client/timing.js"() {
    init_utils();
    init_esm_env();
    now = false_default ? () => performance.now() : () => Date.now();
    raf = {
      // don't access requestAnimationFrame eagerly outside method
      // this allows basic testing of user code without JSDOM
      // bunder will eval and remove ternary when the user's app is built
      tick: (
        /** @param {any} _ */
        (_) => (false_default ? requestAnimationFrame : noop)(_)
      ),
      now: () => now(),
      tasks: /* @__PURE__ */ new Set()
    };
  }
});

// node_modules/svelte/src/internal/client/loop.js
function run_tasks() {
  const now2 = raf.now();
  raf.tasks.forEach((task) => {
    if (!task.c(now2)) {
      raf.tasks.delete(task);
      task.f();
    }
  });
  if (raf.tasks.size !== 0) {
    raf.tick(run_tasks);
  }
}
function loop(callback) {
  let task;
  if (raf.tasks.size === 0) {
    raf.tick(run_tasks);
  }
  return {
    promise: new Promise((fulfill) => {
      raf.tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      raf.tasks.delete(task);
    }
  };
}
var init_loop = __esm({
  "node_modules/svelte/src/internal/client/loop.js"() {
    init_timing();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/transitions.js
function dispatch_event(element3, type) {
  without_reactive_context(() => {
    element3.dispatchEvent(new CustomEvent(type));
  });
}
function css_property_to_camelcase(style) {
  if (style === "float") return "cssFloat";
  if (style === "offset") return "cssOffset";
  if (style.startsWith("--")) return style;
  const parts = style.split("-");
  if (parts.length === 1) return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value] = part.split(":");
    if (!property || value === void 0) break;
    const formatted_property = css_property_to_camelcase(property.trim());
    keyframe[formatted_property] = value.trim();
  }
  return keyframe;
}
function animation(element3, get_fn, get_params) {
  var item = (
    /** @type {EachItem} */
    current_each_item
  );
  var from;
  var to;
  var animation2;
  var original_styles = null;
  item.a ??= {
    element: element3,
    measure() {
      from = this.element.getBoundingClientRect();
    },
    apply() {
      animation2?.abort();
      to = this.element.getBoundingClientRect();
      if (from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom) {
        const options = get_fn()(this.element, { from, to }, get_params?.());
        animation2 = animate(this.element, options, void 0, 1, () => {
          animation2?.abort();
          animation2 = void 0;
        });
      }
    },
    fix() {
      if (element3.getAnimations().length) return;
      var { position, width, height } = getComputedStyle(element3);
      if (position !== "absolute" && position !== "fixed") {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element3.style
        );
        original_styles = {
          position: style.position,
          width: style.width,
          height: style.height,
          transform: style.transform
        };
        style.position = "absolute";
        style.width = width;
        style.height = height;
        var to2 = element3.getBoundingClientRect();
        if (from.left !== to2.left || from.top !== to2.top) {
          var transform = `translate(${from.left - to2.left}px, ${from.top - to2.top}px)`;
          style.transform = style.transform ? `${style.transform} ${transform}` : transform;
        }
      }
    },
    unfix() {
      if (original_styles) {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element3.style
        );
        style.position = original_styles.position;
        style.width = original_styles.width;
        style.height = original_styles.height;
        style.transform = original_styles.transform;
      }
    }
  };
  item.a.element = element3;
}
function transition(flags2, element3, get_fn, get_params) {
  var is_intro = (flags2 & TRANSITION_IN) !== 0;
  var is_outro = (flags2 & TRANSITION_OUT) !== 0;
  var is_both = is_intro && is_outro;
  var is_global = (flags2 & TRANSITION_GLOBAL) !== 0;
  var direction = is_both ? "both" : is_intro ? "in" : "out";
  var current_options;
  var inert = element3.inert;
  var overflow = element3.style.overflow;
  var intro;
  var outro;
  function get_options() {
    return without_reactive_context(() => {
      return current_options ??= get_fn()(element3, get_params?.() ?? /** @type {P} */
      {}, {
        direction
      });
    });
  }
  var transition2 = {
    is_global,
    in() {
      element3.inert = inert;
      if (!is_intro) {
        outro?.abort();
        outro?.reset?.();
        return;
      }
      if (!is_outro) {
        intro?.abort();
      }
      dispatch_event(element3, "introstart");
      intro = animate(element3, get_options(), outro, 1, () => {
        dispatch_event(element3, "introend");
        intro?.abort();
        intro = current_options = void 0;
        element3.style.overflow = overflow;
      });
    },
    out(fn) {
      if (!is_outro) {
        fn?.();
        current_options = void 0;
        return;
      }
      element3.inert = true;
      dispatch_event(element3, "outrostart");
      outro = animate(element3, get_options(), intro, 0, () => {
        dispatch_event(element3, "outroend");
        fn?.();
      });
    },
    stop: () => {
      intro?.abort();
      outro?.abort();
    }
  };
  var e = (
    /** @type {Effect} */
    active_effect
  );
  (e.transitions ??= []).push(transition2);
  if (is_intro && should_intro) {
    var run3 = is_global;
    if (!run3) {
      var block2 = (
        /** @type {Effect | null} */
        e.parent
      );
      while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
        while (block2 = block2.parent) {
          if ((block2.f & BLOCK_EFFECT) !== 0) break;
        }
      }
      run3 = !block2 || (block2.f & EFFECT_RAN) !== 0;
    }
    if (run3) {
      effect(() => {
        untrack(() => transition2.in());
      });
    }
  }
}
function animate(element3, options, counterpart, t2, on_finish) {
  var is_intro = t2 === 1;
  if (is_function(options)) {
    var a;
    var aborted2 = false;
    queue_micro_task(() => {
      if (aborted2) return;
      var o = options({ direction: is_intro ? "in" : "out" });
      a = animate(element3, o, counterpart, t2, on_finish);
    });
    return {
      abort: () => {
        aborted2 = true;
        a?.abort();
      },
      deactivate: () => a.deactivate(),
      reset: () => a.reset(),
      t: () => a.t()
    };
  }
  counterpart?.deactivate();
  if (!options?.duration) {
    on_finish();
    return {
      abort: noop,
      deactivate: noop,
      reset: noop,
      t: () => t2
    };
  }
  const { delay = 0, css, tick: tick3, easing = linear } = options;
  var keyframes = [];
  if (is_intro && counterpart === void 0) {
    if (tick3) {
      tick3(0, 1);
    }
    if (css) {
      var styles = css_to_keyframe(css(0, 1));
      keyframes.push(styles, styles);
    }
  }
  var get_t = () => 1 - t2;
  var animation2 = element3.animate(keyframes, { duration: delay, fill: "forwards" });
  animation2.onfinish = () => {
    animation2.cancel();
    var t1 = counterpart?.t() ?? 1 - t2;
    counterpart?.abort();
    var delta = t2 - t1;
    var duration = (
      /** @type {number} */
      options.duration * Math.abs(delta)
    );
    var keyframes2 = [];
    if (duration > 0) {
      var needs_overflow_hidden = false;
      if (css) {
        var n = Math.ceil(duration / (1e3 / 60));
        for (var i = 0; i <= n; i += 1) {
          var t = t1 + delta * easing(i / n);
          var styles2 = css_to_keyframe(css(t, 1 - t));
          keyframes2.push(styles2);
          needs_overflow_hidden ||= styles2.overflow === "hidden";
        }
      }
      if (needs_overflow_hidden) {
        element3.style.overflow = "hidden";
      }
      get_t = () => {
        var time = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          animation2.currentTime
        );
        return t1 + delta * easing(time / duration);
      };
      if (tick3) {
        loop(() => {
          if (animation2.playState !== "running") return false;
          var t3 = get_t();
          tick3(t3, 1 - t3);
          return true;
        });
      }
    }
    animation2 = element3.animate(keyframes2, { duration, fill: "forwards" });
    animation2.onfinish = () => {
      get_t = () => t2;
      tick3?.(t2, 1 - t2);
      on_finish();
    };
  };
  return {
    abort: () => {
      if (animation2) {
        animation2.cancel();
        animation2.effect = null;
        animation2.onfinish = noop;
      }
    },
    deactivate: () => {
      on_finish = noop;
    },
    reset: () => {
      if (t2 === 0) {
        tick3?.(1, 0);
      }
    },
    t: () => get_t()
  };
}
var linear;
var init_transitions = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/transitions.js"() {
    init_utils();
    init_effects();
    init_runtime();
    init_loop();
    init_render();
    init_each();
    init_constants();
    init_constants2();
    init_task();
    init_shared();
    linear = (t) => t;
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/document.js
function bind_active_element(update2) {
  listen(document, ["focusin", "focusout"], (event2) => {
    if (event2 && event2.type === "focusout" && /** @type {FocusEvent} */
    event2.relatedTarget) {
      return;
    }
    update2(document.activeElement);
  });
}
var init_document = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/document.js"() {
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
function bind_value(input, get3, set2 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  listen_to_event_and_reset_event(input, "input", async (is_reset) => {
    if (true_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = is_reset ? input.defaultValue : input.value;
    value = is_numberlike_input(input) ? to_number(value) : value;
    set2(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
    await tick();
    if (value !== (value = get3())) {
      var start = input.selectionStart;
      var end = input.selectionEnd;
      var length = input.value.length;
      input.value = value ?? "";
      if (end !== null) {
        var new_length = input.value.length;
        if (start === end && end === length && new_length > length) {
          input.selectionStart = new_length;
          input.selectionEnd = new_length;
        } else {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, new_length);
        }
      }
    }
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
    // TODO Svelte 6: remove input.value check and set to empty string?
    untrack(get3) == null && input.value
  ) {
    set2(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  }
  render_effect(() => {
    if (true_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = get3();
    if (input === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    if (is_numberlike_input(input) && value === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value && !input.value) {
      return;
    }
    if (value !== input.value) {
      input.value = value ?? "";
    }
  });
}
function bind_group(inputs, group_index, input, get3, set2 = get3) {
  var is_checkbox = input.getAttribute("type") === "checkbox";
  var binding_group = inputs;
  let hydration_mismatch2 = false;
  if (group_index !== null) {
    for (var index2 of group_index) {
      binding_group = binding_group[index2] ??= [];
    }
  }
  binding_group.push(input);
  listen_to_event_and_reset_event(
    input,
    "change",
    () => {
      var value = input.__value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      }
      set2(value);
    },
    // TODO better default value handling
    () => set2(is_checkbox ? [] : null)
  );
  render_effect(() => {
    var value = get3();
    if (hydrating && input.defaultChecked !== input.checked) {
      hydration_mismatch2 = true;
      return;
    }
    if (is_checkbox) {
      value = value || [];
      input.checked = value.includes(input.__value);
    } else {
      input.checked = is(input.__value, value);
    }
  });
  teardown(() => {
    var index3 = binding_group.indexOf(input);
    if (index3 !== -1) {
      binding_group.splice(index3, 1);
    }
  });
  if (!pending2.has(binding_group)) {
    pending2.add(binding_group);
    queue_micro_task(() => {
      binding_group.sort((a, b) => a.compareDocumentPosition(b) === 4 ? -1 : 1);
      pending2.delete(binding_group);
    });
  }
  queue_micro_task(() => {
    if (hydration_mismatch2) {
      var value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      } else {
        var hydration_input = binding_group.find((input2) => input2.checked);
        value = hydration_input?.__value;
      }
      set2(value);
    }
  });
}
function bind_checked(input, get3, set2 = get3) {
  listen_to_event_and_reset_event(input, "change", (is_reset) => {
    var value = is_reset ? input.defaultChecked : input.checked;
    set2(value);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the update value from the input instead.
    hydrating && input.defaultChecked !== input.checked || // If defaultChecked is set, then checked == defaultChecked
    untrack(get3) == null
  ) {
    set2(input.checked);
  }
  render_effect(() => {
    var value = get3();
    input.checked = Boolean(value);
  });
}
function get_binding_group_value(group, __value, checked) {
  var value = /* @__PURE__ */ new Set();
  for (var i = 0; i < group.length; i += 1) {
    if (group[i].checked) {
      value.add(group[i].__value);
    }
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
function to_number(value) {
  return value === "" ? null : +value;
}
function bind_files(input, get3, set2 = get3) {
  listen_to_event_and_reset_event(input, "change", () => {
    set2(input.files);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.files
  ) {
    set2(input.files);
  }
  render_effect(() => {
    input.files = get3();
  });
}
var pending2;
var init_input = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/input.js"() {
    init_esm_env();
    init_effects();
    init_shared();
    init_errors2();
    init_proxy();
    init_task();
    init_hydration();
    init_runtime();
    init_context();
    init_batch();
    pending2 = /* @__PURE__ */ new Set();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/media.js
function time_ranges_to_array(ranges) {
  var array = [];
  for (var i = 0; i < ranges.length; i += 1) {
    array.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array;
}
function bind_current_time(media, get3, set2 = get3) {
  var raf_id;
  var value;
  var callback = () => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    var next_value = media.currentTime;
    if (value !== next_value) {
      set2(value = next_value);
    }
  };
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    var next_value = Number(get3());
    if (value !== next_value && !isNaN(
      /** @type {any} */
      next_value
    )) {
      media.currentTime = value = next_value;
    }
  });
  teardown(() => {
    cancelAnimationFrame(raf_id);
    media.removeEventListener("timeupdate", callback);
  });
}
function bind_buffered(media, set2) {
  var current;
  listen(media, ["loadedmetadata", "progress", "timeupdate", "seeking"], () => {
    var ranges = media.buffered;
    if (!current || current.length !== ranges.length || current.some((range, i) => ranges.start(i) !== range.start || ranges.end(i) !== range.end)) {
      current = time_ranges_to_array(ranges);
      set2(current);
    }
  });
}
function bind_seekable(media, set2) {
  listen(media, ["loadedmetadata"], () => set2(time_ranges_to_array(media.seekable)));
}
function bind_played(media, set2) {
  listen(media, ["timeupdate"], () => set2(time_ranges_to_array(media.played)));
}
function bind_seeking(media, set2) {
  listen(media, ["seeking", "seeked"], () => set2(media.seeking));
}
function bind_ended(media, set2) {
  listen(media, ["timeupdate", "ended"], () => set2(media.ended));
}
function bind_ready_state(media, set2) {
  listen(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    () => set2(media.readyState)
  );
}
function bind_playback_rate(media, get3, set2 = get3) {
  effect(() => {
    var value = Number(get3());
    if (value !== media.playbackRate && !isNaN(value)) {
      media.playbackRate = value;
    }
  });
  effect(() => {
    listen(media, ["ratechange"], () => {
      set2(media.playbackRate);
    });
  });
}
function bind_paused(media, get3, set2 = get3) {
  var paused = get3();
  var update2 = () => {
    if (paused !== media.paused) {
      set2(paused = media.paused);
    }
  };
  listen(media, ["play", "pause", "canplay"], update2, paused == null);
  effect(() => {
    if ((paused = !!get3()) !== media.paused) {
      if (paused) {
        media.pause();
      } else {
        media.play().catch(() => {
          set2(paused = true);
        });
      }
    }
  });
}
function bind_volume(media, get3, set2 = get3) {
  var callback = () => {
    set2(media.volume);
  };
  if (get3() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = Number(get3());
    if (value !== media.volume && !isNaN(value)) {
      media.volume = value;
    }
  });
}
function bind_muted(media, get3, set2 = get3) {
  var callback = () => {
    set2(media.muted);
  };
  if (get3() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = !!get3();
    if (media.muted !== value) media.muted = value;
  });
}
var init_media = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/media.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js
function bind_online(update2) {
  listen(window, ["online", "offline"], () => {
    update2(navigator.onLine);
  });
}
var init_navigator = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js"() {
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/props.js
function bind_prop(props, prop2, value) {
  var desc = get_descriptor(props, prop2);
  if (desc && desc.set) {
    props[prop2] = value;
    teardown(() => {
      props[prop2] = null;
    });
  }
}
var init_props = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/props.js"() {
    init_effects();
    init_utils();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
function bind_resize_observer(element3, type, set2) {
  var observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  var unsub = observer.observe(
    element3,
    /** @param {any} entry */
    (entry) => set2(entry[type])
  );
  teardown(unsub);
}
function bind_element_size(element3, type, set2) {
  var unsub = resize_observer_border_box.observe(element3, () => set2(element3[type]));
  effect(() => {
    untrack(() => set2(element3[type]));
    return unsub;
  });
}
var ResizeObserverSingleton, resize_observer_content_box, resize_observer_border_box, resize_observer_device_pixel_content_box;
var init_size = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/size.js"() {
    init_effects();
    init_runtime();
    ResizeObserverSingleton = class _ResizeObserverSingleton {
      /** */
      #listeners = /* @__PURE__ */ new WeakMap();
      /** @type {ResizeObserver | undefined} */
      #observer;
      /** @type {ResizeObserverOptions} */
      #options;
      /** @static */
      static entries = /* @__PURE__ */ new WeakMap();
      /** @param {ResizeObserverOptions} options */
      constructor(options) {
        this.#options = options;
      }
      /**
       * @param {Element} element
       * @param {(entry: ResizeObserverEntry) => any} listener
       */
      observe(element3, listener) {
        var listeners = this.#listeners.get(element3) || /* @__PURE__ */ new Set();
        listeners.add(listener);
        this.#listeners.set(element3, listeners);
        this.#getObserver().observe(element3, this.#options);
        return () => {
          var listeners2 = this.#listeners.get(element3);
          listeners2.delete(listener);
          if (listeners2.size === 0) {
            this.#listeners.delete(element3);
            this.#observer.unobserve(element3);
          }
        };
      }
      #getObserver() {
        return this.#observer ?? (this.#observer = new ResizeObserver(
          /** @param {any} entries */
          (entries) => {
            for (var entry of entries) {
              _ResizeObserverSingleton.entries.set(entry.target, entry);
              for (var listener of this.#listeners.get(entry.target) || []) {
                listener(entry);
              }
            }
          }
        ));
      }
    };
    resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
      box: "content-box"
    });
    resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
      box: "border-box"
    });
    resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
      box: "device-pixel-content-box"
    });
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component;
}
function bind_this(element_or_component = {}, update2, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = get_parts?.() || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update2(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update2(null, ...parts);
        }
      });
    };
  });
  return element_or_component;
}
var init_this = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/this.js"() {
    init_constants2();
    init_effects();
    init_runtime();
    init_task();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js
function bind_content_editable(property, element3, get3, set2 = get3) {
  element3.addEventListener("input", () => {
    set2(element3[property]);
  });
  render_effect(() => {
    var value = get3();
    if (element3[property] !== value) {
      if (value == null) {
        var non_null_value = element3[property];
        set2(non_null_value);
      } else {
        element3[property] = value + "";
      }
    }
  });
}
function bind_property(property, event_name, element3, set2, get3) {
  var handler = () => {
    set2(element3[property]);
  };
  element3.addEventListener(event_name, handler);
  if (get3) {
    render_effect(() => {
      element3[property] = get3();
    });
  } else {
    handler();
  }
  if (element3 === document.body || element3 === window || element3 === document) {
    teardown(() => {
      element3.removeEventListener(event_name, handler);
    });
  }
}
function bind_focused(element3, set2) {
  listen(element3, ["focus", "blur"], () => {
    set2(element3 === document.activeElement);
  });
}
var init_universal = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/window.js
function bind_window_scroll(type, get3, set2 = get3) {
  var is_scrolling_x = type === "x";
  var target_handler = () => without_reactive_context(() => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear, 100);
    set2(window[is_scrolling_x ? "scrollX" : "scrollY"]);
  });
  addEventListener("scroll", target_handler, {
    passive: true
  });
  var scrolling = false;
  var timeout;
  var clear = () => {
    scrolling = false;
  };
  var first = true;
  render_effect(() => {
    var latest_value = get3();
    if (first) {
      first = false;
    } else if (!scrolling && latest_value != null) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear, 100);
    }
  });
  effect(target_handler);
  teardown(() => {
    removeEventListener("scroll", target_handler);
  });
}
function bind_window_size(type, set2) {
  listen(window, ["resize"], () => without_reactive_context(() => set2(window[type])));
}
var init_window = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/window.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
function trusted(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.isTrusted) {
      fn?.apply(this, args);
    }
  };
}
function self2(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.target === this) {
      fn?.apply(this, args);
    }
  };
}
function stopPropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopPropagation();
    return fn?.apply(this, args);
  };
}
function once(fn) {
  var ran = false;
  return function(...args) {
    if (ran) return;
    ran = true;
    return fn?.apply(this, args);
  };
}
function stopImmediatePropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopImmediatePropagation();
    return fn?.apply(this, args);
  };
}
function preventDefault(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.preventDefault();
    return fn?.apply(this, args);
  };
}
var init_event_modifiers = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js"() {
    init_utils();
    init_effects();
    init_events();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
function init(immutable = false) {
  const context2 = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  const callbacks = context2.l.u;
  if (!callbacks) return;
  let props = () => deep_read_state(context2.s);
  if (immutable) {
    let version = 0;
    let prev = (
      /** @type {Record<string, any>} */
      {}
    );
    const d = derived(() => {
      let changed = false;
      const props2 = context2.s;
      for (const key2 in props2) {
        if (props2[key2] !== prev[key2]) {
          prev[key2] = props2[key2];
          changed = true;
        }
      }
      if (changed) version++;
      return version;
    });
    props = () => get(d);
  }
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context2, props);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run));
    return () => {
      for (const fn of fns) {
        if (typeof fn === "function") {
          fn();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context2, props);
      run_all(callbacks.a);
    });
  }
}
function observe_all(context2, props) {
  if (context2.l.s) {
    for (const signal of context2.l.s) get(signal);
  }
  props();
}
var init_lifecycle = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js"() {
    init_utils();
    init_context();
    init_deriveds();
    init_effects();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/misc.js
function reactive_import(fn) {
  var s = source(0);
  return function() {
    if (arguments.length === 1) {
      set(s, get(s) + 1);
      return arguments[0];
    } else {
      get(s);
      return fn();
    }
  };
}
function bubble_event($$props, event2) {
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    $$props.$$events?.[event2.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn of callbacks) {
    fn.call(this, event2);
  }
}
function add_legacy_event_listener($$props, event_name, event_callback) {
  $$props.$$events ||= {};
  $$props.$$events[event_name] ||= [];
  $$props.$$events[event_name].push(event_callback);
}
function update_legacy_props($$new_props) {
  for (var key2 in $$new_props) {
    if (key2 in this) {
      this[key2] = $$new_props[key2];
    }
  }
}
var init_misc2 = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/misc.js"() {
    init_sources();
    init_runtime();
    init_utils();
  }
});

// node_modules/svelte/src/store/shared/index.js
function get2(store) {
  let value;
  subscribe_to_store(store, (_) => value = _)();
  return value;
}
var init_shared2 = __esm({
  "node_modules/svelte/src/store/shared/index.js"() {
    init_utils();
    init_equality();
    init_utils3();
  }
});

// node_modules/svelte/src/internal/client/reactivity/store.js
function store_get(store, store_name, stores) {
  const entry = stores[store_name] ??= {
    store: null,
    source: mutable_source(void 0),
    unsubscribe: noop
  };
  if (true_default) {
    entry.source.label = store_name;
  }
  if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = store ?? null;
    if (store == null) {
      entry.source.v = void 0;
      entry.unsubscribe = noop;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store, (v) => {
        if (is_synchronous_callback) {
          entry.source.v = v;
        } else {
          set(entry.source, v);
        }
      });
      is_synchronous_callback = false;
    }
  }
  if (store && IS_UNMOUNTED in stores) {
    return get2(store);
  }
  return get(entry.source);
}
function store_unsub(store, store_name, stores) {
  let entry = stores[store_name];
  if (entry && entry.store !== store) {
    entry.unsubscribe();
    entry.unsubscribe = noop;
  }
  return store;
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function invalidate_store(stores, store_name) {
  var entry = stores[store_name];
  if (entry.store !== null) {
    store_set(entry.store, entry.source.v);
  }
}
function setup_stores() {
  const stores = {};
  function cleanup() {
    teardown(() => {
      for (var store_name in stores) {
        const ref = stores[store_name];
        ref.unsubscribe();
      }
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  }
  return [stores, cleanup];
}
function store_mutate(store, expression, new_value) {
  store.set(new_value);
  return expression;
}
function update_store(store, store_value, d = 1) {
  store.set(store_value + d);
  return store_value;
}
function update_pre_store(store, store_value, d = 1) {
  const value = store_value + d;
  store.set(value);
  return value;
}
function mark_store_binding() {
  is_store_binding = true;
}
function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}
var is_store_binding, IS_UNMOUNTED;
var init_store = __esm({
  "node_modules/svelte/src/internal/client/reactivity/store.js"() {
    init_utils3();
    init_shared2();
    init_utils();
    init_runtime();
    init_effects();
    init_sources();
    init_esm_env();
    is_store_binding = false;
    IS_UNMOUNTED = Symbol();
  }
});

// node_modules/svelte/src/internal/client/reactivity/props.js
function update_prop(fn, d = 1) {
  const value = fn();
  fn(value + d);
  return value;
}
function update_pre_prop(fn, d = 1) {
  const value = fn() + d;
  fn(value);
  return value;
}
// @__NO_SIDE_EFFECTS__
function rest_props(props, exclude, name) {
  return new Proxy(
    true_default ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
    rest_props_handler
  );
}
function legacy_rest_props(props, exclude) {
  return new Proxy(
    {
      props,
      exclude,
      special: {},
      version: source(0),
      // TODO this is only necessary because we need to track component
      // destruction inside `prop`, because of `bind:this`, but it
      // seems likely that we can simplify `bind:this` instead
      parent_effect: (
        /** @type {Effect} */
        active_effect
      )
    },
    legacy_rest_props_handler
  );
}
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function prop(props, key2, flags2, fallback2) {
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback2
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy ? untrack(
        /** @type {() => V} */
        fallback2
      ) : (
        /** @type {V} */
        fallback2
      );
    }
    return fallback_value;
  };
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = get_descriptor(props, key2)?.set ?? (is_entry_props && key2 in props ? (v) => props[key2] = v : void 0);
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key2]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key2];
  }
  if (initial_value === void 0 && fallback2 !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value(key2);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value === void 0) return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value === void 0 ? fallback_value : value;
    };
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return (
      /** @type {() => V} */
      (function(value, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value);
          }
          return value;
        }
        return getter();
      })
    );
  }
  var overridden = false;
  var d = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (true_default) {
    d.label = key2;
  }
  if (bindable) get(d);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return (
    /** @type {() => V} */
    (function(value, mutation) {
      if (arguments.length > 0) {
        const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;
        set(d, new_value);
        overridden = true;
        if (fallback_value !== void 0) {
          fallback_value = new_value;
        }
        return value;
      }
      if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
        return d.v;
      }
      return get(d);
    })
  );
}
var rest_props_handler, legacy_rest_props_handler, spread_props_handler;
var init_props2 = __esm({
  "node_modules/svelte/src/internal/client/reactivity/props.js"() {
    init_esm_env();
    init_constants();
    init_utils();
    init_sources();
    init_deriveds();
    init_runtime();
    init_errors2();
    init_constants2();
    init_proxy();
    init_store();
    init_flags();
    rest_props_handler = {
      get(target, key2) {
        if (target.exclude.includes(key2)) return;
        return target.props[key2];
      },
      set(target, key2) {
        if (true_default) {
          props_rest_readonly(`${target.name}.${String(key2)}`);
        }
        return false;
      },
      getOwnPropertyDescriptor(target, key2) {
        if (target.exclude.includes(key2)) return;
        if (key2 in target.props) {
          return {
            enumerable: true,
            configurable: true,
            value: target.props[key2]
          };
        }
      },
      has(target, key2) {
        if (target.exclude.includes(key2)) return false;
        return key2 in target.props;
      },
      ownKeys(target) {
        return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
      }
    };
    legacy_rest_props_handler = {
      get(target, key2) {
        if (target.exclude.includes(key2)) return;
        get(target.version);
        return key2 in target.special ? target.special[key2]() : target.props[key2];
      },
      set(target, key2, value) {
        if (!(key2 in target.special)) {
          var previous_effect = active_effect;
          try {
            set_active_effect(target.parent_effect);
            target.special[key2] = prop(
              {
                get [key2]() {
                  return target.props[key2];
                }
              },
              /** @type {string} */
              key2,
              PROPS_IS_UPDATED
            );
          } finally {
            set_active_effect(previous_effect);
          }
        }
        target.special[key2](value);
        update(target.version);
        return true;
      },
      getOwnPropertyDescriptor(target, key2) {
        if (target.exclude.includes(key2)) return;
        if (key2 in target.props) {
          return {
            enumerable: true,
            configurable: true,
            value: target.props[key2]
          };
        }
      },
      deleteProperty(target, key2) {
        if (target.exclude.includes(key2)) return true;
        target.exclude.push(key2);
        update(target.version);
        return true;
      },
      has(target, key2) {
        if (target.exclude.includes(key2)) return false;
        return key2 in target.props;
      },
      ownKeys(target) {
        return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
      }
    };
    spread_props_handler = {
      get(target, key2) {
        let i = target.props.length;
        while (i--) {
          let p = target.props[i];
          if (is_function(p)) p = p();
          if (typeof p === "object" && p !== null && key2 in p) return p[key2];
        }
      },
      set(target, key2, value) {
        let i = target.props.length;
        while (i--) {
          let p = target.props[i];
          if (is_function(p)) p = p();
          const desc = get_descriptor(p, key2);
          if (desc && desc.set) {
            desc.set(value);
            return true;
          }
        }
        return false;
      },
      getOwnPropertyDescriptor(target, key2) {
        let i = target.props.length;
        while (i--) {
          let p = target.props[i];
          if (is_function(p)) p = p();
          if (typeof p === "object" && p !== null && key2 in p) {
            const descriptor = get_descriptor(p, key2);
            if (descriptor && !descriptor.configurable) {
              descriptor.configurable = true;
            }
            return descriptor;
          }
        }
      },
      has(target, key2) {
        if (key2 === STATE_SYMBOL || key2 === LEGACY_PROPS) return false;
        for (let p of target.props) {
          if (is_function(p)) p = p();
          if (p != null && key2 in p) return true;
        }
        return false;
      },
      ownKeys(target) {
        const keys = [];
        for (let p of target.props) {
          if (is_function(p)) p = p();
          if (!p) continue;
          for (const key2 in p) {
            if (!keys.includes(key2)) keys.push(key2);
          }
          for (const key2 of Object.getOwnPropertySymbols(p)) {
            if (!keys.includes(key2)) keys.push(key2);
          }
        }
        return keys;
      }
    };
  }
});

// node_modules/svelte/src/internal/client/validate.js
function validate_each_keys(collection, key_fn) {
  render_effect(() => {
    const keys = /* @__PURE__ */ new Map();
    const maybe_array = collection();
    const array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
    const length = array.length;
    for (let i = 0; i < length; i++) {
      const key2 = key_fn(array[i], i);
      if (keys.has(key2)) {
        const a = String(keys.get(key2));
        const b = String(i);
        let k = String(key2);
        if (k.startsWith("[object ")) k = null;
        each_key_duplicate(a, b, k);
      }
      keys.set(key2, i);
    }
  });
}
function validate_binding(binding, blockers, get_object, get_property, line, column) {
  run_after_blockers(blockers, () => {
    var warned = false;
    var filename = dev_current_component_function?.[FILENAME];
    render_effect(() => {
      if (warned) return;
      var [object, is_store_sub] = capture_store_binding(get_object);
      if (is_store_sub) return;
      var property = get_property();
      var ran = false;
      var effect2 = render_effect(() => {
        if (ran) return;
        object[property];
      });
      ran = true;
      if (effect2.deps === null) {
        var location2 = `${filename}:${line}:${column}`;
        binding_property_non_reactive(binding, location2);
        warned = true;
      }
    });
  });
}
var init_validate2 = __esm({
  "node_modules/svelte/src/internal/client/validate.js"() {
    init_context();
    init_utils();
    init_errors2();
    init_constants();
    init_effects();
    init_warnings();
    init_store();
    init_async();
  }
});

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var Svelte4Component;
var init_legacy_client = __esm({
  "node_modules/svelte/src/legacy/legacy-client.js"() {
    init_constants2();
    init_effects();
    init_sources();
    init_render();
    init_runtime();
    init_batch();
    init_utils();
    init_errors2();
    init_warnings();
    init_esm_env();
    init_constants();
    init_context();
    init_flags();
    init_event_modifiers();
    Svelte4Component = class {
      /** @type {any} */
      #events;
      /** @type {Record<string, any>} */
      #instance;
      /**
       * @param {ComponentConstructorOptions & {
       *  component: any;
       * }} options
       */
      constructor(options) {
        var sources = /* @__PURE__ */ new Map();
        var add_source = (key2, value) => {
          var s = mutable_source(value, false, false);
          sources.set(key2, s);
          return s;
        };
        const props = new Proxy(
          { ...options.props || {}, $$events: {} },
          {
            get(target, prop2) {
              return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
            },
            has(target, prop2) {
              if (prop2 === LEGACY_PROPS) return true;
              get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
              return Reflect.has(target, prop2);
            },
            set(target, prop2, value) {
              set(sources.get(prop2) ?? add_source(prop2, value), value);
              return Reflect.set(target, prop2, value);
            }
          }
        );
        this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
          target: options.target,
          anchor: options.anchor,
          props,
          context: options.context,
          intro: options.intro ?? false,
          recover: options.recover
        });
        if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {
          flushSync();
        }
        this.#events = props.$$events;
        for (const key2 of Object.keys(this.#instance)) {
          if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
          define_property(this, key2, {
            get() {
              return this.#instance[key2];
            },
            /** @param {any} value */
            set(value) {
              this.#instance[key2] = value;
            },
            enumerable: true
          });
        }
        this.#instance.$set = /** @param {Record<string, any>} next */
        (next2) => {
          Object.assign(props, next2);
        };
        this.#instance.$destroy = () => {
          unmount(this.#instance);
        };
      }
      /** @param {Record<string, any>} props */
      $set(props) {
        this.#instance.$set(props);
      }
      /**
       * @param {string} event
       * @param {(...args: any[]) => any} callback
       * @returns {any}
       */
      $on(event2, callback) {
        this.#events[event2] = this.#events[event2] || [];
        const cb = (...args) => callback.call(this, ...args);
        this.#events[event2].push(cb);
        return () => {
          this.#events[event2] = this.#events[event2].filter(
            /** @param {any} fn */
            (fn) => fn !== cb
          );
        };
      }
      $destroy() {
        this.#instance.$destroy();
      }
    };
  }
});

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
function get_custom_element_value(prop2, value, props_definition, transform) {
  const type = props_definition[prop2]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element3) {
  const result = {};
  element3.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
function create_custom_element(Component, props_definition, slots, exports2, use_shadow_dom, extend) {
  let Class = class extends SvelteElement {
    constructor() {
      super(Component, slots, use_shadow_dom);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return object_keys(props_definition).map(
        (key2) => (props_definition[key2].attribute || key2).toLowerCase()
      );
    }
  };
  object_keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value) {
        value = get_custom_element_value(prop2, value, props_definition);
        this.$$d[prop2] = value;
        var component2 = this.$$c;
        if (component2) {
          var setter = get_descriptor(component2, prop2)?.get;
          if (setter) {
            component2[prop2] = value;
          } else {
            component2.$set({ [prop2]: value });
          }
        }
      }
    });
  });
  exports2.forEach((property) => {
    define_property(Class.prototype, property, {
      get() {
        return this.$$c?.[property];
      }
    });
  });
  if (extend) {
    Class = extend(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}
var SvelteElement;
var init_custom_element = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/custom-element.js"() {
    init_legacy_client();
    init_effects();
    init_template();
    init_utils();
    if (typeof HTMLElement === "function") {
      SvelteElement = class extends HTMLElement {
        /** The Svelte component constructor */
        $$ctor;
        /** Slots */
        $$s;
        /** @type {any} The Svelte component instance */
        $$c;
        /** Whether or not the custom element is connected */
        $$cn = false;
        /** @type {Record<string, any>} Component props data */
        $$d = {};
        /** `true` if currently in the process of reflecting component props back to attributes */
        $$r = false;
        /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
        $$p_d = {};
        /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
        $$l = {};
        /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
        $$l_u = /* @__PURE__ */ new Map();
        /** @type {any} The managed render effect for reflecting attributes */
        $$me;
        /**
         * @param {*} $$componentCtor
         * @param {*} $$slots
         * @param {*} use_shadow_dom
         */
        constructor($$componentCtor, $$slots, use_shadow_dom) {
          super();
          this.$$ctor = $$componentCtor;
          this.$$s = $$slots;
          if (use_shadow_dom) {
            this.attachShadow({ mode: "open" });
          }
        }
        /**
         * @param {string} type
         * @param {EventListenerOrEventListenerObject} listener
         * @param {boolean | AddEventListenerOptions} [options]
         */
        addEventListener(type, listener, options) {
          this.$$l[type] = this.$$l[type] || [];
          this.$$l[type].push(listener);
          if (this.$$c) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
          super.addEventListener(type, listener, options);
        }
        /**
         * @param {string} type
         * @param {EventListenerOrEventListenerObject} listener
         * @param {boolean | AddEventListenerOptions} [options]
         */
        removeEventListener(type, listener, options) {
          super.removeEventListener(type, listener, options);
          if (this.$$c) {
            const unsub = this.$$l_u.get(listener);
            if (unsub) {
              unsub();
              this.$$l_u.delete(listener);
            }
          }
        }
        async connectedCallback() {
          this.$$cn = true;
          if (!this.$$c) {
            let create_slot = function(name) {
              return (anchor) => {
                const slot3 = document.createElement("slot");
                if (name !== "default") slot3.name = name;
                append(anchor, slot3);
              };
            };
            await Promise.resolve();
            if (!this.$$cn || this.$$c) {
              return;
            }
            const $$slots = {};
            const existing_slots = get_custom_elements_slots(this);
            for (const name of this.$$s) {
              if (name in existing_slots) {
                if (name === "default" && !this.$$d.children) {
                  this.$$d.children = create_slot(name);
                  $$slots.default = true;
                } else {
                  $$slots[name] = create_slot(name);
                }
              }
            }
            for (const attribute of this.attributes) {
              const name = this.$$g_p(attribute.name);
              if (!(name in this.$$d)) {
                this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
              }
            }
            for (const key2 in this.$$p_d) {
              if (!(key2 in this.$$d) && this[key2] !== void 0) {
                this.$$d[key2] = this[key2];
                delete this[key2];
              }
            }
            this.$$c = createClassComponent({
              component: this.$$ctor,
              target: this.shadowRoot || this,
              props: {
                ...this.$$d,
                $$slots,
                $$host: this
              }
            });
            this.$$me = effect_root(() => {
              render_effect(() => {
                this.$$r = true;
                for (const key2 of object_keys(this.$$c)) {
                  if (!this.$$p_d[key2]?.reflect) continue;
                  this.$$d[key2] = this.$$c[key2];
                  const attribute_value = get_custom_element_value(
                    key2,
                    this.$$d[key2],
                    this.$$p_d,
                    "toAttribute"
                  );
                  if (attribute_value == null) {
                    this.removeAttribute(this.$$p_d[key2].attribute || key2);
                  } else {
                    this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
                  }
                }
                this.$$r = false;
              });
            });
            for (const type in this.$$l) {
              for (const listener of this.$$l[type]) {
                const unsub = this.$$c.$on(type, listener);
                this.$$l_u.set(listener, unsub);
              }
            }
            this.$$l = {};
          }
        }
        // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
        // and setting attributes through setAttribute etc, this is helpful
        /**
         * @param {string} attr
         * @param {string} _oldValue
         * @param {string} newValue
         */
        attributeChangedCallback(attr2, _oldValue, newValue) {
          if (this.$$r) return;
          attr2 = this.$$g_p(attr2);
          this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
          this.$$c?.$set({ [attr2]: this.$$d[attr2] });
        }
        disconnectedCallback() {
          this.$$cn = false;
          Promise.resolve().then(() => {
            if (!this.$$cn && this.$$c) {
              this.$$c.$destroy();
              this.$$me();
              this.$$c = void 0;
            }
          });
        }
        /**
         * @param {string} attribute_name
         */
        $$g_p(attribute_name) {
          return object_keys(this.$$p_d).find(
            (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
          ) || attribute_name;
        }
      };
    }
  }
});

// node_modules/svelte/src/internal/client/dev/console-log.js
function log_if_contains_state(method, ...objects) {
  untrack(() => {
    try {
      let has_state = false;
      const transformed = [];
      for (const obj of objects) {
        if (obj && typeof obj === "object" && STATE_SYMBOL in obj) {
          transformed.push(snapshot(obj, true));
          has_state = true;
        } else {
          transformed.push(obj);
        }
      }
      if (has_state) {
        console_log_state(method);
        console.log("%c[snapshot]", "color: grey", ...transformed);
      }
    } catch {
    }
  });
  return objects;
}
var init_console_log = __esm({
  "node_modules/svelte/src/internal/client/dev/console-log.js"() {
    init_constants2();
    init_clone();
    init_warnings();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/index.js
var client_exports = {};
__export(client_exports, {
  CLASS: () => CLASS,
  FILENAME: () => FILENAME,
  HMR: () => HMR,
  NAMESPACE_SVG: () => NAMESPACE_SVG,
  STYLE: () => STYLE,
  aborted: () => aborted,
  action: () => action,
  active_effect: () => active_effect,
  add_legacy_event_listener: () => add_legacy_event_listener,
  add_locations: () => add_locations,
  add_svelte_meta: () => add_svelte_meta,
  animation: () => animation,
  append: () => append,
  append_styles: () => append_styles2,
  apply: () => apply,
  assign: () => assign,
  assign_and: () => assign_and,
  assign_nullish: () => assign_nullish,
  assign_or: () => assign_or,
  async: () => async,
  async_body: () => async_body,
  async_derived: () => async_derived,
  attach: () => attach,
  attachment: () => createAttachmentKey,
  attr: () => attr,
  attribute_effect: () => attribute_effect,
  autofocus: () => autofocus,
  await: () => await_block,
  bind_active_element: () => bind_active_element,
  bind_buffered: () => bind_buffered,
  bind_checked: () => bind_checked,
  bind_content_editable: () => bind_content_editable,
  bind_current_time: () => bind_current_time,
  bind_element_size: () => bind_element_size,
  bind_ended: () => bind_ended,
  bind_files: () => bind_files,
  bind_focused: () => bind_focused,
  bind_group: () => bind_group,
  bind_muted: () => bind_muted,
  bind_online: () => bind_online,
  bind_paused: () => bind_paused,
  bind_playback_rate: () => bind_playback_rate,
  bind_played: () => bind_played,
  bind_prop: () => bind_prop,
  bind_property: () => bind_property,
  bind_ready_state: () => bind_ready_state,
  bind_resize_observer: () => bind_resize_observer,
  bind_seekable: () => bind_seekable,
  bind_seeking: () => bind_seeking,
  bind_select_value: () => bind_select_value,
  bind_this: () => bind_this,
  bind_value: () => bind_value,
  bind_volume: () => bind_volume,
  bind_window_scroll: () => bind_window_scroll,
  bind_window_size: () => bind_window_size,
  boundary: () => boundary,
  bubble_event: () => bubble_event,
  check_target: () => check_target,
  child: () => child,
  cleanup_styles: () => cleanup_styles,
  clsx: () => clsx2,
  comment: () => comment,
  component: () => component,
  create_custom_element: () => create_custom_element,
  create_ownership_validator: () => create_ownership_validator,
  css_props: () => css_props,
  deep_read: () => deep_read,
  deep_read_state: () => deep_read_state,
  deferred_template_effect: () => deferred_template_effect,
  delegate: () => delegate,
  derived: () => user_derived,
  derived_safe_equal: () => derived_safe_equal,
  document: () => $document,
  each: () => each,
  eager: () => eager,
  effect: () => effect,
  effect_root: () => effect_root,
  effect_tracking: () => effect_tracking,
  element: () => element,
  equals: () => equals2,
  event: () => event,
  exclude_from_object: () => exclude_from_object,
  fallback: () => fallback,
  first_child: () => first_child,
  flush: () => flushSync,
  for_await_track_reactivity_loss: () => for_await_track_reactivity_loss,
  from_html: () => from_html,
  from_mathml: () => from_mathml,
  from_svg: () => from_svg,
  from_tree: () => from_tree,
  get: () => get,
  head: () => head,
  hmr: () => hmr,
  html: () => html,
  hydrate_template: () => hydrate_template,
  if: () => if_block,
  index: () => index,
  init: () => init,
  init_select: () => init_select2,
  inspect: () => inspect,
  invalid_default_snippet: () => invalid_default_snippet,
  invalidate_inner_signals: () => invalidate_inner_signals,
  invalidate_store: () => invalidate_store,
  invoke_error_boundary: () => invoke_error_boundary,
  key: () => key,
  legacy_api: () => legacy_api,
  legacy_pre_effect: () => legacy_pre_effect,
  legacy_pre_effect_reset: () => legacy_pre_effect_reset,
  legacy_rest_props: () => legacy_rest_props,
  log_if_contains_state: () => log_if_contains_state,
  mark_store_binding: () => mark_store_binding,
  mutable_source: () => mutable_source,
  mutate: () => mutate,
  next: () => next,
  noop: () => noop,
  once: () => once,
  pending: () => pending,
  pop: () => pop,
  preventDefault: () => preventDefault,
  prevent_snippet_stringification: () => prevent_snippet_stringification,
  prop: () => prop,
  props_id: () => props_id,
  proxy: () => proxy,
  push: () => push,
  raf: () => raf,
  reactive_import: () => reactive_import,
  remove_input_defaults: () => remove_input_defaults,
  remove_textarea_child: () => remove_textarea_child,
  render_effect: () => render_effect,
  replay_events: () => replay_events,
  reset: () => reset,
  rest_props: () => rest_props,
  run: () => run2,
  run_after_blockers: () => run_after_blockers,
  safe_get: () => safe_get,
  sanitize_slots: () => sanitize_slots,
  save: () => save,
  select_option: () => select_option,
  self: () => self2,
  set: () => set,
  set_attribute: () => set_attribute2,
  set_checked: () => set_checked,
  set_class: () => set_class,
  set_custom_element_data: () => set_custom_element_data,
  set_default_checked: () => set_default_checked,
  set_default_value: () => set_default_value,
  set_selected: () => set_selected,
  set_style: () => set_style,
  set_text: () => set_text,
  set_value: () => set_value,
  set_xlink_attribute: () => set_xlink_attribute,
  setup_stores: () => setup_stores,
  sibling: () => sibling,
  slot: () => slot,
  snapshot: () => snapshot,
  snippet: () => snippet,
  spread_props: () => spread_props,
  state: () => state,
  stopImmediatePropagation: () => stopImmediatePropagation,
  stopPropagation: () => stopPropagation,
  store_get: () => store_get,
  store_mutate: () => store_mutate,
  store_set: () => store_set,
  store_unsub: () => store_unsub,
  strict_equals: () => strict_equals,
  tag: () => tag,
  tag_proxy: () => tag_proxy,
  template_effect: () => template_effect,
  text: () => text,
  tick: () => tick,
  to_array: () => to_array,
  trace: () => trace,
  track_reactivity_loss: () => track_reactivity_loss,
  transition: () => transition,
  trusted: () => trusted,
  untrack: () => untrack,
  update: () => update,
  update_legacy_props: () => update_legacy_props,
  update_pre: () => update_pre,
  update_pre_prop: () => update_pre_prop,
  update_pre_store: () => update_pre_store,
  update_prop: () => update_prop,
  update_store: () => update_store,
  user_effect: () => user_effect,
  user_pre_effect: () => user_pre_effect,
  validate_binding: () => validate_binding,
  validate_dynamic_element_tag: () => validate_dynamic_element_tag,
  validate_each_keys: () => validate_each_keys,
  validate_snippet_args: () => validate_snippet_args,
  validate_store: () => validate_store,
  validate_void_dynamic_element: () => validate_void_dynamic_element,
  window: () => $window,
  with_script: () => with_script,
  wrap_snippet: () => wrap_snippet
});
var init_client = __esm({
  "node_modules/svelte/src/internal/client/index.js"() {
    init_attachments();
    init_constants();
    init_context();
    init_assign();
    init_css();
    init_elements();
    init_hmr();
    init_ownership();
    init_legacy2();
    init_tracing();
    init_inspect();
    init_async2();
    init_validation();
    init_await();
    init_if();
    init_key();
    init_css_props();
    init_each();
    init_html();
    init_slot();
    init_snippet();
    init_svelte_component();
    init_svelte_element();
    init_svelte_head();
    init_css2();
    init_actions();
    init_attachments2();
    init_attributes2();
    init_class();
    init_events();
    init_misc();
    init_style();
    init_transitions();
    init_document();
    init_input();
    init_media();
    init_navigator();
    init_props();
    init_select();
    init_size();
    init_this();
    init_universal();
    init_window();
    init_hydration();
    init_event_modifiers();
    init_lifecycle();
    init_misc2();
    init_template();
    init_async();
    init_batch();
    init_deriveds();
    init_effects();
    init_sources();
    init_props2();
    init_store();
    init_boundary();
    init_legacy();
    init_render();
    init_runtime();
    init_validate2();
    init_timing();
    init_proxy();
    init_custom_element();
    init_operations();
    init_attributes();
    init_clone();
    init_utils();
    init_validate();
    init_equality2();
    init_console_log();
    init_error_handling();
  }
});

// node_modules/svelte/src/internal/client/hydratable.js
var init_hydratable = __esm({
  "node_modules/svelte/src/internal/client/hydratable.js"() {
    init_flags();
    init_hydration();
    init_warnings();
    init_errors2();
    init_esm_env();
  }
});

// node_modules/svelte/src/index-client.js
var init_index_client = __esm({
  "node_modules/svelte/src/index-client.js"() {
    init_runtime();
    init_utils();
    init_client();
    init_errors2();
    init_flags();
    init_context();
    init_esm_env();
    init_batch();
    init_context();
    init_hydratable();
    init_render();
    init_runtime();
    init_snippet();
    if (true_default) {
      let throw_rune_error = function(rune) {
        if (!(rune in globalThis)) {
          let value;
          Object.defineProperty(globalThis, rune, {
            configurable: true,
            // eslint-disable-next-line getter-return
            get: () => {
              if (value !== void 0) {
                return value;
              }
              rune_outside_svelte(rune);
            },
            set: (v) => {
              value = v;
            }
          });
        }
      };
      throw_rune_error("$state");
      throw_rune_error("$effect");
      throw_rune_error("$derived");
      throw_rune_error("$inspect");
      throw_rune_error("$props");
      throw_rune_error("$bindable");
    }
  }
});

// node_modules/svelte/src/store/utils.js
function subscribe_to_store(store, run3, invalidate) {
  if (store == null) {
    run3(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store.subscribe(
      run3,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var init_utils3 = __esm({
  "node_modules/svelte/src/store/utils.js"() {
    init_index_client();
    init_utils();
  }
});

// node_modules/svelte/src/internal/server/hydration.js
var BLOCK_OPEN, BLOCK_OPEN_ELSE, BLOCK_CLOSE, EMPTY_COMMENT;
var init_hydration2 = __esm({
  "node_modules/svelte/src/internal/server/hydration.js"() {
    init_constants();
    BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
    BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
    BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
    EMPTY_COMMENT = `<!---->`;
  }
});

// node_modules/svelte/src/internal/server/abort-signal.js
function abort() {
  controller?.abort(STALE_REACTION);
  controller = null;
}
function getAbortSignal() {
  return (controller ??= new AbortController()).signal;
}
var controller;
var init_abort_signal = __esm({
  "node_modules/svelte/src/internal/server/abort-signal.js"() {
    init_constants2();
    controller = null;
  }
});

// node_modules/svelte/src/internal/server/errors.js
function async_local_storage_unavailable() {
  const error = new Error(`async_local_storage_unavailable
The node API \`AsyncLocalStorage\` is not available, but is required to use async server rendering.
https://svelte.dev/e/async_local_storage_unavailable`);
  error.name = "Svelte error";
  throw error;
}
function await_invalid() {
  const error = new Error(`await_invalid
Encountered asynchronous work while rendering synchronously.
https://svelte.dev/e/await_invalid`);
  error.name = "Svelte error";
  throw error;
}
function html_deprecated() {
  const error = new Error(`html_deprecated
The \`html\` property of server render results has been deprecated. Use \`body\` instead.
https://svelte.dev/e/html_deprecated`);
  error.name = "Svelte error";
  throw error;
}
function hydratable_clobbering(key2, stack2) {
  const error = new Error(`hydratable_clobbering
Attempted to set \`hydratable\` with key \`${key2}\` twice with different values.

${stack2}
https://svelte.dev/e/hydratable_clobbering`);
  error.name = "Svelte error";
  throw error;
}
function hydratable_serialization_failed(key2, stack2) {
  const error = new Error(`hydratable_serialization_failed
Failed to serialize \`hydratable\` data for key \`${key2}\`.

\`hydratable\` can serialize anything [\`uneval\` from \`devalue\`](https://npmjs.com/package/uneval) can, plus Promises.

Cause:
${stack2}
https://svelte.dev/e/hydratable_serialization_failed`);
  error.name = "Svelte error";
  throw error;
}
function lifecycle_function_unavailable(name) {
  const error = new Error(`lifecycle_function_unavailable
\`${name}(...)\` is not available on the server
https://svelte.dev/e/lifecycle_function_unavailable`);
  error.name = "Svelte error";
  throw error;
}
function server_context_required() {
  const error = new Error(`server_context_required
Could not resolve \`render\` context.
https://svelte.dev/e/server_context_required`);
  error.name = "Svelte error";
  throw error;
}
var init_errors3 = __esm({
  "node_modules/svelte/src/internal/server/errors.js"() {
    init_errors();
  }
});

// node_modules/svelte/src/internal/server/context.js
function set_ssr_context(v) {
  ssr_context = v;
}
function createContext2() {
  const key2 = {};
  return [() => getContext2(key2), (context2) => setContext2(key2, context2)];
}
function getContext2(key2) {
  const context_map = get_or_init_context_map("getContext");
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
function setContext2(key2, context2) {
  get_or_init_context_map("setContext").set(key2, context2);
  return context2;
}
function hasContext2(key2) {
  return get_or_init_context_map("hasContext").has(key2);
}
function getAllContexts2() {
  return get_or_init_context_map("getAllContexts");
}
function get_or_init_context_map(name) {
  if (ssr_context === null) {
    lifecycle_outside_component(name);
  }
  return ssr_context.c ??= new Map(get_parent_context(ssr_context) || void 0);
}
function push2(fn) {
  ssr_context = { p: ssr_context, c: null, r: null };
  if (true_default) {
    ssr_context.function = fn;
    ssr_context.element = ssr_context.p?.element;
  }
}
function pop2() {
  ssr_context = /** @type {SSRContext} */
  ssr_context.p;
}
function get_parent_context(ssr_context2) {
  let parent = ssr_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
var ssr_context;
var init_context2 = __esm({
  "node_modules/svelte/src/internal/server/context.js"() {
    init_esm_env();
    init_errors3();
    ssr_context = null;
  }
});

// node_modules/svelte/src/internal/server/warnings.js
function unresolved_hydratable(key2, stack2) {
  if (true_default) {
    console.warn(
      `%c[svelte] unresolved_hydratable
%cA \`hydratable\` value with key \`${key2}\` was created, but at least part of it was not used during the render.

The \`hydratable\` was initialized in:
${stack2}
https://svelte.dev/e/unresolved_hydratable`,
      bold3,
      normal3
    );
  } else {
    console.warn(`https://svelte.dev/e/unresolved_hydratable`);
  }
}
var bold3, normal3;
var init_warnings3 = __esm({
  "node_modules/svelte/src/internal/server/warnings.js"() {
    init_esm_env();
    bold3 = "font-weight: bold";
    normal3 = "font-weight: normal";
  }
});

// node_modules/svelte/src/internal/server/render-context.js
function get_render_context() {
  const store = context ?? als?.getStore();
  if (!store) {
    server_context_required();
  }
  return store;
}
async function with_render_context(fn) {
  context = {
    hydratable: {
      lookup: /* @__PURE__ */ new Map(),
      comparisons: [],
      unresolved_promises: /* @__PURE__ */ new Map()
    }
  };
  if (in_webcontainer()) {
    const { promise, resolve } = deferred();
    const previous_render = current_render;
    current_render = promise;
    await previous_render;
    return fn().finally(resolve);
  }
  try {
    if (als === null) {
      async_local_storage_unavailable();
    }
    return als.run(context, fn);
  } finally {
    context = null;
  }
}
async function init_render_context2() {
  if (als !== null) return;
  try {
    const { AsyncLocalStorage } = await import("node:async_hooks");
    als = new AsyncLocalStorage();
  } catch {
  }
}
function in_webcontainer() {
  return !!globalThis.process?.versions?.webcontainer;
}
var current_render, context, als;
var init_render_context = __esm({
  "node_modules/svelte/src/internal/server/render-context.js"() {
    init_utils();
    init_errors3();
    current_render = null;
    context = null;
    als = null;
  }
});

// node_modules/svelte/src/internal/server/renderer.js
var Renderer, SSRState;
var init_renderer = __esm({
  "node_modules/svelte/src/internal/server/renderer.js"() {
    init_flags();
    init_abort_signal();
    init_context2();
    init_errors3();
    init_warnings3();
    init_hydration2();
    init_server();
    init_render_context();
    init_esm_env();
    Renderer = class _Renderer {
      /**
       * The contents of the renderer.
       * @type {RendererItem[]}
       */
      #out = [];
      /**
       * Any `onDestroy` callbacks registered during execution of this renderer.
       * @type {(() => void)[] | undefined}
       */
      #on_destroy = void 0;
      /**
       * Whether this renderer is a component body.
       * @type {boolean}
       */
      #is_component_body = false;
      /**
       * The type of string content that this renderer is accumulating.
       * @type {RendererType}
       */
      type;
      /** @type {Renderer | undefined} */
      #parent;
      /**
       * Asynchronous work associated with this renderer
       * @type {Promise<void> | undefined}
       */
      promise = void 0;
      /**
       * State which is associated with the content tree as a whole.
       * It will be re-exposed, uncopied, on all children.
       * @type {SSRState}
       * @readonly
       */
      global;
      /**
       * State that is local to the branch it is declared in.
       * It will be shallow-copied to all children.
       *
       * @type {{ select_value: string | undefined }}
       */
      local;
      /**
       * @param {SSRState} global
       * @param {Renderer | undefined} [parent]
       */
      constructor(global, parent) {
        this.#parent = parent;
        this.global = global;
        this.local = parent ? { ...parent.local } : { select_value: void 0 };
        this.type = parent ? parent.type : "body";
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      head(fn) {
        const head2 = new _Renderer(this.global, this);
        head2.type = "head";
        this.#out.push(head2);
        head2.child(fn);
      }
      /**
       * @param {Array<Promise<void>>} blockers
       * @param {(renderer: Renderer) => void} fn
       */
      async_block(blockers, fn) {
        this.#out.push(BLOCK_OPEN);
        this.async(blockers, fn);
        this.#out.push(BLOCK_CLOSE);
      }
      /**
       * @param {Array<Promise<void>>} blockers
       * @param {(renderer: Renderer) => void} fn
       */
      async(blockers, fn) {
        let callback = fn;
        if (blockers.length > 0) {
          const context2 = ssr_context;
          callback = (renderer) => {
            return Promise.all(blockers).then(() => {
              const previous_context = ssr_context;
              try {
                set_ssr_context(context2);
                return fn(renderer);
              } finally {
                set_ssr_context(previous_context);
              }
            });
          };
        }
        this.child(callback);
      }
      /**
       * @param {Array<() => void>} thunks
       */
      run(thunks) {
        const context2 = ssr_context;
        let promise = Promise.resolve(thunks[0]());
        const promises = [promise];
        for (const fn of thunks.slice(1)) {
          promise = promise.then(() => {
            const previous_context = ssr_context;
            set_ssr_context(context2);
            try {
              return fn();
            } finally {
              set_ssr_context(previous_context);
            }
          });
          promises.push(promise);
        }
        return promises;
      }
      /**
       * Create a child renderer. The child renderer inherits the state from the parent,
       * but has its own content.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       */
      child(fn) {
        const child2 = new _Renderer(this.global, this);
        this.#out.push(child2);
        const parent = ssr_context;
        set_ssr_context({
          ...ssr_context,
          p: parent,
          c: null,
          r: child2
        });
        const result = fn(child2);
        set_ssr_context(parent);
        if (result instanceof Promise) {
          if (child2.global.mode === "sync") {
            await_invalid();
          }
          result.catch(() => {
          });
          child2.promise = result;
        }
        return child2;
      }
      /**
       * Create a component renderer. The component renderer inherits the state from the parent,
       * but has its own content. It is treated as an ordering boundary for ondestroy callbacks.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       * @param {Function} [component_fn]
       * @returns {void}
       */
      component(fn, component_fn) {
        push2(component_fn);
        const child2 = this.child(fn);
        child2.#is_component_body = true;
        pop2();
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {(renderer: Renderer) => void} fn
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       * @returns {void}
       */
      select(attrs, fn, css_hash, classes, styles, flags2) {
        const { value, ...select_attrs } = attrs;
        this.push(`<select${attributes(select_attrs, css_hash, classes, styles, flags2)}>`);
        this.child((renderer) => {
          renderer.local.select_value = value;
          fn(renderer);
        });
        this.push("</select>");
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {string | number | boolean | ((renderer: Renderer) => void)} body
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       */
      option(attrs, body, css_hash, classes, styles, flags2) {
        this.#out.push(`<option${attributes(attrs, css_hash, classes, styles, flags2)}`);
        const close = (renderer, value, { head: head2, body: body2 }) => {
          if ("value" in attrs) {
            value = attrs.value;
          }
          if (value === this.local.select_value) {
            renderer.#out.push(" selected");
          }
          renderer.#out.push(`>${body2}</option>`);
          if (head2) {
            renderer.head((child2) => child2.push(head2));
          }
        };
        if (typeof body === "function") {
          this.child((renderer) => {
            const r2 = new _Renderer(this.global, this);
            body(r2);
            if (this.global.mode === "async") {
              return r2.#collect_content_async().then((content) => {
                close(renderer, content.body.replaceAll("<!---->", ""), content);
              });
            } else {
              const content = r2.#collect_content();
              close(renderer, content.body.replaceAll("<!---->", ""), content);
            }
          });
        } else {
          close(this, body, { body });
        }
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      title(fn) {
        const path = this.get_path();
        const close = (head2) => {
          this.global.set_title(head2, path);
        };
        this.child((renderer) => {
          const r2 = new _Renderer(renderer.global, renderer);
          fn(r2);
          if (renderer.global.mode === "async") {
            return r2.#collect_content_async().then((content) => {
              close(content.head);
            });
          } else {
            const content = r2.#collect_content();
            close(content.head);
          }
        });
      }
      /**
       * @param {string | (() => Promise<string>)} content
       */
      push(content) {
        if (typeof content === "function") {
          this.child(async (renderer) => renderer.push(await content()));
        } else {
          this.#out.push(content);
        }
      }
      /**
       * @param {() => void} fn
       */
      on_destroy(fn) {
        (this.#on_destroy ??= []).push(fn);
      }
      /**
       * @returns {number[]}
       */
      get_path() {
        return this.#parent ? [...this.#parent.get_path(), this.#parent.#out.indexOf(this)] : [];
      }
      /**
       * @deprecated this is needed for legacy component bindings
       */
      copy() {
        const copy = new _Renderer(this.global, this.#parent);
        copy.#out = this.#out.map((item) => item instanceof _Renderer ? item.copy() : item);
        copy.promise = this.promise;
        return copy;
      }
      /**
       * @param {Renderer} other
       * @deprecated this is needed for legacy component bindings
       */
      subsume(other) {
        if (this.global.mode !== other.global.mode) {
          throw new Error(
            "invariant: A renderer cannot switch modes. If you're seeing this, there's a compiler bug. File an issue!"
          );
        }
        this.local = other.local;
        this.#out = other.#out.map((item) => {
          if (item instanceof _Renderer) {
            item.subsume(item);
          }
          return item;
        });
        this.promise = other.promise;
        this.type = other.type;
      }
      get length() {
        return this.#out.length;
      }
      /**
       * Only available on the server and when compiling with the `server` option.
       * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} [options]
       * @returns {RenderOutput}
       */
      static render(component2, options = {}) {
        let sync;
        let async2;
        const result = (
          /** @type {RenderOutput} */
          {}
        );
        Object.defineProperties(result, {
          html: {
            get: () => {
              return (sync ??= _Renderer.#render(component2, options)).body;
            }
          },
          head: {
            get: () => {
              return (sync ??= _Renderer.#render(component2, options)).head;
            }
          },
          body: {
            get: () => {
              return (sync ??= _Renderer.#render(component2, options)).body;
            }
          },
          then: {
            value: (
              /**
               * this is not type-safe, but honestly it's the best I can do right now, and it's a straightforward function.
               *
               * @template TResult1
               * @template [TResult2=never]
               * @param { (value: SyncRenderOutput) => TResult1 } onfulfilled
               * @param { (reason: unknown) => TResult2 } onrejected
               */
              (onfulfilled, onrejected) => {
                if (!async_mode_flag) {
                  const result2 = sync ??= _Renderer.#render(component2, options);
                  const user_result = onfulfilled({
                    head: result2.head,
                    body: result2.body,
                    html: result2.body
                  });
                  return Promise.resolve(user_result);
                }
                async2 ??= init_render_context2().then(
                  () => with_render_context(() => _Renderer.#render_async(component2, options))
                );
                return async2.then((result2) => {
                  Object.defineProperty(result2, "html", {
                    // eslint-disable-next-line getter-return
                    get: () => {
                      html_deprecated();
                    }
                  });
                  return onfulfilled(
                    /** @type {SyncRenderOutput} */
                    result2
                  );
                }, onrejected);
              }
            )
          }
        });
        return result;
      }
      /**
       * Collect all of the `onDestroy` callbacks registered during rendering. In an async context, this is only safe to call
       * after awaiting `collect_async`.
       *
       * Child renderers are "porous" and don't affect execution order, but component body renderers
       * create ordering boundaries. Within a renderer, callbacks run in order until hitting a component boundary.
       * @returns {Iterable<() => void>}
       */
      *#collect_on_destroy() {
        for (const component2 of this.#traverse_components()) {
          yield* component2.#collect_ondestroy();
        }
      }
      /**
       * Performs a depth-first search of renderers, yielding the deepest components first, then additional components as we backtrack up the tree.
       * @returns {Iterable<Renderer>}
       */
      *#traverse_components() {
        for (const child2 of this.#out) {
          if (typeof child2 !== "string") {
            yield* child2.#traverse_components();
          }
        }
        if (this.#is_component_body) {
          yield this;
        }
      }
      /**
       * @returns {Iterable<() => void>}
       */
      *#collect_ondestroy() {
        if (this.#on_destroy) {
          for (const fn of this.#on_destroy) {
            yield fn;
          }
        }
        for (const child2 of this.#out) {
          if (child2 instanceof _Renderer && !child2.#is_component_body) {
            yield* child2.#collect_ondestroy();
          }
        }
      }
      /**
       * Render a component. Throws if any of the children are performing asynchronous work.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {AccumulatedContent}
       */
      static #render(component2, options) {
        var previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("sync", component2, options);
          const content = renderer.#collect_content();
          return _Renderer.#close_render(content, renderer);
        } finally {
          abort();
          set_ssr_context(previous_context);
        }
      }
      /**
       * Render a component.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Promise<AccumulatedContent>}
       */
      static async #render_async(component2, options) {
        const previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("async", component2, options);
          const content = await renderer.#collect_content_async();
          const hydratables = await renderer.#collect_hydratables();
          if (hydratables !== null) {
            content.head = hydratables + content.head;
          }
          return _Renderer.#close_render(content, renderer);
        } finally {
          set_ssr_context(previous_context);
          abort();
        }
      }
      /**
       * Collect all of the code from the `out` array and return it as a string, or a promise resolving to a string.
       * @param {AccumulatedContent} content
       * @returns {AccumulatedContent}
       */
      #collect_content(content = { head: "", body: "" }) {
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            item.#collect_content(content);
          }
        }
        return content;
      }
      /**
       * Collect all of the code from the `out` array and return it as a string.
       * @param {AccumulatedContent} content
       * @returns {Promise<AccumulatedContent>}
       */
      async #collect_content_async(content = { head: "", body: "" }) {
        await this.promise;
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            await item.#collect_content_async(content);
          }
        }
        return content;
      }
      async #collect_hydratables() {
        const ctx = get_render_context().hydratable;
        for (const [_, key2] of ctx.unresolved_promises) {
          unresolved_hydratable(key2, ctx.lookup.get(key2)?.stack ?? "<missing stack trace>");
        }
        for (const comparison of ctx.comparisons) {
          await comparison;
        }
        return await _Renderer.#hydratable_block(ctx);
      }
      /**
       * @template {Record<string, any>} Props
       * @param {'sync' | 'async'} mode
       * @param {import('svelte').Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Renderer}
       */
      static #open_render(mode, component2, options) {
        const renderer = new _Renderer(
          new SSRState(mode, options.idPrefix ? options.idPrefix + "-" : "")
        );
        renderer.push(BLOCK_OPEN);
        if (options.context) {
          push2();
          ssr_context.c = options.context;
          ssr_context.r = renderer;
        }
        component2(renderer, options.props ?? {});
        if (options.context) {
          pop2();
        }
        renderer.push(BLOCK_CLOSE);
        return renderer;
      }
      /**
       * @param {AccumulatedContent} content
       * @param {Renderer} renderer
       */
      static #close_render(content, renderer) {
        for (const cleanup of renderer.#collect_on_destroy()) {
          cleanup();
        }
        let head2 = content.head + renderer.global.get_title();
        let body = content.body;
        for (const { hash: hash2, code } of renderer.global.css) {
          head2 += `<style id="${hash2}">${code}</style>`;
        }
        return {
          head: head2,
          body
        };
      }
      /**
       * @param {HydratableContext} ctx
       */
      static async #hydratable_block(ctx) {
        if (ctx.lookup.size === 0) {
          return null;
        }
        let entries = [];
        let has_promises = false;
        for (const [k, v] of ctx.lookup) {
          if (v.promises) {
            has_promises = true;
            for (const p of v.promises) await p;
          }
          entries.push(`[${JSON.stringify(k)},${v.serialized}]`);
        }
        let prelude = `const h = (window.__svelte ??= {}).h ??= new Map();`;
        if (has_promises) {
          prelude = `const r = (v) => Promise.resolve(v);
				${prelude}`;
        }
        return `
		<script>
			{
				${prelude}

				for (const [k, v] of [
					${entries.join(",\n					")}
				]) {
					h.set(k, v);
				}
			}
		</script>`;
      }
    };
    SSRState = class {
      /** @readonly @type {'sync' | 'async'} */
      mode;
      /** @readonly @type {() => string} */
      uid;
      /** @readonly @type {Set<{ hash: string; code: string }>} */
      css = /* @__PURE__ */ new Set();
      /** @type {{ path: number[], value: string }} */
      #title = { path: [], value: "" };
      /**
       * @param {'sync' | 'async'} mode
       * @param {string} [id_prefix]
       */
      constructor(mode, id_prefix = "") {
        this.mode = mode;
        let uid = 1;
        this.uid = () => `${id_prefix}s${uid++}`;
      }
      get_title() {
        return this.#title.value;
      }
      /**
       * Performs a depth-first (lexicographic) comparison using the path. Rejects sets
       * from earlier than or equal to the current value.
       * @param {string} value
       * @param {number[]} path
       */
      set_title(value, path) {
        const current = this.#title.path;
        let i = 0;
        let l = Math.min(path.length, current.length);
        while (i < l && path[i] === current[i]) i += 1;
        if (path[i] === void 0) return;
        if (current[i] === void 0 || path[i] > current[i]) {
          this.#title.path = path;
          this.#title.value = value;
        }
      }
    };
  }
});

// node_modules/svelte/src/internal/server/blocks/html.js
var init_html2 = __esm({
  "node_modules/svelte/src/internal/server/blocks/html.js"() {
    init_esm_env();
    init_utils2();
  }
});

// node_modules/svelte/src/html-tree-validation.js
function is_tag_valid_with_ancestor(child_tag, ancestors, child_loc, ancestor_loc) {
  if (child_tag.includes("-")) return null;
  const ancestor_tag = ancestors[ancestors.length - 1];
  const disallowed = disallowed_children[ancestor_tag];
  if (!disallowed) return null;
  if ("reset_by" in disallowed && disallowed.reset_by) {
    for (let i = ancestors.length - 2; i >= 0; i--) {
      const ancestor = ancestors[i];
      if (ancestor.includes("-")) return null;
      if (disallowed.reset_by.includes(ancestors[i])) {
        return null;
      }
    }
  }
  if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
    const child2 = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
    const ancestor = ancestor_loc ? `\`<${ancestor_tag}>\` (${ancestor_loc})` : `\`<${ancestor_tag}>\``;
    return `${child2} cannot be a descendant of ${ancestor}`;
  }
  return null;
}
function is_tag_valid_with_parent(child_tag, parent_tag, child_loc, parent_loc) {
  if (child_tag.includes("-") || parent_tag?.includes("-")) return null;
  if (parent_tag === "template") return null;
  const disallowed = disallowed_children[parent_tag];
  const child2 = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
  const parent = parent_loc ? `\`<${parent_tag}>\` (${parent_loc})` : `\`<${parent_tag}>\``;
  if (disallowed) {
    if ("direct" in disallowed && disallowed.direct.includes(child_tag)) {
      return `${child2} cannot be a direct child of ${parent}`;
    }
    if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
      return `${child2} cannot be a child of ${parent}`;
    }
    if ("only" in disallowed && disallowed.only) {
      if (disallowed.only.includes(child_tag)) {
        return null;
      } else {
        return `${child2} cannot be a child of ${parent}. \`<${parent_tag}>\` only allows these children: ${disallowed.only.map((d) => `\`<${d}>\``).join(", ")}`;
      }
    }
  }
  switch (child_tag) {
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
      return `${child2} cannot be a child of ${parent}`;
    case "thead":
    case "tbody":
    case "tfoot":
      return `${child2} must be the child of a \`<table>\`, not a ${parent}`;
    case "td":
    case "th":
      return `${child2} must be the child of a \`<tr>\`, not a ${parent}`;
    case "tr":
      return `\`<tr>\` must be the child of a \`<thead>\`, \`<tbody>\`, or \`<tfoot>\`, not a ${parent}`;
  }
  return null;
}
var autoclosing_children, disallowed_children;
var init_html_tree_validation = __esm({
  "node_modules/svelte/src/html-tree-validation.js"() {
    autoclosing_children = {
      // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
      li: { direct: ["li"] },
      // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
      dt: { descendant: ["dt", "dd"], reset_by: ["dl"] },
      dd: { descendant: ["dt", "dd"], reset_by: ["dl"] },
      p: {
        descendant: [
          "address",
          "article",
          "aside",
          "blockquote",
          "div",
          "dl",
          "fieldset",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "header",
          "hgroup",
          "hr",
          "main",
          "menu",
          "nav",
          "ol",
          "p",
          "pre",
          "section",
          "table",
          "ul"
        ]
      },
      rt: { descendant: ["rt", "rp"] },
      rp: { descendant: ["rt", "rp"] },
      optgroup: { descendant: ["optgroup"] },
      option: { descendant: ["option", "optgroup"] },
      thead: { direct: ["tbody", "tfoot"] },
      tbody: { direct: ["tbody", "tfoot"] },
      tfoot: { direct: ["tbody"] },
      tr: { direct: ["tr", "tbody"] },
      td: { direct: ["td", "th", "tr"] },
      th: { direct: ["td", "th", "tr"] }
    };
    disallowed_children = {
      ...autoclosing_children,
      optgroup: { only: ["option", "#text"] },
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
      option: { only: ["#text"] },
      form: { descendant: ["form"] },
      a: { descendant: ["a"] },
      button: { descendant: ["button"] },
      h1: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h2: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h3: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h4: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h5: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h6: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      select: { only: ["option", "optgroup", "#text", "hr", "script", "template"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      tr: { only: ["th", "td", "style", "script", "template"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      tbody: { only: ["tr", "style", "script", "template"] },
      thead: { only: ["tr", "style", "script", "template"] },
      tfoot: { only: ["tr", "style", "script", "template"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      colgroup: { only: ["col", "template"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      table: {
        only: ["caption", "colgroup", "tbody", "thead", "tfoot", "style", "script", "template"]
      },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      head: {
        only: [
          "base",
          "basefont",
          "bgsound",
          "link",
          "meta",
          "title",
          "noscript",
          "noframes",
          "style",
          "script",
          "template"
        ]
      },
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      html: { only: ["head", "body", "frameset"] },
      frameset: { only: ["frame"] },
      "#document": { only: ["html"] }
    };
  }
});

// node_modules/svelte/src/internal/server/dev.js
function print_error(renderer, message) {
  message = `node_invalid_placement_ssr: ${message}

This can cause content to shift around as the browser repairs the HTML, and will likely result in a \`hydration_mismatch\` warning.`;
  if ((seen ??= /* @__PURE__ */ new Set()).has(message)) return;
  seen.add(message);
  console.error(message);
  renderer.head((r2) => r2.push(`<script>console.error(${JSON.stringify(message)})</script>`));
}
function push_element(renderer, tag2, line, column) {
  var context2 = (
    /** @type {SSRContext} */
    ssr_context
  );
  var filename = context2.function[FILENAME];
  var parent = context2.element;
  var element3 = { tag: tag2, parent, filename, line, column };
  if (parent !== void 0) {
    var ancestor = parent.parent;
    var ancestors = [parent.tag];
    const child_loc = filename ? `${filename}:${line}:${column}` : void 0;
    const parent_loc = parent.filename ? `${parent.filename}:${parent.line}:${parent.column}` : void 0;
    const message = is_tag_valid_with_parent(tag2, parent.tag, child_loc, parent_loc);
    if (message) print_error(renderer, message);
    while (ancestor != null) {
      ancestors.push(ancestor.tag);
      const ancestor_loc = ancestor.filename ? `${ancestor.filename}:${ancestor.line}:${ancestor.column}` : void 0;
      const message2 = is_tag_valid_with_ancestor(tag2, ancestors, child_loc, ancestor_loc);
      if (message2) print_error(renderer, message2);
      ancestor = ancestor.parent;
    }
  }
  set_ssr_context({ ...context2, p: context2, element: element3 });
}
function pop_element() {
  set_ssr_context(
    /** @type {SSRContext} */
    ssr_context.p
  );
}
function get_user_code_location() {
  const stack2 = get_stack();
  return stack2.filter((line) => line.trim().startsWith("at ")).map((line) => line.replace(/\((.*):\d+:\d+\)$/, (_, file) => `(${file})`)).join("\n");
}
var seen;
var init_dev2 = __esm({
  "node_modules/svelte/src/internal/server/dev.js"() {
    init_constants();
    init_html_tree_validation();
    init_dev();
    init_context2();
    init_errors3();
    init_renderer();
  }
});

// node_modules/svelte/src/internal/server/index.js
function element2(renderer, tag2, attributes_fn = noop, children_fn = noop) {
  renderer.push("<!---->");
  if (tag2) {
    renderer.push(`<${tag2}`);
    attributes_fn();
    renderer.push(`>`);
    if (!is_void(tag2)) {
      children_fn();
      if (!is_raw_text_element(tag2)) {
        renderer.push(EMPTY_COMMENT);
      }
      renderer.push(`</${tag2}>`);
    }
  }
  renderer.push("<!---->");
}
function render(component2, options = {}) {
  return Renderer.render(
    /** @type {Component<Props>} */
    component2,
    options
  );
}
function attributes(attrs, css_hash, classes, styles, flags2 = 0) {
  if (styles) {
    attrs.style = to_style(attrs.style, styles);
  }
  if (attrs.class) {
    attrs.class = clsx2(attrs.class);
  }
  if (css_hash || classes) {
    attrs.class = to_class(attrs.class, css_hash, classes);
  }
  let attr_str = "";
  let name;
  const is_html = (flags2 & ELEMENT_IS_NAMESPACED) === 0;
  const lowercase = (flags2 & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;
  const is_input = (flags2 & ELEMENT_IS_INPUT) !== 0;
  for (name in attrs) {
    if (typeof attrs[name] === "function") continue;
    if (name[0] === "$" && name[1] === "$") continue;
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue;
    var value = attrs[name];
    if (lowercase) {
      name = name.toLowerCase();
    }
    if (is_input) {
      if (name === "defaultvalue" || name === "defaultchecked") {
        name = name === "defaultvalue" ? "value" : "checked";
        if (attrs[name]) continue;
      }
    }
    attr_str += attr(name, value, is_html && is_boolean_attribute(name));
  }
  return attr_str;
}
function spread_props2(props) {
  const merged_props = {};
  let key2;
  for (let i = 0; i < props.length; i++) {
    const obj = props[i];
    for (key2 in obj) {
      const desc = Object.getOwnPropertyDescriptor(obj, key2);
      if (desc) {
        Object.defineProperty(merged_props, key2, desc);
      } else {
        merged_props[key2] = obj[key2];
      }
    }
  }
  return merged_props;
}
function stringify(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
function attr_class(value, hash2, directives) {
  var result = to_class(value, hash2, directives);
  return result ? ` class="${escape_html(result, true)}"` : "";
}
function attr_style(value, directives) {
  var result = to_style(value, directives);
  return result ? ` style="${escape_html(result, true)}"` : "";
}
function slot2(renderer, $$props, name, slot_props, fallback_fn) {
  var slot_fn = $$props.$$slots?.[name];
  if (slot_fn === true) {
    slot_fn = $$props[name === "default" ? "children" : name];
  }
  if (slot_fn !== void 0) {
    slot_fn(renderer, slot_props);
  } else {
    fallback_fn?.();
  }
}
function rest_props2(props, rest) {
  const rest_props3 = {};
  let key2;
  for (key2 in props) {
    if (!rest.includes(key2)) {
      rest_props3[key2] = props[key2];
    }
  }
  return rest_props3;
}
function sanitize_props(props) {
  const { children, $$slots, ...sanitized } = props;
  return sanitized;
}
function bind_props(props_parent, props_now) {
  for (const key2 in props_now) {
    const initial_value = props_parent[key2];
    const value = props_now[key2];
    if (initial_value === void 0 && value !== void 0 && Object.getOwnPropertyDescriptor(props_parent, key2)?.set) {
      props_parent[key2] = value;
    }
  }
}
function ensure_array_like(array_like_or_iterator) {
  if (array_like_or_iterator) {
    return array_like_or_iterator.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }
  return [];
}
var INVALID_ATTR_NAME_CHAR_REGEX;
var init_server = __esm({
  "node_modules/svelte/src/internal/server/index.js"() {
    init_constants();
    init_attributes();
    init_utils();
    init_utils3();
    init_constants();
    init_escaping();
    init_esm_env();
    init_hydration2();
    init_validate();
    init_utils2();
    init_renderer();
    init_html2();
    init_context2();
    init_dev2();
    init_clone();
    init_utils();
    init_validate();
    INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
  }
});

// node_modules/devalue/src/utils.js
function is_primitive(thing) {
  return Object(thing) !== thing;
}
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type2(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char = str[i];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
function stringify_key(key2) {
  return is_identifier.test(key2) ? "." + key2 : "[" + JSON.stringify(key2) + "]";
}
var escaped, DevalueError, object_proto_names, is_identifier;
var init_utils4 = __esm({
  "node_modules/devalue/src/utils.js"() {
    escaped = {
      "<": "\\u003C",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    DevalueError = class extends Error {
      /**
       * @param {string} message
       * @param {string[]} keys
       */
      constructor(message, keys) {
        super(message);
        this.name = "DevalueError";
        this.path = keys.join("");
      }
    };
    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
      Object.prototype
    ).sort().join("\0");
    is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  }
});

// node_modules/devalue/src/uneval.js
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing, (value2) => uneval(value2, replacer));
        if (typeof str2 === "string") {
          custom.set(thing, str2);
          return;
        }
      }
      if (typeof thing === "function") {
        throw new DevalueError(`Cannot stringify a function`, keys);
      }
      const type = get_type2(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
        case "URL":
        case "URLSearchParams":
          return;
        case "Array":
          thing.forEach((value2, i) => {
            keys.push(`[${i}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          walk(thing.buffer);
          return;
        case "ArrayBuffer":
          return;
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(stringify_key(key2));
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a, b) => b[1] - a[1]).forEach((entry, i) => {
    names.set(entry[0], get_name(i));
  });
  function stringify2(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom.has(thing)) {
      return custom.get(thing);
    }
    const type = get_type2(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify2(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "URL":
        return `new URL(${stringify_string(thing.toString())})`;
      case "URLSearchParams":
        return `new URLSearchParams(${stringify_string(thing.toString())})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v, i) => i in thing ? stringify2(v) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify2).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        let str2 = `new ${type}`;
        if (counts.get(thing.buffer) === 1) {
          const array = new thing.constructor(thing.buffer);
          str2 += `([${array}])`;
        } else {
          str2 += `([${stringify2(thing.buffer)}])`;
        }
        const a = thing.byteOffset;
        const b = a + thing.byteLength;
        if (a > 0 || b !== thing.buffer.byteLength) {
          const m = +/(\d+)/.exec(type)[1] / 8;
          str2 += `.subarray(${a / m},${b / m})`;
        }
        return str2;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      case "Temporal.Duration":
      case "Temporal.Instant":
      case "Temporal.PlainDate":
      case "Temporal.PlainTime":
      case "Temporal.PlainDateTime":
      case "Temporal.PlainMonthDay":
      case "Temporal.PlainYearMonth":
      case "Temporal.ZonedDateTime":
        return `${type}.from(${stringify_string(thing.toString())})`;
      default:
        const keys2 = Object.keys(thing);
        const obj = keys2.map((key2) => `${safe_key(key2)}:${stringify2(thing[key2])}`).join(",");
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return keys2.length > 0 ? `{${obj},__proto__:null}` : `{__proto__:null}`;
        }
        return `{${obj}}`;
    }
  }
  const str = stringify2(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name, thing) => {
      params.push(name);
      if (custom.has(thing)) {
        values.push(
          /** @type {string} */
          custom.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type2(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify2(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v, i) => {
            statements.push(`${name}[${i}]=${stringify2(v)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v) => `add(${stringify2(v)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k, v]) => `set(${stringify2(k)}, ${stringify2(v)})`).join(".")}`
          );
          break;
        case "ArrayBuffer":
          values.push(
            `new Uint8Array([${new Uint8Array(thing).join(",")}]).buffer`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name}${safe_prop(key2)}=${stringify2(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
function escape_unsafe_char(c) {
  return escaped[c] || c;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
function stringify_primitive(thing) {
  if (typeof thing === "string") return stringify_string(thing);
  if (thing === void 0) return "void 0";
  if (thing === 0 && 1 / thing < 0) return "-0";
  const str = String(thing);
  if (typeof thing === "number") return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint") return thing + "n";
  return str;
}
var chars, unsafe_chars, reserved;
var init_uneval = __esm({
  "node_modules/devalue/src/uneval.js"() {
    init_utils4();
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
  }
});

// node_modules/devalue/index.js
var init_devalue = __esm({
  "node_modules/devalue/index.js"() {
    init_uneval();
  }
});

// node_modules/svelte/src/internal/server/hydratable.js
function hydratable2(key2, fn) {
  if (!async_mode_flag) {
    experimental_async_required("hydratable");
  }
  const { hydratable: hydratable3 } = get_render_context();
  let entry = hydratable3.lookup.get(key2);
  if (entry !== void 0) {
    if (true_default) {
      const comparison = compare2(key2, entry, encode(key2, fn()));
      comparison.catch(() => {
      });
      hydratable3.comparisons.push(comparison);
    }
    return (
      /** @type {T} */
      entry.value
    );
  }
  const value = fn();
  entry = encode(key2, value, hydratable3.unresolved_promises);
  hydratable3.lookup.set(key2, entry);
  return value;
}
function encode(key2, value, unresolved) {
  const entry = { value, serialized: "" };
  if (true_default) {
    entry.stack = get_user_code_location();
  }
  let uid = 1;
  entry.serialized = uneval(entry.value, (value2, uneval2) => {
    if (is_promise2(value2)) {
      const p = value2.then((v) => `r(${uneval2(v)})`).catch(
        (devalue_error) => hydratable_serialization_failed(
          key2,
          serialization_stack(entry.stack, devalue_error?.stack)
        )
      );
      p.catch(() => {
      });
      unresolved?.set(p, key2);
      p.finally(() => unresolved?.delete(p));
      const placeholder = `"${uid++}"`;
      (entry.promises ??= []).push(
        p.then((s) => {
          entry.serialized = entry.serialized.replace(placeholder, s);
        })
      );
      return placeholder;
    }
  });
  return entry;
}
function is_promise2(value) {
  return Object.prototype.toString.call(value) === "[object Promise]";
}
async function compare2(key2, a, b) {
  for (const p of a?.promises ?? []) {
    await p;
  }
  for (const p of b?.promises ?? []) {
    await p;
  }
  if (a.serialized !== b.serialized) {
    const a_stack = (
      /** @type {string} */
      a.stack
    );
    const b_stack = (
      /** @type {string} */
      b.stack
    );
    const stack2 = a_stack === b_stack ? `Occurred at:
${a_stack}` : `First occurrence at:
${a_stack}

Second occurrence at:
${b_stack}`;
    hydratable_clobbering(key2, stack2);
  }
}
function serialization_stack(root_stack, uneval_stack) {
  let out = "";
  if (root_stack) {
    out += root_stack + "\n";
  }
  if (uneval_stack) {
    out += "Caused by:\n" + uneval_stack + "\n";
  }
  return out || "<missing stack trace>";
}
var init_hydratable2 = __esm({
  "node_modules/svelte/src/internal/server/hydratable.js"() {
    init_flags();
    init_render_context();
    init_errors3();
    init_devalue();
    init_dev();
    init_esm_env();
    init_dev2();
  }
});

// node_modules/svelte/src/internal/server/blocks/snippet.js
function createRawSnippet2(fn) {
  return (renderer, ...args) => {
    var getters = (
      /** @type {Getters<Params>} */
      args.map((value) => () => value)
    );
    renderer.push(
      fn(...getters).render().trim()
    );
  };
}
var init_snippet2 = __esm({
  "node_modules/svelte/src/internal/server/blocks/snippet.js"() {
  }
});

// node_modules/svelte/src/index-server.js
var index_server_exports = {};
__export(index_server_exports, {
  afterUpdate: () => noop,
  beforeUpdate: () => noop,
  createContext: () => createContext2,
  createEventDispatcher: () => createEventDispatcher,
  createRawSnippet: () => createRawSnippet2,
  flushSync: () => noop,
  fork: () => fork2,
  getAbortSignal: () => getAbortSignal,
  getAllContexts: () => getAllContexts2,
  getContext: () => getContext2,
  hasContext: () => hasContext2,
  hydratable: () => hydratable2,
  hydrate: () => hydrate2,
  mount: () => mount2,
  onDestroy: () => onDestroy,
  onMount: () => noop,
  setContext: () => setContext2,
  settled: () => settled2,
  tick: () => tick2,
  unmount: () => unmount2,
  untrack: () => run
});
function onDestroy(fn) {
  /** @type {SSRContext} */
  ssr_context.r.on_destroy(fn);
}
function createEventDispatcher() {
  return noop;
}
function mount2() {
  lifecycle_function_unavailable("mount");
}
function hydrate2() {
  lifecycle_function_unavailable("hydrate");
}
function unmount2() {
  lifecycle_function_unavailable("unmount");
}
function fork2() {
  lifecycle_function_unavailable("fork");
}
async function tick2() {
}
async function settled2() {
}
var init_index_server = __esm({
  "node_modules/svelte/src/index-server.js"() {
    init_context2();
    init_utils();
    init_errors3();
    init_utils();
    init_abort_signal();
    init_context2();
    init_hydratable2();
    init_snippet2();
  }
});

// ../deps/phoenix/priv/static/phoenix.cjs.js
var require_phoenix_cjs = __commonJS({
  "../deps/phoenix/priv/static/phoenix.cjs.js"(exports2, module2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var phoenix_exports = {};
    __export2(phoenix_exports, {
      Channel: () => Channel,
      LongPoll: () => LongPoll,
      Presence: () => Presence,
      Serializer: () => serializer_default,
      Socket: () => Socket2
    });
    module2.exports = __toCommonJS2(phoenix_exports);
    var closure = (value) => {
      if (typeof value === "function") {
        return value;
      } else {
        let closure2 = function() {
          return value;
        };
        return closure2;
      }
    };
    var globalSelf = typeof self !== "undefined" ? self : null;
    var phxWindow = typeof window !== "undefined" ? window : null;
    var global = globalSelf || phxWindow || globalThis;
    var DEFAULT_VSN = "2.0.0";
    var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
    var DEFAULT_TIMEOUT = 1e4;
    var WS_CLOSE_NORMAL = 1e3;
    var CHANNEL_STATES = {
      closed: "closed",
      errored: "errored",
      joined: "joined",
      joining: "joining",
      leaving: "leaving"
    };
    var CHANNEL_EVENTS = {
      close: "phx_close",
      error: "phx_error",
      join: "phx_join",
      reply: "phx_reply",
      leave: "phx_leave"
    };
    var TRANSPORTS = {
      longpoll: "longpoll",
      websocket: "websocket"
    };
    var XHR_STATES = {
      complete: 4
    };
    var AUTH_TOKEN_PREFIX = "base64url.bearer.phx.";
    var Push = class {
      constructor(channel, event2, payload, timeout) {
        this.channel = channel;
        this.event = event2;
        this.payload = payload || function() {
          return {};
        };
        this.receivedResp = null;
        this.timeout = timeout;
        this.timeoutTimer = null;
        this.recHooks = [];
        this.sent = false;
      }
      /**
       *
       * @param {number} timeout
       */
      resend(timeout) {
        this.timeout = timeout;
        this.reset();
        this.send();
      }
      /**
       *
       */
      send() {
        if (this.hasReceived("timeout")) {
          return;
        }
        this.startTimeout();
        this.sent = true;
        this.channel.socket.push({
          topic: this.channel.topic,
          event: this.event,
          payload: this.payload(),
          ref: this.ref,
          join_ref: this.channel.joinRef()
        });
      }
      /**
       *
       * @param {*} status
       * @param {*} callback
       */
      receive(status, callback) {
        if (this.hasReceived(status)) {
          callback(this.receivedResp.response);
        }
        this.recHooks.push({ status, callback });
        return this;
      }
      /**
       * @private
       */
      reset() {
        this.cancelRefEvent();
        this.ref = null;
        this.refEvent = null;
        this.receivedResp = null;
        this.sent = false;
      }
      /**
       * @private
       */
      matchReceive({ status, response, _ref }) {
        this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
      }
      /**
       * @private
       */
      cancelRefEvent() {
        if (!this.refEvent) {
          return;
        }
        this.channel.off(this.refEvent);
      }
      /**
       * @private
       */
      cancelTimeout() {
        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = null;
      }
      /**
       * @private
       */
      startTimeout() {
        if (this.timeoutTimer) {
          this.cancelTimeout();
        }
        this.ref = this.channel.socket.makeRef();
        this.refEvent = this.channel.replyEventName(this.ref);
        this.channel.on(this.refEvent, (payload) => {
          this.cancelRefEvent();
          this.cancelTimeout();
          this.receivedResp = payload;
          this.matchReceive(payload);
        });
        this.timeoutTimer = setTimeout(() => {
          this.trigger("timeout", {});
        }, this.timeout);
      }
      /**
       * @private
       */
      hasReceived(status) {
        return this.receivedResp && this.receivedResp.status === status;
      }
      /**
       * @private
       */
      trigger(status, response) {
        this.channel.trigger(this.refEvent, { status, response });
      }
    };
    var Timer = class {
      constructor(callback, timerCalc) {
        this.callback = callback;
        this.timerCalc = timerCalc;
        this.timer = null;
        this.tries = 0;
      }
      reset() {
        this.tries = 0;
        clearTimeout(this.timer);
      }
      /**
       * Cancels any previous scheduleTimeout and schedules callback
       */
      scheduleTimeout() {
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          this.tries = this.tries + 1;
          this.callback();
        }, this.timerCalc(this.tries + 1));
      }
    };
    var Channel = class {
      constructor(topic, params, socket) {
        this.state = CHANNEL_STATES.closed;
        this.topic = topic;
        this.params = closure(params || {});
        this.socket = socket;
        this.bindings = [];
        this.bindingRef = 0;
        this.timeout = this.socket.timeout;
        this.joinedOnce = false;
        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
        this.pushBuffer = [];
        this.stateChangeRefs = [];
        this.rejoinTimer = new Timer(() => {
          if (this.socket.isConnected()) {
            this.rejoin();
          }
        }, this.socket.rejoinAfterMs);
        this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
        this.stateChangeRefs.push(
          this.socket.onOpen(() => {
            this.rejoinTimer.reset();
            if (this.isErrored()) {
              this.rejoin();
            }
          })
        );
        this.joinPush.receive("ok", () => {
          this.state = CHANNEL_STATES.joined;
          this.rejoinTimer.reset();
          this.pushBuffer.forEach((pushEvent) => pushEvent.send());
          this.pushBuffer = [];
        });
        this.joinPush.receive("error", () => {
          this.state = CHANNEL_STATES.errored;
          if (this.socket.isConnected()) {
            this.rejoinTimer.scheduleTimeout();
          }
        });
        this.onClose(() => {
          this.rejoinTimer.reset();
          if (this.socket.hasLogger())
            this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
          this.state = CHANNEL_STATES.closed;
          this.socket.remove(this);
        });
        this.onError((reason) => {
          if (this.socket.hasLogger())
            this.socket.log("channel", `error ${this.topic}`, reason);
          if (this.isJoining()) {
            this.joinPush.reset();
          }
          this.state = CHANNEL_STATES.errored;
          if (this.socket.isConnected()) {
            this.rejoinTimer.scheduleTimeout();
          }
        });
        this.joinPush.receive("timeout", () => {
          if (this.socket.hasLogger())
            this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
          let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
          leavePush.send();
          this.state = CHANNEL_STATES.errored;
          this.joinPush.reset();
          if (this.socket.isConnected()) {
            this.rejoinTimer.scheduleTimeout();
          }
        });
        this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
          this.trigger(this.replyEventName(ref), payload);
        });
      }
      /**
       * Join the channel
       * @param {integer} timeout
       * @returns {Push}
       */
      join(timeout = this.timeout) {
        if (this.joinedOnce) {
          throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
        } else {
          this.timeout = timeout;
          this.joinedOnce = true;
          this.rejoin();
          return this.joinPush;
        }
      }
      /**
       * Hook into channel close
       * @param {Function} callback
       */
      onClose(callback) {
        this.on(CHANNEL_EVENTS.close, callback);
      }
      /**
       * Hook into channel errors
       * @param {Function} callback
       */
      onError(callback) {
        return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
      }
      /**
       * Subscribes on channel events
       *
       * Subscription returns a ref counter, which can be used later to
       * unsubscribe the exact event listener
       *
       * @example
       * const ref1 = channel.on("event", do_stuff)
       * const ref2 = channel.on("event", do_other_stuff)
       * channel.off("event", ref1)
       * // Since unsubscription, do_stuff won't fire,
       * // while do_other_stuff will keep firing on the "event"
       *
       * @param {string} event
       * @param {Function} callback
       * @returns {integer} ref
       */
      on(event2, callback) {
        let ref = this.bindingRef++;
        this.bindings.push({ event: event2, ref, callback });
        return ref;
      }
      /**
       * Unsubscribes off of channel events
       *
       * Use the ref returned from a channel.on() to unsubscribe one
       * handler, or pass nothing for the ref to unsubscribe all
       * handlers for the given event.
       *
       * @example
       * // Unsubscribe the do_stuff handler
       * const ref1 = channel.on("event", do_stuff)
       * channel.off("event", ref1)
       *
       * // Unsubscribe all handlers from event
       * channel.off("event")
       *
       * @param {string} event
       * @param {integer} ref
       */
      off(event2, ref) {
        this.bindings = this.bindings.filter((bind) => {
          return !(bind.event === event2 && (typeof ref === "undefined" || ref === bind.ref));
        });
      }
      /**
       * @private
       */
      canPush() {
        return this.socket.isConnected() && this.isJoined();
      }
      /**
       * Sends a message `event` to phoenix with the payload `payload`.
       * Phoenix receives this in the `handle_in(event, payload, socket)`
       * function. if phoenix replies or it times out (default 10000ms),
       * then optionally the reply can be received.
       *
       * @example
       * channel.push("event")
       *   .receive("ok", payload => console.log("phoenix replied:", payload))
       *   .receive("error", err => console.log("phoenix errored", err))
       *   .receive("timeout", () => console.log("timed out pushing"))
       * @param {string} event
       * @param {Object} payload
       * @param {number} [timeout]
       * @returns {Push}
       */
      push(event2, payload, timeout = this.timeout) {
        payload = payload || {};
        if (!this.joinedOnce) {
          throw new Error(`tried to push '${event2}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
        }
        let pushEvent = new Push(this, event2, function() {
          return payload;
        }, timeout);
        if (this.canPush()) {
          pushEvent.send();
        } else {
          pushEvent.startTimeout();
          this.pushBuffer.push(pushEvent);
        }
        return pushEvent;
      }
      /** Leaves the channel
       *
       * Unsubscribes from server events, and
       * instructs channel to terminate on server
       *
       * Triggers onClose() hooks
       *
       * To receive leave acknowledgements, use the `receive`
       * hook to bind to the server ack, ie:
       *
       * @example
       * channel.leave().receive("ok", () => alert("left!") )
       *
       * @param {integer} timeout
       * @returns {Push}
       */
      leave(timeout = this.timeout) {
        this.rejoinTimer.reset();
        this.joinPush.cancelTimeout();
        this.state = CHANNEL_STATES.leaving;
        let onClose = () => {
          if (this.socket.hasLogger())
            this.socket.log("channel", `leave ${this.topic}`);
          this.trigger(CHANNEL_EVENTS.close, "leave");
        };
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
        leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
        leavePush.send();
        if (!this.canPush()) {
          leavePush.trigger("ok", {});
        }
        return leavePush;
      }
      /**
       * Overridable message hook
       *
       * Receives all events for specialized message handling
       * before dispatching to the channel callbacks.
       *
       * Must return the payload, modified or unmodified
       * @param {string} event
       * @param {Object} payload
       * @param {integer} ref
       * @returns {Object}
       */
      onMessage(_event, payload, _ref) {
        return payload;
      }
      /**
       * @private
       */
      isMember(topic, event2, payload, joinRef) {
        if (this.topic !== topic) {
          return false;
        }
        if (joinRef && joinRef !== this.joinRef()) {
          if (this.socket.hasLogger())
            this.socket.log("channel", "dropping outdated message", { topic, event: event2, payload, joinRef });
          return false;
        } else {
          return true;
        }
      }
      /**
       * @private
       */
      joinRef() {
        return this.joinPush.ref;
      }
      /**
       * @private
       */
      rejoin(timeout = this.timeout) {
        if (this.isLeaving()) {
          return;
        }
        this.socket.leaveOpenTopic(this.topic);
        this.state = CHANNEL_STATES.joining;
        this.joinPush.resend(timeout);
      }
      /**
       * @private
       */
      trigger(event2, payload, ref, joinRef) {
        let handledPayload = this.onMessage(event2, payload, ref, joinRef);
        if (payload && !handledPayload) {
          throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
        }
        let eventBindings = this.bindings.filter((bind) => bind.event === event2);
        for (let i = 0; i < eventBindings.length; i++) {
          let bind = eventBindings[i];
          bind.callback(handledPayload, ref, joinRef || this.joinRef());
        }
      }
      /**
       * @private
       */
      replyEventName(ref) {
        return `chan_reply_${ref}`;
      }
      /**
       * @private
       */
      isClosed() {
        return this.state === CHANNEL_STATES.closed;
      }
      /**
       * @private
       */
      isErrored() {
        return this.state === CHANNEL_STATES.errored;
      }
      /**
       * @private
       */
      isJoined() {
        return this.state === CHANNEL_STATES.joined;
      }
      /**
       * @private
       */
      isJoining() {
        return this.state === CHANNEL_STATES.joining;
      }
      /**
       * @private
       */
      isLeaving() {
        return this.state === CHANNEL_STATES.leaving;
      }
    };
    var Ajax = class {
      static request(method, endPoint, headers, body, timeout, ontimeout, callback) {
        if (global.XDomainRequest) {
          let req = new global.XDomainRequest();
          return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
        } else if (global.XMLHttpRequest) {
          let req = new global.XMLHttpRequest();
          return this.xhrRequest(req, method, endPoint, headers, body, timeout, ontimeout, callback);
        } else if (global.fetch && global.AbortController) {
          return this.fetchRequest(method, endPoint, headers, body, timeout, ontimeout, callback);
        } else {
          throw new Error("No suitable XMLHttpRequest implementation found");
        }
      }
      static fetchRequest(method, endPoint, headers, body, timeout, ontimeout, callback) {
        let options = {
          method,
          headers,
          body
        };
        let controller2 = null;
        if (timeout) {
          controller2 = new AbortController();
          const _timeoutId = setTimeout(() => controller2.abort(), timeout);
          options.signal = controller2.signal;
        }
        global.fetch(endPoint, options).then((response) => response.text()).then((data) => this.parseJSON(data)).then((data) => callback && callback(data)).catch((err) => {
          if (err.name === "AbortError" && ontimeout) {
            ontimeout();
          } else {
            callback && callback(null);
          }
        });
        return controller2;
      }
      static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
        req.timeout = timeout;
        req.open(method, endPoint);
        req.onload = () => {
          let response = this.parseJSON(req.responseText);
          callback && callback(response);
        };
        if (ontimeout) {
          req.ontimeout = ontimeout;
        }
        req.onprogress = () => {
        };
        req.send(body);
        return req;
      }
      static xhrRequest(req, method, endPoint, headers, body, timeout, ontimeout, callback) {
        req.open(method, endPoint, true);
        req.timeout = timeout;
        for (let [key2, value] of Object.entries(headers)) {
          req.setRequestHeader(key2, value);
        }
        req.onerror = () => callback && callback(null);
        req.onreadystatechange = () => {
          if (req.readyState === XHR_STATES.complete && callback) {
            let response = this.parseJSON(req.responseText);
            callback(response);
          }
        };
        if (ontimeout) {
          req.ontimeout = ontimeout;
        }
        req.send(body);
        return req;
      }
      static parseJSON(resp) {
        if (!resp || resp === "") {
          return null;
        }
        try {
          return JSON.parse(resp);
        } catch {
          console && console.log("failed to parse JSON response", resp);
          return null;
        }
      }
      static serialize(obj, parentKey) {
        let queryStr = [];
        for (var key2 in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, key2)) {
            continue;
          }
          let paramKey = parentKey ? `${parentKey}[${key2}]` : key2;
          let paramVal = obj[key2];
          if (typeof paramVal === "object") {
            queryStr.push(this.serialize(paramVal, paramKey));
          } else {
            queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
          }
        }
        return queryStr.join("&");
      }
      static appendParams(url, params) {
        if (Object.keys(params).length === 0) {
          return url;
        }
        let prefix = url.match(/\?/) ? "&" : "?";
        return `${url}${prefix}${this.serialize(params)}`;
      }
    };
    var arrayBufferToBase64 = (buffer) => {
      let binary = "";
      let bytes = new Uint8Array(buffer);
      let len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    };
    var LongPoll = class {
      constructor(endPoint, protocols) {
        if (protocols && protocols.length === 2 && protocols[1].startsWith(AUTH_TOKEN_PREFIX)) {
          this.authToken = atob(protocols[1].slice(AUTH_TOKEN_PREFIX.length));
        }
        this.endPoint = null;
        this.token = null;
        this.skipHeartbeat = true;
        this.reqs = /* @__PURE__ */ new Set();
        this.awaitingBatchAck = false;
        this.currentBatch = null;
        this.currentBatchTimer = null;
        this.batchBuffer = [];
        this.onopen = function() {
        };
        this.onerror = function() {
        };
        this.onmessage = function() {
        };
        this.onclose = function() {
        };
        this.pollEndpoint = this.normalizeEndpoint(endPoint);
        this.readyState = SOCKET_STATES.connecting;
        setTimeout(() => this.poll(), 0);
      }
      normalizeEndpoint(endPoint) {
        return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
      }
      endpointURL() {
        return Ajax.appendParams(this.pollEndpoint, { token: this.token });
      }
      closeAndRetry(code, reason, wasClean) {
        this.close(code, reason, wasClean);
        this.readyState = SOCKET_STATES.connecting;
      }
      ontimeout() {
        this.onerror("timeout");
        this.closeAndRetry(1005, "timeout", false);
      }
      isActive() {
        return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
      }
      poll() {
        const headers = { "Accept": "application/json" };
        if (this.authToken) {
          headers["X-Phoenix-AuthToken"] = this.authToken;
        }
        this.ajax("GET", headers, null, () => this.ontimeout(), (resp) => {
          if (resp) {
            var { status, token, messages } = resp;
            if (status === 410 && this.token !== null) {
              this.onerror(410);
              this.closeAndRetry(3410, "session_gone", false);
              return;
            }
            this.token = token;
          } else {
            status = 0;
          }
          switch (status) {
            case 200:
              messages.forEach((msg) => {
                setTimeout(() => this.onmessage({ data: msg }), 0);
              });
              this.poll();
              break;
            case 204:
              this.poll();
              break;
            case 410:
              this.readyState = SOCKET_STATES.open;
              this.onopen({});
              this.poll();
              break;
            case 403:
              this.onerror(403);
              this.close(1008, "forbidden", false);
              break;
            case 0:
            case 500:
              this.onerror(500);
              this.closeAndRetry(1011, "internal server error", 500);
              break;
            default:
              throw new Error(`unhandled poll status ${status}`);
          }
        });
      }
      // we collect all pushes within the current event loop by
      // setTimeout 0, which optimizes back-to-back procedural
      // pushes against an empty buffer
      send(body) {
        if (typeof body !== "string") {
          body = arrayBufferToBase64(body);
        }
        if (this.currentBatch) {
          this.currentBatch.push(body);
        } else if (this.awaitingBatchAck) {
          this.batchBuffer.push(body);
        } else {
          this.currentBatch = [body];
          this.currentBatchTimer = setTimeout(() => {
            this.batchSend(this.currentBatch);
            this.currentBatch = null;
          }, 0);
        }
      }
      batchSend(messages) {
        this.awaitingBatchAck = true;
        this.ajax("POST", { "Content-Type": "application/x-ndjson" }, messages.join("\n"), () => this.onerror("timeout"), (resp) => {
          this.awaitingBatchAck = false;
          if (!resp || resp.status !== 200) {
            this.onerror(resp && resp.status);
            this.closeAndRetry(1011, "internal server error", false);
          } else if (this.batchBuffer.length > 0) {
            this.batchSend(this.batchBuffer);
            this.batchBuffer = [];
          }
        });
      }
      close(code, reason, wasClean) {
        for (let req of this.reqs) {
          req.abort();
        }
        this.readyState = SOCKET_STATES.closed;
        let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
        this.batchBuffer = [];
        clearTimeout(this.currentBatchTimer);
        this.currentBatchTimer = null;
        if (typeof CloseEvent !== "undefined") {
          this.onclose(new CloseEvent("close", opts));
        } else {
          this.onclose(opts);
        }
      }
      ajax(method, headers, body, onCallerTimeout, callback) {
        let req;
        let ontimeout = () => {
          this.reqs.delete(req);
          onCallerTimeout();
        };
        req = Ajax.request(method, this.endpointURL(), headers, body, this.timeout, ontimeout, (resp) => {
          this.reqs.delete(req);
          if (this.isActive()) {
            callback(resp);
          }
        });
        this.reqs.add(req);
      }
    };
    var Presence = class {
      constructor(channel, opts = {}) {
        let events = opts.events || { state: "presence_state", diff: "presence_diff" };
        this.state = {};
        this.pendingDiffs = [];
        this.channel = channel;
        this.joinRef = null;
        this.caller = {
          onJoin: function() {
          },
          onLeave: function() {
          },
          onSync: function() {
          }
        };
        this.channel.on(events.state, (newState) => {
          let { onJoin, onLeave, onSync } = this.caller;
          this.joinRef = this.channel.joinRef();
          this.state = Presence.syncState(this.state, newState, onJoin, onLeave);
          this.pendingDiffs.forEach((diff) => {
            this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);
          });
          this.pendingDiffs = [];
          onSync();
        });
        this.channel.on(events.diff, (diff) => {
          let { onJoin, onLeave, onSync } = this.caller;
          if (this.inPendingSyncState()) {
            this.pendingDiffs.push(diff);
          } else {
            this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);
            onSync();
          }
        });
      }
      onJoin(callback) {
        this.caller.onJoin = callback;
      }
      onLeave(callback) {
        this.caller.onLeave = callback;
      }
      onSync(callback) {
        this.caller.onSync = callback;
      }
      list(by) {
        return Presence.list(this.state, by);
      }
      inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel.joinRef();
      }
      // lower-level public static API
      /**
       * Used to sync the list of presences on the server
       * with the client's state. An optional `onJoin` and `onLeave` callback can
       * be provided to react to changes in the client's local presences across
       * disconnects and reconnects with the server.
       *
       * @returns {Presence}
       */
      static syncState(currentState, newState, onJoin, onLeave) {
        let state2 = this.clone(currentState);
        let joins = {};
        let leaves = {};
        this.map(state2, (key2, presence) => {
          if (!newState[key2]) {
            leaves[key2] = presence;
          }
        });
        this.map(newState, (key2, newPresence) => {
          let currentPresence = state2[key2];
          if (currentPresence) {
            let newRefs = newPresence.metas.map((m) => m.phx_ref);
            let curRefs = currentPresence.metas.map((m) => m.phx_ref);
            let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);
            let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);
            if (joinedMetas.length > 0) {
              joins[key2] = newPresence;
              joins[key2].metas = joinedMetas;
            }
            if (leftMetas.length > 0) {
              leaves[key2] = this.clone(currentPresence);
              leaves[key2].metas = leftMetas;
            }
          } else {
            joins[key2] = newPresence;
          }
        });
        return this.syncDiff(state2, { joins, leaves }, onJoin, onLeave);
      }
      /**
       *
       * Used to sync a diff of presence join and leave
       * events from the server, as they happen. Like `syncState`, `syncDiff`
       * accepts optional `onJoin` and `onLeave` callbacks to react to a user
       * joining or leaving from a device.
       *
       * @returns {Presence}
       */
      static syncDiff(state2, diff, onJoin, onLeave) {
        let { joins, leaves } = this.clone(diff);
        if (!onJoin) {
          onJoin = function() {
          };
        }
        if (!onLeave) {
          onLeave = function() {
          };
        }
        this.map(joins, (key2, newPresence) => {
          let currentPresence = state2[key2];
          state2[key2] = this.clone(newPresence);
          if (currentPresence) {
            let joinedRefs = state2[key2].metas.map((m) => m.phx_ref);
            let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);
            state2[key2].metas.unshift(...curMetas);
          }
          onJoin(key2, currentPresence, newPresence);
        });
        this.map(leaves, (key2, leftPresence) => {
          let currentPresence = state2[key2];
          if (!currentPresence) {
            return;
          }
          let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);
          currentPresence.metas = currentPresence.metas.filter((p) => {
            return refsToRemove.indexOf(p.phx_ref) < 0;
          });
          onLeave(key2, currentPresence, leftPresence);
          if (currentPresence.metas.length === 0) {
            delete state2[key2];
          }
        });
        return state2;
      }
      /**
       * Returns the array of presences, with selected metadata.
       *
       * @param {Object} presences
       * @param {Function} chooser
       *
       * @returns {Presence}
       */
      static list(presences, chooser) {
        if (!chooser) {
          chooser = function(key2, pres) {
            return pres;
          };
        }
        return this.map(presences, (key2, presence) => {
          return chooser(key2, presence);
        });
      }
      // private
      static map(obj, func) {
        return Object.getOwnPropertyNames(obj).map((key2) => func(key2, obj[key2]));
      }
      static clone(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
    };
    var serializer_default = {
      HEADER_LENGTH: 1,
      META_LENGTH: 4,
      KINDS: { push: 0, reply: 1, broadcast: 2 },
      encode(msg, callback) {
        if (msg.payload.constructor === ArrayBuffer) {
          return callback(this.binaryEncode(msg));
        } else {
          let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
          return callback(JSON.stringify(payload));
        }
      },
      decode(rawPayload, callback) {
        if (rawPayload.constructor === ArrayBuffer) {
          return callback(this.binaryDecode(rawPayload));
        } else {
          let [join_ref, ref, topic, event2, payload] = JSON.parse(rawPayload);
          return callback({ join_ref, ref, topic, event: event2, payload });
        }
      },
      // private
      binaryEncode(message) {
        let { join_ref, ref, event: event2, topic, payload } = message;
        let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event2.length;
        let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
        let view = new DataView(header);
        let offset = 0;
        view.setUint8(offset++, this.KINDS.push);
        view.setUint8(offset++, join_ref.length);
        view.setUint8(offset++, ref.length);
        view.setUint8(offset++, topic.length);
        view.setUint8(offset++, event2.length);
        Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        Array.from(event2, (char) => view.setUint8(offset++, char.charCodeAt(0)));
        var combined = new Uint8Array(header.byteLength + payload.byteLength);
        combined.set(new Uint8Array(header), 0);
        combined.set(new Uint8Array(payload), header.byteLength);
        return combined.buffer;
      },
      binaryDecode(buffer) {
        let view = new DataView(buffer);
        let kind = view.getUint8(0);
        let decoder = new TextDecoder();
        switch (kind) {
          case this.KINDS.push:
            return this.decodePush(buffer, view, decoder);
          case this.KINDS.reply:
            return this.decodeReply(buffer, view, decoder);
          case this.KINDS.broadcast:
            return this.decodeBroadcast(buffer, view, decoder);
        }
      },
      decodePush(buffer, view, decoder) {
        let joinRefSize = view.getUint8(1);
        let topicSize = view.getUint8(2);
        let eventSize = view.getUint8(3);
        let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
        let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
        offset = offset + joinRefSize;
        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        let event2 = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        let data = buffer.slice(offset, buffer.byteLength);
        return { join_ref: joinRef, ref: null, topic, event: event2, payload: data };
      },
      decodeReply(buffer, view, decoder) {
        let joinRefSize = view.getUint8(1);
        let refSize = view.getUint8(2);
        let topicSize = view.getUint8(3);
        let eventSize = view.getUint8(4);
        let offset = this.HEADER_LENGTH + this.META_LENGTH;
        let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
        offset = offset + joinRefSize;
        let ref = decoder.decode(buffer.slice(offset, offset + refSize));
        offset = offset + refSize;
        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        let event2 = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        let data = buffer.slice(offset, buffer.byteLength);
        let payload = { status: event2, response: data };
        return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
      },
      decodeBroadcast(buffer, view, decoder) {
        let topicSize = view.getUint8(1);
        let eventSize = view.getUint8(2);
        let offset = this.HEADER_LENGTH + 2;
        let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
        offset = offset + topicSize;
        let event2 = decoder.decode(buffer.slice(offset, offset + eventSize));
        offset = offset + eventSize;
        let data = buffer.slice(offset, buffer.byteLength);
        return { join_ref: null, ref: null, topic, event: event2, payload: data };
      }
    };
    var Socket2 = class {
      constructor(endPoint, opts = {}) {
        this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
        this.channels = [];
        this.sendBuffer = [];
        this.ref = 0;
        this.fallbackRef = null;
        this.timeout = opts.timeout || DEFAULT_TIMEOUT;
        this.transport = opts.transport || global.WebSocket || LongPoll;
        this.primaryPassedHealthCheck = false;
        this.longPollFallbackMs = opts.longPollFallbackMs;
        this.fallbackTimer = null;
        this.sessionStore = opts.sessionStorage || global && global.sessionStorage;
        this.establishedConnections = 0;
        this.defaultEncoder = serializer_default.encode.bind(serializer_default);
        this.defaultDecoder = serializer_default.decode.bind(serializer_default);
        this.closeWasClean = false;
        this.disconnecting = false;
        this.binaryType = opts.binaryType || "arraybuffer";
        this.connectClock = 1;
        this.pageHidden = false;
        if (this.transport !== LongPoll) {
          this.encode = opts.encode || this.defaultEncoder;
          this.decode = opts.decode || this.defaultDecoder;
        } else {
          this.encode = this.defaultEncoder;
          this.decode = this.defaultDecoder;
        }
        let awaitingConnectionOnPageShow = null;
        if (phxWindow && phxWindow.addEventListener) {
          phxWindow.addEventListener("pagehide", (_e) => {
            if (this.conn) {
              this.disconnect();
              awaitingConnectionOnPageShow = this.connectClock;
            }
          });
          phxWindow.addEventListener("pageshow", (_e) => {
            if (awaitingConnectionOnPageShow === this.connectClock) {
              awaitingConnectionOnPageShow = null;
              this.connect();
            }
          });
          phxWindow.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "hidden") {
              this.pageHidden = true;
            } else {
              this.pageHidden = false;
              if (!this.isConnected()) {
                this.teardown(() => this.connect());
              }
            }
          });
        }
        this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
        this.rejoinAfterMs = (tries) => {
          if (opts.rejoinAfterMs) {
            return opts.rejoinAfterMs(tries);
          } else {
            return [1e3, 2e3, 5e3][tries - 1] || 1e4;
          }
        };
        this.reconnectAfterMs = (tries) => {
          if (opts.reconnectAfterMs) {
            return opts.reconnectAfterMs(tries);
          } else {
            return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
          }
        };
        this.logger = opts.logger || null;
        if (!this.logger && opts.debug) {
          this.logger = (kind, msg, data) => {
            console.log(`${kind}: ${msg}`, data);
          };
        }
        this.longpollerTimeout = opts.longpollerTimeout || 2e4;
        this.params = closure(opts.params || {});
        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
        this.vsn = opts.vsn || DEFAULT_VSN;
        this.heartbeatTimeoutTimer = null;
        this.heartbeatTimer = null;
        this.pendingHeartbeatRef = null;
        this.reconnectTimer = new Timer(() => {
          if (this.pageHidden) {
            this.log("Not reconnecting as page is hidden!");
            this.teardown();
            return;
          }
          this.teardown(() => this.connect());
        }, this.reconnectAfterMs);
        this.authToken = opts.authToken;
      }
      /**
       * Returns the LongPoll transport reference
       */
      getLongPollTransport() {
        return LongPoll;
      }
      /**
       * Disconnects and replaces the active transport
       *
       * @param {Function} newTransport - The new transport class to instantiate
       *
       */
      replaceTransport(newTransport) {
        this.connectClock++;
        this.closeWasClean = true;
        clearTimeout(this.fallbackTimer);
        this.reconnectTimer.reset();
        if (this.conn) {
          this.conn.close();
          this.conn = null;
        }
        this.transport = newTransport;
      }
      /**
       * Returns the socket protocol
       *
       * @returns {string}
       */
      protocol() {
        return location.protocol.match(/^https/) ? "wss" : "ws";
      }
      /**
       * The fully qualified socket url
       *
       * @returns {string}
       */
      endPointURL() {
        let uri = Ajax.appendParams(
          Ajax.appendParams(this.endPoint, this.params()),
          { vsn: this.vsn }
        );
        if (uri.charAt(0) !== "/") {
          return uri;
        }
        if (uri.charAt(1) === "/") {
          return `${this.protocol()}:${uri}`;
        }
        return `${this.protocol()}://${location.host}${uri}`;
      }
      /**
       * Disconnects the socket
       *
       * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
       *
       * @param {Function} callback - Optional callback which is called after socket is disconnected.
       * @param {integer} code - A status code for disconnection (Optional).
       * @param {string} reason - A textual description of the reason to disconnect. (Optional)
       */
      disconnect(callback, code, reason) {
        this.connectClock++;
        this.disconnecting = true;
        this.closeWasClean = true;
        clearTimeout(this.fallbackTimer);
        this.reconnectTimer.reset();
        this.teardown(() => {
          this.disconnecting = false;
          callback && callback();
        }, code, reason);
      }
      /**
       *
       * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
       *
       * Passing params to connect is deprecated; pass them in the Socket constructor instead:
       * `new Socket("/socket", {params: {user_id: userToken}})`.
       */
      connect(params) {
        if (params) {
          console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
          this.params = closure(params);
        }
        if (this.conn && !this.disconnecting) {
          return;
        }
        if (this.longPollFallbackMs && this.transport !== LongPoll) {
          this.connectWithFallback(LongPoll, this.longPollFallbackMs);
        } else {
          this.transportConnect();
        }
      }
      /**
       * Logs the message. Override `this.logger` for specialized logging. noops by default
       * @param {string} kind
       * @param {string} msg
       * @param {Object} data
       */
      log(kind, msg, data) {
        this.logger && this.logger(kind, msg, data);
      }
      /**
       * Returns true if a logger has been set on this socket.
       */
      hasLogger() {
        return this.logger !== null;
      }
      /**
       * Registers callbacks for connection open events
       *
       * @example socket.onOpen(function(){ console.info("the socket was opened") })
       *
       * @param {Function} callback
       */
      onOpen(callback) {
        let ref = this.makeRef();
        this.stateChangeCallbacks.open.push([ref, callback]);
        return ref;
      }
      /**
       * Registers callbacks for connection close events
       * @param {Function} callback
       */
      onClose(callback) {
        let ref = this.makeRef();
        this.stateChangeCallbacks.close.push([ref, callback]);
        return ref;
      }
      /**
       * Registers callbacks for connection error events
       *
       * @example socket.onError(function(error){ alert("An error occurred") })
       *
       * @param {Function} callback
       */
      onError(callback) {
        let ref = this.makeRef();
        this.stateChangeCallbacks.error.push([ref, callback]);
        return ref;
      }
      /**
       * Registers callbacks for connection message events
       * @param {Function} callback
       */
      onMessage(callback) {
        let ref = this.makeRef();
        this.stateChangeCallbacks.message.push([ref, callback]);
        return ref;
      }
      /**
       * Pings the server and invokes the callback with the RTT in milliseconds
       * @param {Function} callback
       *
       * Returns true if the ping was pushed or false if unable to be pushed.
       */
      ping(callback) {
        if (!this.isConnected()) {
          return false;
        }
        let ref = this.makeRef();
        let startTime = Date.now();
        this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
        let onMsgRef = this.onMessage((msg) => {
          if (msg.ref === ref) {
            this.off([onMsgRef]);
            callback(Date.now() - startTime);
          }
        });
        return true;
      }
      /**
       * @private
       */
      transportConnect() {
        this.connectClock++;
        this.closeWasClean = false;
        let protocols = void 0;
        if (this.authToken) {
          protocols = ["phoenix", `${AUTH_TOKEN_PREFIX}${btoa(this.authToken).replace(/=/g, "")}`];
        }
        this.conn = new this.transport(this.endPointURL(), protocols);
        this.conn.binaryType = this.binaryType;
        this.conn.timeout = this.longpollerTimeout;
        this.conn.onopen = () => this.onConnOpen();
        this.conn.onerror = (error) => this.onConnError(error);
        this.conn.onmessage = (event2) => this.onConnMessage(event2);
        this.conn.onclose = (event2) => this.onConnClose(event2);
      }
      getSession(key2) {
        return this.sessionStore && this.sessionStore.getItem(key2);
      }
      storeSession(key2, val) {
        this.sessionStore && this.sessionStore.setItem(key2, val);
      }
      connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {
        clearTimeout(this.fallbackTimer);
        let established = false;
        let primaryTransport = true;
        let openRef, errorRef;
        let fallback2 = (reason) => {
          this.log("transport", `falling back to ${fallbackTransport.name}...`, reason);
          this.off([openRef, errorRef]);
          primaryTransport = false;
          this.replaceTransport(fallbackTransport);
          this.transportConnect();
        };
        if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {
          return fallback2("memorized");
        }
        this.fallbackTimer = setTimeout(fallback2, fallbackThreshold);
        errorRef = this.onError((reason) => {
          this.log("transport", "error", reason);
          if (primaryTransport && !established) {
            clearTimeout(this.fallbackTimer);
            fallback2(reason);
          }
        });
        if (this.fallbackRef) {
          this.off([this.fallbackRef]);
        }
        this.fallbackRef = this.onOpen(() => {
          established = true;
          if (!primaryTransport) {
            if (!this.primaryPassedHealthCheck) {
              this.storeSession(`phx:fallback:${fallbackTransport.name}`, "true");
            }
            return this.log("transport", `established ${fallbackTransport.name} fallback`);
          }
          clearTimeout(this.fallbackTimer);
          this.fallbackTimer = setTimeout(fallback2, fallbackThreshold);
          this.ping((rtt) => {
            this.log("transport", "connected to primary after", rtt);
            this.primaryPassedHealthCheck = true;
            clearTimeout(this.fallbackTimer);
          });
        });
        this.transportConnect();
      }
      clearHeartbeats() {
        clearTimeout(this.heartbeatTimer);
        clearTimeout(this.heartbeatTimeoutTimer);
      }
      onConnOpen() {
        if (this.hasLogger())
          this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`);
        this.closeWasClean = false;
        this.disconnecting = false;
        this.establishedConnections++;
        this.flushSendBuffer();
        this.reconnectTimer.reset();
        this.resetHeartbeat();
        this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
      }
      /**
       * @private
       */
      heartbeatTimeout() {
        if (this.pendingHeartbeatRef) {
          this.pendingHeartbeatRef = null;
          if (this.hasLogger()) {
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
          }
          this.triggerChanError();
          this.closeWasClean = false;
          this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
        }
      }
      resetHeartbeat() {
        if (this.conn && this.conn.skipHeartbeat) {
          return;
        }
        this.pendingHeartbeatRef = null;
        this.clearHeartbeats();
        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
      }
      teardown(callback, code, reason) {
        if (!this.conn) {
          return callback && callback();
        }
        let connectClock = this.connectClock;
        this.waitForBufferDone(() => {
          if (connectClock !== this.connectClock) {
            return;
          }
          if (this.conn) {
            if (code) {
              this.conn.close(code, reason || "");
            } else {
              this.conn.close();
            }
          }
          this.waitForSocketClosed(() => {
            if (connectClock !== this.connectClock) {
              return;
            }
            if (this.conn) {
              this.conn.onopen = function() {
              };
              this.conn.onerror = function() {
              };
              this.conn.onmessage = function() {
              };
              this.conn.onclose = function() {
              };
              this.conn = null;
            }
            callback && callback();
          });
        });
      }
      waitForBufferDone(callback, tries = 1) {
        if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
          callback();
          return;
        }
        setTimeout(() => {
          this.waitForBufferDone(callback, tries + 1);
        }, 150 * tries);
      }
      waitForSocketClosed(callback, tries = 1) {
        if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
          callback();
          return;
        }
        setTimeout(() => {
          this.waitForSocketClosed(callback, tries + 1);
        }, 150 * tries);
      }
      onConnClose(event2) {
        if (this.conn)
          this.conn.onclose = () => {
          };
        let closeCode = event2 && event2.code;
        if (this.hasLogger())
          this.log("transport", "close", event2);
        this.triggerChanError();
        this.clearHeartbeats();
        if (!this.closeWasClean && closeCode !== 1e3) {
          this.reconnectTimer.scheduleTimeout();
        }
        this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event2));
      }
      /**
       * @private
       */
      onConnError(error) {
        if (this.hasLogger())
          this.log("transport", error);
        let transportBefore = this.transport;
        let establishedBefore = this.establishedConnections;
        this.stateChangeCallbacks.error.forEach(([, callback]) => {
          callback(error, transportBefore, establishedBefore);
        });
        if (transportBefore === this.transport || establishedBefore > 0) {
          this.triggerChanError();
        }
      }
      /**
       * @private
       */
      triggerChanError() {
        this.channels.forEach((channel) => {
          if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
            channel.trigger(CHANNEL_EVENTS.error);
          }
        });
      }
      /**
       * @returns {string}
       */
      connectionState() {
        switch (this.conn && this.conn.readyState) {
          case SOCKET_STATES.connecting:
            return "connecting";
          case SOCKET_STATES.open:
            return "open";
          case SOCKET_STATES.closing:
            return "closing";
          default:
            return "closed";
        }
      }
      /**
       * @returns {boolean}
       */
      isConnected() {
        return this.connectionState() === "open";
      }
      /**
       * @private
       *
       * @param {Channel}
       */
      remove(channel) {
        this.off(channel.stateChangeRefs);
        this.channels = this.channels.filter((c) => c !== channel);
      }
      /**
       * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
       *
       * @param {refs} - list of refs returned by calls to
       *                 `onOpen`, `onClose`, `onError,` and `onMessage`
       */
      off(refs) {
        for (let key2 in this.stateChangeCallbacks) {
          this.stateChangeCallbacks[key2] = this.stateChangeCallbacks[key2].filter(([ref]) => {
            return refs.indexOf(ref) === -1;
          });
        }
      }
      /**
       * Initiates a new channel for the given topic
       *
       * @param {string} topic
       * @param {Object} chanParams - Parameters for the channel
       * @returns {Channel}
       */
      channel(topic, chanParams = {}) {
        let chan = new Channel(topic, chanParams, this);
        this.channels.push(chan);
        return chan;
      }
      /**
       * @param {Object} data
       */
      push(data) {
        if (this.hasLogger()) {
          let { topic, event: event2, payload, ref, join_ref } = data;
          this.log("push", `${topic} ${event2} (${join_ref}, ${ref})`, payload);
        }
        if (this.isConnected()) {
          this.encode(data, (result) => this.conn.send(result));
        } else {
          this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
        }
      }
      /**
       * Return the next message ref, accounting for overflows
       * @returns {string}
       */
      makeRef() {
        let newRef = this.ref + 1;
        if (newRef === this.ref) {
          this.ref = 0;
        } else {
          this.ref = newRef;
        }
        return this.ref.toString();
      }
      sendHeartbeat() {
        if (this.pendingHeartbeatRef && !this.isConnected()) {
          return;
        }
        this.pendingHeartbeatRef = this.makeRef();
        this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
        this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
      }
      flushSendBuffer() {
        if (this.isConnected() && this.sendBuffer.length > 0) {
          this.sendBuffer.forEach((callback) => callback());
          this.sendBuffer = [];
        }
      }
      onConnMessage(rawMessage) {
        this.decode(rawMessage.data, (msg) => {
          let { topic, event: event2, payload, ref, join_ref } = msg;
          if (ref && ref === this.pendingHeartbeatRef) {
            this.clearHeartbeats();
            this.pendingHeartbeatRef = null;
            this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
          }
          if (this.hasLogger())
            this.log("receive", `${payload.status || ""} ${topic} ${event2} ${ref && "(" + ref + ")" || ""}`, payload);
          for (let i = 0; i < this.channels.length; i++) {
            const channel = this.channels[i];
            if (!channel.isMember(topic, event2, payload, join_ref)) {
              continue;
            }
            channel.trigger(event2, payload, ref, join_ref);
          }
          for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
            let [, callback] = this.stateChangeCallbacks.message[i];
            callback(msg);
          }
        });
      }
      leaveOpenTopic(topic) {
        let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
        if (dupChannel) {
          if (this.hasLogger())
            this.log("transport", `leaving duplicate topic "${topic}"`);
          dupChannel.leave();
        }
      }
    };
  }
});

// node_modules/svelte/src/server/index.js
var server_exports2 = {};
__export(server_exports2, {
  render: () => render
});
var init_server2 = __esm({
  "node_modules/svelte/src/server/index.js"() {
    init_server();
  }
});

// ../deps/live_svelte/priv/static/live_svelte.cjs.js
var require_live_svelte_cjs = __commonJS({
  "../deps/live_svelte/priv/static/live_svelte.cjs.js"(exports2, module2) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var live_svelte_exports = {};
    __export2(live_svelte_exports, {
      getHooks: () => getHooks,
      getRender: () => getRender2
    });
    module2.exports = __toCommonJS2(live_svelte_exports);
    function normalizeComponents(components) {
      if (!Array.isArray(components.default) || !Array.isArray(components.filenames)) return components;
      const normalized = {};
      for (const [index2, module22] of components.default.entries()) {
        const Component = module22.default;
        const name = components.filenames[index2].replace("../svelte/", "").replace(".svelte", "");
        normalized[name] = Component;
      }
      return normalized;
    }
    var import_server2 = (init_server2(), __toCommonJS(server_exports2));
    var import_svelte3 = (init_index_server(), __toCommonJS(index_server_exports));
    function getRender2(components) {
      components = normalizeComponents(components);
      return function r2(name, props, slots) {
        const snippets = Object.fromEntries(
          Object.entries(slots).map(([slotName, v]) => {
            const snippet2 = (0, import_svelte3.createRawSnippet)((name2) => {
              return {
                render: () => v
              };
            });
            if (slotName === "default") return ["children", snippet2];
            else return [slotName, snippet2];
          })
        );
        return (0, import_server2.render)(components[name], { props: { ...props, ...snippets } });
      };
    }
    var $ = __toESM2((init_client(), __toCommonJS(client_exports)));
    var import_svelte22 = (init_index_server(), __toCommonJS(index_server_exports));
    function getAttributeJson(ref, attributeName) {
      const data = ref.el.getAttribute(attributeName);
      return data ? JSON.parse(data) : {};
    }
    function getSlots(ref) {
      let snippets = {};
      for (const slotName in getAttributeJson(ref, "data-slots")) {
        const base64 = getAttributeJson(ref, "data-slots")[slotName];
        const element3 = document.createElement("div");
        element3.innerHTML = atob(base64).trim();
        const snippet2 = (0, import_svelte22.createRawSnippet)((name) => {
          return { render: () => element3.outerHTML };
        });
        if (slotName === "default") snippets["children"] = snippet2;
        else snippets[slotName] = snippet2;
      }
      return snippets;
    }
    function getLiveJsonProps(ref) {
      const json = getAttributeJson(ref, "data-live-json");
      if (!Array.isArray(json)) return json;
      const liveJsonData = {};
      for (const liveJsonVariable of json) {
        const data = window[liveJsonVariable];
        if (data) liveJsonData[liveJsonVariable] = data;
      }
      return liveJsonData;
    }
    function getProps(ref) {
      return {
        ...getAttributeJson(ref, "data-props"),
        ...getLiveJsonProps(ref),
        ...getSlots(ref),
        live: ref
      };
    }
    function update_state(ref) {
      const newProps = getProps(ref);
      for (const key2 in newProps) {
        ref._instance.state[key2] = newProps[key2];
      }
    }
    function getHooks(components) {
      components = normalizeComponents(components);
      const SvelteHook = {
        mounted() {
          let state2 = $.proxy(getProps(this));
          const componentName = this.el.getAttribute("data-name");
          if (!componentName) throw new Error("Component name must be provided");
          const Component = components[componentName];
          if (!Component) throw new Error(`Unable to find ${componentName} component.`);
          for (const liveJsonElement of Object.keys(getAttributeJson(this, "data-live-json"))) {
            window.addEventListener(`${liveJsonElement}_initialized`, (_event) => update_state(this), false);
            window.addEventListener(`${liveJsonElement}_patched`, (_event) => update_state(this), false);
          }
          if (!this.el.hasAttribute("data-ssr")) {
            this.el.innerHTML = "";
          }
          const hydrateOrMount = this.el.hasAttribute("data-ssr") ? import_svelte22.hydrate : import_svelte22.mount;
          this._instance = hydrateOrMount(Component, { target: this.el, props: state2 });
          this._instance.state = state2;
        },
        updated() {
          update_state(this);
        },
        destroyed() {
          if (this._instance) window.addEventListener("phx:page-loading-stop", () => (0, import_svelte22.unmount)(this._instance), { once: true });
        }
      };
      return { SvelteHook };
    }
  }
});

// js/server.js
var server_exports3 = {};
__export(server_exports3, {
  render: () => render2
});
module.exports = __toCommonJS(server_exports3);

// import-glob:../svelte/**/*.svelte
var __exports = {};
__export(__exports, {
  default: () => __default,
  filenames: () => filenames
});

// svelte/AuthModal.svelte
var AuthModal_exports = {};
__export(AuthModal_exports, {
  default: () => AuthModal_default
});
init_server();

// node_modules/lucide-svelte/dist/Icon.svelte
init_server();

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
Icon[FILENAME] = "node_modules/lucide-svelte/dist/Icon.svelte";
function Icon($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  const $$restProps = rest_props2($$sanitized_props, [
    "name",
    "color",
    "size",
    "strokeWidth",
    "absoluteStrokeWidth",
    "iconNode"
  ]);
  $$renderer.component(
    ($$renderer2) => {
      let name = fallback($$props["name"], void 0);
      let color = fallback($$props["color"], "currentColor");
      let size = fallback($$props["size"], 24);
      let strokeWidth = fallback($$props["strokeWidth"], 2);
      let absoluteStrokeWidth = fallback($$props["absoluteStrokeWidth"], false);
      let iconNode = fallback($$props["iconNode"], () => [], true);
      const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
        return Boolean(className) && array.indexOf(className) === index2;
      }).join(" ");
      $$renderer2.push(`<svg${attributes(
        {
          ...defaultAttributes_default,
          ...$$restProps,
          width: size,
          height: size,
          stroke: color,
          "stroke-width": absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
          class: clsx2(mergeClasses("lucide-icon", "lucide", name ? `lucide-${name}` : "", $$sanitized_props.class))
        },
        void 0,
        void 0,
        void 0,
        3
      )}>`);
      push_element($$renderer2, "svg", 14, 0);
      $$renderer2.push(`<!--[-->`);
      const each_array = ensure_array_like(iconNode);
      for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
        let [tag2, attrs] = each_array[$$index];
        validate_dynamic_element_tag(() => tag2);
        push_element($$renderer2, tag2, 35, 4);
        element2($$renderer2, tag2, () => {
          $$renderer2.push(`${attributes({ ...attrs }, void 0, void 0, void 0, 3)}`);
        });
        pop_element();
      }
      $$renderer2.push(`<!--]--><!--[-->`);
      slot2($$renderer2, $$props, "default", {}, null);
      $$renderer2.push(`<!--]--></svg>`);
      pop_element();
      bind_props($$props, {
        name,
        color,
        size,
        strokeWidth,
        absoluteStrokeWidth,
        iconNode
      });
    },
    Icon
  );
}
Icon.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/icons/book-open.svelte
init_server();
Book_open[FILENAME] = "node_modules/lucide-svelte/dist/icons/book-open.svelte";
function Book_open($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        ["path", { "d": "M12 7v14" }],
        [
          "path",
          {
            "d": "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"
          }
        ]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "book-open" },
        $$sanitized_props,
        {
          /**
           * @component @name BookOpen
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTIgN3YxNCIgLz4KICA8cGF0aCBkPSJNMyAxOGExIDEgMCAwIDEtMS0xVjRhMSAxIDAgMCAxIDEtMWg1YTQgNCAwIDAgMSA0IDQgNCA0IDAgMCAxIDQtNGg1YTEgMSAwIDAgMSAxIDF2MTNhMSAxIDAgMCAxLTEgMWgtNmEzIDMgMCAwIDAtMyAzIDMgMyAwIDAgMC0zLTN6IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/book-open
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    Book_open
  );
}
Book_open.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var book_open_default = Book_open;

// node_modules/lucide-svelte/dist/icons/bookmark.svelte
init_server();
Bookmark[FILENAME] = "node_modules/lucide-svelte/dist/icons/bookmark.svelte";
function Bookmark($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        [
          "path",
          { "d": "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z" }
        ]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "bookmark" },
        $$sanitized_props,
        {
          /**
           * @component @name Bookmark
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTkgMjEtNy00LTcgNFY1YTIgMiAwIDAgMSAyLTJoMTBhMiAyIDAgMCAxIDIgMnYxNnoiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/bookmark
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    Bookmark
  );
}
Bookmark.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var bookmark_default = Bookmark;

// node_modules/lucide-svelte/dist/icons/eye-off.svelte
init_server();
Eye_off[FILENAME] = "node_modules/lucide-svelte/dist/icons/eye-off.svelte";
function Eye_off($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        [
          "path",
          {
            "d": "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49"
          }
        ],
        ["path", { "d": "M14.084 14.158a3 3 0 0 1-4.242-4.242" }],
        [
          "path",
          {
            "d": "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143"
          }
        ],
        ["path", { "d": "m2 2 20 20" }]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "eye-off" },
        $$sanitized_props,
        {
          /**
           * @component @name EyeOff
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTAuNzMzIDUuMDc2YTEwLjc0NCAxMC43NDQgMCAwIDEgMTEuMjA1IDYuNTc1IDEgMSAwIDAgMSAwIC42OTYgMTAuNzQ3IDEwLjc0NyAwIDAgMS0xLjQ0NCAyLjQ5IiAvPgogIDxwYXRoIGQ9Ik0xNC4wODQgMTQuMTU4YTMgMyAwIDAgMS00LjI0Mi00LjI0MiIgLz4KICA8cGF0aCBkPSJNMTcuNDc5IDE3LjQ5OWExMC43NSAxMC43NSAwIDAgMS0xNS40MTctNS4xNTEgMSAxIDAgMCAxIDAtLjY5NiAxMC43NSAxMC43NSAwIDAgMSA0LjQ0Ni01LjE0MyIgLz4KICA8cGF0aCBkPSJtMiAyIDIwIDIwIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/eye-off
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    Eye_off
  );
}
Eye_off.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var eye_off_default = Eye_off;

// node_modules/lucide-svelte/dist/icons/eye.svelte
init_server();
Eye[FILENAME] = "node_modules/lucide-svelte/dist/icons/eye.svelte";
function Eye($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        [
          "path",
          {
            "d": "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"
          }
        ],
        ["circle", { "cx": "12", "cy": "12", "r": "3" }]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "eye" },
        $$sanitized_props,
        {
          /**
           * @component @name Eye
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMi4wNjIgMTIuMzQ4YTEgMSAwIDAgMSAwLS42OTYgMTAuNzUgMTAuNzUgMCAwIDEgMTkuODc2IDAgMSAxIDAgMCAxIDAgLjY5NiAxMC43NSAxMC43NSAwIDAgMS0xOS44NzYgMCIgLz4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIzIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/eye
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    Eye
  );
}
Eye.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var eye_default = Eye;

// node_modules/lucide-svelte/dist/icons/layout-dashboard.svelte
init_server();
Layout_dashboard[FILENAME] = "node_modules/lucide-svelte/dist/icons/layout-dashboard.svelte";
function Layout_dashboard($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        [
          "rect",
          { "width": "7", "height": "9", "x": "3", "y": "3", "rx": "1" }
        ],
        [
          "rect",
          { "width": "7", "height": "5", "x": "14", "y": "3", "rx": "1" }
        ],
        [
          "rect",
          { "width": "7", "height": "9", "x": "14", "y": "12", "rx": "1" }
        ],
        [
          "rect",
          { "width": "7", "height": "5", "x": "3", "y": "16", "rx": "1" }
        ]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "layout-dashboard" },
        $$sanitized_props,
        {
          /**
           * @component @name LayoutDashboard
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI5IiB4PSIzIiB5PSIzIiByeD0iMSIgLz4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI1IiB4PSIxNCIgeT0iMyIgcng9IjEiIC8+CiAgPHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iOSIgeD0iMTQiIHk9IjEyIiByeD0iMSIgLz4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI1IiB4PSIzIiB5PSIxNiIgcng9IjEiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/layout-dashboard
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    Layout_dashboard
  );
}
Layout_dashboard.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var layout_dashboard_default = Layout_dashboard;

// node_modules/lucide-svelte/dist/icons/loader-circle.svelte
init_server();
Loader_circle[FILENAME] = "node_modules/lucide-svelte/dist/icons/loader-circle.svelte";
function Loader_circle($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [["path", { "d": "M21 12a9 9 0 1 1-6.219-8.56" }]];
      Icon_default($$renderer2, spread_props2([
        { name: "loader-circle" },
        $$sanitized_props,
        {
          /**
           * @component @name LoaderCircle
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEgMTJhOSA5IDAgMSAxLTYuMjE5LTguNTYiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/loader-circle
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    Loader_circle
  );
}
Loader_circle.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var loader_circle_default = Loader_circle;

// node_modules/lucide-svelte/dist/icons/log-out.svelte
init_server();
Log_out[FILENAME] = "node_modules/lucide-svelte/dist/icons/log-out.svelte";
function Log_out($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        ["path", { "d": "m16 17 5-5-5-5" }],
        ["path", { "d": "M21 12H9" }],
        ["path", { "d": "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" }]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "log-out" },
        $$sanitized_props,
        {
          /**
           * @component @name LogOut
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTYgMTcgNS01LTUtNSIgLz4KICA8cGF0aCBkPSJNMjEgMTJIOSIgLz4KICA8cGF0aCBkPSJNOSAyMUg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDQiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/log-out
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    Log_out
  );
}
Log_out.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var log_out_default = Log_out;

// node_modules/lucide-svelte/dist/icons/settings.svelte
init_server();
Settings[FILENAME] = "node_modules/lucide-svelte/dist/icons/settings.svelte";
function Settings($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        [
          "path",
          {
            "d": "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915"
          }
        ],
        ["circle", { "cx": "12", "cy": "12", "r": "3" }]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "settings" },
        $$sanitized_props,
        {
          /**
           * @component @name Settings
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNOS42NzEgNC4xMzZhMi4zNCAyLjM0IDAgMCAxIDQuNjU5IDAgMi4zNCAyLjM0IDAgMCAwIDMuMzE5IDEuOTE1IDIuMzQgMi4zNCAwIDAgMSAyLjMzIDQuMDMzIDIuMzQgMi4zNCAwIDAgMCAwIDMuODMxIDIuMzQgMi4zNCAwIDAgMS0yLjMzIDQuMDMzIDIuMzQgMi4zNCAwIDAgMC0zLjMxOSAxLjkxNSAyLjM0IDIuMzQgMCAwIDEtNC42NTkgMCAyLjM0IDIuMzQgMCAwIDAtMy4zMi0xLjkxNSAyLjM0IDIuMzQgMCAwIDEtMi4zMy00LjAzMyAyLjM0IDIuMzQgMCAwIDAgMC0zLjgzMUEyLjM0IDIuMzQgMCAwIDEgNi4zNSA2LjA1MWEyLjM0IDIuMzQgMCAwIDAgMy4zMTktMS45MTUiIC8+CiAgPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMyIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/settings
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    Settings
  );
}
Settings.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var settings_default = Settings;

// node_modules/lucide-svelte/dist/icons/user.svelte
init_server();
User[FILENAME] = "node_modules/lucide-svelte/dist/icons/user.svelte";
function User($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        ["path", { "d": "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" }],
        ["circle", { "cx": "12", "cy": "7", "r": "4" }]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "user" },
        $$sanitized_props,
        {
          /**
           * @component @name User
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTkgMjF2LTJhNCA0IDAgMCAwLTQtNEg5YTQgNCAwIDAgMC00IDR2MiIgLz4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjciIHI9IjQiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/user
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    User
  );
}
User.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var user_default = User;

// node_modules/lucide-svelte/dist/icons/x.svelte
init_server();
X[FILENAME] = "node_modules/lucide-svelte/dist/icons/x.svelte";
function X($$renderer, $$props) {
  const $$sanitized_props = sanitize_props($$props);
  $$renderer.component(
    ($$renderer2) => {
      const iconNode = [
        ["path", { "d": "M18 6 6 18" }],
        ["path", { "d": "m6 6 12 12" }]
      ];
      Icon_default($$renderer2, spread_props2([
        { name: "x" },
        $$sanitized_props,
        {
          /**
           * @component @name X
           * @description Lucide SVG icon component, renders SVG Element with children.
           *
           * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTggNiA2IDE4IiAvPgogIDxwYXRoIGQ9Im02IDYgMTIgMTIiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/x
           * @see https://lucide.dev/guide/packages/lucide-svelte - Documentation
           *
           * @param {Object} props - Lucide icons props and any valid SVG attribute
           * @returns {FunctionalComponent} Svelte component
           *
           */
          iconNode,
          children: prevent_snippet_stringification(($$renderer3) => {
            $$renderer3.push(`<!--[-->`);
            slot2($$renderer3, $$props, "default", {}, null);
            $$renderer3.push(`<!--]-->`);
          }),
          $$slots: { default: true }
        }
      ]));
    },
    X
  );
}
X.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var x_default = X;

// svelte/GoogleSignInButton.svelte
var GoogleSignInButton_exports = {};
__export(GoogleSignInButton_exports, {
  default: () => GoogleSignInButton_default
});
init_server();
GoogleSignInButton[FILENAME] = "svelte/GoogleSignInButton.svelte";
function GoogleSignInButton($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { disabled = false, text: text2 = "Continue with Google" } = $$props;
      function handleGoogleSignIn() {
        if (disabled) return;
        window.location.href = "/auth/google";
      }
      $$renderer2.push(`<button type="button"${attr("disabled", disabled, true)} class="btn btn-outline w-full gap-3">`);
      push_element($$renderer2, "button", 10, 0);
      $$renderer2.push(`<svg class="w-5 h-5" viewBox="0 0 24 24">`);
      push_element($$renderer2, "svg", 17, 2);
      $$renderer2.push(`<path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z">`);
      push_element($$renderer2, "path", 18, 4);
      $$renderer2.push(`</path>`);
      pop_element();
      $$renderer2.push(`<path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z">`);
      push_element($$renderer2, "path", 22, 4);
      $$renderer2.push(`</path>`);
      pop_element();
      $$renderer2.push(`<path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z">`);
      push_element($$renderer2, "path", 26, 4);
      $$renderer2.push(`</path>`);
      pop_element();
      $$renderer2.push(`<path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z">`);
      push_element($$renderer2, "path", 30, 4);
      $$renderer2.push(`</path>`);
      pop_element();
      $$renderer2.push(`</svg>`);
      pop_element();
      $$renderer2.push(` <span>`);
      push_element($$renderer2, "span", 35, 2);
      $$renderer2.push(`${escape_html(text2)}</span>`);
      pop_element();
      $$renderer2.push(`</button>`);
      pop_element();
    },
    GoogleSignInButton
  );
}
GoogleSignInButton.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var GoogleSignInButton_default = GoogleSignInButton;

// svelte/AuthModal.svelte
AuthModal[FILENAME] = "svelte/AuthModal.svelte";
function AuthModal($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { isOpen = false, live } = $$props;
      let mode = "signin";
      let email = "";
      let password = "";
      let name = "";
      let error = "";
      let loading = false;
      let showPassword = false;
      function closeModal() {
        isOpen = false;
        email = "";
        password = "";
        name = "";
        error = "";
        showPassword = false;
      }
      function switchMode() {
        mode = mode === "signin" ? "signup" : "signin";
        error = "";
      }
      async function handleEmailAuth(event2) {
        event2.preventDefault();
        error = "";
        loading = true;
        try {
          const endpoint = mode === "signin" ? "/auth/signin" : "/auth/signup";
          const body = mode === "signin" ? { email, password } : { email, password, name };
          const response = await fetch(endpoint, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": document.querySelector('meta[name="csrf-token"]')?.content || ""
            },
            body: JSON.stringify(body)
          });
          if (response.ok) {
            window.location.reload();
          } else {
            const data = await response.json();
            error = data.error || "Authentication failed";
          }
        } catch (e) {
          error = "Network error. Please try again.";
        } finally {
          loading = false;
        }
      }
      $$renderer2.push(`<dialog${attr_class("modal", void 0, { "modal-open": isOpen })}>`);
      push_element($$renderer2, "dialog", 63, 0);
      $$renderer2.push(`<div class="modal-box bg-base-200 max-w-md">`);
      push_element($$renderer2, "div", 64, 2);
      $$renderer2.push(`<form method="dialog">`);
      push_element($$renderer2, "form", 65, 4);
      $$renderer2.push(`<button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" aria-label="Close">`);
      push_element($$renderer2, "button", 66, 6);
      x_default($$renderer2, { class: "w-4 h-4" });
      $$renderer2.push(`<!----></button>`);
      pop_element();
      $$renderer2.push(`</form>`);
      pop_element();
      $$renderer2.push(` <h3 class="font-bold text-2xl mb-2">`);
      push_element($$renderer2, "h3", 75, 4);
      $$renderer2.push(`${escape_html(mode === "signin" ? "Welcome Back" : "Create Account")}</h3>`);
      pop_element();
      $$renderer2.push(` <p class="text-base-content/70 mb-6">`);
      push_element($$renderer2, "p", 76, 4);
      $$renderer2.push(`${escape_html(mode === "signin" ? "Sign in to save prompts, leave comments, and more" : "Join to unlock all features")}</p>`);
      pop_element();
      $$renderer2.push(` `);
      GoogleSignInButton_default($$renderer2, { disabled: loading });
      $$renderer2.push(`<!----> <div class="divider text-xs text-base-content/50">`);
      push_element($$renderer2, "div", 84, 4);
      $$renderer2.push(`or</div>`);
      pop_element();
      $$renderer2.push(` <form class="flex flex-col gap-4">`);
      push_element($$renderer2, "form", 87, 4);
      if (mode === "signup") {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="form-control w-full">`);
        push_element($$renderer2, "div", 89, 8);
        $$renderer2.push(`<label class="label pb-1" for="name">`);
        push_element($$renderer2, "label", 90, 10);
        $$renderer2.push(`<span class="label-text text-sm">`);
        push_element($$renderer2, "span", 91, 12);
        $$renderer2.push(`Name</span>`);
        pop_element();
        $$renderer2.push(`</label>`);
        pop_element();
        $$renderer2.push(` <input id="name" type="text"${attr("value", name)} placeholder="Your name" class="input input-bordered w-full" required${attr("disabled", loading, true)}/>`);
        push_element($$renderer2, "input", 93, 10);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
      }
      $$renderer2.push(`<!--]--> <div class="form-control w-full">`);
      push_element($$renderer2, "div", 105, 6);
      $$renderer2.push(`<label class="label pb-1" for="email">`);
      push_element($$renderer2, "label", 106, 8);
      $$renderer2.push(`<span class="label-text text-sm">`);
      push_element($$renderer2, "span", 107, 10);
      $$renderer2.push(`Email</span>`);
      pop_element();
      $$renderer2.push(`</label>`);
      pop_element();
      $$renderer2.push(` <input id="email" type="email"${attr("value", email)} placeholder="you@example.com" class="input input-bordered w-full" required${attr("disabled", loading, true)}/>`);
      push_element($$renderer2, "input", 109, 8);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="form-control w-full">`);
      push_element($$renderer2, "div", 120, 6);
      $$renderer2.push(`<label class="label pb-1" for="password">`);
      push_element($$renderer2, "label", 121, 8);
      $$renderer2.push(`<span class="label-text text-sm">`);
      push_element($$renderer2, "span", 122, 10);
      $$renderer2.push(`Password</span>`);
      pop_element();
      $$renderer2.push(`</label>`);
      pop_element();
      $$renderer2.push(` <label class="input input-bordered w-full flex items-center gap-2">`);
      push_element($$renderer2, "label", 124, 8);
      $$renderer2.push(`<input id="password"${attr("type", showPassword ? "text" : "password")}${attr("value", password)} placeholder="\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022" class="grow bg-transparent outline-none" required minlength="8"${attr("disabled", loading, true)}/>`);
      push_element($$renderer2, "input", 125, 10);
      pop_element();
      $$renderer2.push(` <button type="button" class="btn btn-ghost btn-xs btn-circle"${attr("aria-label", showPassword ? "Hide password" : "Show password")}>`);
      push_element($$renderer2, "button", 135, 10);
      if (showPassword) {
        $$renderer2.push("<!--[-->");
        eye_default($$renderer2, { class: "w-4 h-4" });
      } else {
        $$renderer2.push("<!--[!-->");
        eye_off_default($$renderer2, { class: "w-4 h-4" });
      }
      $$renderer2.push(`<!--]--></button>`);
      pop_element();
      $$renderer2.push(`</label>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` `);
      if (error) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="alert alert-error text-sm">`);
        push_element($$renderer2, "div", 151, 8);
        $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
        push_element($$renderer2, "svg", 152, 10);
        $$renderer2.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">`);
        push_element($$renderer2, "path", 153, 12);
        $$renderer2.push(`</path>`);
        pop_element();
        $$renderer2.push(`</svg>`);
        pop_element();
        $$renderer2.push(` <span>`);
        push_element($$renderer2, "span", 155, 10);
        $$renderer2.push(`${escape_html(error)}</span>`);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
      }
      $$renderer2.push(`<!--]--> <button type="submit" class="btn btn-primary btn-lg w-full"${attr("disabled", loading, true)}>`);
      push_element($$renderer2, "button", 159, 6);
      if (loading) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<span class="loading loading-spinner">`);
        push_element($$renderer2, "span", 161, 10);
        $$renderer2.push(`</span>`);
        pop_element();
        $$renderer2.push(` Loading...`);
      } else {
        $$renderer2.push("<!--[!-->");
        $$renderer2.push(`${escape_html(mode === "signin" ? "Sign In" : "Sign Up")}`);
      }
      $$renderer2.push(`<!--]--></button>`);
      pop_element();
      $$renderer2.push(`</form>`);
      pop_element();
      $$renderer2.push(` <div class="mt-4 text-center text-sm">`);
      push_element($$renderer2, "div", 170, 4);
      $$renderer2.push(`<span class="text-base-content/70">`);
      push_element($$renderer2, "span", 171, 6);
      $$renderer2.push(`${escape_html(mode === "signin" ? "Don't have an account?" : "Already have an account?")}</span>`);
      pop_element();
      $$renderer2.push(` <button class="link link-primary ml-1">`);
      push_element($$renderer2, "button", 174, 6);
      $$renderer2.push(`${escape_html(mode === "signin" ? "Sign up" : "Sign in")}</button>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="mt-6 text-xs text-base-content/50 text-center">`);
      push_element($$renderer2, "div", 179, 4);
      $$renderer2.push(`By continuing, you agree to our Terms of Service and Privacy Policy</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <form method="dialog" class="modal-backdrop">`);
      push_element($$renderer2, "form", 183, 2);
      $$renderer2.push(`<button>`);
      push_element($$renderer2, "button", 184, 4);
      $$renderer2.push(`close</button>`);
      pop_element();
      $$renderer2.push(`</form>`);
      pop_element();
      $$renderer2.push(`</dialog>`);
      pop_element();
      bind_props($$props, { isOpen });
    },
    AuthModal
  );
}
AuthModal.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var AuthModal_default = AuthModal;

// svelte/ChatWindow.svelte
var ChatWindow_exports = {};
__export(ChatWindow_exports, {
  default: () => ChatWindow_default
});
init_server();
init_index_server();
var import_phoenix = __toESM(require_phoenix_cjs());

// node_modules/svelte/src/transition/index.js
init_esm_env();
init_warnings();

// svelte/ChatWindow.svelte
ChatWindow[FILENAME] = "svelte/ChatWindow.svelte";
var $$css = {
  hash: "svelte-1tcjyee",
  code: '\n  /* :global {*/\n    @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");\n  /*}*/\n\n  .chat-wrapper.svelte-1tcjyee {\n    font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;\n  }\n\n  .messages-container.svelte-1tcjyee {\n    scroll-behavior: smooth;\n  }\n\n  .messages-container.svelte-1tcjyee::-webkit-scrollbar {\n    width: 8px;\n  }\n\n  .messages-container.svelte-1tcjyee::-webkit-scrollbar-track {\n    background: transparent;\n  }\n\n  .messages-container.svelte-1tcjyee::-webkit-scrollbar-thumb {\n    @apply bg-base-700 rounded;\n  }\n\n  .messages-container.svelte-1tcjyee::-webkit-scrollbar-thumb:hover {\n    @apply bg-base-600;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hhdFdpbmRvdy5zdmVsdGUiLCJzb3VyY2VzIjpbIkNoYXRXaW5kb3cuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCJcbiAgaW1wb3J0IHsgU29ja2V0IH0gZnJvbSBcInBob2VuaXhcIlxuICBpbXBvcnQgeyBmbHkgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIlxuXG4gIGV4cG9ydCBsZXQgcm9vbVxuICBleHBvcnQgbGV0IG1lc3NhZ2VzID0gW11cbiAgZXhwb3J0IGxldCB1c2VySWRcblxuICBsZXQgbmV3TWVzc2FnZSA9IFwiXCJcbiAgbGV0IGNoYW5uZWwgPSBudWxsXG4gIGxldCBzb2NrZXQgPSBudWxsXG4gIGxldCBpc0Nvbm5lY3RlZCA9IGZhbHNlXG4gIGxldCBtZXNzYWdlTGlzdCA9IG51bGxcbiAgbGV0IHRleHRhcmVhRWxlbWVudCA9IG51bGxcblxuICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KFwiL3NvY2tldFwiLCB7XG4gICAgICBwYXJhbXM6IHsgdXNlcl9pZDogdXNlcklkIH1cbiAgICB9KVxuICAgIHNvY2tldC5jb25uZWN0KClcblxuICAgIGNoYW5uZWwgPSBzb2NrZXQuY2hhbm5lbChgcm9vbToke3Jvb20uaWR9YClcblxuICAgIGNoYW5uZWwub24oXCJtZXNzYWdlX2NyZWF0ZWRcIiwgKHBheWxvYWQpID0+IHtcbiAgICAgIG1lc3NhZ2VzID0gWy4uLm1lc3NhZ2VzLCBwYXlsb2FkXVxuICAgICAgc2Nyb2xsVG9Cb3R0b20oKVxuICAgIH0pXG5cbiAgICBjaGFubmVsLm9uKFwidHlwaW5nXCIsIChwYXlsb2FkKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtwYXlsb2FkLnVzZXJuYW1lfSBpcyB0eXBpbmcuLi5gKVxuICAgIH0pXG5cbiAgICBjaGFubmVsXG4gICAgICAuam9pbigpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgbWVzc2FnZXMgPSByZXNwLm1lc3NhZ2VzXG4gICAgICAgIH1cbiAgICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlXG4gICAgICAgIHNjcm9sbFRvQm90dG9tKClcbiAgICAgIH0pXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIChyZXNwKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gam9pblwiLCByZXNwKVxuICAgICAgICBpc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB9KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjaGFubmVsKSBjaGFubmVsLmxlYXZlKClcbiAgICAgIGlmIChzb2NrZXQpIHNvY2tldC5kaXNjb25uZWN0KClcbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2UoKSB7XG4gICAgaWYgKCFuZXdNZXNzYWdlLnRyaW0oKSB8fCAhaXNDb25uZWN0ZWQpIHJldHVyblxuICAgIGNoYW5uZWwucHVzaChcIm5ld19tZXNzYWdlXCIsIHsgYm9keTogbmV3TWVzc2FnZS50cmltKCkgfSlcbiAgICBuZXdNZXNzYWdlID0gXCJcIlxuICAgIGlmICh0ZXh0YXJlYUVsZW1lbnQpIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvQm90dG9tKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VMaXN0KSB7XG4gICAgICAgIG1lc3NhZ2VMaXN0LnNjcm9sbFRvcCA9IG1lc3NhZ2VMaXN0LnNjcm9sbEhlaWdodFxuICAgICAgfVxuICAgIH0sIDEwMClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVR5cGluZygpIHtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgY2hhbm5lbC5wdXNoKFwidHlwaW5nXCIsIHt9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUlucHV0KGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldFxuICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBNYXRoLm1pbih0YXJnZXQuc2Nyb2xsSGVpZ2h0LCAxMjApICsgXCJweFwiXG4gICAgaGFuZGxlVHlwaW5nKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFRpbWUodGltZXN0YW1wKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcClcbiAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoXCJlbi1VU1wiLCB7XG4gICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyMTI6IHRydWVcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNNZXNzYWdlU2VxdWVuY2UoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPiAwICYmIG1lc3NhZ2VzW2luZGV4IC0gMV0udXNlcl9pZCA9PT0gbWVzc2FnZXNbaW5kZXhdLnVzZXJfaWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ3VycmVudFVzZXIodXNlcklkKSB7XG4gICAgcmV0dXJuIHVzZXJJZCA9PT0gcGFyc2VJbnQodXNlcklkKVxuICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNoYXQtd3JhcHBlciBiZy1iYXNlLTEwMCBmbGV4IGZsZXgtY29sIGgtZnVsbFwiPlxuICA8IS0tIEhlYWRlciAtLT5cbiAgPGRpdiBjbGFzcz1cImNoYXQtaGVhZGVyIGJnLWJhc2UtMTAwIGJvcmRlci1iIGJvcmRlci1iYXNlLTMwMCBweC02IHB5LTQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgPGRpdj5cbiAgICAgIDxoMiBjbGFzcz1cInRleHQteGwgZm9udC1ib2xkIHRleHQtYmFzZS1jb250ZW50XCI+IyB7cm9vbS5uYW1lfTwvaDI+XG4gICAgICB7I2lmIHJvb20uZGVzY3JpcHRpb259XG4gICAgICAgIDxwIGNsYXNzPVwidGV4dC1zbSB0ZXh0LWJhc2UtY29udGVudC83MCBtdC0xXCI+e3Jvb20uZGVzY3JpcHRpb259PC9wPlxuICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYmFkZ2VcIiBjbGFzczpiYWRnZS1zdWNjZXNzPXtpc0Nvbm5lY3RlZH0gY2xhc3M6YmFkZ2UtZXJyb3I9eyFpc0Nvbm5lY3RlZH0+XG4gICAgICA8c3BhbiBjbGFzcz1cImlubGluZS1ibG9jayB3LTIgaC0yIHJvdW5kZWQtZnVsbCBtci0yXCIgY2xhc3M6Ymctc3VjY2Vzcz17aXNDb25uZWN0ZWR9IGNsYXNzOmJnLWVycm9yPXshaXNDb25uZWN0ZWR9IC8+XG4gICAgICB7aXNDb25uZWN0ZWQgPyBcIk9ubGluZVwiIDogXCJPZmZsaW5lXCJ9XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDwhLS0gTWVzc2FnZXMgLS0+XG4gIDxkaXYgYmluZDp0aGlzPXttZXNzYWdlTGlzdH0gY2xhc3M9XCJtZXNzYWdlcy1jb250YWluZXIgZmxleC0xIG92ZXJmbG93LXktYXV0byBweC00IHB5LTQgYmctYmFzZS0xMDBcIj5cbiAgICB7I2lmIG1lc3NhZ2VzLmxlbmd0aCA9PT0gMH1cbiAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBoLWZ1bGwgZ2FwLTMgdGV4dC1iYXNlLWNvbnRlbnQvNTBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtNXhsIG9wYWNpdHktNjBcIj7wn5KsPC9kaXY+XG4gICAgICAgIDxwIGNsYXNzPVwidGV4dC1sZyBmb250LXNlbWlib2xkIHRleHQtYmFzZS1jb250ZW50XCI+V2VsY29tZSB0byAje3Jvb20ubmFtZX08L3A+XG4gICAgICAgIDxwIGNsYXNzPVwidGV4dC1zbVwiPlN0YXJ0IHRoZSBjb252ZXJzYXRpb248L3A+XG4gICAgICA8L2Rpdj5cbiAgICB7OmVsc2V9XG4gICAgICB7I2VhY2ggbWVzc2FnZXMgYXMgbXNnLCBpIChtc2cuaWQpfVxuICAgICAgICB7QGNvbnN0IGlzU2VxdWVuY2UgPSBpc01lc3NhZ2VTZXF1ZW5jZShpKX1cbiAgICAgICAge0Bjb25zdCBpc01pbmUgPSBtc2cudXNlcl9pZC50b1N0cmluZygpID09PSB1c2VySWR9XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQge2lzTWluZSA/ICdjaGF0LWVuZCcgOiAnY2hhdC1zdGFydCd9IHtpc1NlcXVlbmNlID8gJ210LTEnIDogJ210LTQnfVwiIGluOmZseT17eyB5OiAyMCwgZHVyYXRpb246IDMwMCB9fT5cbiAgICAgICAgICB7I2lmICFpc1NlcXVlbmNlfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQtaW1hZ2UgYXZhdGFyXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3LTggaC04IHJvdW5kZWQtZnVsbCBiZy1ncmFkaWVudC10by1iciBmcm9tLXByaW1hcnkgdG8tc2Vjb25kYXJ5IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRleHQtcHJpbWFyeS1jb250ZW50IGZvbnQtYm9sZCB0ZXh0LXhzIHNoYWRvdy1tZFwiPlxuICAgICAgICAgICAgICAgIHsobXNnLnVzZXJuYW1lIHx8IFwiP1wiKS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LWhlYWRlciB0ZXh0LXhzIHRleHQtYmFzZS1jb250ZW50LzYwIG1iLTFcIj5cbiAgICAgICAgICAgICAge21zZy51c2VybmFtZSB8fCBcIlVua25vd25cIn1cbiAgICAgICAgICAgICAgPHRpbWUgY2xhc3M9XCJ0ZXh0LVsxMHB4XSB0ZXh0LWJhc2UtY29udGVudC80MCBtbC0yXCI+e2Zvcm1hdFRpbWUobXNnLmluc2VydGVkX2F0KX08L3RpbWU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7L2lmfVxuXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQtYnViYmxlIHtpc01pbmUgPyAnYmctcHJpbWFyeSB0ZXh0LXByaW1hcnktY29udGVudCcgOiAnYmctYmFzZS0yMDAgdGV4dC1iYXNlLWNvbnRlbnQnfSBtYXgtdy14cyBicmVhay13b3Jkc1wiPlxuICAgICAgICAgICAge21zZy5ib2R5fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIHsvZWFjaH1cbiAgICB7L2lmfVxuICA8L2Rpdj5cblxuICA8IS0tIElucHV0IEFyZWEgLS0+XG4gIDxkaXYgY2xhc3M9XCJpbnB1dC1zZWN0aW9uIGJnLWJhc2UtMTAwIGJvcmRlci10IGJvcmRlci1iYXNlLTMwMCBweC00IHB5LTNcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZmxleCBnYXAtMiBpdGVtcy1lbmQgcm91bmRlZC0zeGwgYmctYmFzZS0yMDAgcHgtNCBweS0yXCI+XG4gICAgICA8dGV4dGFyZWFcbiAgICAgICAgYmluZDp0aGlzPXt0ZXh0YXJlYUVsZW1lbnR9XG4gICAgICAgIGJpbmQ6dmFsdWU9e25ld01lc3NhZ2V9XG4gICAgICAgIG9uOmtleWRvd249eyhlKSA9PiB7XG4gICAgICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgc2VuZE1lc3NhZ2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgICAgb246aW5wdXQ9e2hhbmRsZUlucHV0fVxuICAgICAgICBwbGFjZWhvbGRlcj1cIk1lc3NhZ2UgI3tyb29tLm5hbWV9XCJcbiAgICAgICAgZGlzYWJsZWQ9eyFpc0Nvbm5lY3RlZH1cbiAgICAgICAgYXV0b2NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgcm93cz1cIjFcIlxuICAgICAgICBjbGFzcz1cInRleHRhcmVhIHRleHRhcmVhLWJvcmRlcmVkLTAgZmxleC0xIGJnLWJhc2UtMjAwIHRleHQtYmFzZS1jb250ZW50IHBsYWNlaG9sZGVyLWJhc2UtY29udGVudC81MCBmb2N1czpvdXRsaW5lLW5vbmUgcmVzaXplLW5vbmUgbWF4LWgtWzEyMHB4XSBwLTAgYm9yZGVyLTBcIlxuICAgICAgLz5cbiAgICAgIDxidXR0b25cbiAgICAgICAgb246Y2xpY2s9e3NlbmRNZXNzYWdlfVxuICAgICAgICBkaXNhYmxlZD17IWlzQ29ubmVjdGVkIHx8ICFuZXdNZXNzYWdlLnRyaW0oKX1cbiAgICAgICAgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtIGJ0bi1jaXJjbGUgZmxleC1zaHJpbmstMFwiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJTZW5kIG1lc3NhZ2VcIlxuICAgICAgPlxuICAgICAgICA8c3ZnIHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIxOFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIj5cbiAgICAgICAgICA8bGluZSB4MT1cIjIyXCIgeTE9XCIyXCIgeDI9XCIxMVwiIHkyPVwiMTNcIiAvPlxuICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz1cIjIyIDIgMTUgMjIgMTEgMTMgMiA5IDIyIDJcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIDpnbG9iYWwge1xuICAgIEBpbXBvcnQgdXJsKFwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1JbnRlcjp3Z2h0QDQwMDs1MDA7NjAwOzcwMCZkaXNwbGF5PXN3YXBcIik7XG4gIH1cblxuICAuY2hhdC13cmFwcGVyIHtcbiAgICBmb250LWZhbWlseTogXCJJbnRlclwiLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFwiU2Vnb2UgVUlcIiwgc2Fucy1zZXJpZjtcbiAgfVxuXG4gIC5tZXNzYWdlcy1jb250YWluZXIge1xuICAgIHNjcm9sbC1iZWhhdmlvcjogc21vb3RoO1xuICB9XG5cbiAgLm1lc3NhZ2VzLWNvbnRhaW5lcjo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICAgIHdpZHRoOiA4cHg7XG4gIH1cblxuICAubWVzc2FnZXMtY29udGFpbmVyOjotd2Via2l0LXNjcm9sbGJhci10cmFjayB7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gIH1cblxuICAubWVzc2FnZXMtY29udGFpbmVyOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XG4gICAgQGFwcGx5IGJnLWJhc2UtNzAwIHJvdW5kZWQ7XG4gIH1cblxuICAubWVzc2FnZXMtY29udGFpbmVyOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciB7XG4gICAgQGFwcGx5IGJnLWJhc2UtNjAwO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUF5TEEsS0FBRSxRQUFRO0FBQ1YsSUFBSTtBQUNKLElBQUU7O0FBRUYsRUFBRSw0QkFBYSxDQUFDO0FBQ2hCLElBQUksK0VBQStFO0FBQ25GOztBQUVBLEVBQUUsa0NBQW1CLENBQUM7QUFDdEIsSUFBSSx1QkFBdUI7QUFDM0I7O0FBRUEsRUFBRSxrQ0FBbUIsbUJBQW1CLENBQUM7QUFDekMsSUFBSSxVQUFVO0FBQ2Q7O0FBRUEsRUFBRSxrQ0FBbUIseUJBQXlCLENBQUM7QUFDL0MsSUFBSSx1QkFBdUI7QUFDM0I7O0FBRUEsRUFBRSxrQ0FBbUIseUJBQXlCLENBQUM7QUFDL0MsSUFBSTtBQUNKOztBQUVBLEVBQUUsa0NBQW1CLHlCQUF5QixNQUFNLENBQUM7QUFDckQsSUFBSTtBQUNKIiwiaWdub3JlTGlzdCI6W119 */'
};
function ChatWindow($$renderer, $$props) {
  $$renderer.global.css.add($$css);
  $$renderer.component(
    ($$renderer2) => {
      let room = $$props["room"];
      let messages = fallback($$props["messages"], () => [], true);
      let userId = $$props["userId"];
      let newMessage = "";
      let channel = null;
      let socket = null;
      let isConnected = false;
      let messageList = null;
      let textareaElement = null;
      noop(async () => {
        socket = new import_phoenix.Socket("/socket", { params: { user_id: userId } });
        socket.connect();
        channel = socket.channel(`room:${room.id}`);
        channel.on("message_created", (payload) => {
          messages = [...messages, payload];
          scrollToBottom();
        });
        channel.on("typing", (payload) => {
          console.log(`${payload.username} is typing...`);
        });
        channel.join().receive("ok", (resp) => {
          if (resp.messages) {
            messages = resp.messages;
          }
          isConnected = true;
          scrollToBottom();
        }).receive("error", (resp) => {
          console.error("Unable to join", resp);
          isConnected = false;
        });
        return () => {
          if (channel) channel.leave();
          if (socket) socket.disconnect();
        };
      });
      function sendMessage() {
        if (!newMessage.trim() || !isConnected) return;
        channel.push("new_message", { body: newMessage.trim() });
        newMessage = "";
        if (textareaElement) {
          textareaElement.style.height = "auto";
        }
      }
      function scrollToBottom() {
        setTimeout(
          () => {
            if (messageList) {
              messageList.scrollTop = messageList.scrollHeight;
            }
          },
          100
        );
      }
      function handleTyping() {
        if (channel) {
          channel.push("typing", {});
        }
      }
      function handleInput(e) {
        const target = e.target;
        target.style.height = "auto";
        target.style.height = Math.min(target.scrollHeight, 120) + "px";
        handleTyping();
      }
      function formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true });
      }
      function isMessageSequence(index2) {
        return index2 > 0 && messages[index2 - 1].user_id === messages[index2].user_id;
      }
      function isCurrentUser(userId2) {
        return userId2 === parseInt(userId2);
      }
      $$renderer2.push(`<div class="chat-wrapper bg-base-100 flex flex-col h-full svelte-1tcjyee">`);
      push_element($$renderer2, "div", 102, 0);
      $$renderer2.push(`<div class="chat-header bg-base-100 border-b border-base-300 px-6 py-4 flex items-center justify-between">`);
      push_element($$renderer2, "div", 104, 2);
      $$renderer2.push(`<div>`);
      push_element($$renderer2, "div", 105, 4);
      $$renderer2.push(`<h2 class="text-xl font-bold text-base-content">`);
      push_element($$renderer2, "h2", 106, 6);
      $$renderer2.push(`# ${escape_html(room.name)}</h2>`);
      pop_element();
      $$renderer2.push(` `);
      if (room.description) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<p class="text-sm text-base-content/70 mt-1">`);
        push_element($$renderer2, "p", 108, 8);
        $$renderer2.push(`${escape_html(room.description)}</p>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
      $$renderer2.push(` <div${attr_class("badge", void 0, { "badge-success": isConnected, "badge-error": !isConnected })}>`);
      push_element($$renderer2, "div", 111, 4);
      $$renderer2.push(`<span${attr_class("inline-block w-2 h-2 rounded-full mr-2", void 0, { "bg-success": isConnected, "bg-error": !isConnected })}>`);
      push_element($$renderer2, "span", 112, 6);
      $$renderer2.push(`</span>`);
      pop_element();
      $$renderer2.push(` ${escape_html(isConnected ? "Online" : "Offline")}</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="messages-container flex-1 overflow-y-auto px-4 py-4 bg-base-100 svelte-1tcjyee">`);
      push_element($$renderer2, "div", 118, 2);
      if (messages.length === 0) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="flex flex-col items-center justify-center h-full gap-3 text-base-content/50">`);
        push_element($$renderer2, "div", 120, 6);
        $$renderer2.push(`<div class="text-5xl opacity-60">`);
        push_element($$renderer2, "div", 121, 8);
        $$renderer2.push(`\u{1F4AC}</div>`);
        pop_element();
        $$renderer2.push(` <p class="text-lg font-semibold text-base-content">`);
        push_element($$renderer2, "p", 122, 8);
        $$renderer2.push(`Welcome to #${escape_html(room.name)}</p>`);
        pop_element();
        $$renderer2.push(` <p class="text-sm">`);
        push_element($$renderer2, "p", 123, 8);
        $$renderer2.push(`Start the conversation</p>`);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
        $$renderer2.push(`<!--[-->`);
        const each_array = ensure_array_like(messages);
        for (let i = 0, $$length = each_array.length; i < $$length; i++) {
          let msg = each_array[i];
          const isSequence = isMessageSequence(i);
          const isMine = msg.user_id.toString() === userId;
          $$renderer2.push(`<div${attr_class(`chat ${stringify(isMine ? "chat-end" : "chat-start")} ${stringify(isSequence ? "mt-1" : "mt-4")}`)}>`);
          push_element($$renderer2, "div", 130, 8);
          if (!isSequence) {
            $$renderer2.push("<!--[-->");
            $$renderer2.push(`<div class="chat-image avatar">`);
            push_element($$renderer2, "div", 132, 12);
            $$renderer2.push(`<div class="w-8 h-8 rounded-full bg-gradient-to-br from-primary to-secondary flex items-center justify-center text-primary-content font-bold text-xs shadow-md">`);
            push_element($$renderer2, "div", 133, 14);
            $$renderer2.push(`${escape_html((msg.username || "?").charAt(0).toUpperCase())}</div>`);
            pop_element();
            $$renderer2.push(`</div>`);
            pop_element();
            $$renderer2.push(` <div class="chat-header text-xs text-base-content/60 mb-1">`);
            push_element($$renderer2, "div", 137, 12);
            $$renderer2.push(`${escape_html(msg.username || "Unknown")} <time class="text-[10px] text-base-content/40 ml-2">`);
            push_element($$renderer2, "time", 139, 14);
            $$renderer2.push(`${escape_html(formatTime(msg.inserted_at))}</time>`);
            pop_element();
            $$renderer2.push(`</div>`);
            pop_element();
          } else {
            $$renderer2.push("<!--[!-->");
          }
          $$renderer2.push(`<!--]--> <div${attr_class(`chat-bubble ${stringify(isMine ? "bg-primary text-primary-content" : "bg-base-200 text-base-content")} max-w-xs break-words`)}>`);
          push_element($$renderer2, "div", 143, 10);
          $$renderer2.push(`${escape_html(msg.body)}</div>`);
          pop_element();
          $$renderer2.push(`</div>`);
          pop_element();
        }
        $$renderer2.push(`<!--]-->`);
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
      $$renderer2.push(` <div class="input-section bg-base-100 border-t border-base-300 px-4 py-3">`);
      push_element($$renderer2, "div", 152, 2);
      $$renderer2.push(`<div class="flex gap-2 items-end rounded-3xl bg-base-200 px-4 py-2">`);
      push_element($$renderer2, "div", 153, 4);
      $$renderer2.push(`<textarea${attr("placeholder", `Message #${stringify(room.name)}`)}${attr("disabled", !isConnected, true)} autocomplete="off" rows="1" class="textarea textarea-bordered-0 flex-1 bg-base-200 text-base-content placeholder-base-content/50 focus:outline-none resize-none max-h-[120px] p-0 border-0">`);
      push_element($$renderer2, "textarea", 154, 6);
      const $$body = escape_html(newMessage);
      if ($$body) {
        $$renderer2.push(`${$$body}`);
      } else {
      }
      $$renderer2.push(`</textarea>`);
      pop_element();
      $$renderer2.push(` <button${attr("disabled", !isConnected || !newMessage.trim(), true)} class="btn btn-primary btn-sm btn-circle flex-shrink-0" aria-label="Send message">`);
      push_element($$renderer2, "button", 170, 6);
      $$renderer2.push(`<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">`);
      push_element($$renderer2, "svg", 176, 8);
      $$renderer2.push(`<line x1="22" y1="2" x2="11" y2="13">`);
      push_element($$renderer2, "line", 177, 10);
      $$renderer2.push(`</line>`);
      pop_element();
      $$renderer2.push(`<polygon points="22 2 15 22 11 13 2 9 22 2">`);
      push_element($$renderer2, "polygon", 178, 10);
      $$renderer2.push(`</polygon>`);
      pop_element();
      $$renderer2.push(`</svg>`);
      pop_element();
      $$renderer2.push(`</button>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      bind_props($$props, { room, messages, userId });
    },
    ChatWindow
  );
}
ChatWindow.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var ChatWindow_default = ChatWindow;

// svelte/CodeSnippetCard.svelte
var CodeSnippetCard_exports = {};
__export(CodeSnippetCard_exports, {
  default: () => CodeSnippetCard_default
});
init_server();
CodeSnippetCard[FILENAME] = "svelte/CodeSnippetCard.svelte";
function CodeSnippetCard($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { delay = 0 } = $$props;
      $$renderer2.push(`<div class="absolute hidden lg:block top-1/4 left-10 xl:left-32 w-64 bg-base-200/90 backdrop-blur-xl border border-base-300 shadow-[0_20px_40px_-15px_rgba(0,0,0,0.1)] rounded-2xl p-4 animate-float rotate-[-3deg]"${attr_style(`animation-delay: ${stringify(delay)}s`)}>`);
      push_element($$renderer2, "div", 5, 0);
      $$renderer2.push(`<div class="font-mono text-[10px] text-base-content/70 leading-relaxed">`);
      push_element($$renderer2, "div", 9, 2);
      $$renderer2.push(`<div class="flex gap-2 mb-2 border-b border-base-300 pb-2">`);
      push_element($$renderer2, "div", 10, 4);
      $$renderer2.push(`<div class="w-2 h-2 rounded-full bg-red-500">`);
      push_element($$renderer2, "div", 11, 6);
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="w-2 h-2 rounded-full bg-yellow-500">`);
      push_element($$renderer2, "div", 12, 6);
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="w-2 h-2 rounded-full bg-green-500">`);
      push_element($$renderer2, "div", 13, 6);
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="text-blue-400">`);
      push_element($$renderer2, "div", 15, 4);
      $$renderer2.push(`const <span class="text-yellow-200">`);
      push_element($$renderer2, "span", 16, 12);
      $$renderer2.push(`automate</span>`);
      pop_element();
      $$renderer2.push(` = <span class="text-purple-400">`);
      push_element($$renderer2, "span", 16, 60);
      $$renderer2.push(`async</span>`);
      pop_element();
      $$renderer2.push(` () => {</div>`);
      pop_element();
      $$renderer2.push(` <div class="pl-4">`);
      push_element($$renderer2, "div", 18, 4);
      $$renderer2.push(`await <span class="text-green-300">`);
      push_element($$renderer2, "span", 19, 12);
      $$renderer2.push(`n8n</span>`);
      pop_element();
      $$renderer2.push(`.trigger();</div>`);
      pop_element();
      $$renderer2.push(` <div class="pl-4">`);
      push_element($$renderer2, "div", 21, 4);
      $$renderer2.push(`return <span class="text-orange-300">`);
      push_element($$renderer2, "span", 22, 13);
      $$renderer2.push(`"Freedom"</span>`);
      pop_element();
      $$renderer2.push(`;</div>`);
      pop_element();
      $$renderer2.push(` <div>`);
      push_element($$renderer2, "div", 24, 4);
      $$renderer2.push(`}</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    CodeSnippetCard
  );
}
CodeSnippetCard.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var CodeSnippetCard_default = CodeSnippetCard;

// svelte/Counter.svelte
var Counter_exports = {};
__export(Counter_exports, {
  default: () => Counter_default
});
init_server();
Counter[FILENAME] = "svelte/Counter.svelte";
function Counter($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { count = 0, live } = $$props;
      function increment2() {
        live.pushEvent("increment", {});
      }
      function decrement() {
        live.pushEvent("decrement", {});
      }
      $$renderer2.push(`<div class="flex flex-col items-center gap-4 p-8">`);
      push_element($$renderer2, "div", 13, 0);
      $$renderer2.push(`<h2 class="text-3xl font-bold">`);
      push_element($$renderer2, "h2", 14, 2);
      $$renderer2.push(`Counter: ${escape_html(count)}</h2>`);
      pop_element();
      $$renderer2.push(` <div class="flex gap-2">`);
      push_element($$renderer2, "div", 16, 2);
      $$renderer2.push(`<button class="btn btn-error">`);
      push_element($$renderer2, "button", 17, 4);
      $$renderer2.push(`Decrement</button>`);
      pop_element();
      $$renderer2.push(` <button class="btn btn-primary">`);
      push_element($$renderer2, "button", 24, 4);
      $$renderer2.push(`Increment</button>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    Counter
  );
}
Counter.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var Counter_default = Counter;

// svelte/Navbar.svelte
var Navbar_exports = {};
__export(Navbar_exports, {
  default: () => Navbar_default
});
init_server();

// svelte/UserMenu.svelte
var UserMenu_exports = {};
__export(UserMenu_exports, {
  default: () => UserMenu_default
});
init_server();
UserMenu[FILENAME] = "svelte/UserMenu.svelte";
function UserMenu($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { currentUser } = $$props;
      let isLoggingOut = false;
      function getUserInitials() {
        if (currentUser.name) {
          return currentUser.name.split(" ").map((n) => n.charAt(0)).join("").toUpperCase().slice(0, 2);
        }
        if (currentUser.email) {
          return currentUser.email.charAt(0).toUpperCase();
        }
        return "U";
      }
      async function handleLogout() {
        if (isLoggingOut) return;
        isLoggingOut = true;
        const form = document.createElement("form");
        form.method = "POST";
        form.action = "/auth/logout";
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
        if (csrfToken) {
          const csrfInput = document.createElement("input");
          csrfInput.type = "hidden";
          csrfInput.name = "_csrf_token";
          csrfInput.value = csrfToken;
          form.appendChild(csrfInput);
        }
        const methodInput = document.createElement("input");
        methodInput.type = "hidden";
        methodInput.name = "_method";
        methodInput.value = "DELETE";
        form.appendChild(methodInput);
        document.body.appendChild(form);
        form.submit();
      }
      $$renderer2.push(`<div class="dropdown dropdown-end">`);
      push_element($$renderer2, "div", 53, 0);
      $$renderer2.push(`<button tabindex="0" class="btn btn-ghost btn-circle avatar"${attr("aria-label", `${stringify(currentUser.name || currentUser.email)} account menu`)}>`);
      push_element($$renderer2, "button", 54, 2);
      $$renderer2.push(`<div class="w-10 rounded-full">`);
      push_element($$renderer2, "div", 59, 4);
      if (currentUser.avatarUrl) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<img${attr("src", currentUser.avatarUrl)}${attr("alt", currentUser.name || currentUser.email)}/>`);
        push_element($$renderer2, "img", 61, 8);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
        $$renderer2.push(`<div class="avatar placeholder">`);
        push_element($$renderer2, "div", 66, 8);
        $$renderer2.push(`<div class="bg-primary text-primary-content w-10 rounded-full">`);
        push_element($$renderer2, "div", 67, 10);
        $$renderer2.push(`<span class="text-sm">`);
        push_element($$renderer2, "span", 68, 12);
        $$renderer2.push(`${escape_html(getUserInitials())}</span>`);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
      $$renderer2.push(`</button>`);
      pop_element();
      $$renderer2.push(` <ul tabindex="0" class="menu dropdown-content bg-base-100 rounded-box z-[1] w-52 p-2 shadow mt-3">`);
      push_element($$renderer2, "ul", 75, 2);
      $$renderer2.push(`<li class="menu-title">`);
      push_element($$renderer2, "li", 76, 4);
      $$renderer2.push(`<span>`);
      push_element($$renderer2, "span", 77, 6);
      $$renderer2.push(`${escape_html(currentUser.name || "User")}</span>`);
      pop_element();
      $$renderer2.push(` <span class="text-xs opacity-50">`);
      push_element($$renderer2, "span", 78, 6);
      $$renderer2.push(`@${escape_html(currentUser.username || currentUser.email?.split("@")[0] || "user")}</span>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(` <li>`);
      push_element($$renderer2, "li", 80, 4);
      $$renderer2.push(`<div class="divider my-0">`);
      push_element($$renderer2, "div", 80, 8);
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(` <li>`);
      push_element($$renderer2, "li", 81, 4);
      $$renderer2.push(`<a href="/">`);
      push_element($$renderer2, "a", 82, 6);
      layout_dashboard_default($$renderer2, { class: "w-4 h-4" });
      $$renderer2.push(`<!----> Dashboard</a>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(` <li>`);
      push_element($$renderer2, "li", 87, 4);
      $$renderer2.push(`<a href="/lessons">`);
      push_element($$renderer2, "a", 88, 6);
      book_open_default($$renderer2, { class: "w-4 h-4" });
      $$renderer2.push(`<!----> Courses</a>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(` <li>`);
      push_element($$renderer2, "li", 93, 4);
      $$renderer2.push(`<a href="/romanov-prompts">`);
      push_element($$renderer2, "a", 94, 6);
      bookmark_default($$renderer2, { class: "w-4 h-4" });
      $$renderer2.push(`<!----> Saved</a>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(` <li>`);
      push_element($$renderer2, "li", 99, 4);
      $$renderer2.push(`<a href="/profile">`);
      push_element($$renderer2, "a", 100, 6);
      user_default($$renderer2, { class: "w-4 h-4" });
      $$renderer2.push(`<!----> Profile</a>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(` <li>`);
      push_element($$renderer2, "li", 105, 4);
      $$renderer2.push(`<a href="/settings">`);
      push_element($$renderer2, "a", 106, 6);
      settings_default($$renderer2, { class: "w-4 h-4" });
      $$renderer2.push(`<!----> Settings</a>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(` <li>`);
      push_element($$renderer2, "li", 111, 4);
      $$renderer2.push(`<div class="divider my-0">`);
      push_element($$renderer2, "div", 111, 8);
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(` <li>`);
      push_element($$renderer2, "li", 112, 4);
      $$renderer2.push(`<button${attr("disabled", isLoggingOut, true)}>`);
      push_element($$renderer2, "button", 113, 6);
      if (isLoggingOut) {
        $$renderer2.push("<!--[-->");
        loader_circle_default($$renderer2, { class: "w-4 h-4 animate-spin" });
        $$renderer2.push(`<!----> Logging out...`);
      } else {
        $$renderer2.push("<!--[!-->");
        log_out_default($$renderer2, { class: "w-4 h-4" });
        $$renderer2.push(`<!----> Log out`);
      }
      $$renderer2.push(`<!--]--></button>`);
      pop_element();
      $$renderer2.push(`</li>`);
      pop_element();
      $$renderer2.push(`</ul>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    UserMenu
  );
}
UserMenu.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var UserMenu_default = UserMenu;

// svelte/Navbar.svelte
Navbar[FILENAME] = "svelte/Navbar.svelte";
function Navbar($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { currentPage = "", currentUser = null } = $$props;
      let isScrolled = false;
      let isMenuOpen = false;
      let showAuthModal = false;
      let dropdownRef;
      function handleScroll() {
        isScrolled = window.scrollY > 20;
      }
      function toggleMenu() {
        isMenuOpen = !isMenuOpen;
      }
      function closeMenu() {
        isMenuOpen = false;
      }
      function openAuthModal() {
        showAuthModal = true;
      }
      function handleClickOutside(event2) {
        if (dropdownRef && !dropdownRef.contains(event2.target)) {
          closeMenu();
        }
      }
      let $$settled = true;
      let $$inner_renderer;
      function $$render_inner($$renderer3) {
        $$renderer3.push(`<div${attr_class(`navbar fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${isScrolled ? "bg-base-100/80 backdrop-blur-md border-b border-base-300" : "bg-transparent"}`)}>`);
        push_element($$renderer3, "div", 46, 0);
        $$renderer3.push(`<div class="navbar-start">`);
        push_element($$renderer3, "div", 51, 2);
        $$renderer3.push(`<div${attr_class("dropdown lg:hidden", void 0, { "dropdown-open": isMenuOpen })}>`);
        push_element($$renderer3, "div", 53, 4);
        $$renderer3.push(`<button aria-label="Toggle navigation menu"${attr("aria-expanded", isMenuOpen)} aria-controls="mobile-nav" class="btn btn-ghost">`);
        push_element($$renderer3, "button", 54, 6);
        $$renderer3.push(`<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
        push_element($$renderer3, "svg", 61, 8);
        $$renderer3.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16">`);
        push_element($$renderer3, "path", 62, 10);
        $$renderer3.push(`</path>`);
        pop_element();
        $$renderer3.push(`</svg>`);
        pop_element();
        $$renderer3.push(`</button>`);
        pop_element();
        $$renderer3.push(` `);
        if (isMenuOpen) {
          $$renderer3.push("<!--[-->");
          $$renderer3.push(`<ul id="mobile-nav" class="menu menu-sm dropdown-content bg-base-100 rounded-box z-[1] mt-3 w-52 p-2 shadow">`);
          push_element($$renderer3, "ul", 66, 8);
          $$renderer3.push(`<li>`);
          push_element($$renderer3, "li", 67, 10);
          $$renderer3.push(`<a href="/"${attr_class("", void 0, { "active": currentPage === "home" })}>`);
          push_element($$renderer3, "a", 67, 14);
          $$renderer3.push(`Home</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 68, 10);
          $$renderer3.push(`<a href="/blog"${attr_class("", void 0, { "active": currentPage === "blog" })}>`);
          push_element($$renderer3, "a", 68, 14);
          $$renderer3.push(`Blog</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 69, 10);
          $$renderer3.push(`<a href="/romanov-prompts?category=coding">`);
          push_element($$renderer3, "a", 69, 14);
          $$renderer3.push(`Coding</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 70, 10);
          $$renderer3.push(`<a href="/romanov-prompts?category=ai">`);
          push_element($$renderer3, "a", 70, 14);
          $$renderer3.push(`AI</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 71, 10);
          $$renderer3.push(`<a href="/romanov-prompts?category=n8n">`);
          push_element($$renderer3, "a", 71, 14);
          $$renderer3.push(`n8n</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 72, 10);
          $$renderer3.push(`<a href="/romanov-prompts?category=tools">`);
          push_element($$renderer3, "a", 72, 14);
          $$renderer3.push(`Tools</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 73, 10);
          $$renderer3.push(`<a href="/romanov-prompts"${attr_class("", void 0, { "active": currentPage === "references" })}>`);
          push_element($$renderer3, "a", 73, 14);
          $$renderer3.push(`Prompts</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(`</ul>`);
          pop_element();
        } else {
          $$renderer3.push("<!--[!-->");
        }
        $$renderer3.push(`<!--]--></div>`);
        pop_element();
        $$renderer3.push(` <a href="/" class="btn btn-ghost text-xl font-semibold tracking-tight">`);
        push_element($$renderer3, "a", 79, 4);
        $$renderer3.push(`UrielM<span class="text-base-content/50">`);
        push_element($$renderer3, "span", 80, 12);
        $$renderer3.push(`.dev</span>`);
        pop_element();
        $$renderer3.push(`</a>`);
        pop_element();
        $$renderer3.push(`</div>`);
        pop_element();
        $$renderer3.push(` <div class="navbar-center hidden lg:flex">`);
        push_element($$renderer3, "div", 85, 2);
        $$renderer3.push(`<div class="flex items-center gap-8">`);
        push_element($$renderer3, "div", 86, 4);
        $$renderer3.push(`<a href="/"${attr_class(`font-medium transition-colors ${currentPage === "home" ? "text-primary font-bold" : "text-base-content hover:text-primary"}`)}>`);
        push_element($$renderer3, "a", 87, 6);
        $$renderer3.push(`Home</a>`);
        pop_element();
        $$renderer3.push(` <a href="/blog"${attr_class(`font-medium transition-colors ${currentPage === "blog" ? "text-primary font-bold" : "text-base-content hover:text-primary"}`)}>`);
        push_element($$renderer3, "a", 93, 6);
        $$renderer3.push(`Blog</a>`);
        pop_element();
        $$renderer3.push(` <a href="/romanov-prompts?category=coding" class="font-medium text-base-content hover:text-primary transition-colors">`);
        push_element($$renderer3, "a", 99, 6);
        $$renderer3.push(`Coding</a>`);
        pop_element();
        $$renderer3.push(` <a href="/romanov-prompts?category=ai" class="font-medium text-base-content hover:text-primary transition-colors">`);
        push_element($$renderer3, "a", 105, 6);
        $$renderer3.push(`AI</a>`);
        pop_element();
        $$renderer3.push(` <a href="/romanov-prompts?category=n8n" class="font-medium text-base-content hover:text-primary transition-colors">`);
        push_element($$renderer3, "a", 111, 6);
        $$renderer3.push(`n8n</a>`);
        pop_element();
        $$renderer3.push(` <a href="/romanov-prompts?category=tools" class="font-medium text-base-content hover:text-primary transition-colors">`);
        push_element($$renderer3, "a", 117, 6);
        $$renderer3.push(`Tools</a>`);
        pop_element();
        $$renderer3.push(` <a href="/romanov-prompts"${attr_class(`font-medium transition-colors ${currentPage === "references" ? "text-primary font-bold" : "text-base-content hover:text-primary"}`)}>`);
        push_element($$renderer3, "a", 123, 6);
        $$renderer3.push(`Prompts</a>`);
        pop_element();
        $$renderer3.push(`</div>`);
        pop_element();
        $$renderer3.push(`</div>`);
        pop_element();
        $$renderer3.push(` <div class="navbar-end gap-2">`);
        push_element($$renderer3, "div", 133, 2);
        if (currentUser) {
          $$renderer3.push("<!--[-->");
          UserMenu_default($$renderer3, { currentUser });
        } else {
          $$renderer3.push("<!--[!-->");
          $$renderer3.push(`<button class="btn btn-sm btn-primary rounded-full px-6">`);
          push_element($$renderer3, "button", 137, 6);
          $$renderer3.push(`Sign In</button>`);
          pop_element();
        }
        $$renderer3.push(`<!--]--></div>`);
        pop_element();
        $$renderer3.push(`</div>`);
        pop_element();
        $$renderer3.push(` `);
        AuthModal_default($$renderer3, {
          get isOpen() {
            return showAuthModal;
          },
          set isOpen($$value) {
            showAuthModal = $$value;
            $$settled = false;
          }
        });
        $$renderer3.push(`<!---->`);
      }
      do {
        $$settled = true;
        $$inner_renderer = $$renderer2.copy();
        $$render_inner($$inner_renderer);
      } while (!$$settled);
      $$renderer2.subsume($$inner_renderer);
    },
    Navbar
  );
}
Navbar.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var Navbar_default = Navbar;

// svelte/SubNav.svelte
var SubNav_exports = {};
__export(SubNav_exports, {
  default: () => SubNav_default
});
init_server();
SubNav[FILENAME] = "svelte/SubNav.svelte";
function SubNav($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { activeFilter = "all", categories = [], live } = $$props;
      function selectFilter(filter) {
        live.pushEvent("filter_changed", { category: filter });
      }
      $$renderer2.push(`<div class="bg-base-100 border-b border-base-300">`);
      push_element($$renderer2, "div", 9, 0);
      $$renderer2.push(`<div class="container mx-auto px-4">`);
      push_element($$renderer2, "div", 10, 2);
      $$renderer2.push(`<div class="tabs tabs-bordered overflow-x-auto scrollbar-hide" aria-label="Reference filters" role="tablist">`);
      push_element($$renderer2, "div", 11, 4);
      $$renderer2.push(`<button type="button" role="tab"${attr("aria-selected", activeFilter === "all")}${attr_class(`tab tab-sm sm:tab-md whitespace-nowrap transition-colors duration-200 hover:text-primary ${activeFilter === "all" ? "tab-active" : ""}`)}>`);
      push_element($$renderer2, "button", 12, 6);
      $$renderer2.push(`All</button>`);
      pop_element();
      $$renderer2.push(` <!--[-->`);
      const each_array = ensure_array_like(categories);
      for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
        let category = each_array[$$index];
        $$renderer2.push(`<button type="button" role="tab"${attr("aria-selected", activeFilter === category)}${attr_class(`tab tab-sm sm:tab-md whitespace-nowrap capitalize transition-colors duration-200 hover:text-primary ${activeFilter === category ? "tab-active" : ""}`)}>`);
        push_element($$renderer2, "button", 22, 8);
        $$renderer2.push(`${escape_html(category)}</button>`);
        pop_element();
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    SubNav
  );
}
SubNav.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var SubNav_default = SubNav;

// svelte/ThemeSelector.svelte
var ThemeSelector_exports = {};
__export(ThemeSelector_exports, {
  default: () => ThemeSelector_default
});
init_server();
ThemeSelector[FILENAME] = "svelte/ThemeSelector.svelte";
var $$css2 = {
  hash: "svelte-k618ps",
  code: "\n  .theme-selector.svelte-k618ps {\n    user-select: none;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGhlbWVTZWxlY3Rvci5zdmVsdGUiLCJzb3VyY2VzIjpbIlRoZW1lU2VsZWN0b3Iuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGNvbnN0IHRoZW1lcyA9IFtcbiAgICB7IHZhbHVlOiAnbGlnaHQnLCBsYWJlbDogJ0xpZ2h0JywgaWNvbjogJ+KYgO+4jycgfSxcbiAgICB7IHZhbHVlOiAnZGFyaycsIGxhYmVsOiAnRGFyaycsIGljb246ICfwn4yZJyB9LFxuICAgIHsgdmFsdWU6ICdkcmFjdWxhJywgbGFiZWw6ICdEcmFjdWxhJywgaWNvbjogJ/Cfp5snIH0sXG4gICAgeyB2YWx1ZTogJ3N5bnRod2F2ZScsIGxhYmVsOiAnU3ludGh3YXZlJywgaWNvbjogJ/CfjIYnIH0sXG4gICAgeyB2YWx1ZTogJ2J1c2luZXNzJywgbGFiZWw6ICdCdXNpbmVzcycsIGljb246ICfwn5K8JyB9LFxuICAgIHsgdmFsdWU6ICdkaW0nLCBsYWJlbDogJ0RpbScsIGljb246ICfwn4yRJyB9XG4gIF1cblxuICBsZXQgY3VycmVudFRoZW1lID0gJHN0YXRlKCdkYXJrJylcbiAgbGV0IGlzT3BlbiA9ICRzdGF0ZShmYWxzZSlcblxuICBmdW5jdGlvbiBhcHBseVRoZW1lKHRoZW1lKSB7XG4gICAgY3VycmVudFRoZW1lID0gdGhlbWVcbiAgICBpZiAodGhlbWUgPT09ICdzeXN0ZW0nKSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRoZW1lJylcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwaHg6dGhlbWUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJywgdGhlbWUpXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgc3RvcmFnZSBrZXkgYXMgUGhvZW5peCArIG90aGVyIHRvZ2dsZXNcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwaHg6dGhlbWUnLCB0aGVtZSlcbiAgICB9XG4gICAgLy8gTm90aWZ5IGxpc3RlbmVycyAoZS5nLiwgUGhvZW5peCBoZWFkIHNjcmlwdClcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3BoeDpzZXQtdGhlbWUnLCB7IGRldGFpbDogeyB0aGVtZSB9IH0pKVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0VGhlbWUodGhlbWUpIHtcbiAgICBhcHBseVRoZW1lKHRoZW1lKVxuICAgIGlzT3BlbiA9IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVEcm9wZG93bigpIHtcbiAgICBpc09wZW4gPSAhaXNPcGVuXG4gIH1cblxuICAvLyBDbG9zZSBkcm9wZG93biB3aGVuIGNsaWNraW5nIG91dHNpZGVcbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQuY2xvc2VzdCgnLnRoZW1lLXNlbGVjdG9yJykpIHtcbiAgICAgIGlzT3BlbiA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3luYyBmcm9tIHBhZ2UvaGVhZCBpbml0aWFsaXphdGlvblxuICAgIGNvbnN0IHNhdmVkVGhlbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGh4OnRoZW1lJykgfHwgJ3N5c3RlbSdcbiAgICBpZiAoc2F2ZWRUaGVtZSA9PT0gJ3N5c3RlbScpIHtcbiAgICAgIGN1cnJlbnRUaGVtZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKSB8fCAnbGlnaHQnXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRUaGVtZSA9IHNhdmVkVGhlbWVcbiAgICB9XG5cbiAgICAvLyBLZWVwIGluIHN5bmMgd2l0aCBvdGhlciBjb250cm9scyAoTGF5b3V0cy50aGVtZV90b2dnbGUsIG90aGVyIHRhYnMpXG4gICAgY29uc3Qgc3RvcmFnZUhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSAncGh4OnRoZW1lJykge1xuICAgICAgICBjb25zdCBuZXh0ID0gZS5uZXdWYWx1ZSB8fCAnc3lzdGVtJ1xuICAgICAgICBjdXJyZW50VGhlbWUgPSBuZXh0ID09PSAnc3lzdGVtJyA/IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJykgfHwgJ2xpZ2h0JykgOiBuZXh0XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRoZW1lRXZlbnRIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLmRldGFpbD8udGhlbWUgPz8gZS50YXJnZXQ/LmRhdGFzZXQ/LnBoeFRoZW1lID8/ICdzeXN0ZW0nXG4gICAgICBjdXJyZW50VGhlbWUgPSBuZXh0ID09PSAnc3lzdGVtJyA/IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJykgfHwgJ2xpZ2h0JykgOiBuZXh0XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGlja091dHNpZGUpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBzdG9yYWdlSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGh4OnNldC10aGVtZScsIHRoZW1lRXZlbnRIYW5kbGVyKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrT3V0c2lkZSlcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgc3RvcmFnZUhhbmRsZXIpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGh4OnNldC10aGVtZScsIHRoZW1lRXZlbnRIYW5kbGVyKVxuICAgIH1cbiAgfSlcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwidGhlbWUtc2VsZWN0b3IgcmVsYXRpdmVcIj5cbiAgPGJ1dHRvblxuICAgIG9uY2xpY2s9e3RvZ2dsZURyb3Bkb3dufVxuICAgIGNsYXNzPVwiYnRuIGJ0bi1naG9zdCBidG4tc20gZ2FwLTJcIlxuICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgdGhlbWVcIlxuICA+XG4gICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LWxnXCI+e3RoZW1lcy5maW5kKHQgPT4gdC52YWx1ZSA9PT0gY3VycmVudFRoZW1lKT8uaWNvbiB8fCAn8J+MmSd9PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiaGlkZGVuIG1kOmlubGluZVwiPlRoZW1lPC9zcGFuPlxuICAgIDxzdmdcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgY2xhc3M9XCJoLTQgdy00IHRyYW5zaXRpb24tdHJhbnNmb3JtIHtpc09wZW4gPyAncm90YXRlLTE4MCcgOiAnJ31cIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgID5cbiAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE5IDlsLTcgNy03LTdcIiAvPlxuICAgIDwvc3ZnPlxuICA8L2J1dHRvbj5cblxuICB7I2lmIGlzT3Blbn1cbiAgICA8ZGl2IGNsYXNzPVwiYWJzb2x1dGUgcmlnaHQtMCBtdC0yIHctNDggYmctYmFzZS0yMDAgcm91bmRlZC1sZyBzaGFkb3cteGwgYm9yZGVyIGJvcmRlci1iYXNlLTMwMCB6LTUwXCI+XG4gICAgICA8dWwgY2xhc3M9XCJtZW51IHAtMlwiPlxuICAgICAgICB7I2VhY2ggdGhlbWVzIGFzIHRoZW1lfVxuICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgb25jbGljaz17KCkgPT4gc2VsZWN0VGhlbWUodGhlbWUudmFsdWUpfVxuICAgICAgICAgICAgICBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zIHtjdXJyZW50VGhlbWUgPT09IHRoZW1lLnZhbHVlID8gJ2FjdGl2ZSBiZy1wcmltYXJ5IHRleHQtcHJpbWFyeS1jb250ZW50JyA6ICcnfVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC1sZ1wiPnt0aGVtZS5pY29ufTwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4+e3RoZW1lLmxhYmVsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgeyNpZiBjdXJyZW50VGhlbWUgPT09IHRoZW1lLnZhbHVlfVxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoLTQgdy00IG1sLWF1dG9cIlxuICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUgMTNsNCA0TDE5IDdcIiAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgey9lYWNofVxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgey9pZn1cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC50aGVtZS1zZWxlY3RvciB7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQTZIQSxFQUFFLDZCQUFlLENBQUM7QUFDbEIsSUFBSSxpQkFBaUI7QUFDckIiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function ThemeSelector($$renderer, $$props) {
  $$renderer.global.css.add($$css2);
  $$renderer.component(
    ($$renderer2) => {
      const themes = [
        { value: "light", label: "Light", icon: "\u2600\uFE0F" },
        { value: "dark", label: "Dark", icon: "\u{1F319}" },
        { value: "dracula", label: "Dracula", icon: "\u{1F9DB}" },
        { value: "synthwave", label: "Synthwave", icon: "\u{1F306}" },
        { value: "business", label: "Business", icon: "\u{1F4BC}" },
        { value: "dim", label: "Dim", icon: "\u{1F311}" }
      ];
      let currentTheme = "dark";
      let isOpen = false;
      function applyTheme(theme) {
        currentTheme = theme;
        if (theme === "system") {
          document.documentElement.removeAttribute("data-theme");
          localStorage.removeItem("phx:theme");
        } else {
          document.documentElement.setAttribute("data-theme", theme);
          localStorage.setItem("phx:theme", theme);
        }
        window.dispatchEvent(new CustomEvent("phx:set-theme", { detail: { theme } }));
      }
      function selectTheme(theme) {
        applyTheme(theme);
        isOpen = false;
      }
      function toggleDropdown() {
        isOpen = !isOpen;
      }
      function handleClickOutside(event2) {
        if (!event2.target.closest(".theme-selector")) {
          isOpen = false;
        }
      }
      $$renderer2.push(`<div class="theme-selector relative svelte-k618ps">`);
      push_element($$renderer2, "div", 76, 0);
      $$renderer2.push(`<button class="btn btn-ghost btn-sm gap-2" aria-label="Select theme">`);
      push_element($$renderer2, "button", 77, 2);
      $$renderer2.push(`<span class="text-lg">`);
      push_element($$renderer2, "span", 82, 4);
      $$renderer2.push(`${escape_html(
        // Sync from page/head initialization
        // Keep in sync with other controls (Layouts.theme_toggle, other tabs)
        themes.find((t) => t.value === currentTheme)?.icon || "\u{1F319}"
      )}</span>`);
      pop_element();
      $$renderer2.push(` <span class="hidden md:inline">`);
      push_element($$renderer2, "span", 83, 4);
      $$renderer2.push(`Theme</span>`);
      pop_element();
      $$renderer2.push(` <svg xmlns="http://www.w3.org/2000/svg"${attr_class(`h-4 w-4 transition-transform ${stringify(isOpen ? "rotate-180" : "")}`)} fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
      push_element($$renderer2, "svg", 84, 4);
      $$renderer2.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">`);
      push_element($$renderer2, "path", 91, 6);
      $$renderer2.push(`</path>`);
      pop_element();
      $$renderer2.push(`</svg>`);
      pop_element();
      $$renderer2.push(`</button>`);
      pop_element();
      $$renderer2.push(` `);
      if (isOpen) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="absolute right-0 mt-2 w-48 bg-base-200 rounded-lg shadow-xl border border-base-300 z-50">`);
        push_element($$renderer2, "div", 96, 4);
        $$renderer2.push(`<ul class="menu p-2">`);
        push_element($$renderer2, "ul", 97, 6);
        $$renderer2.push(`<!--[-->`);
        const each_array = ensure_array_like(themes);
        for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
          let theme = each_array[$$index];
          $$renderer2.push(`<li>`);
          push_element($$renderer2, "li", 99, 10);
          $$renderer2.push(`<button${attr_class(`flex items-center gap-3 ${stringify(currentTheme === theme.value ? "active bg-primary text-primary-content" : "")}`)}>`);
          push_element($$renderer2, "button", 100, 12);
          $$renderer2.push(`<span class="text-lg">`);
          push_element($$renderer2, "span", 104, 14);
          $$renderer2.push(`${escape_html(theme.icon)}</span>`);
          pop_element();
          $$renderer2.push(` <span>`);
          push_element($$renderer2, "span", 105, 14);
          $$renderer2.push(`${escape_html(theme.label)}</span>`);
          pop_element();
          $$renderer2.push(` `);
          if (currentTheme === theme.value) {
            $$renderer2.push("<!--[-->");
            $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
            push_element($$renderer2, "svg", 107, 16);
            $$renderer2.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7">`);
            push_element($$renderer2, "path", 114, 18);
            $$renderer2.push(`</path>`);
            pop_element();
            $$renderer2.push(`</svg>`);
            pop_element();
          } else {
            $$renderer2.push("<!--[!-->");
          }
          $$renderer2.push(`<!--]--></button>`);
          pop_element();
          $$renderer2.push(`</li>`);
          pop_element();
        }
        $$renderer2.push(`<!--]--></ul>`);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
    },
    ThemeSelector
  );
}
ThemeSelector.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var ThemeSelector_default = ThemeSelector;

// svelte/ThemeToggle.svelte
var ThemeToggle_exports = {};
__export(ThemeToggle_exports, {
  default: () => ThemeToggle_default
});
init_server();
ThemeToggle[FILENAME] = "svelte/ThemeToggle.svelte";
function ThemeToggle($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let currentTheme = "light";
      function toggleTheme() {
        const newTheme = currentTheme === "light" ? "dark" : "light";
        currentTheme = newTheme;
        document.documentElement.setAttribute("data-theme", newTheme);
        localStorage.setItem("phx:theme", newTheme);
        window.dispatchEvent(new CustomEvent("phx:set-theme", { detail: { theme: newTheme } }));
      }
      $$renderer2.push(`<button class="btn btn-ghost btn-circle btn-sm" aria-label="Toggle theme">`);
      push_element($$renderer2, "button", 28, 0);
      if (
        // Get initial theme
        currentTheme === "light"
      ) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">`);
        push_element($$renderer2, "svg", 35, 4);
        $$renderer2.push(`<path fill-rule="evenodd" d="M7.455 2.004a.75.75 0 01.26.77 7 7 0 009.958 7.967.75.75 0 011.067.853A8.5 8.5 0 116.647 1.921a.75.75 0 01.808.083z" clip-rule="evenodd">`);
        push_element($$renderer2, "path", 36, 6);
        $$renderer2.push(`</path>`);
        pop_element();
        $$renderer2.push(`</svg>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
        $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">`);
        push_element($$renderer2, "svg", 40, 4);
        $$renderer2.push(`<path d="M10 2a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 2zM10 15a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 15zM10 7a3 3 0 100 6 3 3 0 000-6zM15.657 5.404a.75.75 0 10-1.06-1.06l-1.061 1.06a.75.75 0 001.06 1.06l1.06-1.06zM6.464 14.596a.75.75 0 10-1.06-1.06l-1.06 1.06a.75.75 0 001.06 1.06l1.06-1.06zM18 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0118 10zM5 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 015 10zM14.596 15.657a.75.75 0 001.06-1.06l-1.06-1.061a.75.75 0 10-1.06 1.06l1.06 1.06zM5.404 6.464a.75.75 0 001.06-1.06l-1.06-1.06a.75.75 0 10-1.061 1.06l1.06 1.06z">`);
        push_element($$renderer2, "path", 41, 6);
        $$renderer2.push(`</path>`);
        pop_element();
        $$renderer2.push(`</svg>`);
        pop_element();
      }
      $$renderer2.push(`<!--]--></button>`);
      pop_element();
    },
    ThemeToggle
  );
}
ThemeToggle.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var ThemeToggle_default = ThemeToggle;

// svelte/WorkflowStatusCard.svelte
var WorkflowStatusCard_exports = {};
__export(WorkflowStatusCard_exports, {
  default: () => WorkflowStatusCard_default
});
init_server();
WorkflowStatusCard[FILENAME] = "svelte/WorkflowStatusCard.svelte";
function WorkflowStatusCard($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { delay = 0 } = $$props;
      $$renderer2.push(`<div class="absolute hidden lg:block bottom-20 right-10 xl:right-32 w-auto bg-base-100/40 backdrop-blur-xl border border-base-300/50 shadow-[0_20px_40px_-15px_rgba(0,0,0,0.1)] rounded-2xl p-4 animate-float rotate-[3deg]"${attr_style(`animation-delay: ${stringify(delay)}s`)}>`);
      push_element($$renderer2, "div", 5, 0);
      $$renderer2.push(`<div class="flex items-center space-x-3 pr-2">`);
      push_element($$renderer2, "div", 9, 2);
      $$renderer2.push(`<div class="w-10 h-10 rounded-xl bg-[#EA4B71] flex items-center justify-center text-white shadow-lg shadow-pink-500/20">`);
      push_element($$renderer2, "div", 10, 4);
      $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">`);
      push_element($$renderer2, "svg", 11, 6);
      $$renderer2.push(`<path fill-rule="evenodd" d="M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm1.23-3.723a.75.75 0 00.219-.53V2.929a.75.75 0 00-1.5 0V5.36l-.31-.31A7 7 0 003.239 8.188a.75.75 0 101.448.389A5.5 5.5 0 0113.89 6.11l.311.31h-2.432a.75.75 0 000 1.5h4.243a.75.75 0 00.53-.219z" clip-rule="evenodd">`);
      push_element($$renderer2, "path", 12, 8);
      $$renderer2.push(`</path>`);
      pop_element();
      $$renderer2.push(`</svg>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="text-left">`);
      push_element($$renderer2, "div", 15, 4);
      $$renderer2.push(`<div class="text-xs text-base-content/60 font-medium">`);
      push_element($$renderer2, "div", 16, 6);
      $$renderer2.push(`Active Workflow</div>`);
      pop_element();
      $$renderer2.push(` <div class="text-sm font-bold text-base-content">`);
      push_element($$renderer2, "div", 17, 6);
      $$renderer2.push(`Lead Gen Bot \xB7 Running</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    WorkflowStatusCard
  );
}
WorkflowStatusCard.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var WorkflowStatusCard_default = WorkflowStatusCard;

// svelte/lib/youtube/YouTubePlayer.svelte
var YouTubePlayer_exports = {};
__export(YouTubePlayer_exports, {
  default: () => YouTubePlayer_default
});
init_server();
init_index_server();
YouTubePlayer[FILENAME] = "svelte/lib/youtube/YouTubePlayer.svelte";
function YouTubePlayer($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const YT_SRC = "https://www.youtube.com/iframe_api";
      const dispatcher = createEventDispatcher();
      let videoId = $$props["videoId"];
      let startSeconds = fallback($$props["startSeconds"], null);
      let autoplay = fallback($$props["autoplay"], false);
      let controls = fallback($$props["controls"], true);
      let rel = fallback($$props["rel"], false);
      let modestBranding = fallback($$props["modestBranding"], true);
      let loop2 = fallback($$props["loop"], false);
      let playTrigger = fallback($$props["playTrigger"], null);
      let pauseTrigger = fallback($$props["pauseTrigger"], null);
      let seekToSeconds = fallback($$props["seekToSeconds"], null);
      let container;
      let player;
      let playerReady = false;
      let scriptLoaded = false;
      let destroyed = false;
      let playerId = `yt-player-${Math.random().toString(36).substr(2, 9)}`;
      function ensureYouTubeScript() {
        return new Promise((resolve, reject) => {
          if (window.YT && window.YT.Player) {
            scriptLoaded = true;
            return resolve();
          }
          const existing = document.querySelector(`script[src="${YT_SRC}"]`);
          if (existing) {
            const checkReady = setInterval(
              () => {
                if (window.YT && window.YT.Player) {
                  scriptLoaded = true;
                  clearInterval(checkReady);
                  resolve();
                }
              },
              100
            );
            return;
          }
          const tag2 = document.createElement("script");
          tag2.src = YT_SRC;
          tag2.async = true;
          window.onYouTubeIframeAPIReady = () => {
            scriptLoaded = true;
            resolve();
          };
          tag2.onerror = (err) => reject(err);
          document.head.appendChild(tag2);
        });
      }
      function createPlayer() {
        if (!scriptLoaded || !container || !videoId || destroyed) return;
        const YT = window.YT;
        player = new YT.Player(container, {
          width: "100%",
          height: "100%",
          videoId,
          playerVars: {
            autoplay: autoplay ? 1 : 0,
            controls: controls ? 1 : 0,
            rel: rel ? 1 : 0,
            modestbranding: modestBranding ? 1 : 0,
            loop: loop2 ? 1 : 0,
            playlist: loop2 ? videoId : void 0,
            start: startSeconds !== null && startSeconds !== void 0 ? startSeconds : void 0
          },
          events: {
            onReady: onPlayerReady,
            onStateChange: onPlayerStateChange,
            onError: onPlayerError
          }
        });
      }
      function onPlayerReady(event2) {
        var _a;
        playerReady = true;
        dispatcher("ready", {
          duration: (_a = player.getDuration) === null || _a === void 0 ? void 0 : _a.call(player)
        });
        if (autoplay) {
          player.playVideo();
        }
      }
      function onPlayerStateChange(event2) {
        const state2 = event2.data;
        dispatcher("stateChange", {
          state: state2,
          currentTime: safeGetCurrentTime(),
          duration: safeGetDuration()
        });
        if (state2 === 1) dispatcher("play");
        if (state2 === 2) dispatcher("pause");
        if (state2 === 0) dispatcher("ended");
      }
      function onPlayerError(event2) {
        dispatcher("error", { code: event2.data });
      }
      function safeGetCurrentTime() {
        try {
          return (player === null || player === void 0 ? void 0 : player.getCurrentTime) ? player.getCurrentTime() : null;
        } catch (_) {
          return null;
        }
      }
      function safeGetDuration() {
        try {
          return (player === null || player === void 0 ? void 0 : player.getDuration) ? player.getDuration() : null;
        } catch (_) {
          return null;
        }
      }
      noop(() => __awaiter(void 0, void 0, void 0, function* () {
        yield ensureYouTubeScript();
        createPlayer();
      }));
      onDestroy(() => {
        var _a;
        destroyed = true;
        try {
          (_a = player === null || player === void 0 ? void 0 : player.destroy) === null || _a === void 0 ? void 0 : _a.call(player);
        } catch (_) {
        }
      });
      $: if (playerReady && playTrigger !== null) {
        player.playVideo();
      }
      $: if (playerReady && pauseTrigger !== null) {
        player.pauseVideo();
      }
      $: if (playerReady && seekToSeconds !== null) {
        player.seekTo(seekToSeconds, true);
      }
      $$renderer2.push(`<div${attr("playerid", playerId)} style="width: 100%; height: 100%;">`);
      push_element($$renderer2, "div", 148, 0);
      $$renderer2.push(`</div>`);
      pop_element();
      bind_props($$props, {
        videoId,
        startSeconds,
        autoplay,
        controls,
        rel,
        modestBranding,
        loop: loop2,
        playTrigger,
        pauseTrigger,
        seekToSeconds
      });
    },
    YouTubePlayer
  );
}
YouTubePlayer.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var YouTubePlayer_default = YouTubePlayer;

// import-glob:../svelte/**/*.svelte
var modules = [AuthModal_exports, ChatWindow_exports, CodeSnippetCard_exports, Counter_exports, GoogleSignInButton_exports, Navbar_exports, SubNav_exports, ThemeSelector_exports, ThemeToggle_exports, UserMenu_exports, WorkflowStatusCard_exports, YouTubePlayer_exports];
var __default = modules;
var filenames = ["../svelte/AuthModal.svelte", "../svelte/ChatWindow.svelte", "../svelte/CodeSnippetCard.svelte", "../svelte/Counter.svelte", "../svelte/GoogleSignInButton.svelte", "../svelte/Navbar.svelte", "../svelte/SubNav.svelte", "../svelte/ThemeSelector.svelte", "../svelte/ThemeToggle.svelte", "../svelte/UserMenu.svelte", "../svelte/WorkflowStatusCard.svelte", "../svelte/lib/youtube/YouTubePlayer.svelte"];

// js/server.js
var import_live_svelte = __toESM(require_live_svelte_cjs());
var render2 = (0, import_live_svelte.getRender)(__exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  render
});
/*! Bundled license information:

lucide-svelte/dist/defaultAttributes.js:
lucide-svelte/dist/icons/index.js:
lucide-svelte/dist/icons/loader-2.js:
lucide-svelte/dist/aliases/aliases.js:
  (**
   * @license lucide-svelte v0.556.0 - ISC
   *
   * ISC License
   * 
   * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
   * 
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   * 
   * ---
   * 
   * The MIT License (MIT) (for portions derived from Feather)
   * 
   * Copyright (c) 2013-2023 Cole Bemis
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

lucide-svelte/dist/icons/book-open.svelte:
lucide-svelte/dist/icons/bookmark.svelte:
lucide-svelte/dist/icons/eye-off.svelte:
lucide-svelte/dist/icons/eye.svelte:
lucide-svelte/dist/icons/layout-dashboard.svelte:
lucide-svelte/dist/icons/loader-circle.svelte:
lucide-svelte/dist/icons/log-out.svelte:
lucide-svelte/dist/icons/settings.svelte:
lucide-svelte/dist/icons/user.svelte:
lucide-svelte/dist/icons/x.svelte:
  (**
   * @license lucide-svelte v0.556.0 - ISC
   *
   * ISC License
   *
   * Copyright (c) for portions of Lucide are held by Cole Bemis 2013-2023 as part of Feather (MIT). All other copyright (c) for Lucide are held by Lucide Contributors 2025.
   *
   * Permission to use, copy, modify, and/or distribute this software for any
   * purpose with or without fee is hereby granted, provided that the above
   * copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * ---
   *
   * The MIT License (MIT) (for portions derived from Feather)
   *
   * Copyright (c) 2013-2023 Cole Bemis
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2NvbnN0YW50cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvZXNjYXBpbmcuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9hdHRyaWJ1dGVzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9lc20tZW52L2ZhbHNlLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZXNtLWVudi90cnVlLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZXNtLWVudi9pbmRleC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2NvbnN0YW50cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvc2hhcmVkL2Vycm9ycy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Vycm9ycy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3dhcm5pbmdzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2h5ZHJhdGlvbi5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZXF1YWxpdHkuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2ZsYWdzL2luZGV4LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvd2FybmluZ3MuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9jbG9uZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi90cmFjaW5nLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvZGV2LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS90YXNrLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZXJyb3ItaGFuZGxpbmcuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2JhdGNoLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9yZWFjdGl2aXR5L2NyZWF0ZS1zdWJzY3JpYmVyLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvZWFjaC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvYXN5bmMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zb3VyY2VzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcHJveHkuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvZXF1YWxpdHkuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vb3BlcmF0aW9ucy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9taXNjLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NoYXJlZC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZWZmZWN0cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2xlZ2FjeS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2F0dGFjaG1lbnRzL2luZGV4LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy91dGlscy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi9hc3NpZ24uanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvY3NzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2VsZW1lbnRzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2V2ZW50cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9yZWNvbmNpbGVyLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL3RlbXBsYXRlLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVuZGVyLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2htci5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi9vd25lcnNoaXAuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvbGVnYWN5LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2luc3BlY3QuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2FzeW5jLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L3ZhbGlkYXRpb24uanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2JyYW5jaGVzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9hd2FpdC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvaWYuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2tleS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvY3NzLXByb3BzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9odG1sLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbG90LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdmFsaWRhdGUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3NuaXBwZXQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1jb21wb25lbnQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1lbGVtZW50LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zdmVsdGUtaGVhZC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9jc3MuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYWN0aW9ucy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9hdHRhY2htZW50cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9jbGFzcy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9zdHlsZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zZWxlY3QuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYXR0cmlidXRlcy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3RpbWluZy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2xvb3AuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvdHJhbnNpdGlvbnMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvZG9jdW1lbnQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvaW5wdXQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvbWVkaWEuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvbmF2aWdhdG9yLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3Byb3BzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NpemUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvdGhpcy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy91bml2ZXJzYWwuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3Mvd2luZG93LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2xlZ2FjeS9ldmVudC1tb2RpZmllcnMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vbGVnYWN5L2xpZmVjeWNsZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbWlzYy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvc2hhcmVkL2luZGV4LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zdG9yZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvcHJvcHMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC92YWxpZGF0ZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvbGVnYWN5L2xlZ2FjeS1jbGllbnQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvY3VzdG9tLWVsZW1lbnQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvY29uc29sZS1sb2cuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2h5ZHJhdGFibGUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2luZGV4LWNsaWVudC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvdXRpbHMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9oeWRyYXRpb24uanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9hYm9ydC1zaWduYWwuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9lcnJvcnMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9jb250ZXh0LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvd2FybmluZ3MuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9yZW5kZXItY29udGV4dC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvc2VydmVyL3JlbmRlcmVyLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvYmxvY2tzL2h0bWwuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2h0bWwtdHJlZS12YWxpZGF0aW9uLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvZGV2LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvaW5kZXguanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9kZXZhbHVlL3NyYy91dGlscy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RldmFsdWUvc3JjL3VuZXZhbC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RldmFsdWUvaW5kZXguanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9oeWRyYXRhYmxlLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvYmxvY2tzL3NuaXBwZXQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2luZGV4LXNlcnZlci5qcyIsICIuLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvaW5kZXguanMiLCAiLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3V0aWxzLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9jb25zdGFudHMuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3B1c2guanMiLCAiLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3RpbWVyLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9jaGFubmVsLmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9hamF4LmpzIiwgIi4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9sb25ncG9sbC5qcyIsICIuLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvcHJlc2VuY2UuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3NlcmlhbGl6ZXIuanMiLCAiLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3NvY2tldC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc2VydmVyL2luZGV4LmpzIiwgIi4uLy4uL2RlcHMvbGl2ZV9zdmVsdGUvYXNzZXRzL2pzL2xpdmVfc3ZlbHRlL2luZGV4LmpzIiwgIi4uLy4uL2RlcHMvbGl2ZV9zdmVsdGUvYXNzZXRzL2pzL2xpdmVfc3ZlbHRlL3V0aWxzLmpzIiwgIi4uLy4uL2RlcHMvbGl2ZV9zdmVsdGUvYXNzZXRzL2pzL2xpdmVfc3ZlbHRlL3JlbmRlci5qcyIsICIuLi8uLi9kZXBzL2xpdmVfc3ZlbHRlL2Fzc2V0cy9qcy9saXZlX3N2ZWx0ZS9ob29rcy5zdmVsdGUuanMiLCAiLi4vLi4vYXNzZXRzL2pzL3NlcnZlci5qcyIsICJpbXBvcnQtZ2xvYjouLi9zdmVsdGUvKiovKi5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvSWNvbi5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvaWNvbnMvYm9vay1vcGVuLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdmVsdGUvZGlzdC9pY29ucy9ib29rbWFyay5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvaWNvbnMvZXllLW9mZi5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvaWNvbnMvZXllLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdmVsdGUvZGlzdC9pY29ucy9sYXlvdXQtZGFzaGJvYXJkLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdmVsdGUvZGlzdC9pY29ucy9sb2FkZXItY2lyY2xlLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdmVsdGUvZGlzdC9pY29ucy9sb2ctb3V0LnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdmVsdGUvZGlzdC9pY29ucy9zZXR0aW5ncy5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvaWNvbnMvdXNlci5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9sdWNpZGUtc3ZlbHRlL2Rpc3QvaWNvbnMveC5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL3N2ZWx0ZS9Hb29nbGVTaWduSW5CdXR0b24uc3ZlbHRlIiwgIi4uLy4uL2Fzc2V0cy9zdmVsdGUvQXV0aE1vZGFsLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL0NoYXRXaW5kb3cuc3ZlbHRlIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy90cmFuc2l0aW9uL2luZGV4LmpzIiwgIi4uLy4uL2Fzc2V0cy9zdmVsdGUvQ29kZVNuaXBwZXRDYXJkLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL0NvdW50ZXIuc3ZlbHRlIiwgIi4uLy4uL2Fzc2V0cy9zdmVsdGUvVXNlck1lbnUuc3ZlbHRlIiwgIi4uLy4uL2Fzc2V0cy9zdmVsdGUvTmF2YmFyLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL1N1Yk5hdi5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL3N2ZWx0ZS9UaGVtZVNlbGVjdG9yLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL1RoZW1lVG9nZ2xlLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL1dvcmtmbG93U3RhdHVzQ2FyZC5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL3N2ZWx0ZS9saWIveW91dHViZS9Zb3VUdWJlUGxheWVyLnN2ZWx0ZSJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiZXhwb3J0IGNvbnN0IEVBQ0hfSVRFTV9SRUFDVElWRSA9IDE7XG5leHBvcnQgY29uc3QgRUFDSF9JTkRFWF9SRUFDVElWRSA9IDEgPDwgMTtcbi8qKiBTZWUgRWFjaEJsb2NrIGludGVyZmFjZSBtZXRhZGF0YS5pc19jb250cm9sbGVkIGZvciBhbiBleHBsYW5hdGlvbiB3aGF0IHRoaXMgaXMgKi9cbmV4cG9ydCBjb25zdCBFQUNIX0lTX0NPTlRST0xMRUQgPSAxIDw8IDI7XG5leHBvcnQgY29uc3QgRUFDSF9JU19BTklNQVRFRCA9IDEgPDwgMztcbmV4cG9ydCBjb25zdCBFQUNIX0lURU1fSU1NVVRBQkxFID0gMSA8PCA0O1xuXG5leHBvcnQgY29uc3QgUFJPUFNfSVNfSU1NVVRBQkxFID0gMTtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19SVU5FUyA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19VUERBVEVEID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0JJTkRBQkxFID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0xBWllfSU5JVElBTCA9IDEgPDwgNDtcblxuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fSU4gPSAxO1xuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fT1VUID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fR0xPQkFMID0gMSA8PCAyO1xuXG5leHBvcnQgY29uc3QgVEVNUExBVEVfRlJBR01FTlQgPSAxO1xuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBURU1QTEFURV9VU0VfU1ZHID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1VTRV9NQVRITUwgPSAxIDw8IDM7XG5cbmV4cG9ydCBjb25zdCBIWURSQVRJT05fU1RBUlQgPSAnWyc7XG4vKiogdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGFuIGB7OmVsc2V9Li4uYCBibG9jayB3YXMgcmVuZGVyZWQgKi9cbmV4cG9ydCBjb25zdCBIWURSQVRJT05fU1RBUlRfRUxTRSA9ICdbISc7XG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX0VORCA9ICddJztcbmV4cG9ydCBjb25zdCBIWURSQVRJT05fRVJST1IgPSB7fTtcblxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfSVNfTkFNRVNQQUNFRCA9IDE7XG5leHBvcnQgY29uc3QgRUxFTUVOVF9QUkVTRVJWRV9BVFRSSUJVVEVfQ0FTRSA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBFTEVNRU5UX0lTX0lOUFVUID0gMSA8PCAyO1xuXG5leHBvcnQgY29uc3QgVU5JTklUSUFMSVpFRCA9IFN5bWJvbCgpO1xuXG4vLyBEZXYtdGltZSBjb21wb25lbnQgcHJvcGVydGllc1xuZXhwb3J0IGNvbnN0IEZJTEVOQU1FID0gU3ltYm9sKCdmaWxlbmFtZScpO1xuZXhwb3J0IGNvbnN0IEhNUiA9IFN5bWJvbCgnaG1yJyk7XG5cbmV4cG9ydCBjb25zdCBOQU1FU1BBQ0VfSFRNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbmV4cG9ydCBjb25zdCBOQU1FU1BBQ0VfU1ZHID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmV4cG9ydCBjb25zdCBOQU1FU1BBQ0VfTUFUSE1MID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuXG4vLyB3ZSB1c2UgYSBsaXN0IG9mIGlnbm9yYWJsZSBydW50aW1lIHdhcm5pbmdzIGJlY2F1c2Ugbm90IGV2ZXJ5IHJ1bnRpbWUgd2FybmluZ1xuLy8gY2FuIGJlIGlnbm9yZWQgYW5kIHdlIHdhbnQgdG8ga2VlcCB0aGUgdmFsaWRhdGlvbiBmb3Igc3ZlbHRlLWlnbm9yZSBpbiBwbGFjZVxuZXhwb3J0IGNvbnN0IElHTk9SQUJMRV9SVU5USU1FX1dBUk5JTkdTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcblx0J2F3YWl0X3dhdGVyZmFsbCcsXG5cdCdhd2FpdF9yZWFjdGl2aXR5X2xvc3MnLFxuXHQnc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUnLFxuXHQnYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmUnLFxuXHQnaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkJyxcblx0J2h5ZHJhdGlvbl9odG1sX2NoYW5nZWQnLFxuXHQnb3duZXJzaGlwX2ludmFsaWRfYmluZGluZycsXG5cdCdvd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbidcbl0pO1xuXG4vKipcbiAqIFdoaXRlc3BhY2UgaW5zaWRlIG9uZSBvZiB0aGVzZSBlbGVtZW50cyB3aWxsIG5vdCByZXN1bHQgaW5cbiAqIGEgd2hpdGVzcGFjZSBub2RlIGJlaW5nIGNyZWF0ZWQgaW4gYW55IGNpcmN1bXN0YW5jZXMuIChUaGlzXG4gKiBsaXN0IGlzIGFsbW9zdCBjZXJ0YWlubHkgdmVyeSBpbmNvbXBsZXRlKVxuICogVE9ETyB0aGlzIGlzIGN1cnJlbnRseSB1bnVzZWRcbiAqL1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRTX1dJVEhPVVRfVEVYVCA9IFsnYXVkaW8nLCAnZGF0YWxpc3QnLCAnZGwnLCAnb3B0Z3JvdXAnLCAnc2VsZWN0JywgJ3ZpZGVvJ107XG5cbmV4cG9ydCBjb25zdCBBVFRBQ0hNRU5UX0tFWSA9ICdAYXR0YWNoJztcbiIsICJjb25zdCBBVFRSX1JFR0VYID0gL1smXCI8XS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzX2F0dHJdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVfaHRtbCh2YWx1ZSwgaXNfYXR0cikge1xuXHRjb25zdCBzdHIgPSBTdHJpbmcodmFsdWUgPz8gJycpO1xuXG5cdGNvbnN0IHBhdHRlcm4gPSBpc19hdHRyID8gQVRUUl9SRUdFWCA6IENPTlRFTlRfUkVHRVg7XG5cdHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcblxuXHRsZXQgZXNjYXBlZCA9ICcnO1xuXHRsZXQgbGFzdCA9IDA7XG5cblx0d2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG5cdFx0Y29uc3QgaSA9IHBhdHRlcm4ubGFzdEluZGV4IC0gMTtcblx0XHRjb25zdCBjaCA9IHN0cltpXTtcblx0XHRlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiBjaCA9PT0gJ1wiJyA/ICcmcXVvdDsnIDogJyZsdDsnKTtcblx0XHRsYXN0ID0gaSArIDE7XG5cdH1cblxuXHRyZXR1cm4gZXNjYXBlZCArIHN0ci5zdWJzdHJpbmcobGFzdCk7XG59XG4iLCAiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpe3ZhciBvPWUubGVuZ3RoO2Zvcih0PTA7dDxvO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zil9ZWxzZSBmb3IoZiBpbiBlKWVbZl0mJihuJiYobis9XCIgXCIpLG4rPWYpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIixvPWFyZ3VtZW50cy5sZW5ndGg7ZjxvO2YrKykoZT1hcmd1bWVudHNbZl0pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCAiaW1wb3J0IHsgZXNjYXBlX2h0bWwgfSBmcm9tICcuLi8uLi9lc2NhcGluZy5qcyc7XG5pbXBvcnQgeyBjbHN4IGFzIF9jbHN4IH0gZnJvbSAnY2xzeCc7XG5cbi8qKlxuICogYDxkaXYgdHJhbnNsYXRlPXtmYWxzZX0+YCBzaG91bGQgYmUgcmVuZGVyZWQgYXMgYDxkaXYgdHJhbnNsYXRlPVwibm9cIj5gIGFuZCBfbm90X1xuICogYDxkaXYgdHJhbnNsYXRlPVwiZmFsc2VcIj5gLCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIGA8ZGl2IHRyYW5zbGF0ZT1cInllc1wiPmAuIFRoZXJlXG4gKiBtYXkgYmUgb3RoZXIgb2RkIGNhc2VzIHRoYXQgbmVlZCB0byBiZSBhZGRlZCB0byB0aGlzIGxpc3QgaW4gZnV0dXJlXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgTWFwPGFueSwgc3RyaW5nPj59XG4gKi9cbmNvbnN0IHJlcGxhY2VtZW50cyA9IHtcblx0dHJhbnNsYXRlOiBuZXcgTWFwKFtcblx0XHRbdHJ1ZSwgJ3llcyddLFxuXHRcdFtmYWxzZSwgJ25vJ11cblx0XSlcbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc19ib29sZWFuXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHIobmFtZSwgdmFsdWUsIGlzX2Jvb2xlYW4gPSBmYWxzZSkge1xuXHQvLyBhdHRyaWJ1dGUgaGlkZGVuIGZvciB2YWx1ZXMgb3RoZXIgdGhhbiBcInVudGlsLWZvdW5kXCIgYmVoYXZlcyBsaWtlIGEgYm9vbGVhbiBhdHRyaWJ1dGVcblx0aWYgKG5hbWUgPT09ICdoaWRkZW4nICYmIHZhbHVlICE9PSAndW50aWwtZm91bmQnKSB7XG5cdFx0aXNfYm9vbGVhbiA9IHRydWU7XG5cdH1cblx0aWYgKHZhbHVlID09IG51bGwgfHwgKCF2YWx1ZSAmJiBpc19ib29sZWFuKSkgcmV0dXJuICcnO1xuXHRjb25zdCBub3JtYWxpemVkID0gKG5hbWUgaW4gcmVwbGFjZW1lbnRzICYmIHJlcGxhY2VtZW50c1tuYW1lXS5nZXQodmFsdWUpKSB8fCB2YWx1ZTtcblx0Y29uc3QgYXNzaWdubWVudCA9IGlzX2Jvb2xlYW4gPyAnJyA6IGA9XCIke2VzY2FwZV9odG1sKG5vcm1hbGl6ZWQsIHRydWUpfVwiYDtcblx0cmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuXG4vKipcbiAqIFNtYWxsIHdyYXBwZXIgYXJvdW5kIGNsc3ggdG8gcHJlc2VydmUgU3ZlbHRlJ3MgKHdlaXJkKSBoYW5kbGluZyBvZiBmYWxzeSB2YWx1ZXMuXG4gKiBUT0RPIFN2ZWx0ZSA2IHJldmlzaXQgdGhpcywgYW5kIGxpa2VseSB0dXJuIGFsbCBmYWxzeSB2YWx1ZXMgaW50byB0aGUgZW1wdHkgc3RyaW5nICh3aGF0IGNsc3ggYWxzbyBkb2VzKVxuICogQHBhcmFtICB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xzeCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBfY2xzeCh2YWx1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHZhbHVlID8/ICcnO1xuXHR9XG59XG5cbmNvbnN0IHdoaXRlc3BhY2UgPSBbLi4uJyBcXHRcXG5cXHJcXGZcXHUwMGEwXFx1MDAwYlxcdWZlZmYnXTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW2hhc2hdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSBbZGlyZWN0aXZlc11cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9fY2xhc3ModmFsdWUsIGhhc2gsIGRpcmVjdGl2ZXMpIHtcblx0dmFyIGNsYXNzbmFtZSA9IHZhbHVlID09IG51bGwgPyAnJyA6ICcnICsgdmFsdWU7XG5cblx0aWYgKGhhc2gpIHtcblx0XHRjbGFzc25hbWUgPSBjbGFzc25hbWUgPyBjbGFzc25hbWUgKyAnICcgKyBoYXNoIDogaGFzaDtcblx0fVxuXG5cdGlmIChkaXJlY3RpdmVzKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGRpcmVjdGl2ZXMpIHtcblx0XHRcdGlmIChkaXJlY3RpdmVzW2tleV0pIHtcblx0XHRcdFx0Y2xhc3NuYW1lID0gY2xhc3NuYW1lID8gY2xhc3NuYW1lICsgJyAnICsga2V5IDoga2V5O1xuXHRcdFx0fSBlbHNlIGlmIChjbGFzc25hbWUubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBsZW4gPSBrZXkubGVuZ3RoO1xuXHRcdFx0XHR2YXIgYSA9IDA7XG5cblx0XHRcdFx0d2hpbGUgKChhID0gY2xhc3NuYW1lLmluZGV4T2Yoa2V5LCBhKSkgPj0gMCkge1xuXHRcdFx0XHRcdHZhciBiID0gYSArIGxlbjtcblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdChhID09PSAwIHx8IHdoaXRlc3BhY2UuaW5jbHVkZXMoY2xhc3NuYW1lW2EgLSAxXSkpICYmXG5cdFx0XHRcdFx0XHQoYiA9PT0gY2xhc3NuYW1lLmxlbmd0aCB8fCB3aGl0ZXNwYWNlLmluY2x1ZGVzKGNsYXNzbmFtZVtiXSkpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRjbGFzc25hbWUgPSAoYSA9PT0gMCA/ICcnIDogY2xhc3NuYW1lLnN1YnN0cmluZygwLCBhKSkgKyBjbGFzc25hbWUuc3Vic3RyaW5nKGIgKyAxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YSA9IGI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNsYXNzbmFtZSA9PT0gJycgPyBudWxsIDogY2xhc3NuYW1lO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsYW55Pn0gc3R5bGVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGltcG9ydGFudFxuICovXG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHN0eWxlcywgaW1wb3J0YW50ID0gZmFsc2UpIHtcblx0dmFyIHNlcGFyYXRvciA9IGltcG9ydGFudCA/ICcgIWltcG9ydGFudDsnIDogJzsnO1xuXHR2YXIgY3NzID0gJyc7XG5cblx0Zm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuXHRcdHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuXHRcdGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJykge1xuXHRcdFx0Y3NzICs9ICcgJyArIGtleSArICc6ICcgKyB2YWx1ZSArIHNlcGFyYXRvcjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3NzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b19jc3NfbmFtZShuYW1lKSB7XG5cdGlmIChuYW1lWzBdICE9PSAnLScgfHwgbmFtZVsxXSAhPT0gJy0nKSB7XG5cdFx0cmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fVxuXHRyZXR1cm4gbmFtZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55PiB8IFtSZWNvcmQ8c3RyaW5nLCBhbnk+LCBSZWNvcmQ8c3RyaW5nLCBhbnk+XX0gW3N0eWxlc11cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9fc3R5bGUodmFsdWUsIHN0eWxlcykge1xuXHRpZiAoc3R5bGVzKSB7XG5cdFx0dmFyIG5ld19zdHlsZSA9ICcnO1xuXG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLGFueT4gfCB1bmRlZmluZWR9ICovXG5cdFx0dmFyIG5vcm1hbF9zdHlsZXM7XG5cblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsYW55PiB8IHVuZGVmaW5lZH0gKi9cblx0XHR2YXIgaW1wb3J0YW50X3N0eWxlcztcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcblx0XHRcdG5vcm1hbF9zdHlsZXMgPSBzdHlsZXNbMF07XG5cdFx0XHRpbXBvcnRhbnRfc3R5bGVzID0gc3R5bGVzWzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub3JtYWxfc3R5bGVzID0gc3R5bGVzO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpXG5cdFx0XHRcdC5yZXBsYWNlQWxsKC9cXHMqXFwvXFwqLio/XFwqXFwvXFxzKi9nLCAnJylcblx0XHRcdFx0LnRyaW0oKTtcblxuXHRcdFx0LyoqIEB0eXBlIHtib29sZWFuIHwgJ1wiJyB8IFwiJ1wifSAqL1xuXHRcdFx0dmFyIGluX3N0ciA9IGZhbHNlO1xuXHRcdFx0dmFyIGluX2FwbyA9IDA7XG5cdFx0XHR2YXIgaW5fY29tbWVudCA9IGZhbHNlO1xuXG5cdFx0XHR2YXIgcmVzZXJ2ZWRfbmFtZXMgPSBbXTtcblxuXHRcdFx0aWYgKG5vcm1hbF9zdHlsZXMpIHtcblx0XHRcdFx0cmVzZXJ2ZWRfbmFtZXMucHVzaCguLi5PYmplY3Qua2V5cyhub3JtYWxfc3R5bGVzKS5tYXAodG9fY3NzX25hbWUpKTtcblx0XHRcdH1cblx0XHRcdGlmIChpbXBvcnRhbnRfc3R5bGVzKSB7XG5cdFx0XHRcdHJlc2VydmVkX25hbWVzLnB1c2goLi4uT2JqZWN0LmtleXMoaW1wb3J0YW50X3N0eWxlcykubWFwKHRvX2Nzc19uYW1lKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdGFydF9pbmRleCA9IDA7XG5cdFx0XHR2YXIgbmFtZV9pbmRleCA9IC0xO1xuXG5cdFx0XHRjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBjID0gdmFsdWVbaV07XG5cblx0XHRcdFx0aWYgKGluX2NvbW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoYyA9PT0gJy8nICYmIHZhbHVlW2kgLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRcdFx0XHRpbl9jb21tZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGluX3N0cikge1xuXHRcdFx0XHRcdGlmIChpbl9zdHIgPT09IGMpIHtcblx0XHRcdFx0XHRcdGluX3N0ciA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnLycgJiYgdmFsdWVbaSArIDFdID09PSAnKicpIHtcblx0XHRcdFx0XHRpbl9jb21tZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiKSB7XG5cdFx0XHRcdFx0aW5fc3RyID0gYztcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnKCcpIHtcblx0XHRcdFx0XHRpbl9hcG8rKztcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnKScpIHtcblx0XHRcdFx0XHRpbl9hcG8tLTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaW5fY29tbWVudCAmJiBpbl9zdHIgPT09IGZhbHNlICYmIGluX2FwbyA9PT0gMCkge1xuXHRcdFx0XHRcdGlmIChjID09PSAnOicgJiYgbmFtZV9pbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdG5hbWVfaW5kZXggPSBpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJzsnIHx8IGkgPT09IGxlbiAtIDEpIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lX2luZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbmFtZSA9IHRvX2Nzc19uYW1lKHZhbHVlLnN1YnN0cmluZyhzdGFydF9pbmRleCwgbmFtZV9pbmRleCkudHJpbSgpKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIXJlc2VydmVkX25hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGMgIT09ICc7Jykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eSA9IHZhbHVlLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaSkudHJpbSgpO1xuXHRcdFx0XHRcdFx0XHRcdG5ld19zdHlsZSArPSAnICcgKyBwcm9wZXJ0eSArICc7Jztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydF9pbmRleCA9IGkgKyAxO1xuXHRcdFx0XHRcdFx0bmFtZV9pbmRleCA9IC0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChub3JtYWxfc3R5bGVzKSB7XG5cdFx0XHRuZXdfc3R5bGUgKz0gYXBwZW5kX3N0eWxlcyhub3JtYWxfc3R5bGVzKTtcblx0XHR9XG5cblx0XHRpZiAoaW1wb3J0YW50X3N0eWxlcykge1xuXHRcdFx0bmV3X3N0eWxlICs9IGFwcGVuZF9zdHlsZXMoaW1wb3J0YW50X3N0eWxlcywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0bmV3X3N0eWxlID0gbmV3X3N0eWxlLnRyaW0oKTtcblx0XHRyZXR1cm4gbmV3X3N0eWxlID09PSAnJyA/IG51bGwgOiBuZXdfc3R5bGU7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBTdHJpbmcodmFsdWUpO1xufVxuIiwgIi8vIFN0b3JlIHRoZSByZWZlcmVuY2VzIHRvIGdsb2JhbHMgaW4gY2FzZSBzb21lb25lIHRyaWVzIHRvIG1vbmtleSBwYXRjaCB0aGVzZSwgY2F1c2luZyB0aGUgYmVsb3dcbi8vIHRvIGRlLW9wdCAodGhpcyBvY2N1cnMgb2Z0ZW4gd2hlbiB1c2luZyBwb3B1bGFyIGV4dGVuc2lvbnMpLlxuZXhwb3J0IHZhciBpc19hcnJheSA9IEFycmF5LmlzQXJyYXk7XG5leHBvcnQgdmFyIGluZGV4X29mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG5leHBvcnQgdmFyIGFycmF5X2Zyb20gPSBBcnJheS5mcm9tO1xuZXhwb3J0IHZhciBvYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzO1xuZXhwb3J0IHZhciBkZWZpbmVfcHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5leHBvcnQgdmFyIGdldF9kZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmV4cG9ydCB2YXIgZ2V0X2Rlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5leHBvcnQgdmFyIG9iamVjdF9wcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZXhwb3J0IHZhciBhcnJheV9wcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5leHBvcnQgdmFyIGdldF9wcm90b3R5cGVfb2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5leHBvcnQgdmFyIGlzX2V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB0aGluZ1xuICogQHJldHVybnMge3RoaW5nIGlzIEZ1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcblx0cmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBbVD1hbnldXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBQcm9taXNlTGlrZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZT8udGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqIEBwYXJhbSB7RnVuY3Rpb259IGZuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuKGZuKSB7XG5cdHJldHVybiBmbigpO1xufVxuXG4vKiogQHBhcmFtIHtBcnJheTwoKSA9PiB2b2lkPn0gYXJyICovXG5leHBvcnQgZnVuY3Rpb24gcnVuX2FsbChhcnIpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRhcnJbaV0oKTtcblx0fVxufVxuXG4vKipcbiAqIFRPRE8gcmVwbGFjZSB3aXRoIFByb21pc2Uud2l0aFJlc29sdmVycyBvbmNlIHN1cHBvcnRlZCB3aWRlbHkgZW5vdWdoXG4gKiBAdGVtcGxhdGUgW1Q9dm9pZF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmVycmVkKCkge1xuXHQvKiogQHR5cGUgeyh2YWx1ZTogVCkgPT4gdm9pZH0gKi9cblx0dmFyIHJlc29sdmU7XG5cblx0LyoqIEB0eXBlIHsocmVhc29uOiBhbnkpID0+IHZvaWR9ICovXG5cdHZhciByZWplY3Q7XG5cblx0LyoqIEB0eXBlIHtQcm9taXNlPFQ+fSAqL1xuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdHJlc29sdmUgPSByZXM7XG5cdFx0cmVqZWN0ID0gcmVqO1xuXHR9KTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge1YgfCAoKCkgPT4gVil9IGZhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsYXp5XVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWxsYmFjayh2YWx1ZSwgZmFsbGJhY2ssIGxhenkgPSBmYWxzZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuXHRcdD8gbGF6eVxuXHRcdFx0PyAvKiogQHR5cGUgeygpID0+IFZ9ICovIChmYWxsYmFjaykoKVxuXHRcdFx0OiAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjaylcblx0XHQ6IHZhbHVlO1xufVxuXG4vKipcbiAqIFdoZW4gZW5jb3VudGVyaW5nIGEgc2l0dWF0aW9uIGxpa2UgYGxldCBbYSwgYiwgY10gPSAkZGVyaXZlZChibGFoKCkpYCxcbiAqIHdlIG5lZWQgdG8gc3Rhc2ggYW4gaW50ZXJtZWRpYXRlIHZhbHVlIHRoYXQgYGFgLCBgYmAsIGFuZCBgY2AgZGVyaXZlXG4gKiBmcm9tLCBpbiBjYXNlIGl0J3MgYW4gaXRlcmFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPiB8IEl0ZXJhYmxlPFQ+fSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtuXVxuICogQHJldHVybnMge0FycmF5PFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9fYXJyYXkodmFsdWUsIG4pIHtcblx0Ly8gcmV0dXJuIGFycmF5cyB1bmNoYW5nZWRcblx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0Ly8gaWYgdmFsdWUgaXMgbm90IGl0ZXJhYmxlLCBvciBgbmAgaXMgdW5zcGVjaWZpZWQgKGluZGljYXRlcyBhIHJlc3Rcblx0Ly8gZWxlbWVudCwgd2hpY2ggbWVhbnMgd2UncmUgbm90IGNvbmNlcm5lZCBhYm91dCB1bmJvdW5kZWQgaXRlcmFibGVzKVxuXHQvLyBjb252ZXJ0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb21gXG5cdGlmIChuID09PSB1bmRlZmluZWQgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpKSB7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xuXHR9XG5cblx0Ly8gb3RoZXJ3aXNlLCBwb3B1bGF0ZSBhbiBhcnJheSB3aXRoIGBuYCB2YWx1ZXNcblxuXHQvKiogQHR5cGUge1RbXX0gKi9cblx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWUpIHtcblx0XHRhcnJheS5wdXNoKGVsZW1lbnQpO1xuXHRcdGlmIChhcnJheS5sZW5ndGggPT09IG4pIGJyZWFrO1xuXHR9XG5cblx0cmV0dXJuIGFycmF5O1xufVxuIiwgImV4cG9ydCBkZWZhdWx0IGZhbHNlO1xuIiwgImV4cG9ydCBkZWZhdWx0IHRydWU7XG4iLCAiZXhwb3J0IHsgZGVmYXVsdCBhcyBCUk9XU0VSIH0gZnJvbSAnZXNtLWVudi9icm93c2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgREVWIH0gZnJvbSAnZXNtLWVudi9kZXZlbG9wbWVudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5PREUgfSBmcm9tICdlc20tZW52L25vZGUnO1xuIiwgIi8vIEdlbmVyYWwgZmxhZ3NcbmV4cG9ydCBjb25zdCBERVJJVkVEID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IEVGRkVDVCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBSRU5ERVJfRUZGRUNUID0gMSA8PCAzO1xuLyoqXG4gKiBBbiBlZmZlY3QgdGhhdCBkb2VzIG5vdCBkZXN0cm95IGl0cyBjaGlsZCBlZmZlY3RzIHdoZW4gaXQgcmVydW5zLlxuICogUnVucyBhcyBwYXJ0IG9mIHJlbmRlciBlZmZlY3RzLCBpLmUuIG5vdCBlYWdlcmx5IGFzIHBhcnQgb2YgdHJlZSB0cmF2ZXJzYWwgb3IgZWZmZWN0IGZsdXNoaW5nLlxuICovXG5leHBvcnQgY29uc3QgTUFOQUdFRF9FRkZFQ1QgPSAxIDw8IDI0O1xuLyoqXG4gKiBBbiBlZmZlY3QgdGhhdCBkb2VzIG5vdCBkZXN0cm95IGl0cyBjaGlsZCBlZmZlY3RzIHdoZW4gaXQgcmVydW5zIChsaWtlIE1BTkFHRURfRUZGRUNUKS5cbiAqIFJ1bnMgZWFnZXJseSBhcyBwYXJ0IG9mIHRyZWUgdHJhdmVyc2FsIG9yIGVmZmVjdCBmbHVzaGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IEJMT0NLX0VGRkVDVCA9IDEgPDwgNDtcbmV4cG9ydCBjb25zdCBCUkFOQ0hfRUZGRUNUID0gMSA8PCA1O1xuZXhwb3J0IGNvbnN0IFJPT1RfRUZGRUNUID0gMSA8PCA2O1xuZXhwb3J0IGNvbnN0IEJPVU5EQVJZX0VGRkVDVCA9IDEgPDwgNztcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgYSByZWFjdGlvbiBpcyBjb25uZWN0ZWQgdG8gYW4gZWZmZWN0IHJvb3QgXHUyMDE0IGVpdGhlciBpdCBpcyBhbiBlZmZlY3QsXG4gKiBvciBpdCBpcyBhIGRlcml2ZWQgdGhhdCBpcyBkZXBlbmRlZCBvbiBieSBhdCBsZWFzdCBvbmUgZWZmZWN0LiBJZiBhIGRlcml2ZWQgaGFzXG4gKiBubyBkZXBlbmRlbnRzLCB3ZSBjYW4gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSBncmFwaCwgYWxsb3dpbmcgaXQgdG8gZWl0aGVyIGJlXG4gKiBHQydkIG9yIHJlY29ubmVjdGVkIGxhdGVyIGlmIGFuIGVmZmVjdCBjb21lcyB0byBkZXBlbmQgb24gaXQgYWdhaW5cbiAqL1xuZXhwb3J0IGNvbnN0IENPTk5FQ1RFRCA9IDEgPDwgOTtcbmV4cG9ydCBjb25zdCBDTEVBTiA9IDEgPDwgMTA7XG5leHBvcnQgY29uc3QgRElSVFkgPSAxIDw8IDExO1xuZXhwb3J0IGNvbnN0IE1BWUJFX0RJUlRZID0gMSA8PCAxMjtcbmV4cG9ydCBjb25zdCBJTkVSVCA9IDEgPDwgMTM7XG5leHBvcnQgY29uc3QgREVTVFJPWUVEID0gMSA8PCAxNDtcblxuLy8gRmxhZ3MgZXhjbHVzaXZlIHRvIGVmZmVjdHNcbi8qKiBTZXQgb25jZSBhbiBlZmZlY3QgdGhhdCBzaG91bGQgcnVuIHN5bmNocm9ub3VzbHkgaGFzIHJ1biAqL1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9SQU4gPSAxIDw8IDE1O1xuLyoqXG4gKiAnVHJhbnNwYXJlbnQnIGVmZmVjdHMgZG8gbm90IGNyZWF0ZSBhIHRyYW5zaXRpb24gYm91bmRhcnkuXG4gKiBUaGlzIGlzIG9uIGEgYmxvY2sgZWZmZWN0IDk5JSBvZiB0aGUgdGltZSBidXQgbWF5IGFsc28gYmUgb24gYSBicmFuY2ggZWZmZWN0IGlmIGl0cyBwYXJlbnQgYmxvY2sgZWZmZWN0IHdhcyBwcnVuZWRcbiAqL1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9UUkFOU1BBUkVOVCA9IDEgPDwgMTY7XG5leHBvcnQgY29uc3QgRUFHRVJfRUZGRUNUID0gMSA8PCAxNztcbmV4cG9ydCBjb25zdCBIRUFEX0VGRkVDVCA9IDEgPDwgMTg7XG5leHBvcnQgY29uc3QgRUZGRUNUX1BSRVNFUlZFRCA9IDEgPDwgMTk7XG5leHBvcnQgY29uc3QgVVNFUl9FRkZFQ1QgPSAxIDw8IDIwO1xuXG4vLyBGbGFncyBleGNsdXNpdmUgdG8gZGVyaXZlZHNcbi8qKlxuICogVGVsbHMgdGhhdCB3ZSBtYXJrZWQgdGhpcyBkZXJpdmVkIGFuZCBpdHMgcmVhY3Rpb25zIGFzIHZpc2l0ZWQgZHVyaW5nIHRoZSBcIm1hcmsgYXMgKG1heWJlKSBkaXJ0eVwiLXBoYXNlLlxuICogV2lsbCBiZSBsaWZ0ZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiB0aGUgZGVyaXZlZCBhbmQgZHVyaW5nIGNoZWNraW5nIGl0cyBkaXJ0eSBzdGF0ZSAoYm90aCBhcmUgbmVjZXNzYXJ5XG4gKiBiZWNhdXNlIGEgZGVyaXZlZCBtaWdodCBiZSBjaGVja2VkIGJ1dCBub3QgZXhlY3V0ZWQpLlxuICovXG5leHBvcnQgY29uc3QgV0FTX01BUktFRCA9IDEgPDwgMTU7XG5cbi8vIEZsYWdzIHVzZWQgZm9yIGFzeW5jXG5leHBvcnQgY29uc3QgUkVBQ1RJT05fSVNfVVBEQVRJTkcgPSAxIDw8IDIxO1xuZXhwb3J0IGNvbnN0IEFTWU5DID0gMSA8PCAyMjtcblxuZXhwb3J0IGNvbnN0IEVSUk9SX1ZBTFVFID0gMSA8PCAyMztcblxuZXhwb3J0IGNvbnN0IFNUQVRFX1NZTUJPTCA9IFN5bWJvbCgnJHN0YXRlJyk7XG5leHBvcnQgY29uc3QgTEVHQUNZX1BST1BTID0gU3ltYm9sKCdsZWdhY3kgcHJvcHMnKTtcbmV4cG9ydCBjb25zdCBMT0FESU5HX0FUVFJfU1lNQk9MID0gU3ltYm9sKCcnKTtcbmV4cG9ydCBjb25zdCBQUk9YWV9QQVRIX1NZTUJPTCA9IFN5bWJvbCgncHJveHkgcGF0aCcpO1xuXG4vKiogYWxsb3cgdXNlcnMgdG8gaWdub3JlIGFib3J0ZWQgc2lnbmFsIGVycm9ycyBpZiBgcmVhc29uLm5hbWUgPT09ICdTdGFsZVJlYWN0aW9uRXJyb3JgICovXG5leHBvcnQgY29uc3QgU1RBTEVfUkVBQ1RJT04gPSBuZXcgKGNsYXNzIFN0YWxlUmVhY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcblx0bmFtZSA9ICdTdGFsZVJlYWN0aW9uRXJyb3InO1xuXHRtZXNzYWdlID0gJ1RoZSByZWFjdGlvbiB0aGF0IGNhbGxlZCBgZ2V0QWJvcnRTaWduYWwoKWAgd2FzIHJlLXJ1biBvciBkZXN0cm95ZWQnO1xufSkoKTtcblxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfTk9ERSA9IDE7XG5leHBvcnQgY29uc3QgVEVYVF9OT0RFID0gMztcbmV4cG9ydCBjb25zdCBDT01NRU5UX05PREUgPSA4O1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbiIsICIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKipcbiAqIENhbm5vdCB1c2UgYCVuYW1lJSguLi4pYCB1bmxlc3MgdGhlIGBleHBlcmltZW50YWwuYXN5bmNgIGNvbXBpbGVyIG9wdGlvbiBpcyBgdHJ1ZWBcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBlcmltZW50YWxfYXN5bmNfcmVxdWlyZWQobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGV4cGVyaW1lbnRhbF9hc3luY19yZXF1aXJlZFxcbkNhbm5vdCB1c2UgXFxgJHtuYW1lfSguLi4pXFxgIHVubGVzcyB0aGUgXFxgZXhwZXJpbWVudGFsLmFzeW5jXFxgIGNvbXBpbGVyIG9wdGlvbiBpcyBcXGB0cnVlXFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZXhwZXJpbWVudGFsX2FzeW5jX3JlcXVpcmVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2V4cGVyaW1lbnRhbF9hc3luY19yZXF1aXJlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IHVzZSBge0ByZW5kZXIgY2hpbGRyZW4oLi4uKX1gIGlmIHRoZSBwYXJlbnQgY29tcG9uZW50IHVzZXMgYGxldDpgIGRpcmVjdGl2ZXMuIENvbnNpZGVyIHVzaW5nIGEgbmFtZWQgc25pcHBldCBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX2RlZmF1bHRfc25pcHBldCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkX2RlZmF1bHRfc25pcHBldFxcbkNhbm5vdCB1c2UgXFxge0ByZW5kZXIgY2hpbGRyZW4oLi4uKX1cXGAgaWYgdGhlIHBhcmVudCBjb21wb25lbnQgdXNlcyBcXGBsZXQ6XFxgIGRpcmVjdGl2ZXMuIENvbnNpZGVyIHVzaW5nIGEgbmFtZWQgc25pcHBldCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRgKTtcblx0fVxufVxuXG4vKipcbiAqIEEgc25pcHBldCBmdW5jdGlvbiB3YXMgcGFzc2VkIGludmFsaWQgYXJndW1lbnRzLiBTbmlwcGV0cyBzaG91bGQgb25seSBiZSBpbnN0YW50aWF0ZWQgdmlhIGB7QHJlbmRlciAuLi59YFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50cygpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkX3NuaXBwZXRfYXJndW1lbnRzXFxuQSBzbmlwcGV0IGZ1bmN0aW9uIHdhcyBwYXNzZWQgaW52YWxpZCBhcmd1bWVudHMuIFNuaXBwZXRzIHNob3VsZCBvbmx5IGJlIGluc3RhbnRpYXRlZCB2aWEgXFxge0ByZW5kZXIgLi4ufVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldF9hcmd1bWVudHNgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50c2ApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJSguLi4pYCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudFxcblxcYCR7bmFtZX0oLi4uKVxcYCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb250ZXh0IHdhcyBub3Qgc2V0IGluIGEgcGFyZW50IGNvbXBvbmVudFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWlzc2luZ19jb250ZXh0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYG1pc3NpbmdfY29udGV4dFxcbkNvbnRleHQgd2FzIG5vdCBzZXQgaW4gYSBwYXJlbnQgY29tcG9uZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbWlzc2luZ19jb250ZXh0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL21pc3NpbmdfY29udGV4dGApO1xuXHR9XG59XG5cbi8qKlxuICogQXR0ZW1wdGVkIHRvIHJlbmRlciBhIHNuaXBwZXQgd2l0aG91dCBhIGB7QHJlbmRlcn1gIGJsb2NrLiBUaGlzIHdvdWxkIGNhdXNlIHRoZSBzbmlwcGV0IGNvZGUgdG8gYmUgc3RyaW5naWZpZWQgaW5zdGVhZCBvZiBpdHMgY29udGVudCBiZWluZyByZW5kZXJlZCB0byB0aGUgRE9NLiBUbyBmaXggdGhpcywgY2hhbmdlIGB7c25pcHBldH1gIHRvIGB7QHJlbmRlciBzbmlwcGV0KCl9YC5cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuaXBwZXRfd2l0aG91dF9yZW5kZXJfdGFnKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHNuaXBwZXRfd2l0aG91dF9yZW5kZXJfdGFnXFxuQXR0ZW1wdGVkIHRvIHJlbmRlciBhIHNuaXBwZXQgd2l0aG91dCBhIFxcYHtAcmVuZGVyfVxcYCBibG9jay4gVGhpcyB3b3VsZCBjYXVzZSB0aGUgc25pcHBldCBjb2RlIHRvIGJlIHN0cmluZ2lmaWVkIGluc3RlYWQgb2YgaXRzIGNvbnRlbnQgYmVpbmcgcmVuZGVyZWQgdG8gdGhlIERPTS4gVG8gZml4IHRoaXMsIGNoYW5nZSBcXGB7c25pcHBldH1cXGAgdG8gXFxge0ByZW5kZXIgc25pcHBldCgpfVxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zbmlwcGV0X3dpdGhvdXRfcmVuZGVyX3RhZ2ApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zbmlwcGV0X3dpdGhvdXRfcmVuZGVyX3RhZ2ApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJWAgaXMgbm90IGEgc3RvcmUgd2l0aCBhIGBzdWJzY3JpYmVgIG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2ludmFsaWRfc2hhcGUobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0b3JlX2ludmFsaWRfc2hhcGVcXG5cXGAke25hbWV9XFxgIGlzIG5vdCBhIHN0b3JlIHdpdGggYSBcXGBzdWJzY3JpYmVcXGAgbWV0aG9kXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RvcmVfaW52YWxpZF9zaGFwZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdG9yZV9pbnZhbGlkX3NoYXBlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHRoaXNgIHByb3Agb24gYDxzdmVsdGU6ZWxlbWVudD5gIG11c3QgYmUgYSBzdHJpbmcsIGlmIGRlZmluZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZSgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVcXG5UaGUgXFxgdGhpc1xcYCBwcm9wIG9uIFxcYDxzdmVsdGU6ZWxlbWVudD5cXGAgbXVzdCBiZSBhIHN0cmluZywgaWYgZGVmaW5lZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVgKTtcblx0fVxufSIsICIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG5leHBvcnQgKiAgZnJvbSAnLi4vc2hhcmVkL2Vycm9ycy5qcyc7XG5cbi8qKlxuICogQ2Fubm90IGNyZWF0ZSBhIGAkZGVyaXZlZCguLi4pYCB3aXRoIGFuIGBhd2FpdGAgZXhwcmVzc2lvbiBvdXRzaWRlIG9mIGFuIGVmZmVjdCB0cmVlXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3luY19kZXJpdmVkX29ycGhhbigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBhc3luY19kZXJpdmVkX29ycGhhblxcbkNhbm5vdCBjcmVhdGUgYSBcXGAkZGVyaXZlZCguLi4pXFxgIHdpdGggYW4gXFxgYXdhaXRcXGAgZXhwcmVzc2lvbiBvdXRzaWRlIG9mIGFuIGVmZmVjdCB0cmVlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXN5bmNfZGVyaXZlZF9vcnBoYW5gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXN5bmNfZGVyaXZlZF9vcnBoYW5gKTtcblx0fVxufVxuXG4vKipcbiAqIFVzaW5nIGBiaW5kOnZhbHVlYCB0b2dldGhlciB3aXRoIGEgY2hlY2tib3ggaW5wdXQgaXMgbm90IGFsbG93ZWQuIFVzZSBgYmluZDpjaGVja2VkYCBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWUoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlXFxuVXNpbmcgXFxgYmluZDp2YWx1ZVxcYCB0b2dldGhlciB3aXRoIGEgY2hlY2tib3ggaW5wdXQgaXMgbm90IGFsbG93ZWQuIFVzZSBcXGBiaW5kOmNoZWNrZWRcXGAgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIENvbXBvbmVudCAlY29tcG9uZW50JSBoYXMgYW4gZXhwb3J0IG5hbWVkIGAla2V5JWAgdGhhdCBhIGNvbnN1bWVyIGNvbXBvbmVudCBpcyB0cnlpbmcgdG8gYWNjZXNzIHVzaW5nIGBiaW5kOiVrZXklYCwgd2hpY2ggaXMgZGlzYWxsb3dlZC4gSW5zdGVhZCwgdXNlIGBiaW5kOnRoaXNgIChlLmcuIGA8JW5hbWUlIGJpbmQ6dGhpcz17Y29tcG9uZW50fSAvPmApIGFuZCB0aGVuIGFjY2VzcyB0aGUgcHJvcGVydHkgb24gdGhlIGJvdW5kIGNvbXBvbmVudCBpbnN0YW5jZSAoZS5nLiBgY29tcG9uZW50LiVrZXklYClcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ludmFsaWRfZXhwb3J0KGNvbXBvbmVudCwga2V5LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9pbnZhbGlkX2V4cG9ydFxcbkNvbXBvbmVudCAke2NvbXBvbmVudH0gaGFzIGFuIGV4cG9ydCBuYW1lZCBcXGAke2tleX1cXGAgdGhhdCBhIGNvbnN1bWVyIGNvbXBvbmVudCBpcyB0cnlpbmcgdG8gYWNjZXNzIHVzaW5nIFxcYGJpbmQ6JHtrZXl9XFxgLCB3aGljaCBpcyBkaXNhbGxvd2VkLiBJbnN0ZWFkLCB1c2UgXFxgYmluZDp0aGlzXFxgIChlLmcuIFxcYDwke25hbWV9IGJpbmQ6dGhpcz17Y29tcG9uZW50fSAvPlxcYCkgYW5kIHRoZW4gYWNjZXNzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYm91bmQgY29tcG9uZW50IGluc3RhbmNlIChlLmcuIFxcYGNvbXBvbmVudC4ke2tleX1cXGApXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2V4cG9ydGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfZXhwb3J0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCBpcyBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYSBub24tYmluZGFibGUgcHJvcGVydHkgYCVrZXklYCBiZWxvbmdpbmcgdG8gJWNvbXBvbmVudCUgKGkuZS4gYDwlbmFtZSUgYmluZDola2V5JT17Li4ufT5gKS4gVG8gbWFyayBhIHByb3BlcnR5IGFzIGJpbmRhYmxlOiBgbGV0IHsgJWtleSUgPSAkYmluZGFibGUoKSB9ID0gJHByb3BzKClgXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9ub3RfYmluZGFibGUoa2V5LCBjb21wb25lbnQsIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX25vdF9iaW5kYWJsZVxcbkEgY29tcG9uZW50IGlzIGF0dGVtcHRpbmcgdG8gYmluZCB0byBhIG5vbi1iaW5kYWJsZSBwcm9wZXJ0eSBcXGAke2tleX1cXGAgYmVsb25naW5nIHRvICR7Y29tcG9uZW50fSAoaS5lLiBcXGA8JHtuYW1lfSBiaW5kOiR7a2V5fT17Li4ufT5cXGApLiBUbyBtYXJrIGEgcHJvcGVydHkgYXMgYmluZGFibGU6IFxcYGxldCB7ICR7a2V5fSA9ICRiaW5kYWJsZSgpIH0gPSAkcHJvcHMoKVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfbm90X2JpbmRhYmxlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfbm90X2JpbmRhYmxlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYWxsaW5nIGAlbWV0aG9kJWAgb24gYSBjb21wb25lbnQgaW5zdGFuY2UgKG9mICVjb21wb25lbnQlKSBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9hcGlfY2hhbmdlZChtZXRob2QsIGNvbXBvbmVudCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGNvbXBvbmVudF9hcGlfY2hhbmdlZFxcbkNhbGxpbmcgXFxgJHttZXRob2R9XFxgIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIChvZiAke2NvbXBvbmVudH0pIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfY2hhbmdlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2NoYW5nZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIEF0dGVtcHRlZCB0byBpbnN0YW50aWF0ZSAlY29tcG9uZW50JSB3aXRoIGBuZXcgJW5hbWUlYCwgd2hpY2ggaXMgbm8gbG9uZ2VyIHZhbGlkIGluIFN2ZWx0ZSA1LiBJZiB0aGlzIGNvbXBvbmVudCBpcyBub3QgdW5kZXIgeW91ciBjb250cm9sLCBzZXQgdGhlIGBjb21wYXRpYmlsaXR5LmNvbXBvbmVudEFwaWAgY29tcGlsZXIgb3B0aW9uIHRvIGA0YCB0byBrZWVwIGl0IHdvcmtpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X2FwaV9pbnZhbGlkX25ldyhjb21wb25lbnQsIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBjb21wb25lbnRfYXBpX2ludmFsaWRfbmV3XFxuQXR0ZW1wdGVkIHRvIGluc3RhbnRpYXRlICR7Y29tcG9uZW50fSB3aXRoIFxcYG5ldyAke25hbWV9XFxgLCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDUuIElmIHRoaXMgY29tcG9uZW50IGlzIG5vdCB1bmRlciB5b3VyIGNvbnRyb2wsIHNldCB0aGUgXFxgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGlcXGAgY29tcGlsZXIgb3B0aW9uIHRvIFxcYDRcXGAgdG8ga2VlcCBpdCB3b3JraW5nLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfaW52YWxpZF9uZXdgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld2ApO1xuXHR9XG59XG5cbi8qKlxuICogQSBkZXJpdmVkIHZhbHVlIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmIHJlY3Vyc2l2ZWx5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkX3JlZmVyZW5jZXNfc2VsZigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBkZXJpdmVkX3JlZmVyZW5jZXNfc2VsZlxcbkEgZGVyaXZlZCB2YWx1ZSBjYW5ub3QgcmVmZXJlbmNlIGl0c2VsZiByZWN1cnNpdmVseVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2Rlcml2ZWRfcmVmZXJlbmNlc19zZWxmYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2Rlcml2ZWRfcmVmZXJlbmNlc19zZWxmYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IGAldmFsdWUlYCBhdCBpbmRleGVzICVhJSBhbmQgJWIlXG4gKiBAcGFyYW0ge3N0cmluZ30gYVxuICogQHBhcmFtIHtzdHJpbmd9IGJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW3ZhbHVlXVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaF9rZXlfZHVwbGljYXRlKGEsIGIsIHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWFjaF9rZXlfZHVwbGljYXRlXFxuJHt2YWx1ZVxuXHRcdFx0PyBgS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBcXGAke3ZhbHVlfVxcYCBhdCBpbmRleGVzICR7YX0gYW5kICR7Yn1gXG5cdFx0XHQ6IGBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IGF0IGluZGV4ZXMgJHthfSBhbmQgJHtifWB9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWFjaF9rZXlfZHVwbGljYXRlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VhY2hfa2V5X2R1cGxpY2F0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogYCVydW5lJWAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCBjbGVhbnVwIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X2luX3RlYXJkb3duKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfaW5fdGVhcmRvd25cXG5cXGAke3J1bmV9XFxgIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgY2xlYW51cCBmdW5jdGlvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9pbl90ZWFyZG93bmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdGVhcmRvd25gKTtcblx0fVxufVxuXG4vKipcbiAqIEVmZmVjdCBjYW5ub3QgYmUgY3JlYXRlZCBpbnNpZGUgYSBgJGRlcml2ZWRgIHZhbHVlIHRoYXQgd2FzIG5vdCBpdHNlbGYgY3JlYXRlZCBpbnNpZGUgYW4gZWZmZWN0XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWRcXG5FZmZlY3QgY2Fubm90IGJlIGNyZWF0ZWQgaW5zaWRlIGEgXFxgJGRlcml2ZWRcXGAgdmFsdWUgdGhhdCB3YXMgbm90IGl0c2VsZiBjcmVhdGVkIGluc2lkZSBhbiBlZmZlY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlcnVuZSVgIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCAoZS5nLiBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uKVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF9vcnBoYW4ocnVuZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9vcnBoYW5cXG5cXGAke3J1bmV9XFxgIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCAoZS5nLiBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uKVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9vcnBoYW5gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X29ycGhhbmApO1xuXHR9XG59XG5cbi8qKlxuICogYCRlZmZlY3QucGVuZGluZygpYCBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGFuIGVmZmVjdCBvciBkZXJpdmVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9wZW5kaW5nX291dHNpZGVfcmVhY3Rpb25cXG5cXGAkZWZmZWN0LnBlbmRpbmcoKVxcYCBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGFuIGVmZmVjdCBvciBkZXJpdmVkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3BlbmRpbmdfb3V0c2lkZV9yZWFjdGlvbmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoYXQgYW4gZWZmZWN0IHJlYWRzIGFuZCB3cml0ZXMgdGhlIHNhbWUgcGllY2Ugb2Ygc3RhdGVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZFxcbk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIHR5cGljYWxseSBpbmRpY2F0ZXMgdGhhdCBhbiBlZmZlY3QgcmVhZHMgYW5kIHdyaXRlcyB0aGUgc2FtZSBwaWVjZSBvZiBzdGF0ZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IHVzZSBgZmx1c2hTeW5jYCBpbnNpZGUgYW4gZWZmZWN0XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF9zeW5jX2luX2VmZmVjdCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBmbHVzaF9zeW5jX2luX2VmZmVjdFxcbkNhbm5vdCB1c2UgXFxgZmx1c2hTeW5jXFxgIGluc2lkZSBhbiBlZmZlY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9mbHVzaF9zeW5jX2luX2VmZmVjdGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9mbHVzaF9zeW5jX2luX2VmZmVjdGApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IGNvbW1pdCBhIGZvcmsgdGhhdCB3YXMgYWxyZWFkeSBkaXNjYXJkZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcmtfZGlzY2FyZGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGZvcmtfZGlzY2FyZGVkXFxuQ2Fubm90IGNvbW1pdCBhIGZvcmsgdGhhdCB3YXMgYWxyZWFkeSBkaXNjYXJkZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9mb3JrX2Rpc2NhcmRlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9mb3JrX2Rpc2NhcmRlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IGNyZWF0ZSBhIGZvcmsgaW5zaWRlIGFuIGVmZmVjdCBvciB3aGVuIHN0YXRlIGNoYW5nZXMgYXJlIHBlbmRpbmdcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcmtfdGltaW5nKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGZvcmtfdGltaW5nXFxuQ2Fubm90IGNyZWF0ZSBhIGZvcmsgaW5zaWRlIGFuIGVmZmVjdCBvciB3aGVuIHN0YXRlIGNoYW5nZXMgYXJlIHBlbmRpbmdcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9mb3JrX3RpbWluZ2ApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9mb3JrX3RpbWluZ2ApO1xuXHR9XG59XG5cbi8qKlxuICogYGdldEFib3J0U2lnbmFsKClgIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYW4gZWZmZWN0IG9yIGRlcml2ZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9hYm9ydF9zaWduYWxfb3V0c2lkZV9yZWFjdGlvbigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBnZXRfYWJvcnRfc2lnbmFsX291dHNpZGVfcmVhY3Rpb25cXG5cXGBnZXRBYm9ydFNpZ25hbCgpXFxgIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYW4gZWZmZWN0IG9yIGRlcml2ZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9nZXRfYWJvcnRfc2lnbmFsX291dHNpZGVfcmVhY3Rpb25gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZ2V0X2Fib3J0X3NpZ25hbF9vdXRzaWRlX3JlYWN0aW9uYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBFeHBlY3RlZCB0byBmaW5kIGEgaHlkcmF0YWJsZSB3aXRoIGtleSBgJWtleSVgIGR1cmluZyBoeWRyYXRpb24sIGJ1dCBkaWQgbm90LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0YWJsZV9taXNzaW5nX2J1dF9yZXF1aXJlZChrZXkpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBoeWRyYXRhYmxlX21pc3NpbmdfYnV0X3JlcXVpcmVkXFxuRXhwZWN0ZWQgdG8gZmluZCBhIGh5ZHJhdGFibGUgd2l0aCBrZXkgXFxgJHtrZXl9XFxgIGR1cmluZyBoeWRyYXRpb24sIGJ1dCBkaWQgbm90Llxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGFibGVfbWlzc2luZ19idXRfcmVxdWlyZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0YWJsZV9taXNzaW5nX2J1dF9yZXF1aXJlZGApO1xuXHR9XG59XG5cbi8qKlxuICogRmFpbGVkIHRvIGh5ZHJhdGUgdGhlIGFwcGxpY2F0aW9uXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25fZmFpbGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGh5ZHJhdGlvbl9mYWlsZWRcXG5GYWlsZWQgdG8gaHlkcmF0ZSB0aGUgYXBwbGljYXRpb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fZmFpbGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9mYWlsZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENvdWxkIG5vdCBge0ByZW5kZXJ9YCBzbmlwcGV0IGR1ZSB0byB0aGUgZXhwcmVzc2lvbiBiZWluZyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuIENvbnNpZGVyIHVzaW5nIG9wdGlvbmFsIGNoYWluaW5nIGB7QHJlbmRlciBzbmlwcGV0Py4oKX1gXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX3NuaXBwZXQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9zbmlwcGV0XFxuQ291bGQgbm90IFxcYHtAcmVuZGVyfVxcYCBzbmlwcGV0IGR1ZSB0byB0aGUgZXhwcmVzc2lvbiBiZWluZyBcXGBudWxsXFxgIG9yIFxcYHVuZGVmaW5lZFxcYC4gQ29uc2lkZXIgdXNpbmcgb3B0aW9uYWwgY2hhaW5pbmcgXFxge0ByZW5kZXIgc25pcHBldD8uKCl9XFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9zbmlwcGV0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldGApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJSguLi4pYCBjYW5ub3QgYmUgdXNlZCBpbiBydW5lcyBtb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5KG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBsaWZlY3ljbGVfbGVnYWN5X29ubHlcXG5cXGAke25hbWV9KC4uLilcXGAgY2Fubm90IGJlIHVzZWQgaW4gcnVuZXMgbW9kZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9sZWdhY3lfb25seWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfbGVnYWN5X29ubHlgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBkbyBgYmluZDola2V5JT17dW5kZWZpbmVkfWAgd2hlbiBgJWtleSVgIGhhcyBhIGZhbGxiYWNrIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19pbnZhbGlkX3ZhbHVlKGtleSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHByb3BzX2ludmFsaWRfdmFsdWVcXG5DYW5ub3QgZG8gXFxgYmluZDoke2tleX09e3VuZGVmaW5lZH1cXGAgd2hlbiBcXGAke2tleX1cXGAgaGFzIGEgZmFsbGJhY2sgdmFsdWVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19pbnZhbGlkX3ZhbHVlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3Byb3BzX2ludmFsaWRfdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIFJlc3QgZWxlbWVudCBwcm9wZXJ0aWVzIG9mIGAkcHJvcHMoKWAgc3VjaCBhcyBgJXByb3BlcnR5JWAgYXJlIHJlYWRvbmx5XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BzX3Jlc3RfcmVhZG9ubHkocHJvcGVydHkpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBwcm9wc19yZXN0X3JlYWRvbmx5XFxuUmVzdCBlbGVtZW50IHByb3BlcnRpZXMgb2YgXFxgJHByb3BzKClcXGAgc3VjaCBhcyBcXGAke3Byb3BlcnR5fVxcYCBhcmUgcmVhZG9ubHlcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19yZXN0X3JlYWRvbmx5YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3Byb3BzX3Jlc3RfcmVhZG9ubHlgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgJXJ1bmUlYCBydW5lIGlzIG9ubHkgYXZhaWxhYmxlIGluc2lkZSBgLnN2ZWx0ZWAgYW5kIGAuc3ZlbHRlLmpzL3RzYCBmaWxlc1xuICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bmVfb3V0c2lkZV9zdmVsdGUocnVuZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHJ1bmVfb3V0c2lkZV9zdmVsdGVcXG5UaGUgXFxgJHtydW5lfVxcYCBydW5lIGlzIG9ubHkgYXZhaWxhYmxlIGluc2lkZSBcXGAuc3ZlbHRlXFxgIGFuZCBcXGAuc3ZlbHRlLmpzL3RzXFxgIGZpbGVzXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcnVuZV9vdXRzaWRlX3N2ZWx0ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9ydW5lX291dHNpZGVfc3ZlbHRlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgc2V0Q29udGV4dGAgbXVzdCBiZSBjYWxsZWQgd2hlbiBhIGNvbXBvbmVudCBmaXJzdCBpbml0aWFsaXplcywgbm90IGluIGEgc3Vic2VxdWVudCBlZmZlY3Qgb3IgYWZ0ZXIgYW4gYGF3YWl0YCBleHByZXNzaW9uXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY29udGV4dF9hZnRlcl9pbml0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHNldF9jb250ZXh0X2FmdGVyX2luaXRcXG5cXGBzZXRDb250ZXh0XFxgIG11c3QgYmUgY2FsbGVkIHdoZW4gYSBjb21wb25lbnQgZmlyc3QgaW5pdGlhbGl6ZXMsIG5vdCBpbiBhIHN1YnNlcXVlbnQgZWZmZWN0IG9yIGFmdGVyIGFuIFxcYGF3YWl0XFxgIGV4cHJlc3Npb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zZXRfY29udGV4dF9hZnRlcl9pbml0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3NldF9jb250ZXh0X2FmdGVyX2luaXRgKTtcblx0fVxufVxuXG4vKipcbiAqIFByb3BlcnR5IGRlc2NyaXB0b3JzIGRlZmluZWQgb24gYCRzdGF0ZWAgb2JqZWN0cyBtdXN0IGNvbnRhaW4gYHZhbHVlYCBhbmQgYWx3YXlzIGJlIGBlbnVtZXJhYmxlYCwgYGNvbmZpZ3VyYWJsZWAgYW5kIGB3cml0YWJsZWAuXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9kZXNjcmlwdG9yc19maXhlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV9kZXNjcmlwdG9yc19maXhlZFxcblByb3BlcnR5IGRlc2NyaXB0b3JzIGRlZmluZWQgb24gXFxgJHN0YXRlXFxgIG9iamVjdHMgbXVzdCBjb250YWluIFxcYHZhbHVlXFxgIGFuZCBhbHdheXMgYmUgXFxgZW51bWVyYWJsZVxcYCwgXFxgY29uZmlndXJhYmxlXFxgIGFuZCBcXGB3cml0YWJsZVxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9kZXNjcmlwdG9yc19maXhlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9kZXNjcmlwdG9yc19maXhlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IHNldCBwcm90b3R5cGUgb2YgYCRzdGF0ZWAgb2JqZWN0XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9wcm90b3R5cGVfZml4ZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RhdGVfcHJvdG90eXBlX2ZpeGVkXFxuQ2Fubm90IHNldCBwcm90b3R5cGUgb2YgXFxgJHN0YXRlXFxgIG9iamVjdFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3RvdHlwZV9maXhlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm90b3R5cGVfZml4ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFVwZGF0aW5nIHN0YXRlIGluc2lkZSBgJGRlcml2ZWQoLi4uKWAsIGAkaW5zcGVjdCguLi4pYCBvciBhIHRlbXBsYXRlIGV4cHJlc3Npb24gaXMgZm9yYmlkZGVuLiBJZiB0aGUgdmFsdWUgc2hvdWxkIG5vdCBiZSByZWFjdGl2ZSwgZGVjbGFyZSBpdCB3aXRob3V0IGAkc3RhdGVgXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV91bnNhZmVfbXV0YXRpb24oKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RhdGVfdW5zYWZlX211dGF0aW9uXFxuVXBkYXRpbmcgc3RhdGUgaW5zaWRlIFxcYCRkZXJpdmVkKC4uLilcXGAsIFxcYCRpbnNwZWN0KC4uLilcXGAgb3IgYSB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIGZvcmJpZGRlbi4gSWYgdGhlIHZhbHVlIHNob3VsZCBub3QgYmUgcmVhY3RpdmUsIGRlY2xhcmUgaXQgd2l0aG91dCBcXGAkc3RhdGVcXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV91bnNhZmVfbXV0YXRpb25gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX211dGF0aW9uYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIGA8c3ZlbHRlOmJvdW5kYXJ5PmAgYHJlc2V0YCBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIHdoaWxlIGFuIGVycm9yIGlzIHN0aWxsIGJlaW5nIGhhbmRsZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9vbmVycm9yKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9vbmVycm9yXFxuQSBcXGA8c3ZlbHRlOmJvdW5kYXJ5PlxcYCBcXGByZXNldFxcYCBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIHdoaWxlIGFuIGVycm9yIGlzIHN0aWxsIGJlaW5nIGhhbmRsZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfYm91bmRhcnlfcmVzZXRfb25lcnJvcmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfYm91bmRhcnlfcmVzZXRfb25lcnJvcmApO1xuXHR9XG59IiwgIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbnZhciBib2xkID0gJ2ZvbnQtd2VpZ2h0OiBib2xkJztcbnZhciBub3JtYWwgPSAnZm9udC13ZWlnaHQ6IG5vcm1hbCc7XG5cbi8qKlxuICogQXNzaWdubWVudCB0byBgJXByb3BlcnR5JWAgcHJvcGVydHkgKCVsb2NhdGlvbiUpIHdpbGwgZXZhbHVhdGUgdG8gdGhlIHJpZ2h0LWhhbmQgc2lkZSwgbm90IHRoZSB2YWx1ZSBvZiBgJXByb3BlcnR5JWAgZm9sbG93aW5nIHRoZSBhc3NpZ25tZW50LiBUaGlzIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvdXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWdubWVudF92YWx1ZV9zdGFsZShwcm9wZXJ0eSwgbG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBhc3NpZ25tZW50X3ZhbHVlX3N0YWxlXFxuJWNBc3NpZ25tZW50IHRvIFxcYCR7cHJvcGVydHl9XFxgIHByb3BlcnR5ICgke2xvY2F0aW9ufSkgd2lsbCBldmFsdWF0ZSB0byB0aGUgcmlnaHQtaGFuZCBzaWRlLCBub3QgdGhlIHZhbHVlIG9mIFxcYCR7cHJvcGVydHl9XFxgIGZvbGxvd2luZyB0aGUgYXNzaWdubWVudC4gVGhpcyBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2Fzc2lnbm1lbnRfdmFsdWVfc3RhbGVgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXNzaWdubWVudF92YWx1ZV9zdGFsZWApO1xuXHR9XG59XG5cbi8qKlxuICogRGV0ZWN0ZWQgcmVhY3Rpdml0eSBsb3NzIHdoZW4gcmVhZGluZyBgJW5hbWUlYC4gVGhpcyBoYXBwZW5zIHdoZW4gc3RhdGUgaXMgcmVhZCBpbiBhbiBhc3luYyBmdW5jdGlvbiBhZnRlciBhbiBlYXJsaWVyIGBhd2FpdGBcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdF9yZWFjdGl2aXR5X2xvc3MobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGF3YWl0X3JlYWN0aXZpdHlfbG9zc1xcbiVjRGV0ZWN0ZWQgcmVhY3Rpdml0eSBsb3NzIHdoZW4gcmVhZGluZyBcXGAke25hbWV9XFxgLiBUaGlzIGhhcHBlbnMgd2hlbiBzdGF0ZSBpcyByZWFkIGluIGFuIGFzeW5jIGZ1bmN0aW9uIGFmdGVyIGFuIGVhcmxpZXIgXFxgYXdhaXRcXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hd2FpdF9yZWFjdGl2aXR5X2xvc3NgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXdhaXRfcmVhY3Rpdml0eV9sb3NzYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBbiBhc3luYyBkZXJpdmVkLCBgJW5hbWUlYCAoJWxvY2F0aW9uJSkgd2FzIG5vdCByZWFkIGltbWVkaWF0ZWx5IGFmdGVyIGl0IHJlc29sdmVkLiBUaGlzIG9mdGVuIGluZGljYXRlcyBhbiB1bm5lY2Vzc2FyeSB3YXRlcmZhbGwsIHdoaWNoIGNhbiBzbG93IGRvd24geW91ciBhcHBcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF3YWl0X3dhdGVyZmFsbChuYW1lLCBsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGF3YWl0X3dhdGVyZmFsbFxcbiVjQW4gYXN5bmMgZGVyaXZlZCwgXFxgJHtuYW1lfVxcYCAoJHtsb2NhdGlvbn0pIHdhcyBub3QgcmVhZCBpbW1lZGlhdGVseSBhZnRlciBpdCByZXNvbHZlZC4gVGhpcyBvZnRlbiBpbmRpY2F0ZXMgYW4gdW5uZWNlc3Nhcnkgd2F0ZXJmYWxsLCB3aGljaCBjYW4gc2xvdyBkb3duIHlvdXIgYXBwXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXdhaXRfd2F0ZXJmYWxsYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2F3YWl0X3dhdGVyZmFsbGApO1xuXHR9XG59XG5cbi8qKlxuICogYCViaW5kaW5nJWAgKCVsb2NhdGlvbiUpIGlzIGJpbmRpbmcgdG8gYSBub24tcmVhY3RpdmUgcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5kaW5nXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtsb2NhdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlKGJpbmRpbmcsIGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRgJWNbc3ZlbHRlXSBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZVxcbiVjJHtsb2NhdGlvblxuXHRcdFx0XHQ/IGBcXGAke2JpbmRpbmd9XFxgICgke2xvY2F0aW9ufSkgaXMgYmluZGluZyB0byBhIG5vbi1yZWFjdGl2ZSBwcm9wZXJ0eWBcblx0XHRcdFx0OiBgXFxgJHtiaW5kaW5nfVxcYCBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5YH1cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBZb3VyIGBjb25zb2xlLiVtZXRob2QlYCBjb250YWluZWQgYCRzdGF0ZWAgcHJveGllcy4gQ29uc2lkZXIgdXNpbmcgYCRpbnNwZWN0KC4uLilgIG9yIGAkc3RhdGUuc25hcHNob3QoLi4uKWAgaW5zdGVhZFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uc29sZV9sb2dfc3RhdGUobWV0aG9kKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gY29uc29sZV9sb2dfc3RhdGVcXG4lY1lvdXIgXFxgY29uc29sZS4ke21ldGhvZH1cXGAgY29udGFpbmVkIFxcYCRzdGF0ZVxcYCBwcm94aWVzLiBDb25zaWRlciB1c2luZyBcXGAkaW5zcGVjdCguLi4pXFxgIG9yIFxcYCRzdGF0ZS5zbmFwc2hvdCguLi4pXFxgIGluc3RlYWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb25zb2xlX2xvZ19zdGF0ZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9jb25zb2xlX2xvZ19zdGF0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogJWhhbmRsZXIlIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBEaWQgeW91IG1lYW4gdG8gJXN1Z2dlc3Rpb24lP1xuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWdnZXN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmVudF9oYW5kbGVyX2ludmFsaWQoaGFuZGxlciwgc3VnZ2VzdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGV2ZW50X2hhbmRsZXJfaW52YWxpZFxcbiVjJHtoYW5kbGVyfSBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBtZWFuIHRvICR7c3VnZ2VzdGlvbn0/XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZXZlbnRfaGFuZGxlcl9pbnZhbGlkYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2V2ZW50X2hhbmRsZXJfaW52YWxpZGApO1xuXHR9XG59XG5cbi8qKlxuICogRXhwZWN0ZWQgdG8gZmluZCBhIGh5ZHJhdGFibGUgd2l0aCBrZXkgYCVrZXklYCBkdXJpbmcgaHlkcmF0aW9uLCBidXQgZGlkIG5vdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGFibGVfbWlzc2luZ19idXRfZXhwZWN0ZWQoa2V5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaHlkcmF0YWJsZV9taXNzaW5nX2J1dF9leHBlY3RlZFxcbiVjRXhwZWN0ZWQgdG8gZmluZCBhIGh5ZHJhdGFibGUgd2l0aCBrZXkgXFxgJHtrZXl9XFxgIGR1cmluZyBoeWRyYXRpb24sIGJ1dCBkaWQgbm90Llxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGFibGVfbWlzc2luZ19idXRfZXhwZWN0ZWRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0YWJsZV9taXNzaW5nX2J1dF9leHBlY3RlZGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGAlYXR0cmlidXRlJWAgYXR0cmlidXRlIG9uIGAlaHRtbCVgIGNoYW5nZWQgaXRzIHZhbHVlIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSwgYCV2YWx1ZSVgLCB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZChhdHRyaWJ1dGUsIGh0bWwsIHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkXFxuJWNUaGUgXFxgJHthdHRyaWJ1dGV9XFxgIGF0dHJpYnV0ZSBvbiBcXGAke2h0bWx9XFxgIGNoYW5nZWQgaXRzIHZhbHVlIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSwgXFxgJHt2YWx1ZX1cXGAsIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSB2YWx1ZSBvZiBhbiBge0BodG1sIC4uLn1gIGJsb2NrICVsb2NhdGlvbiUgY2hhbmdlZCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtsb2NhdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9odG1sX2NoYW5nZWQobG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGAlY1tzdmVsdGVdIGh5ZHJhdGlvbl9odG1sX2NoYW5nZWRcXG4lYyR7bG9jYXRpb25cblx0XHRcdFx0PyBgVGhlIHZhbHVlIG9mIGFuIFxcYHtAaHRtbCAuLi59XFxgIGJsb2NrICR7bG9jYXRpb259IGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZWBcblx0XHRcdFx0OiAnVGhlIHZhbHVlIG9mIGFuIGB7QGh0bWwgLi4ufWAgYmxvY2sgY2hhbmdlZCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlJ31cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25faHRtbF9jaGFuZ2VkYCxcblx0XHRcdGJvbGQsXG5cdFx0XHRub3JtYWxcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2h0bWxfY2hhbmdlZGApO1xuXHR9XG59XG5cbi8qKlxuICogSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuIFRoZSBlcnJvciBvY2N1cnJlZCBuZWFyICVsb2NhdGlvbiVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2xvY2F0aW9uXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX21pc21hdGNoKGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRgJWNbc3ZlbHRlXSBoeWRyYXRpb25fbWlzbWF0Y2hcXG4lYyR7bG9jYXRpb25cblx0XHRcdFx0PyBgSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuIFRoZSBlcnJvciBvY2N1cnJlZCBuZWFyICR7bG9jYXRpb259YFxuXHRcdFx0XHQ6ICdIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlcid9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX21pc21hdGNoYCxcblx0XHRcdGJvbGQsXG5cdFx0XHRub3JtYWxcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX21pc21hdGNoYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHJlbmRlcmAgZnVuY3Rpb24gcGFzc2VkIHRvIGBjcmVhdGVSYXdTbmlwcGV0YCBzaG91bGQgcmV0dXJuIEhUTUwgZm9yIGEgc2luZ2xlIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRfcmF3X3NuaXBwZXRfcmVuZGVyKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGludmFsaWRfcmF3X3NuaXBwZXRfcmVuZGVyXFxuJWNUaGUgXFxgcmVuZGVyXFxgIGZ1bmN0aW9uIHBhc3NlZCB0byBcXGBjcmVhdGVSYXdTbmlwcGV0XFxgIHNob3VsZCByZXR1cm4gSFRNTCBmb3IgYSBzaW5nbGUgZWxlbWVudFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfcmF3X3NuaXBwZXRfcmVuZGVyYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfcmF3X3NuaXBwZXRfcmVuZGVyYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBEZXRlY3RlZCBhIG1pZ3JhdGVkIGAkOmAgcmVhY3RpdmUgYmxvY2sgaW4gYCVmaWxlbmFtZSVgIHRoYXQgYm90aCBhY2Nlc3NlcyBhbmQgdXBkYXRlcyB0aGUgc2FtZSByZWFjdGl2ZSB2YWx1ZS4gVGhpcyBtYXkgY2F1c2UgcmVjdXJzaXZlIHVwZGF0ZXMgd2hlbiBjb252ZXJ0ZWQgdG8gYW4gYCRlZmZlY3RgLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrKGZpbGVuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9ja1xcbiVjRGV0ZWN0ZWQgYSBtaWdyYXRlZCBcXGAkOlxcYCByZWFjdGl2ZSBibG9jayBpbiBcXGAke2ZpbGVuYW1lfVxcYCB0aGF0IGJvdGggYWNjZXNzZXMgYW5kIHVwZGF0ZXMgdGhlIHNhbWUgcmVhY3RpdmUgdmFsdWUuIFRoaXMgbWF5IGNhdXNlIHJlY3Vyc2l2ZSB1cGRhdGVzIHdoZW4gY29udmVydGVkIHRvIGFuIFxcYCRlZmZlY3RcXGAuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9ja2AsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9sZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUcmllZCB0byB1bm1vdW50IGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBtb3VudGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfZG91YmxlX3VubW91bnQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50XFxuJWNUcmllZCB0byB1bm1vdW50IGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBtb3VudGVkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50YCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9kb3VibGVfdW5tb3VudGApO1xuXHR9XG59XG5cbi8qKlxuICogJXBhcmVudCUgcGFzc2VkIHByb3BlcnR5IGAlcHJvcCVgIHRvICVjaGlsZCUgd2l0aCBgYmluZDpgLCBidXQgaXRzIHBhcmVudCBjb21wb25lbnQgJW93bmVyJSBkaWQgbm90IGRlY2xhcmUgYCVwcm9wJWAgYXMgYSBiaW5kaW5nLiBDb25zaWRlciBjcmVhdGluZyBhIGJpbmRpbmcgYmV0d2VlbiAlb3duZXIlIGFuZCAlcGFyZW50JSAoZS5nLiBgYmluZDolcHJvcCU9ey4uLn1gIGluc3RlYWQgb2YgYCVwcm9wJT17Li4ufWApXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3duZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcocGFyZW50LCBwcm9wLCBjaGlsZCwgb3duZXIpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBvd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nXFxuJWMke3BhcmVudH0gcGFzc2VkIHByb3BlcnR5IFxcYCR7cHJvcH1cXGAgdG8gJHtjaGlsZH0gd2l0aCBcXGBiaW5kOlxcYCwgYnV0IGl0cyBwYXJlbnQgY29tcG9uZW50ICR7b3duZXJ9IGRpZCBub3QgZGVjbGFyZSBcXGAke3Byb3B9XFxgIGFzIGEgYmluZGluZy4gQ29uc2lkZXIgY3JlYXRpbmcgYSBiaW5kaW5nIGJldHdlZW4gJHtvd25lcn0gYW5kICR7cGFyZW50fSAoZS5nLiBcXGBiaW5kOiR7cHJvcH09ey4uLn1cXGAgaW5zdGVhZCBvZiBcXGAke3Byb3B9PXsuLi59XFxgKVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmdgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfYmluZGluZ2ApO1xuXHR9XG59XG5cbi8qKlxuICogTXV0YXRpbmcgdW5ib3VuZCBwcm9wcyAoYCVuYW1lJWAsIGF0ICVsb2NhdGlvbiUpIGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkLiBDb25zaWRlciB1c2luZyBgYmluZDolcHJvcCU9ey4uLn1gIGluICVwYXJlbnQlIChvciB1c2luZyBhIGNhbGxiYWNrKSBpbnN0ZWFkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24obmFtZSwgbG9jYXRpb24sIHByb3AsIHBhcmVudCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIG93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uXFxuJWNNdXRhdGluZyB1bmJvdW5kIHByb3BzIChcXGAke25hbWV9XFxgLCBhdCAke2xvY2F0aW9ufSkgaXMgc3Ryb25nbHkgZGlzY291cmFnZWQuIENvbnNpZGVyIHVzaW5nIFxcYGJpbmQ6JHtwcm9wfT17Li4ufVxcYCBpbiAke3BhcmVudH0gKG9yIHVzaW5nIGEgY2FsbGJhY2spIGluc3RlYWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbmAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbmApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGB2YWx1ZWAgcHJvcGVydHkgb2YgYSBgPHNlbGVjdCBtdWx0aXBsZT5gIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5LCBidXQgaXQgcmVjZWl2ZWQgYSBub24tYXJyYXkgdmFsdWUuIFRoZSBzZWxlY3Rpb24gd2lsbCBiZSBrZXB0IGFzIGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX2ludmFsaWRfdmFsdWUoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc2VsZWN0X211bHRpcGxlX2ludmFsaWRfdmFsdWVcXG4lY1RoZSBcXGB2YWx1ZVxcYCBwcm9wZXJ0eSBvZiBhIFxcYDxzZWxlY3QgbXVsdGlwbGU+XFxgIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5LCBidXQgaXQgcmVjZWl2ZWQgYSBub24tYXJyYXkgdmFsdWUuIFRoZSBzZWxlY3Rpb24gd2lsbCBiZSBrZXB0IGFzIGlzLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3NlbGVjdF9tdWx0aXBsZV9pbnZhbGlkX3ZhbHVlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3NlbGVjdF9tdWx0aXBsZV9pbnZhbGlkX3ZhbHVlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZWFjdGl2ZSBgJHN0YXRlKC4uLilgIHByb3hpZXMgYW5kIHRoZSB2YWx1ZXMgdGhleSBwcm94eSBoYXZlIGRpZmZlcmVudCBpZGVudGl0aWVzLiBCZWNhdXNlIG9mIHRoaXMsIGNvbXBhcmlzb25zIHdpdGggYCVvcGVyYXRvciVgIHdpbGwgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2gob3BlcmF0b3IpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBzdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaFxcbiVjUmVhY3RpdmUgXFxgJHN0YXRlKC4uLilcXGAgcHJveGllcyBhbmQgdGhlIHZhbHVlcyB0aGV5IHByb3h5IGhhdmUgZGlmZmVyZW50IGlkZW50aXRpZXMuIEJlY2F1c2Ugb2YgdGhpcywgY29tcGFyaXNvbnMgd2l0aCBcXGAke29wZXJhdG9yfVxcYCB3aWxsIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hgKTtcblx0fVxufVxuXG4vKipcbiAqIFRyaWVkIHRvIHVubW91bnQgYSBzdGF0ZSBwcm94eSwgcmF0aGVyIHRoYW4gYSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Byb3h5X3VubW91bnQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc3RhdGVfcHJveHlfdW5tb3VudFxcbiVjVHJpZWQgdG8gdW5tb3VudCBhIHN0YXRlIHByb3h5LCByYXRoZXIgdGhhbiBhIGNvbXBvbmVudFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X3VubW91bnRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJveHlfdW5tb3VudGApO1xuXHR9XG59XG5cbi8qKlxuICogQSBgPHN2ZWx0ZTpib3VuZGFyeT5gIGByZXNldGAgZnVuY3Rpb24gb25seSByZXNldHMgdGhlIGJvdW5kYXJ5IHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X25vb3AoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X25vb3BcXG4lY0EgXFxgPHN2ZWx0ZTpib3VuZGFyeT5cXGAgXFxgcmVzZXRcXGAgZnVuY3Rpb24gb25seSByZXNldHMgdGhlIGJvdW5kYXJ5IHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHNsaWRlYCB0cmFuc2l0aW9uIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5IGZvciBlbGVtZW50cyB3aXRoIGBkaXNwbGF5OiAldmFsdWUlYFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXkodmFsdWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSB0cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXlcXG4lY1RoZSBcXGBzbGlkZVxcYCB0cmFuc2l0aW9uIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5IGZvciBlbGVtZW50cyB3aXRoIFxcYGRpc3BsYXk6ICR7dmFsdWV9XFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvdHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5YCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3RyYW5zaXRpb25fc2xpZGVfZGlzcGxheWApO1xuXHR9XG59IiwgIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cblxuaW1wb3J0IHsgQ09NTUVOVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHtcblx0SFlEUkFUSU9OX0VORCxcblx0SFlEUkFUSU9OX0VSUk9SLFxuXHRIWURSQVRJT05fU1RBUlQsXG5cdEhZRFJBVElPTl9TVEFSVF9FTFNFXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuL29wZXJhdGlvbnMuanMnO1xuXG4vKipcbiAqIFVzZSB0aGlzIHZhcmlhYmxlIHRvIGd1YXJkIGV2ZXJ5dGhpbmcgcmVsYXRlZCB0byBoeWRyYXRpb24gY29kZSBzbyBpdCBjYW4gYmUgdHJlZXNoYWtlbiBvdXRcbiAqIGlmIHRoZSB1c2VyIGRvZXNuJ3QgdXNlIHRoZSBgaHlkcmF0ZWAgbWV0aG9kIGFuZCB0aGVzZSBjb2RlIHBhdGhzIGFyZSB0aGVyZWZvcmUgbm90IG5lZWRlZC5cbiAqL1xuZXhwb3J0IGxldCBoeWRyYXRpbmcgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaHlkcmF0aW5nKHZhbHVlKSB7XG5cdGh5ZHJhdGluZyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBub2RlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGh5ZHJhdGVkLiBUaGlzIHN0YXJ0cyBvdXQgYXMgdGhlIGZpcnN0IG5vZGUgaW5zaWRlIHRoZSBvcGVuaW5nXG4gKiA8IS0tWy0tPiBjb21tZW50LCBhbmQgdXBkYXRlcyBlYWNoIHRpbWUgYSBjb21wb25lbnQgY2FsbHMgYCQuY2hpbGQoLi4uKWAgb3IgYCQuc2libGluZyguLi4pYC5cbiAqIFdoZW4gZW50ZXJpbmcgYSBibG9jayAoZS5nLiBgeyNpZiAuLi59YCksIGBoeWRyYXRlX25vZGVgIGlzIHRoZSBibG9jayBvcGVuaW5nIGNvbW1lbnQ7IGJ5IHRoZVxuICogdGltZSB3ZSBsZWF2ZSB0aGUgYmxvY2sgaXQgaXMgdGhlIGNsb3NpbmcgY29tbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBibG9jaydzIGFuY2hvci5cbiAqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9XG4gKi9cbmV4cG9ydCBsZXQgaHlkcmF0ZV9ub2RlO1xuXG4vKiogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaHlkcmF0ZV9ub2RlKG5vZGUpIHtcblx0aWYgKG5vZGUgPT09IG51bGwpIHtcblx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0fVxuXG5cdHJldHVybiAoaHlkcmF0ZV9ub2RlID0gbm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlX25leHQoKSB7XG5cdHJldHVybiBzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhoeWRyYXRlX25vZGUpKSk7XG59XG5cbi8qKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KG5vZGUpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHQvLyBJZiB0aGUgbm9kZSBoYXMgcmVtYWluaW5nIHNpYmxpbmdzLCBzb21ldGhpbmcgaGFzIGdvbmUgd3Jvbmdcblx0aWYgKGdldF9uZXh0X3NpYmxpbmcoaHlkcmF0ZV9ub2RlKSAhPT0gbnVsbCkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0aHlkcmF0ZV9ub2RlID0gbm9kZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlX3RlbXBsYXRlKHRlbXBsYXRlKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRlbXBsYXRlTm9kZSBkb2Vzbid0IGluY2x1ZGUgRG9jdW1lbnRGcmFnbWVudCwgYnV0IGl0J3MgYWN0dWFsbHkgZmluZVxuXHRcdGh5ZHJhdGVfbm9kZSA9IHRlbXBsYXRlLmNvbnRlbnQ7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHQoY291bnQgPSAxKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHR2YXIgaSA9IGNvdW50O1xuXHRcdHZhciBub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0fVxuXG5cdFx0aHlkcmF0ZV9ub2RlID0gbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIFNraXBzIG9yIHJlbW92ZXMgKGRlcGVuZGluZyBvbiB7QGxpbmsgcmVtb3ZlfSkgYWxsIG5vZGVzIHN0YXJ0aW5nIGF0IGBoeWRyYXRlX25vZGVgIHVwIHVudGlsIHRoZSBuZXh0IGh5ZHJhdGlvbiBlbmQgY29tbWVudFxuICogQHBhcmFtIHtib29sZWFufSByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNraXBfbm9kZXMocmVtb3ZlID0gdHJ1ZSkge1xuXHR2YXIgZGVwdGggPSAwO1xuXHR2YXIgbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcblx0XHRcdHZhciBkYXRhID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobm9kZSkuZGF0YTtcblxuXHRcdFx0aWYgKGRhdGEgPT09IEhZRFJBVElPTl9FTkQpIHtcblx0XHRcdFx0aWYgKGRlcHRoID09PSAwKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0ZGVwdGggLT0gMTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUIHx8IGRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFKSB7XG5cdFx0XHRcdGRlcHRoICs9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIG5leHQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXHRcdGlmIChyZW1vdmUpIG5vZGUucmVtb3ZlKCk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfaHlkcmF0aW9uX2luc3RydWN0aW9uKG5vZGUpIHtcblx0aWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0cmV0dXJuIC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5vZGUpLmRhdGE7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFcXVhbHMgfSBmcm9tICcjY2xpZW50JyAqL1xuXG4vKiogQHR5cGUge0VxdWFsc30gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHModmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSB0aGlzLnY7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBhXG4gKiBAcGFyYW0ge3Vua25vd259IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhXG5cdFx0PyBiID09IGJcblx0XHQ6IGEgIT09IGIgfHwgKGEgIT09IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGFcbiAqIEBwYXJhbSB7dW5rbm93bn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPT0gYjtcbn1cblxuLyoqIEB0eXBlIHtFcXVhbHN9ICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9lcXVhbHModmFsdWUpIHtcblx0cmV0dXJuICFzYWZlX25vdF9lcXVhbCh2YWx1ZSwgdGhpcy52KTtcbn1cbiIsICIvKiogVHJ1ZSBpZiBleHBlcmltZW50YWwuYXN5bmM9dHJ1ZSAqL1xuZXhwb3J0IGxldCBhc3luY19tb2RlX2ZsYWcgPSBmYWxzZTtcbi8qKiBUcnVlIGlmIHdlJ3JlIG5vdCBjZXJ0YWluIHRoYXQgd2Ugb25seSBoYXZlIFN2ZWx0ZSA1IGNvZGUgaW4gdGhlIGNvbXBpbGF0aW9uICovXG5leHBvcnQgbGV0IGxlZ2FjeV9tb2RlX2ZsYWcgPSBmYWxzZTtcbi8qKiBUcnVlIGlmICRpbnNwZWN0LnRyYWNlIGlzIHVzZWQgKi9cbmV4cG9ydCBsZXQgdHJhY2luZ19tb2RlX2ZsYWcgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZV9hc3luY19tb2RlX2ZsYWcoKSB7XG5cdGFzeW5jX21vZGVfZmxhZyA9IHRydWU7XG59XG5cbi8qKiBPTkxZIFVTRSBUSElTIERVUklORyBURVNUSU5HICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZV9hc3luY19tb2RlX2ZsYWcoKSB7XG5cdGFzeW5jX21vZGVfZmxhZyA9IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX2xlZ2FjeV9tb2RlX2ZsYWcoKSB7XG5cdGxlZ2FjeV9tb2RlX2ZsYWcgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX3RyYWNpbmdfbW9kZV9mbGFnKCkge1xuXHR0cmFjaW5nX21vZGVfZmxhZyA9IHRydWU7XG59XG4iLCAiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxudmFyIGJvbGQgPSAnZm9udC13ZWlnaHQ6IGJvbGQnO1xudmFyIG5vcm1hbCA9ICdmb250LXdlaWdodDogbm9ybWFsJztcblxuLyoqXG4gKiBgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIldGFnJVwiPmAgaXMgYSB2b2lkIGVsZW1lbnQgXHUyMDE0IGl0IGNhbm5vdCBoYXZlIGNvbnRlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGR5bmFtaWNfdm9pZF9lbGVtZW50X2NvbnRlbnQodGFnKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudFxcbiVjXFxgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIke3RhZ31cIj5cXGAgaXMgYSB2b2lkIGVsZW1lbnQgXHUyMDE0IGl0IGNhbm5vdCBoYXZlIGNvbnRlbnRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9keW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50YCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2R5bmFtaWNfdm9pZF9lbGVtZW50X2NvbnRlbnRgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBjYW5ub3QgYmUgY2xvbmVkIHdpdGggYCRzdGF0ZS5zbmFwc2hvdGAgXHUyMDE0IHRoZSByZXR1cm4gdmFsdWUgY29udGFpbnMgdGhlIG9yaWdpbmFsczpcbiAqIFxuICogJXByb3BlcnRpZXMlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtwcm9wZXJ0aWVzXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUocHJvcGVydGllcykge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YCVjW3N2ZWx0ZV0gc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGVcXG4lYyR7cHJvcGVydGllc1xuXHRcdFx0XHQ/IGBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIGNsb25lZCB3aXRoIFxcYCRzdGF0ZS5zbmFwc2hvdFxcYCBcdTIwMTQgdGhlIHJldHVybiB2YWx1ZSBjb250YWlucyB0aGUgb3JpZ2luYWxzOlxuXG4ke3Byb3BlcnRpZXN9YFxuXHRcdFx0XHQ6ICdWYWx1ZSBjYW5ub3QgYmUgY2xvbmVkIHdpdGggYCRzdGF0ZS5zbmFwc2hvdGAgXHUyMDE0IHRoZSBvcmlnaW5hbCB2YWx1ZSB3YXMgcmV0dXJuZWQnfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlYCxcblx0XHRcdGJvbGQsXG5cdFx0XHRub3JtYWxcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGVgKTtcblx0fVxufSIsICIvKiogQGltcG9ydCB7IFNuYXBzaG90IH0gZnJvbSAnLi90eXBlcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9wcm90b3R5cGVfb2YsIGlzX2FycmF5LCBvYmplY3RfcHJvdG90eXBlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qKlxuICogSW4gZGV2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIHByb3BlcnRpZXMgY291bGQgbm90IGJlIGNsb25lZC4gSW4gcHJvZFxuICogd2UgZG9uJ3QgYm90aGVyLCBidXQgd2Uga2VlcCBhIGR1bW15IGFycmF5IGFyb3VuZCBzbyB0aGF0IHRoZVxuICogc2lnbmF0dXJlIHN0YXlzIHRoZSBzYW1lXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKi9cbmNvbnN0IGVtcHR5ID0gW107XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vX3RvanNvbl1cbiAqIEByZXR1cm5zIHtTbmFwc2hvdDxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90KHZhbHVlLCBza2lwX3dhcm5pbmcgPSBmYWxzZSwgbm9fdG9qc29uID0gZmFsc2UpIHtcblx0aWYgKERFViAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblx0XHRjb25zdCBwYXRocyA9IFtdO1xuXG5cdFx0Y29uc3QgY29weSA9IGNsb25lKHZhbHVlLCBuZXcgTWFwKCksICcnLCBwYXRocywgbnVsbCwgbm9fdG9qc29uKTtcblx0XHRpZiAocGF0aHMubGVuZ3RoID09PSAxICYmIHBhdGhzWzBdID09PSAnJykge1xuXHRcdFx0Ly8gdmFsdWUgY291bGQgbm90IGJlIGNsb25lZFxuXHRcdFx0dy5zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZSgpO1xuXHRcdH0gZWxzZSBpZiAocGF0aHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Ly8gc29tZSBwcm9wZXJ0aWVzIGNvdWxkIG5vdCBiZSBjbG9uZWRcblx0XHRcdGNvbnN0IHNsaWNlID0gcGF0aHMubGVuZ3RoID4gMTAgPyBwYXRocy5zbGljZSgwLCA3KSA6IHBhdGhzLnNsaWNlKDAsIDEwKTtcblx0XHRcdGNvbnN0IGV4Y2VzcyA9IHBhdGhzLmxlbmd0aCAtIHNsaWNlLmxlbmd0aDtcblxuXHRcdFx0bGV0IHVuY2xvbmVkID0gc2xpY2UubWFwKChwYXRoKSA9PiBgLSA8dmFsdWU+JHtwYXRofWApLmpvaW4oJ1xcbicpO1xuXHRcdFx0aWYgKGV4Y2VzcyA+IDApIHVuY2xvbmVkICs9IGBcXG4tIC4uLmFuZCAke2V4Y2Vzc30gbW9yZWA7XG5cblx0XHRcdHcuc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUodW5jbG9uZWQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb3B5O1xuXHR9XG5cblx0cmV0dXJuIGNsb25lKHZhbHVlLCBuZXcgTWFwKCksICcnLCBlbXB0eSwgbnVsbCwgbm9fdG9qc29uKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHtNYXA8VCwgU25hcHNob3Q8VD4+fSBjbG9uZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoc1xuICogQHBhcmFtIHtudWxsIHwgVH0gW29yaWdpbmFsXSBUaGUgb3JpZ2luYWwgdmFsdWUsIGlmIGB2YWx1ZWAgd2FzIHByb2R1Y2VkIGZyb20gYSBgdG9KU09OYCBjYWxsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtub190b2pzb25dXG4gKiBAcmV0dXJucyB7U25hcHNob3Q8VD59XG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlLCBjbG9uZWQsIHBhdGgsIHBhdGhzLCBvcmlnaW5hbCA9IG51bGwsIG5vX3RvanNvbiA9IGZhbHNlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0dmFyIHVud3JhcHBlZCA9IGNsb25lZC5nZXQodmFsdWUpO1xuXHRcdGlmICh1bndyYXBwZWQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHVud3JhcHBlZDtcblxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkgcmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovIChuZXcgTWFwKHZhbHVlKSk7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSByZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKG5ldyBTZXQodmFsdWUpKTtcblxuXHRcdGlmIChpc19hcnJheSh2YWx1ZSkpIHtcblx0XHRcdHZhciBjb3B5ID0gLyoqIEB0eXBlIHtTbmFwc2hvdDxhbnk+fSAqLyAoQXJyYXkodmFsdWUubGVuZ3RoKSk7XG5cdFx0XHRjbG9uZWQuc2V0KHZhbHVlLCBjb3B5KTtcblxuXHRcdFx0aWYgKG9yaWdpbmFsICE9PSBudWxsKSB7XG5cdFx0XHRcdGNsb25lZC5zZXQob3JpZ2luYWwsIGNvcHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gdmFsdWVbaV07XG5cdFx0XHRcdGlmIChpIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0Y29weVtpXSA9IGNsb25lKGVsZW1lbnQsIGNsb25lZCwgREVWID8gYCR7cGF0aH1bJHtpfV1gIDogcGF0aCwgcGF0aHMsIG51bGwsIG5vX3RvanNvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fVxuXG5cdFx0aWYgKGdldF9wcm90b3R5cGVfb2YodmFsdWUpID09PSBvYmplY3RfcHJvdG90eXBlKSB7XG5cdFx0XHQvKiogQHR5cGUge1NuYXBzaG90PGFueT59ICovXG5cdFx0XHRjb3B5ID0ge307XG5cdFx0XHRjbG9uZWQuc2V0KHZhbHVlLCBjb3B5KTtcblxuXHRcdFx0aWYgKG9yaWdpbmFsICE9PSBudWxsKSB7XG5cdFx0XHRcdGNsb25lZC5zZXQob3JpZ2luYWwsIGNvcHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdFx0Y29weVtrZXldID0gY2xvbmUoXG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRcdHZhbHVlW2tleV0sXG5cdFx0XHRcdFx0Y2xvbmVkLFxuXHRcdFx0XHRcdERFViA/IGAke3BhdGh9LiR7a2V5fWAgOiBwYXRoLFxuXHRcdFx0XHRcdHBhdGhzLFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0bm9fdG9qc29uXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAoc3RydWN0dXJlZENsb25lKHZhbHVlKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiAoLyoqIEB0eXBlIHtUICYgeyB0b0pTT04/OiBhbnkgfSB9ICovICh2YWx1ZSkudG9KU09OKSA9PT0gJ2Z1bmN0aW9uJyAmJiAhbm9fdG9qc29uKSB7XG5cdFx0XHRyZXR1cm4gY2xvbmUoXG5cdFx0XHRcdC8qKiBAdHlwZSB7VCAmIHsgdG9KU09OKCk6IGFueSB9IH0gKi8gKHZhbHVlKS50b0pTT04oKSxcblx0XHRcdFx0Y2xvbmVkLFxuXHRcdFx0XHRERVYgPyBgJHtwYXRofS50b0pTT04oKWAgOiBwYXRoLFxuXHRcdFx0XHRwYXRocyxcblx0XHRcdFx0Ly8gQXNzb2NpYXRlIHRoZSBpbnN0YW5jZSB3aXRoIHRoZSB0b0pTT04gY2xvbmVcblx0XHRcdFx0dmFsdWVcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcblx0XHQvLyBjYW4ndCBiZSBjbG9uZWRcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKHZhbHVlKTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovIChzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdHBhdGhzLnB1c2gocGF0aCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovICh2YWx1ZSk7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IERlcml2ZWQsIFJlYWN0aW9uLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHNuYXBzaG90IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Nsb25lLmpzJztcbmltcG9ydCB7IERFUklWRUQsIEFTWU5DLCBQUk9YWV9QQVRIX1NZTUJPTCwgU1RBVEVfU1lNQk9MIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgZWZmZWN0X3RyYWNraW5nIH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9yZWFjdGlvbiwgdW50cmFjayB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHRyYWNlczogRXJyb3JbXTtcbiAqIH19IFRyYWNlRW50cnlcbiAqL1xuXG4vKiogQHR5cGUge3sgcmVhY3Rpb246IFJlYWN0aW9uIHwgbnVsbCwgZW50cmllczogTWFwPFZhbHVlLCBUcmFjZUVudHJ5PiB9IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgdHJhY2luZ19leHByZXNzaW9ucyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtWYWx1ZX0gc2lnbmFsXG4gKiBAcGFyYW0ge1RyYWNlRW50cnl9IFtlbnRyeV1cbiAqL1xuZnVuY3Rpb24gbG9nX2VudHJ5KHNpZ25hbCwgZW50cnkpIHtcblx0Y29uc3QgdmFsdWUgPSBzaWduYWwudjtcblxuXHRpZiAodmFsdWUgPT09IFVOSU5JVElBTElaRUQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB0eXBlID0gZ2V0X3R5cGUoc2lnbmFsKTtcblx0Y29uc3QgY3VycmVudF9yZWFjdGlvbiA9IC8qKiBAdHlwZSB7UmVhY3Rpb259ICovIChhY3RpdmVfcmVhY3Rpb24pO1xuXHRjb25zdCBkaXJ0eSA9IHNpZ25hbC53diA+IGN1cnJlbnRfcmVhY3Rpb24ud3YgfHwgY3VycmVudF9yZWFjdGlvbi53diA9PT0gMDtcblx0Y29uc3Qgc3R5bGUgPSBkaXJ0eVxuXHRcdD8gJ2NvbG9yOiBDb3JuZmxvd2VyQmx1ZTsgZm9udC13ZWlnaHQ6IGJvbGQnXG5cdFx0OiAnY29sb3I6IGdyZXk7IGZvbnQtd2VpZ2h0OiBub3JtYWwnO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG5cdFx0c2lnbmFsLmxhYmVsID8gYCVjJHt0eXBlfSVjICR7c2lnbmFsLmxhYmVsfWAgOiBgJWMke3R5cGV9JWNgLFxuXHRcdHN0eWxlLFxuXHRcdGRpcnR5ID8gJ2ZvbnQtd2VpZ2h0OiBub3JtYWwnIDogc3R5bGUsXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBTVEFURV9TWU1CT0wgaW4gdmFsdWVcblx0XHRcdD8gc25hcHNob3QodmFsdWUsIHRydWUpXG5cdFx0XHQ6IHZhbHVlXG5cdCk7XG5cblx0aWYgKHR5cGUgPT09ICckZGVyaXZlZCcpIHtcblx0XHRjb25zdCBkZXBzID0gbmV3IFNldCgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpLmRlcHMpO1xuXHRcdGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcblx0XHRcdGxvZ19lbnRyeShkZXApO1xuXHRcdH1cblx0fVxuXG5cdGlmIChzaWduYWwuY3JlYXRlZCkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0Y29uc29sZS5sb2coc2lnbmFsLmNyZWF0ZWQpO1xuXHR9XG5cblx0aWYgKGRpcnR5ICYmIHNpZ25hbC51cGRhdGVkKSB7XG5cdFx0Zm9yIChjb25zdCB1cGRhdGVkIG9mIHNpZ25hbC51cGRhdGVkLnZhbHVlcygpKSB7XG5cdFx0XHRpZiAodXBkYXRlZC5lcnJvcikge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0XHRjb25zb2xlLmxvZyh1cGRhdGVkLmVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZW50cnkpIHtcblx0XHRmb3IgKHZhciB0cmFjZSBvZiBlbnRyeS50cmFjZXMpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmxvZyh0cmFjZSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0Y29uc29sZS5ncm91cEVuZCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VmFsdWV9IHNpZ25hbFxuICogQHJldHVybnMgeyckc3RhdGUnIHwgJyRkZXJpdmVkJyB8ICdzdG9yZSd9XG4gKi9cbmZ1bmN0aW9uIGdldF90eXBlKHNpZ25hbCkge1xuXHRpZiAoKHNpZ25hbC5mICYgKERFUklWRUQgfCBBU1lOQykpICE9PSAwKSByZXR1cm4gJyRkZXJpdmVkJztcblx0cmV0dXJuIHNpZ25hbC5sYWJlbD8uc3RhcnRzV2l0aCgnJCcpID8gJ3N0b3JlJyA6ICckc3RhdGUnO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IHN0cmluZ30gbGFiZWxcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNlKGxhYmVsLCBmbikge1xuXHR2YXIgcHJldmlvdXNseV90cmFjaW5nX2V4cHJlc3Npb25zID0gdHJhY2luZ19leHByZXNzaW9ucztcblxuXHR0cnkge1xuXHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMgPSB7IGVudHJpZXM6IG5ldyBNYXAoKSwgcmVhY3Rpb246IGFjdGl2ZV9yZWFjdGlvbiB9O1xuXG5cdFx0dmFyIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0dmFyIHZhbHVlID0gZm4oKTtcblx0XHR2YXIgdGltZSA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpO1xuXG5cdFx0dmFyIHByZWZpeCA9IHVudHJhY2sobGFiZWwpO1xuXG5cdFx0aWYgKCFlZmZlY3RfdHJhY2tpbmcoKSkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUubG9nKGAke3ByZWZpeH0gJWNyYW4gb3V0c2lkZSBvZiBhbiBlZmZlY3QgKCR7dGltZX1tcylgLCAnY29sb3I6IGdyZXknKTtcblx0XHR9IGVsc2UgaWYgKHRyYWNpbmdfZXhwcmVzc2lvbnMuZW50cmllcy5zaXplID09PSAwKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS5sb2coYCR7cHJlZml4fSAlY25vIHJlYWN0aXZlIGRlcGVuZGVuY2llcyAoJHt0aW1lfW1zKWAsICdjb2xvcjogZ3JleScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS5ncm91cChgJHtwcmVmaXh9ICVjKCR7dGltZX1tcylgLCAnY29sb3I6IGdyZXknKTtcblxuXHRcdFx0dmFyIGVudHJpZXMgPSB0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXM7XG5cblx0XHRcdHVudHJhY2soKCkgPT4ge1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzaWduYWwsIHRyYWNlc10gb2YgZW50cmllcykge1xuXHRcdFx0XHRcdGxvZ19lbnRyeShzaWduYWwsIHRyYWNlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zID0gbnVsbDtcblxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJhY2luZ19leHByZXNzaW9ucyA9IHByZXZpb3VzbHlfdHJhY2luZ19leHByZXNzaW9ucztcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VmFsdWV9IHNvdXJjZVxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWcoc291cmNlLCBsYWJlbCkge1xuXHRzb3VyY2UubGFiZWwgPSBsYWJlbDtcblx0dGFnX3Byb3h5KHNvdXJjZS52LCBsYWJlbCk7XG5cblx0cmV0dXJuIHNvdXJjZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhZ19wcm94eSh2YWx1ZSwgbGFiZWwpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YWx1ZT8uW1BST1hZX1BBVEhfU1lNQk9MXT8uKGxhYmVsKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhYmVsKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSByZXR1cm4gYFN5bWJvbCgke3ZhbHVlLmRlc2NyaXB0aW9ufSlgO1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gJzxmdW5jdGlvbj4nO1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSkgcmV0dXJuICc8b2JqZWN0Pic7XG5cdHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuIiwgImltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICogQHJldHVybnMge0Vycm9yICYgeyBzdGFjazogc3RyaW5nIH0gfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2Vycm9yKGxhYmVsKSB7XG5cdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG5cdGNvbnN0IHN0YWNrID0gZ2V0X3N0YWNrKCk7XG5cblx0aWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0c3RhY2sudW5zaGlmdCgnXFxuJyk7XG5cblx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnc3RhY2snLCB7XG5cdFx0dmFsdWU6IHN0YWNrLmpvaW4oJ1xcbicpXG5cdH0pO1xuXG5cdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ25hbWUnLCB7XG5cdFx0dmFsdWU6IGxhYmVsXG5cdH0pO1xuXG5cdHJldHVybiAvKiogQHR5cGUge0Vycm9yICYgeyBzdGFjazogc3RyaW5nIH19ICovIChlcnJvcik7XG59XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N0YWNrKCkge1xuXHQvLyBAdHMtaWdub3JlIC0gZG9lc24ndCBleGlzdCBldmVyeXdoZXJlXG5cdGNvbnN0IGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuXHQvLyBAdHMtaWdub3JlIC0gZG9lc24ndCBleGlzdCBldmVyeXdoZXJlXG5cdEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IEluZmluaXR5O1xuXHRjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuXHQvLyBAdHMtaWdub3JlIC0gZG9lc24ndCBleGlzdCBldmVyeXdoZXJlXG5cdEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuXG5cdGlmICghc3RhY2spIHJldHVybiBbXTtcblxuXHRjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KCdcXG4nKTtcblx0Y29uc3QgbmV3X2xpbmVzID0gW107XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcblx0XHRjb25zdCBwb3NpeGlmaWVkID0gbGluZS5yZXBsYWNlQWxsKCdcXFxcJywgJy8nKTtcblxuXHRcdGlmIChsaW5lLnRyaW0oKSA9PT0gJ0Vycm9yJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKGxpbmUuaW5jbHVkZXMoJ3ZhbGlkYXRlX2VhY2hfa2V5cycpKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0aWYgKHBvc2l4aWZpZWQuaW5jbHVkZXMoJ3N2ZWx0ZS9zcmMvaW50ZXJuYWwnKSB8fCBwb3NpeGlmaWVkLmluY2x1ZGVzKCdub2RlX21vZHVsZXMvLnZpdGUnKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0bmV3X2xpbmVzLnB1c2gobGluZSk7XG5cdH1cblxuXHRyZXR1cm4gbmV3X2xpbmVzO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgRGV2U3RhY2tFbnRyeSwgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBhY3RpdmVfcmVhY3Rpb24gfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3VzZXJfZWZmZWN0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnLCBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQlJBTkNIX0VGRkVDVCwgRUZGRUNUX1JBTiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgY29tcG9uZW50X2NvbnRleHQgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gY29udGV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jb21wb25lbnRfY29udGV4dChjb250ZXh0KSB7XG5cdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqIEB0eXBlIHtEZXZTdGFja0VudHJ5IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgZGV2X3N0YWNrID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7RGV2U3RhY2tFbnRyeSB8IG51bGx9IHN0YWNrICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rldl9zdGFjayhzdGFjaykge1xuXHRkZXZfc3RhY2sgPSBzdGFjaztcbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgd2l0aCBhIG5ldyBkZXYgc3RhY2sgZW50cnlcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7RGV2U3RhY2tFbnRyeVsndHlwZSddfSB0eXBlIC0gVHlwZSBvZiBibG9jay9jb21wb25lbnRcbiAqIEBwYXJhbSB7YW55fSBjb21wb25lbnQgLSBDb21wb25lbnQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIC0gTGluZSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gLSBDb2x1bW4gbnVtYmVyXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFthZGRpdGlvbmFsXSAtIEFueSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBkZXYgc3RhY2sgZW50cnlcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfc3ZlbHRlX21ldGEoY2FsbGJhY2ssIHR5cGUsIGNvbXBvbmVudCwgbGluZSwgY29sdW1uLCBhZGRpdGlvbmFsKSB7XG5cdGNvbnN0IHBhcmVudCA9IGRldl9zdGFjaztcblxuXHRkZXZfc3RhY2sgPSB7XG5cdFx0dHlwZSxcblx0XHRmaWxlOiBjb21wb25lbnRbRklMRU5BTUVdLFxuXHRcdGxpbmUsXG5cdFx0Y29sdW1uLFxuXHRcdHBhcmVudCxcblx0XHQuLi5hZGRpdGlvbmFsXG5cdH07XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gY2FsbGJhY2soKTtcblx0fSBmaW5hbGx5IHtcblx0XHRkZXZfc3RhY2sgPSBwYXJlbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBjb21wb25lbnQgZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGN1cnJlbnQgY29tcG9uZW50IGNvbnRleHQ6XG4gKiBgYGBodG1sXG4gKiA8IS0tIEFwcC5zdmVsdGUgLS0+XG4gKiA8Rm9vPlxuICogICA8QmFyIC8+IDwhLS0gY29udGV4dCA9PSBGb28uc3ZlbHRlLCBmdW5jdGlvbiA9PSBBcHAuc3ZlbHRlIC0tPlxuICogPC9Gb28+XG4gKiBgYGBcbiAqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0WydmdW5jdGlvbiddfVxuICovXG5leHBvcnQgbGV0IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRbJ2Z1bmN0aW9uJ119IGZuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihmbikge1xuXHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBmbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYFtnZXQsIHNldF1gIHBhaXIgb2YgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggY29udGV4dCBpbiBhIHR5cGUtc2FmZSB3YXkuXG4gKlxuICogYGdldGAgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBubyBwYXJlbnQgY29tcG9uZW50IGNhbGxlZCBgc2V0YC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHJldHVybnMge1soKSA9PiBULCAoY29udGV4dDogVCkgPT4gVF19XG4gKiBAc2luY2UgNS40MC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xuXHRjb25zdCBrZXkgPSB7fTtcblxuXHRyZXR1cm4gW1xuXHRcdCgpID0+IHtcblx0XHRcdGlmICghaGFzQ29udGV4dChrZXkpKSB7XG5cdFx0XHRcdGUubWlzc2luZ19jb250ZXh0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZXRDb250ZXh0KGtleSk7XG5cdFx0fSxcblx0XHQoY29udGV4dCkgPT4gc2V0Q29udGV4dChrZXksIGNvbnRleHQpXG5cdF07XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogW2BjcmVhdGVDb250ZXh0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3N2ZWx0ZSNjcmVhdGVDb250ZXh0KSBpcyBhIHR5cGUtc2FmZSBhbHRlcm5hdGl2ZS5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRDb250ZXh0Jyk7XG5cdGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7VH0gKi8gKGNvbnRleHRfbWFwLmdldChrZXkpKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIFtgY3JlYXRlQ29udGV4dGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUjY3JlYXRlQ29udGV4dCkgaXMgYSB0eXBlLXNhZmUgYWx0ZXJuYXRpdmUuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEBwYXJhbSB7VH0gY29udGV4dFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdzZXRDb250ZXh0Jyk7XG5cblx0aWYgKGFzeW5jX21vZGVfZmxhZykge1xuXHRcdHZhciBmbGFncyA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuZjtcblx0XHR2YXIgdmFsaWQgPVxuXHRcdFx0IWFjdGl2ZV9yZWFjdGlvbiAmJlxuXHRcdFx0KGZsYWdzICYgQlJBTkNIX0VGRkVDVCkgIT09IDAgJiZcblx0XHRcdC8vIHBvcCgpIHJ1bnMgc3luY2hyb25vdXNseSwgc28gdGhpcyBpbmRpY2F0ZXMgd2UncmUgc2V0dGluZyBjb250ZXh0IGFmdGVyIGFuIGF3YWl0XG5cdFx0XHQhKC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KS5pKTtcblxuXHRcdGlmICghdmFsaWQpIHtcblx0XHRcdGUuc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdCgpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnRleHRfbWFwLnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnaGFzQ29udGV4dCcpO1xuXHRyZXR1cm4gY29udGV4dF9tYXAuaGFzKGtleSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IFtUPU1hcDxhbnksIGFueT5dXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRBbGxDb250ZXh0cycpO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAoY29udGV4dF9tYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge2FueX0gcnVuZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaChwcm9wcywgcnVuZXMgPSBmYWxzZSwgZm4pIHtcblx0Y29tcG9uZW50X2NvbnRleHQgPSB7XG5cdFx0cDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0aTogZmFsc2UsXG5cdFx0YzogbnVsbCxcblx0XHRlOiBudWxsLFxuXHRcdHM6IHByb3BzLFxuXHRcdHg6IG51bGwsXG5cdFx0bDogbGVnYWN5X21vZGVfZmxhZyAmJiAhcnVuZXMgPyB7IHM6IG51bGwsIHU6IG51bGwsICQ6IFtdIH0gOiBudWxsXG5cdH07XG5cblx0aWYgKERFVikge1xuXHRcdC8vIGNvbXBvbmVudCBmdW5jdGlvblxuXHRcdGNvbXBvbmVudF9jb250ZXh0LmZ1bmN0aW9uID0gZm47XG5cdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gZm47XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFRcbiAqIEBwYXJhbSB7VH0gW2NvbXBvbmVudF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wKGNvbXBvbmVudCkge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblx0dmFyIGVmZmVjdHMgPSBjb250ZXh0LmU7XG5cblx0aWYgKGVmZmVjdHMgIT09IG51bGwpIHtcblx0XHRjb250ZXh0LmUgPSBudWxsO1xuXG5cdFx0Zm9yICh2YXIgZm4gb2YgZWZmZWN0cykge1xuXHRcdFx0Y3JlYXRlX3VzZXJfZWZmZWN0KGZuKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29tcG9uZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb250ZXh0LnggPSBjb21wb25lbnQ7XG5cdH1cblxuXHRjb250ZXh0LmkgPSB0cnVlO1xuXG5cdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dC5wO1xuXG5cdGlmIChERVYpIHtcblx0XHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBjb21wb25lbnRfY29udGV4dD8uZnVuY3Rpb24gPz8gbnVsbDtcblx0fVxuXG5cdHJldHVybiBjb21wb25lbnQgPz8gLyoqIEB0eXBlIHtUfSAqLyAoe30pO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcnVuZXMoKSB7XG5cdHJldHVybiAhbGVnYWN5X21vZGVfZmxhZyB8fCAoY29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiYgY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtNYXA8dW5rbm93biwgdW5rbm93bj59XG4gKi9cbmZ1bmN0aW9uIGdldF9vcl9pbml0X2NvbnRleHRfbWFwKG5hbWUpIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQobmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gKGNvbXBvbmVudF9jb250ZXh0LmMgPz89IG5ldyBNYXAoZ2V0X3BhcmVudF9jb250ZXh0KGNvbXBvbmVudF9jb250ZXh0KSB8fCB1bmRlZmluZWQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHR9IGNvbXBvbmVudF9jb250ZXh0XG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0X3BhcmVudF9jb250ZXh0KGNvbXBvbmVudF9jb250ZXh0KSB7XG5cdGxldCBwYXJlbnQgPSBjb21wb25lbnRfY29udGV4dC5wO1xuXHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgY29udGV4dF9tYXAgPSBwYXJlbnQuYztcblx0XHRpZiAoY29udGV4dF9tYXAgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBjb250ZXh0X21hcDtcblx0XHR9XG5cdFx0cGFyZW50ID0gcGFyZW50LnA7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG4iLCAiaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBpc19mbHVzaGluZ19zeW5jIH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5cbi8qKiBAdHlwZSB7QXJyYXk8KCkgPT4gdm9pZD59ICovXG5sZXQgbWljcm9fdGFza3MgPSBbXTtcblxuZnVuY3Rpb24gcnVuX21pY3JvX3Rhc2tzKCkge1xuXHR2YXIgdGFza3MgPSBtaWNyb190YXNrcztcblx0bWljcm9fdGFza3MgPSBbXTtcblx0cnVuX2FsbCh0YXNrcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVldWVfbWljcm9fdGFzayhmbikge1xuXHRpZiAobWljcm9fdGFza3MubGVuZ3RoID09PSAwICYmICFpc19mbHVzaGluZ19zeW5jKSB7XG5cdFx0dmFyIHRhc2tzID0gbWljcm9fdGFza3M7XG5cdFx0cXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBmYWxzZSwgYSBmbHVzaFN5bmMgaGFwcGVuZWQgaW4gdGhlIG1lYW50aW1lLiBEbyBfbm90XyBydW4gbmV3IHNjaGVkdWxlZCBtaWNyb3Rhc2tzIGluIHRoYXQgY2FzZVxuXHRcdFx0Ly8gYXMgdGhlIG9yZGVyaW5nIG9mIG1pY3JvdGFza3Mgd291bGQgYmUgYnJva2VuIGF0IHRoYXQgcG9pbnQgLSBjb25zaWRlciB0aGlzIGNhc2U6XG5cdFx0XHQvLyAtIHF1ZXVlX21pY3JvX3Rhc2sgc2NoZWR1bGVzIG1pY3JvdGFzayBBIHRvIGZsdXNoIHRhc2sgWFxuXHRcdFx0Ly8gLSBzeW5jaHJvbm91c2x5IGFmdGVyLCBmbHVzaFN5bmMgcnVucywgcHJvY2Vzc2luZyB0YXNrIFhcblx0XHRcdC8vIC0gc3luY2hyb25vdXNseSBhZnRlciwgc29tZSBvdGhlciBtaWNyb3Rhc2sgQiBpcyBzY2hlZHVsZWQsIGJ1dCBub3QgdGhyb3VnaCBxdWV1ZV9taWNyb190YXNrIGJ1dCBmb3IgZXhhbXBsZSBhIFByb21pc2UucmVzb2x2ZSgpIGluIHVzZXIgY29kZVxuXHRcdFx0Ly8gLSBzeW5jaHJvbm91c2x5IGFmdGVyLCBxdWV1ZV9taWNyb190YXNrIHNjaGVkdWxlcyBtaWNyb3Rhc2sgQyB0byBmbHVzaCB0YXNrIFlcblx0XHRcdC8vIC0gb25lIHRpY2sgbGF0ZXIsIG1pY3JvdGFzayBBIG5vdyByZXNvbHZlcywgZmx1c2hpbmcgdGFzayBZIGJlZm9yZSBtaWNyb3Rhc2sgQiwgd2hpY2ggaXMgaW5jb3JyZWN0XG5cdFx0XHQvLyBUaGlzIGlmIGNoZWNrIHByZXZlbnRzIHRoYXQgcmFjZSBjb25kaXRpb24gKHRoYXQgcmVhbGlzdGljYWxseSB3aWxsIG9ubHkgaGFwcGVuIGluIHRlc3RzKVxuXHRcdFx0aWYgKHRhc2tzID09PSBtaWNyb190YXNrcykgcnVuX21pY3JvX3Rhc2tzKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRtaWNyb190YXNrcy5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHJ1biBhbnkgcXVldWVkIHRhc2tzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfdGFza3MoKSB7XG5cdHdoaWxlIChtaWNyb190YXNrcy5sZW5ndGggPiAwKSB7XG5cdFx0cnVuX21pY3JvX3Rhc2tzKCk7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEJvdW5kYXJ5IH0gZnJvbSAnLi9kb20vYmxvY2tzL2JvdW5kYXJ5LmpzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBGSUxFTkFNRSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBpc19maXJlZm94IH0gZnJvbSAnLi9kb20vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBFUlJPUl9WQUxVRSwgQk9VTkRBUllfRUZGRUNULCBFRkZFQ1RfUkFOIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBnZXRfZGVzY3JpcHRvciB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBhY3RpdmVfcmVhY3Rpb24gfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuXG5jb25zdCBhZGp1c3RtZW50cyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBlcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlX2Vycm9yKGVycm9yKSB7XG5cdHZhciBlZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdC8vIGZvciB1bm93bmVkIGRlcml2ZWRzLCBkb24ndCB0aHJvdyB1bnRpbCB3ZSByZWFkIHRoZSB2YWx1ZVxuXHRpZiAoZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0LyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKS5mIHw9IEVSUk9SX1ZBTFVFO1xuXHRcdHJldHVybiBlcnJvcjtcblx0fVxuXG5cdGlmIChERVYgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhYWRqdXN0bWVudHMuaGFzKGVycm9yKSkge1xuXHRcdGFkanVzdG1lbnRzLnNldChlcnJvciwgZ2V0X2FkanVzdG1lbnRzKGVycm9yLCBlZmZlY3QpKTtcblx0fVxuXG5cdGlmICgoZWZmZWN0LmYgJiBFRkZFQ1RfUkFOKSA9PT0gMCkge1xuXHRcdC8vIGlmIHRoZSBlcnJvciBvY2N1cnJlZCB3aGlsZSBjcmVhdGluZyB0aGlzIHN1YnRyZWUsIHdlIGxldCBpdFxuXHRcdC8vIGJ1YmJsZSB1cCB1bnRpbCBpdCBoaXRzIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIGl0XG5cdFx0aWYgKChlZmZlY3QuZiAmIEJPVU5EQVJZX0VGRkVDVCkgPT09IDApIHtcblx0XHRcdGlmIChERVYgJiYgIWVmZmVjdC5wYXJlbnQgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHRhcHBseV9hZGp1c3RtZW50cyhlcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdC8qKiBAdHlwZSB7Qm91bmRhcnl9ICovIChlZmZlY3QuYikuZXJyb3IoZXJyb3IpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIG90aGVyd2lzZSB3ZSBidWJibGUgdXAgdGhlIGVmZmVjdCB0cmVlIG91cnNlbHZlc1xuXHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3JcbiAqIEBwYXJhbSB7RWZmZWN0IHwgbnVsbH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIGVmZmVjdCkge1xuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0aWYgKChlZmZlY3QuZiAmIEJPVU5EQVJZX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7Qm91bmRhcnl9ICovIChlZmZlY3QuYikuZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRlZmZlY3QgPSBlZmZlY3QucGFyZW50O1xuXHR9XG5cblx0aWYgKERFViAmJiBlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0YXBwbHlfYWRqdXN0bWVudHMoZXJyb3IpO1xuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG5cbi8qKlxuICogQWRkIHVzZWZ1bCBpbmZvcm1hdGlvbiB0byB0aGUgZXJyb3IgbWVzc2FnZS9zdGFjayBpbiBkZXZlbG9wbWVudFxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0X2FkanVzdG1lbnRzKGVycm9yLCBlZmZlY3QpIHtcblx0Y29uc3QgbWVzc2FnZV9kZXNjcmlwdG9yID0gZ2V0X2Rlc2NyaXB0b3IoZXJyb3IsICdtZXNzYWdlJyk7XG5cblx0Ly8gaWYgdGhlIG1lc3NhZ2Ugd2FzIGFscmVhZHkgY2hhbmdlZCBhbmQgaXQncyBub3QgY29uZmlndXJhYmxlIHdlIGNhbid0IGNoYW5nZSBpdFxuXHQvLyBvciBpdCB3aWxsIHRocm93IGEgZGlmZmVyZW50IGVycm9yIHN3YWxsb3dpbmcgdGhlIG9yaWdpbmFsIGVycm9yXG5cdGlmIChtZXNzYWdlX2Rlc2NyaXB0b3IgJiYgIW1lc3NhZ2VfZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHJldHVybjtcblxuXHR2YXIgaW5kZW50ID0gaXNfZmlyZWZveCA/ICcgICcgOiAnXFx0Jztcblx0dmFyIGNvbXBvbmVudF9zdGFjayA9IGBcXG4ke2luZGVudH1pbiAke2VmZmVjdC5mbj8ubmFtZSB8fCAnPHVua25vd24+J31gO1xuXHR2YXIgY29udGV4dCA9IGVmZmVjdC5jdHg7XG5cblx0d2hpbGUgKGNvbnRleHQgIT09IG51bGwpIHtcblx0XHRjb21wb25lbnRfc3RhY2sgKz0gYFxcbiR7aW5kZW50fWluICR7Y29udGV4dC5mdW5jdGlvbj8uW0ZJTEVOQU1FXS5zcGxpdCgnLycpLnBvcCgpfWA7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQucDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bWVzc2FnZTogZXJyb3IubWVzc2FnZSArIGBcXG4ke2NvbXBvbmVudF9zdGFja31cXG5gLFxuXHRcdHN0YWNrOiBlcnJvci5zdGFja1xuXHRcdFx0Py5zcGxpdCgnXFxuJylcblx0XHRcdC5maWx0ZXIoKGxpbmUpID0+ICFsaW5lLmluY2x1ZGVzKCdzdmVsdGUvc3JjL2ludGVybmFsJykpXG5cdFx0XHQuam9pbignXFxuJylcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICovXG5mdW5jdGlvbiBhcHBseV9hZGp1c3RtZW50cyhlcnJvcikge1xuXHRjb25zdCBhZGp1c3RlZCA9IGFkanVzdG1lbnRzLmdldChlcnJvcik7XG5cblx0aWYgKGFkanVzdGVkKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnbWVzc2FnZScsIHtcblx0XHRcdHZhbHVlOiBhZGp1c3RlZC5tZXNzYWdlXG5cdFx0fSk7XG5cblx0XHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdzdGFjaycsIHtcblx0XHRcdHZhbHVlOiBhZGp1c3RlZC5zdGFja1xuXHRcdH0pO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBGb3JrIH0gZnJvbSAnc3ZlbHRlJyAqL1xuLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFJlYWN0aW9uLCBTb3VyY2UsIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7XG5cdEJMT0NLX0VGRkVDVCxcblx0QlJBTkNIX0VGRkVDVCxcblx0Q0xFQU4sXG5cdERFU1RST1lFRCxcblx0RElSVFksXG5cdEVGRkVDVCxcblx0QVNZTkMsXG5cdElORVJULFxuXHRSRU5ERVJfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0TUFZQkVfRElSVFksXG5cdERFUklWRUQsXG5cdEJPVU5EQVJZX0VGRkVDVCxcblx0RUFHRVJfRUZGRUNULFxuXHRIRUFEX0VGRkVDVCxcblx0RVJST1JfVkFMVUUsXG5cdFdBU19NQVJLRUQsXG5cdE1BTkFHRURfRUZGRUNUXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IGRlZmVycmVkLCBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0Z2V0LFxuXHRpc19kaXJ0eSxcblx0aXNfdXBkYXRpbmdfZWZmZWN0LFxuXHRzZXRfaXNfdXBkYXRpbmdfZWZmZWN0LFxuXHRzZXRfc2lnbmFsX3N0YXR1cyxcblx0dXBkYXRlX2VmZmVjdFxufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGZsdXNoX3Rhc2tzLCBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vZG9tL3Rhc2suanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBpbnZva2VfZXJyb3JfYm91bmRhcnkgfSBmcm9tICcuLi9lcnJvci1oYW5kbGluZy5qcyc7XG5pbXBvcnQgeyBmbHVzaF9lYWdlcl9lZmZlY3RzLCBvbGRfdmFsdWVzLCBzZXRfZWFnZXJfZWZmZWN0cywgc291cmNlLCB1cGRhdGUgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZWFnZXJfZWZmZWN0LCB1bmxpbmtfZWZmZWN0IH0gZnJvbSAnLi9lZmZlY3RzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBwYXJlbnQ6IEVmZmVjdFRhcmdldCB8IG51bGw7XG4gKiAgIGVmZmVjdDogRWZmZWN0IHwgbnVsbDtcbiAqICAgZWZmZWN0czogRWZmZWN0W107XG4gKiAgIHJlbmRlcl9lZmZlY3RzOiBFZmZlY3RbXTtcbiAqICAgYmxvY2tfZWZmZWN0czogRWZmZWN0W107XG4gKiB9fSBFZmZlY3RUYXJnZXRcbiAqL1xuXG4vKiogQHR5cGUge1NldDxCYXRjaD59ICovXG5jb25zdCBiYXRjaGVzID0gbmV3IFNldCgpO1xuXG4vKiogQHR5cGUge0JhdGNoIHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgY3VycmVudF9iYXRjaCA9IG51bGw7XG5cbi8qKlxuICogVGhpcyBpcyBuZWVkZWQgdG8gYXZvaWQgb3ZlcndyaXRpbmcgaW5wdXRzIGluIG5vbi1hc3luYyBtb2RlXG4gKiBUT0RPIDYuMCByZW1vdmUgdGhpcywgYXMgbm9uLWFzeW5jIG1vZGUgd2lsbCBnbyBhd2F5XG4gKiBAdHlwZSB7QmF0Y2ggfCBudWxsfVxuICovXG5leHBvcnQgbGV0IHByZXZpb3VzX2JhdGNoID0gbnVsbDtcblxuLyoqXG4gKiBXaGVuIHRpbWUgdHJhdmVsbGluZyAoaS5lLiB3b3JraW5nIGluIG9uZSBiYXRjaCwgd2hpbGUgb3RoZXIgYmF0Y2hlc1xuICogc3RpbGwgaGF2ZSBvbmdvaW5nIHdvcmspLCB3ZSBpZ25vcmUgdGhlIHJlYWwgdmFsdWVzIG9mIGFmZmVjdGVkXG4gKiBzaWduYWxzIGluIGZhdm91ciBvZiB0aGVpciB2YWx1ZXMgd2l0aGluIHRoZSBiYXRjaFxuICogQHR5cGUge01hcDxWYWx1ZSwgYW55PiB8IG51bGx9XG4gKi9cbmV4cG9ydCBsZXQgYmF0Y2hfdmFsdWVzID0gbnVsbDtcblxuLy8gVE9ETyB0aGlzIHNob3VsZCByZWFsbHkgYmUgYSBwcm9wZXJ0eSBvZiBgYmF0Y2hgXG4vKiogQHR5cGUge0VmZmVjdFtdfSAqL1xubGV0IHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblxuLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xubGV0IGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cbmxldCBpc19mbHVzaGluZyA9IGZhbHNlO1xuZXhwb3J0IGxldCBpc19mbHVzaGluZ19zeW5jID0gZmFsc2U7XG5cbmV4cG9ydCBjbGFzcyBCYXRjaCB7XG5cdGNvbW1pdHRlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCB2YWx1ZXMgb2YgYW55IHNvdXJjZXMgdGhhdCBhcmUgdXBkYXRlZCBpbiB0aGlzIGJhdGNoXG5cdCAqIFRoZXkga2V5cyBvZiB0aGlzIG1hcCBhcmUgaWRlbnRpY2FsIHRvIGB0aGlzLiNwcmV2aW91c2Bcblx0ICogQHR5cGUge01hcDxTb3VyY2UsIGFueT59XG5cdCAqL1xuXHRjdXJyZW50ID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBUaGUgdmFsdWVzIG9mIGFueSBzb3VyY2VzIHRoYXQgYXJlIHVwZGF0ZWQgaW4gdGhpcyBiYXRjaCBfYmVmb3JlXyB0aG9zZSB1cGRhdGVzIHRvb2sgcGxhY2UuXG5cdCAqIFRoZXkga2V5cyBvZiB0aGlzIG1hcCBhcmUgaWRlbnRpY2FsIHRvIGB0aGlzLiNjdXJyZW50YFxuXHQgKiBAdHlwZSB7TWFwPFNvdXJjZSwgYW55Pn1cblx0ICovXG5cdHByZXZpb3VzID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBXaGVuIHRoZSBiYXRjaCBpcyBjb21taXR0ZWQgKGFuZCB0aGUgRE9NIGlzIHVwZGF0ZWQpLCB3ZSBuZWVkIHRvIHJlbW92ZSBvbGQgYnJhbmNoZXNcblx0ICogYW5kIGFwcGVuZCBuZXcgb25lcyBieSBjYWxsaW5nIHRoZSBmdW5jdGlvbnMgYWRkZWQgaW5zaWRlIChpZi9lYWNoL2tleS9ldGMpIGJsb2Nrc1xuXHQgKiBAdHlwZSB7U2V0PCgpID0+IHZvaWQ+fVxuXHQgKi9cblx0I2NvbW1pdF9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIElmIGEgZm9yayBpcyBkaXNjYXJkZWQsIHdlIG5lZWQgdG8gZGVzdHJveSBhbnkgZWZmZWN0cyB0aGF0IGFyZSBubyBsb25nZXIgbmVlZGVkXG5cdCAqIEB0eXBlIHtTZXQ8KGJhdGNoOiBCYXRjaCkgPT4gdm9pZD59XG5cdCAqL1xuXHQjZGlzY2FyZF9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgYXN5bmMgZWZmZWN0cyB0aGF0IGFyZSBjdXJyZW50bHkgaW4gZmxpZ2h0XG5cdCAqL1xuXHQjcGVuZGluZyA9IDA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgYXN5bmMgZWZmZWN0cyB0aGF0IGFyZSBjdXJyZW50bHkgaW4gZmxpZ2h0LCBfbm90XyBpbnNpZGUgYSBwZW5kaW5nIGJvdW5kYXJ5XG5cdCAqL1xuXHQjYmxvY2tpbmdfcGVuZGluZyA9IDA7XG5cblx0LyoqXG5cdCAqIEEgZGVmZXJyZWQgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBiYXRjaCBpcyBjb21taXR0ZWQsIHVzZWQgd2l0aCBgc2V0dGxlZCgpYFxuXHQgKiBUT0RPIHJlcGxhY2Ugd2l0aCBQcm9taXNlLndpdGhSZXNvbHZlcnMgb25jZSBzdXBwb3J0ZWQgd2lkZWx5IGVub3VnaFxuXHQgKiBAdHlwZSB7eyBwcm9taXNlOiBQcm9taXNlPHZvaWQ+LCByZXNvbHZlOiAodmFsdWU/OiBhbnkpID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbjogdW5rbm93bikgPT4gdm9pZCB9IHwgbnVsbH1cblx0ICovXG5cdCNkZWZlcnJlZCA9IG51bGw7XG5cblx0LyoqXG5cdCAqIERlZmVycmVkIGVmZmVjdHMgKHdoaWNoIHJ1biBhZnRlciBhc3luYyB3b3JrIGhhcyBjb21wbGV0ZWQpIHRoYXQgYXJlIERJUlRZXG5cdCAqIEB0eXBlIHtFZmZlY3RbXX1cblx0ICovXG5cdCNkaXJ0eV9lZmZlY3RzID0gW107XG5cblx0LyoqXG5cdCAqIERlZmVycmVkIGVmZmVjdHMgdGhhdCBhcmUgTUFZQkVfRElSVFlcblx0ICogQHR5cGUge0VmZmVjdFtdfVxuXHQgKi9cblx0I21heWJlX2RpcnR5X2VmZmVjdHMgPSBbXTtcblxuXHQvKipcblx0ICogQSBzZXQgb2YgYnJhbmNoZXMgdGhhdCBzdGlsbCBleGlzdCwgYnV0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhpcyBiYXRjaFxuXHQgKiBpcyBjb21taXR0ZWQgXHUyMDE0IHdlIHNraXAgb3ZlciB0aGVzZSBkdXJpbmcgYHByb2Nlc3NgXG5cdCAqIEB0eXBlIHtTZXQ8RWZmZWN0Pn1cblx0ICovXG5cdHNraXBwZWRfZWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuXHRpc19mb3JrID0gZmFsc2U7XG5cblx0aXNfZGVmZXJyZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNfZm9yayB8fCB0aGlzLiNibG9ja2luZ19wZW5kaW5nID4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0VmZmVjdFtdfSByb290X2VmZmVjdHNcblx0ICovXG5cdHByb2Nlc3Mocm9vdF9lZmZlY3RzKSB7XG5cdFx0cXVldWVkX3Jvb3RfZWZmZWN0cyA9IFtdO1xuXG5cdFx0cHJldmlvdXNfYmF0Y2ggPSBudWxsO1xuXG5cdFx0dGhpcy5hcHBseSgpO1xuXG5cdFx0LyoqIEB0eXBlIHtFZmZlY3RUYXJnZXR9ICovXG5cdFx0dmFyIHRhcmdldCA9IHtcblx0XHRcdHBhcmVudDogbnVsbCxcblx0XHRcdGVmZmVjdDogbnVsbCxcblx0XHRcdGVmZmVjdHM6IFtdLFxuXHRcdFx0cmVuZGVyX2VmZmVjdHM6IFtdLFxuXHRcdFx0YmxvY2tfZWZmZWN0czogW11cblx0XHR9O1xuXG5cdFx0Zm9yIChjb25zdCByb290IG9mIHJvb3RfZWZmZWN0cykge1xuXHRcdFx0dGhpcy4jdHJhdmVyc2VfZWZmZWN0X3RyZWUocm9vdCwgdGFyZ2V0KTtcblx0XHRcdC8vIE5vdGU6ICN0cmF2ZXJzZV9lZmZlY3RfdHJlZSBydW5zIGJsb2NrIGVmZmVjdHMgZWFnZXJseSwgd2hpY2ggY2FuIHNjaGVkdWxlIGVmZmVjdHMsXG5cdFx0XHQvLyB3aGljaCBtZWFucyBxdWV1ZWRfcm9vdF9lZmZlY3RzIG5vdyBtYXkgYmUgZmlsbGVkIGFnYWluLlxuXG5cdFx0XHQvLyBIZWxwZnVsIGZvciBkZWJ1Z2dpbmcgcmVhY3Rpdml0eSBsb3NzIHRoYXQgaGFzIHRvIGRvIHdpdGggYnJhbmNoZXMgYmVpbmcgc2tpcHBlZDpcblx0XHRcdC8vIGxvZ19pbmNvbnNpc3RlbnRfYnJhbmNoZXMocm9vdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzX2ZvcmspIHtcblx0XHRcdHRoaXMuI3Jlc29sdmUoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pc19kZWZlcnJlZCgpKSB7XG5cdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5lZmZlY3RzKTtcblx0XHRcdHRoaXMuI2RlZmVyX2VmZmVjdHModGFyZ2V0LnJlbmRlcl9lZmZlY3RzKTtcblx0XHRcdHRoaXMuI2RlZmVyX2VmZmVjdHModGFyZ2V0LmJsb2NrX2VmZmVjdHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBzb3VyY2VzIGFyZSB3cml0dGVuIHRvLCB0aGVuIHdvcmsgbmVlZHMgdG8gaGFwcGVuIGluIGEgc2VwYXJhdGUgYmF0Y2gsIGVsc2UgcHJpb3Igc291cmNlcyB3b3VsZCBiZSBtaXhlZCB3aXRoXG5cdFx0XHQvLyBuZXdseSB1cGRhdGVkIHNvdXJjZXMsIHdoaWNoIGNvdWxkIGxlYWQgdG8gaW5maW5pdGUgbG9vcHMgd2hlbiBlZmZlY3RzIHJ1biBvdmVyIGFuZCBvdmVyIGFnYWluLlxuXHRcdFx0cHJldmlvdXNfYmF0Y2ggPSB0aGlzO1xuXHRcdFx0Y3VycmVudF9iYXRjaCA9IG51bGw7XG5cblx0XHRcdGZsdXNoX3F1ZXVlZF9lZmZlY3RzKHRhcmdldC5yZW5kZXJfZWZmZWN0cyk7XG5cdFx0XHRmbHVzaF9xdWV1ZWRfZWZmZWN0cyh0YXJnZXQuZWZmZWN0cyk7XG5cblx0XHRcdHByZXZpb3VzX2JhdGNoID0gbnVsbDtcblxuXHRcdFx0dGhpcy4jZGVmZXJyZWQ/LnJlc29sdmUoKTtcblx0XHR9XG5cblx0XHRiYXRjaF92YWx1ZXMgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyYXZlcnNlIHRoZSBlZmZlY3QgdHJlZSwgZXhlY3V0aW5nIGVmZmVjdHMgb3Igc3Rhc2hpbmdcblx0ICogdGhlbSBmb3IgbGF0ZXIgZXhlY3V0aW9uIGFzIGFwcHJvcHJpYXRlXG5cdCAqIEBwYXJhbSB7RWZmZWN0fSByb290XG5cdCAqIEBwYXJhbSB7RWZmZWN0VGFyZ2V0fSB0YXJnZXRcblx0ICovXG5cdCN0cmF2ZXJzZV9lZmZlY3RfdHJlZShyb290LCB0YXJnZXQpIHtcblx0XHRyb290LmYgXj0gQ0xFQU47XG5cblx0XHR2YXIgZWZmZWN0ID0gcm9vdC5maXJzdDtcblxuXHRcdHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdHZhciBmbGFncyA9IGVmZmVjdC5mO1xuXHRcdFx0dmFyIGlzX2JyYW5jaCA9IChmbGFncyAmIChCUkFOQ0hfRUZGRUNUIHwgUk9PVF9FRkZFQ1QpKSAhPT0gMDtcblx0XHRcdHZhciBpc19za2lwcGFibGVfYnJhbmNoID0gaXNfYnJhbmNoICYmIChmbGFncyAmIENMRUFOKSAhPT0gMDtcblxuXHRcdFx0dmFyIHNraXAgPSBpc19za2lwcGFibGVfYnJhbmNoIHx8IChmbGFncyAmIElORVJUKSAhPT0gMCB8fCB0aGlzLnNraXBwZWRfZWZmZWN0cy5oYXMoZWZmZWN0KTtcblxuXHRcdFx0aWYgKChlZmZlY3QuZiAmIEJPVU5EQVJZX0VGRkVDVCkgIT09IDAgJiYgZWZmZWN0LmI/LmlzX3BlbmRpbmcoKSkge1xuXHRcdFx0XHR0YXJnZXQgPSB7XG5cdFx0XHRcdFx0cGFyZW50OiB0YXJnZXQsXG5cdFx0XHRcdFx0ZWZmZWN0LFxuXHRcdFx0XHRcdGVmZmVjdHM6IFtdLFxuXHRcdFx0XHRcdHJlbmRlcl9lZmZlY3RzOiBbXSxcblx0XHRcdFx0XHRibG9ja19lZmZlY3RzOiBbXVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNraXAgJiYgZWZmZWN0LmZuICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChpc19icmFuY2gpIHtcblx0XHRcdFx0XHRlZmZlY3QuZiBePSBDTEVBTjtcblx0XHRcdFx0fSBlbHNlIGlmICgoZmxhZ3MgJiBFRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LmVmZmVjdHMucHVzaChlZmZlY3QpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFzeW5jX21vZGVfZmxhZyAmJiAoZmxhZ3MgJiAoUkVOREVSX0VGRkVDVCB8IE1BTkFHRURfRUZGRUNUKSkgIT09IDApIHtcblx0XHRcdFx0XHR0YXJnZXQucmVuZGVyX2VmZmVjdHMucHVzaChlZmZlY3QpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzX2RpcnR5KGVmZmVjdCkpIHtcblx0XHRcdFx0XHRpZiAoKGVmZmVjdC5mICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkgdGFyZ2V0LmJsb2NrX2VmZmVjdHMucHVzaChlZmZlY3QpO1xuXHRcdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjaGlsZCA9IGVmZmVjdC5maXJzdDtcblxuXHRcdFx0XHRpZiAoY2hpbGQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRlZmZlY3QgPSBjaGlsZDtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWZmZWN0LnBhcmVudDtcblx0XHRcdGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuXG5cdFx0XHR3aGlsZSAoZWZmZWN0ID09PSBudWxsICYmIHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocGFyZW50ID09PSB0YXJnZXQuZWZmZWN0KSB7XG5cdFx0XHRcdFx0Ly8gVE9ETyByYXRoZXIgdGhhbiB0cmF2ZXJzaW5nIGludG8gcGVuZGluZyBib3VuZGFyaWVzIGFuZCBkZWZlcnJpbmcgdGhlIGVmZmVjdHMsXG5cdFx0XHRcdFx0Ly8gY291bGQgd2UganVzdCBhdHRhY2ggdGhlIGVmZmVjdHMgX3RvXyB0aGUgcGVuZGluZyBib3VuZGFyeSBhbmQgc2NoZWR1bGUgdGhlbVxuXHRcdFx0XHRcdC8vIG9uY2UgdGhlIGJvdW5kYXJ5IGlzIHJlYWR5P1xuXHRcdFx0XHRcdHRoaXMuI2RlZmVyX2VmZmVjdHModGFyZ2V0LmVmZmVjdHMpO1xuXHRcdFx0XHRcdHRoaXMuI2RlZmVyX2VmZmVjdHModGFyZ2V0LnJlbmRlcl9lZmZlY3RzKTtcblx0XHRcdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5ibG9ja19lZmZlY3RzKTtcblxuXHRcdFx0XHRcdHRhcmdldCA9IC8qKiBAdHlwZSB7RWZmZWN0VGFyZ2V0fSAqLyAodGFyZ2V0LnBhcmVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlZmZlY3QgPSBwYXJlbnQubmV4dDtcblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFZmZlY3RbXX0gZWZmZWN0c1xuXHQgKi9cblx0I2RlZmVyX2VmZmVjdHMoZWZmZWN0cykge1xuXHRcdGZvciAoY29uc3QgZSBvZiBlZmZlY3RzKSB7XG5cdFx0XHRjb25zdCB0YXJnZXQgPSAoZS5mICYgRElSVFkpICE9PSAwID8gdGhpcy4jZGlydHlfZWZmZWN0cyA6IHRoaXMuI21heWJlX2RpcnR5X2VmZmVjdHM7XG5cdFx0XHR0YXJnZXQucHVzaChlKTtcblxuXHRcdFx0Ly8gU2luY2Ugd2UncmUgbm90IGV4ZWN1dGluZyB0aGVzZSBlZmZlY3RzIG5vdywgd2UgbmVlZCB0byBjbGVhciBhbnkgV0FTX01BUktFRCBmbGFnc1xuXHRcdFx0Ly8gc28gdGhhdCBvdGhlciBiYXRjaGVzIGNhbiBjb3JyZWN0bHkgcmVhY2ggdGhlc2UgZWZmZWN0cyBkdXJpbmcgdGhlaXIgb3duIHRyYXZlcnNhbFxuXHRcdFx0dGhpcy4jY2xlYXJfbWFya2VkKGUuZGVwcyk7XG5cblx0XHRcdC8vIG1hcmsgYXMgY2xlYW4gc28gdGhleSBnZXQgc2NoZWR1bGVkIGlmIHRoZXkgZGVwZW5kIG9uIHBlbmRpbmcgYXN5bmMgc3RhdGVcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGUsIENMRUFOKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtWYWx1ZVtdIHwgbnVsbH0gZGVwc1xuXHQgKi9cblx0I2NsZWFyX21hcmtlZChkZXBzKSB7XG5cdFx0aWYgKGRlcHMgPT09IG51bGwpIHJldHVybjtcblxuXHRcdGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcblx0XHRcdGlmICgoZGVwLmYgJiBERVJJVkVEKSA9PT0gMCB8fCAoZGVwLmYgJiBXQVNfTUFSS0VEKSA9PT0gMCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0ZGVwLmYgXj0gV0FTX01BUktFRDtcblxuXHRcdFx0dGhpcy4jY2xlYXJfbWFya2VkKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcCkuZGVwcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFzc29jaWF0ZSBhIGNoYW5nZSB0byBhIGdpdmVuIHNvdXJjZSB3aXRoIHRoZSBjdXJyZW50XG5cdCAqIGJhdGNoLCBub3RpbmcgaXRzIHByZXZpb3VzIGFuZCBjdXJyZW50IHZhbHVlc1xuXHQgKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuXHQgKi9cblx0Y2FwdHVyZShzb3VyY2UsIHZhbHVlKSB7XG5cdFx0aWYgKCF0aGlzLnByZXZpb3VzLmhhcyhzb3VyY2UpKSB7XG5cdFx0XHR0aGlzLnByZXZpb3VzLnNldChzb3VyY2UsIHZhbHVlKTtcblx0XHR9XG5cblx0XHQvLyBEb24ndCBzYXZlIGVycm9ycyBpbiBgYmF0Y2hfdmFsdWVzYCwgb3IgdGhleSB3b24ndCBiZSB0aHJvd24gaW4gYHJ1bnRpbWUuanMjZ2V0YFxuXHRcdGlmICgoc291cmNlLmYgJiBFUlJPUl9WQUxVRSkgPT09IDApIHtcblx0XHRcdHRoaXMuY3VycmVudC5zZXQoc291cmNlLCBzb3VyY2Uudik7XG5cdFx0XHRiYXRjaF92YWx1ZXM/LnNldChzb3VyY2UsIHNvdXJjZS52KTtcblx0XHR9XG5cdH1cblxuXHRhY3RpdmF0ZSgpIHtcblx0XHRjdXJyZW50X2JhdGNoID0gdGhpcztcblx0XHR0aGlzLmFwcGx5KCk7XG5cdH1cblxuXHRkZWFjdGl2YXRlKCkge1xuXHRcdC8vIElmIHdlJ3JlIG5vdCB0aGUgY3VycmVudCBiYXRjaCwgZG9uJ3QgZGVhY3RpdmF0ZSxcblx0XHQvLyBlbHNlIHdlIGNvdWxkIGNyZWF0ZSB6b21iaWUgYmF0Y2hlcyB0aGF0IGFyZSBuZXZlciBmbHVzaGVkXG5cdFx0aWYgKGN1cnJlbnRfYmF0Y2ggIT09IHRoaXMpIHJldHVybjtcblxuXHRcdGN1cnJlbnRfYmF0Y2ggPSBudWxsO1xuXHRcdGJhdGNoX3ZhbHVlcyA9IG51bGw7XG5cdH1cblxuXHRmbHVzaCgpIHtcblx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cblx0XHRpZiAocXVldWVkX3Jvb3RfZWZmZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRmbHVzaF9lZmZlY3RzKCk7XG5cblx0XHRcdGlmIChjdXJyZW50X2JhdGNoICE9PSBudWxsICYmIGN1cnJlbnRfYmF0Y2ggIT09IHRoaXMpIHtcblx0XHRcdFx0Ly8gdGhpcyBjYW4gaGFwcGVuIGlmIGEgbmV3IGJhdGNoIHdhcyBjcmVhdGVkIGR1cmluZyBgZmx1c2hfZWZmZWN0cygpYFxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLiNwZW5kaW5nID09PSAwKSB7XG5cdFx0XHR0aGlzLnByb2Nlc3MoW10pOyAvLyBUT0RPIHRoaXMgZmVlbHMgYXdrd2FyZFxuXHRcdH1cblxuXHRcdHRoaXMuZGVhY3RpdmF0ZSgpO1xuXHR9XG5cblx0ZGlzY2FyZCgpIHtcblx0XHRmb3IgKGNvbnN0IGZuIG9mIHRoaXMuI2Rpc2NhcmRfY2FsbGJhY2tzKSBmbih0aGlzKTtcblx0XHR0aGlzLiNkaXNjYXJkX2NhbGxiYWNrcy5jbGVhcigpO1xuXHR9XG5cblx0I3Jlc29sdmUoKSB7XG5cdFx0aWYgKHRoaXMuI2Jsb2NraW5nX3BlbmRpbmcgPT09IDApIHtcblx0XHRcdC8vIGFwcGVuZC9yZW1vdmUgYnJhbmNoZXNcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgdGhpcy4jY29tbWl0X2NhbGxiYWNrcykgZm4oKTtcblx0XHRcdHRoaXMuI2NvbW1pdF9jYWxsYmFja3MuY2xlYXIoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jcGVuZGluZyA9PT0gMCkge1xuXHRcdFx0dGhpcy4jY29tbWl0KCk7XG5cdFx0fVxuXHR9XG5cblx0I2NvbW1pdCgpIHtcblx0XHQvLyBJZiB0aGVyZSBhcmUgb3RoZXIgcGVuZGluZyBiYXRjaGVzLCB0aGV5IG5vdyBuZWVkIHRvIGJlICdyZWJhc2VkJyBcdTIwMTRcblx0XHQvLyBpbiBvdGhlciB3b3Jkcywgd2UgcmUtcnVuIGJsb2NrL2FzeW5jIGVmZmVjdHMgd2l0aCB0aGUgbmV3bHlcblx0XHQvLyBjb21taXR0ZWQgc3RhdGUsIHVubGVzcyB0aGUgYmF0Y2ggaW4gcXVlc3Rpb24gaGFzIGEgbW9yZVxuXHRcdC8vIHJlY2VudCB2YWx1ZSBmb3IgYSBnaXZlbiBzb3VyY2Vcblx0XHRpZiAoYmF0Y2hlcy5zaXplID4gMSkge1xuXHRcdFx0dGhpcy5wcmV2aW91cy5jbGVhcigpO1xuXG5cdFx0XHR2YXIgcHJldmlvdXNfYmF0Y2hfdmFsdWVzID0gYmF0Y2hfdmFsdWVzO1xuXHRcdFx0dmFyIGlzX2VhcmxpZXIgPSB0cnVlO1xuXG5cdFx0XHQvKiogQHR5cGUge0VmZmVjdFRhcmdldH0gKi9cblx0XHRcdHZhciBkdW1teV90YXJnZXQgPSB7XG5cdFx0XHRcdHBhcmVudDogbnVsbCxcblx0XHRcdFx0ZWZmZWN0OiBudWxsLFxuXHRcdFx0XHRlZmZlY3RzOiBbXSxcblx0XHRcdFx0cmVuZGVyX2VmZmVjdHM6IFtdLFxuXHRcdFx0XHRibG9ja19lZmZlY3RzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yIChjb25zdCBiYXRjaCBvZiBiYXRjaGVzKSB7XG5cdFx0XHRcdGlmIChiYXRjaCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdGlzX2VhcmxpZXIgPSBmYWxzZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKiBAdHlwZSB7U291cmNlW119ICovXG5cdFx0XHRcdGNvbnN0IHNvdXJjZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IFtzb3VyY2UsIHZhbHVlXSBvZiB0aGlzLmN1cnJlbnQpIHtcblx0XHRcdFx0XHRpZiAoYmF0Y2guY3VycmVudC5oYXMoc291cmNlKSkge1xuXHRcdFx0XHRcdFx0aWYgKGlzX2VhcmxpZXIgJiYgdmFsdWUgIT09IGJhdGNoLmN1cnJlbnQuZ2V0KHNvdXJjZSkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gYnJpbmcgdGhlIHZhbHVlIHVwIHRvIGRhdGVcblx0XHRcdFx0XHRcdFx0YmF0Y2guY3VycmVudC5zZXQoc291cmNlLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBzYW1lIHZhbHVlIG9yIGxhdGVyIGJhdGNoIGhhcyBtb3JlIHJlY2VudCB2YWx1ZSxcblx0XHRcdFx0XHRcdFx0Ly8gbm8gbmVlZCB0byByZS1ydW4gdGhlc2UgZWZmZWN0c1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmUtcnVuIGFzeW5jL2Jsb2NrIGVmZmVjdHMgdGhhdCBkZXBlbmQgb24gZGlzdGluY3QgdmFsdWVzIGNoYW5nZWQgaW4gYm90aCBiYXRjaGVzXG5cdFx0XHRcdGNvbnN0IG90aGVycyA9IFsuLi5iYXRjaC5jdXJyZW50LmtleXMoKV0uZmlsdGVyKChzKSA9PiAhdGhpcy5jdXJyZW50LmhhcyhzKSk7XG5cdFx0XHRcdGlmIChvdGhlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdC8vIEF2b2lkIHJ1bm5pbmcgcXVldWVkIHJvb3QgZWZmZWN0cyBvbiB0aGUgd3JvbmcgYnJhbmNoXG5cdFx0XHRcdFx0dmFyIHByZXZfcXVldWVkX3Jvb3RfZWZmZWN0cyA9IHF1ZXVlZF9yb290X2VmZmVjdHM7XG5cdFx0XHRcdFx0cXVldWVkX3Jvb3RfZWZmZWN0cyA9IFtdO1xuXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtTZXQ8VmFsdWU+fSAqL1xuXHRcdFx0XHRcdGNvbnN0IG1hcmtlZCA9IG5ldyBTZXQoKTtcblx0XHRcdFx0XHQvKiogQHR5cGUge01hcDxSZWFjdGlvbiwgYm9vbGVhbj59ICovXG5cdFx0XHRcdFx0Y29uc3QgY2hlY2tlZCA9IG5ldyBNYXAoKTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG5cdFx0XHRcdFx0XHRtYXJrX2VmZmVjdHMoc291cmNlLCBvdGhlcnMsIG1hcmtlZCwgY2hlY2tlZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0Y3VycmVudF9iYXRjaCA9IGJhdGNoO1xuXHRcdFx0XHRcdFx0YmF0Y2guYXBwbHkoKTtcblxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCByb290IG9mIHF1ZXVlZF9yb290X2VmZmVjdHMpIHtcblx0XHRcdFx0XHRcdFx0YmF0Y2guI3RyYXZlcnNlX2VmZmVjdF90cmVlKHJvb3QsIGR1bW15X3RhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFRPRE8gZG8gd2UgbmVlZCB0byBkbyBhbnl0aGluZyB3aXRoIGB0YXJnZXRgPyBkZWZlciBibG9jayBlZmZlY3RzP1xuXG5cdFx0XHRcdFx0XHRiYXRjaC5kZWFjdGl2YXRlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cXVldWVkX3Jvb3RfZWZmZWN0cyA9IHByZXZfcXVldWVkX3Jvb3RfZWZmZWN0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50X2JhdGNoID0gbnVsbDtcblx0XHRcdGJhdGNoX3ZhbHVlcyA9IHByZXZpb3VzX2JhdGNoX3ZhbHVlcztcblx0XHR9XG5cblx0XHR0aGlzLmNvbW1pdHRlZCA9IHRydWU7XG5cdFx0YmF0Y2hlcy5kZWxldGUodGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBibG9ja2luZ1xuXHQgKi9cblx0aW5jcmVtZW50KGJsb2NraW5nKSB7XG5cdFx0dGhpcy4jcGVuZGluZyArPSAxO1xuXHRcdGlmIChibG9ja2luZykgdGhpcy4jYmxvY2tpbmdfcGVuZGluZyArPSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYmxvY2tpbmdcblx0ICovXG5cdGRlY3JlbWVudChibG9ja2luZykge1xuXHRcdHRoaXMuI3BlbmRpbmcgLT0gMTtcblx0XHRpZiAoYmxvY2tpbmcpIHRoaXMuI2Jsb2NraW5nX3BlbmRpbmcgLT0gMTtcblxuXHRcdHRoaXMucmV2aXZlKCk7XG5cdH1cblxuXHRyZXZpdmUoKSB7XG5cdFx0Zm9yIChjb25zdCBlIG9mIHRoaXMuI2RpcnR5X2VmZmVjdHMpIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGUsIERJUlRZKTtcblx0XHRcdHNjaGVkdWxlX2VmZmVjdChlKTtcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IGUgb2YgdGhpcy4jbWF5YmVfZGlydHlfZWZmZWN0cykge1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZSwgTUFZQkVfRElSVFkpO1xuXHRcdFx0c2NoZWR1bGVfZWZmZWN0KGUpO1xuXHRcdH1cblxuXHRcdHRoaXMuI2RpcnR5X2VmZmVjdHMgPSBbXTtcblx0XHR0aGlzLiNtYXliZV9kaXJ0eV9lZmZlY3RzID0gW107XG5cblx0XHR0aGlzLmZsdXNoKCk7XG5cdH1cblxuXHQvKiogQHBhcmFtIHsoKSA9PiB2b2lkfSBmbiAqL1xuXHRvbmNvbW1pdChmbikge1xuXHRcdHRoaXMuI2NvbW1pdF9jYWxsYmFja3MuYWRkKGZuKTtcblx0fVxuXG5cdC8qKiBAcGFyYW0geyhiYXRjaDogQmF0Y2gpID0+IHZvaWR9IGZuICovXG5cdG9uZGlzY2FyZChmbikge1xuXHRcdHRoaXMuI2Rpc2NhcmRfY2FsbGJhY2tzLmFkZChmbik7XG5cdH1cblxuXHRzZXR0bGVkKCkge1xuXHRcdHJldHVybiAodGhpcy4jZGVmZXJyZWQgPz89IGRlZmVycmVkKCkpLnByb21pc2U7XG5cdH1cblxuXHRzdGF0aWMgZW5zdXJlKCkge1xuXHRcdGlmIChjdXJyZW50X2JhdGNoID09PSBudWxsKSB7XG5cdFx0XHRjb25zdCBiYXRjaCA9IChjdXJyZW50X2JhdGNoID0gbmV3IEJhdGNoKCkpO1xuXHRcdFx0YmF0Y2hlcy5hZGQoY3VycmVudF9iYXRjaCk7XG5cblx0XHRcdGlmICghaXNfZmx1c2hpbmdfc3luYykge1xuXHRcdFx0XHRCYXRjaC5lbnF1ZXVlKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gYmF0Y2gpIHtcblx0XHRcdFx0XHRcdC8vIGEgZmx1c2hTeW5jIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJhdGNoLmZsdXNoKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjdXJyZW50X2JhdGNoO1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7KCkgPT4gdm9pZH0gdGFzayAqL1xuXHRzdGF0aWMgZW5xdWV1ZSh0YXNrKSB7XG5cdFx0cXVldWVfbWljcm9fdGFzayh0YXNrKTtcblx0fVxuXG5cdGFwcGx5KCkge1xuXHRcdGlmICghYXN5bmNfbW9kZV9mbGFnIHx8ICghdGhpcy5pc19mb3JrICYmIGJhdGNoZXMuc2l6ZSA9PT0gMSkpIHJldHVybjtcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBiYXRjaGVzLCB3ZSBhcmUgJ3RpbWUgdHJhdmVsbGluZycgXHUyMDE0XG5cdFx0Ly8gd2UgbmVlZCB0byBvdmVycmlkZSB2YWx1ZXMgd2l0aCB0aGUgb25lcyBpbiB0aGlzIGJhdGNoLi4uXG5cdFx0YmF0Y2hfdmFsdWVzID0gbmV3IE1hcCh0aGlzLmN1cnJlbnQpO1xuXG5cdFx0Ly8gLi4uYW5kIHVuZG8gY2hhbmdlcyBiZWxvbmdpbmcgdG8gb3RoZXIgYmF0Y2hlc1xuXHRcdGZvciAoY29uc3QgYmF0Y2ggb2YgYmF0Y2hlcykge1xuXHRcdFx0aWYgKGJhdGNoID09PSB0aGlzKSBjb250aW51ZTtcblxuXHRcdFx0Zm9yIChjb25zdCBbc291cmNlLCBwcmV2aW91c10gb2YgYmF0Y2gucHJldmlvdXMpIHtcblx0XHRcdFx0aWYgKCFiYXRjaF92YWx1ZXMuaGFzKHNvdXJjZSkpIHtcblx0XHRcdFx0XHRiYXRjaF92YWx1ZXMuc2V0KHNvdXJjZSwgcHJldmlvdXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBmbHVzaCBhbnkgcGVuZGluZyB1cGRhdGVzLlxuICogUmV0dXJucyB2b2lkIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFtUPXZvaWRdXG4gKiBAcGFyYW0geygoKSA9PiBUKSB8IHVuZGVmaW5lZH0gW2ZuXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcblx0dmFyIHdhc19mbHVzaGluZ19zeW5jID0gaXNfZmx1c2hpbmdfc3luYztcblx0aXNfZmx1c2hpbmdfc3luYyA9IHRydWU7XG5cblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0aWYgKGZuKSB7XG5cdFx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCkge1xuXHRcdFx0XHRmbHVzaF9lZmZlY3RzKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdCA9IGZuKCk7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGZsdXNoX3Rhc2tzKCk7XG5cblx0XHRcdGlmIChxdWV1ZWRfcm9vdF9lZmZlY3RzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRjdXJyZW50X2JhdGNoPy5mbHVzaCgpO1xuXG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW4sIGluIGNhc2Ugd2UganVzdCB1cGRhdGVkIGFuIGAkZWZmZWN0LnBlbmRpbmcoKWBcblx0XHRcdFx0aWYgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyB3b3VsZCBiZSByZXNldCBpbiBgZmx1c2hfZWZmZWN0cygpYCBidXQgc2luY2Ugd2UgYXJlIGVhcmx5IHJldHVybmluZyBoZXJlLFxuXHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8gcmVzZXQgaXQgaGVyZSBhcyB3ZWxsIGluIGNhc2UgdGhlIGZpcnN0IHRpbWUgdGhlcmUncyAwIHF1ZXVlZCByb290IGVmZmVjdHNcblx0XHRcdFx0XHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBudWxsO1xuXG5cdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7VH0gKi8gKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zmx1c2hfZWZmZWN0cygpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRpc19mbHVzaGluZ19zeW5jID0gd2FzX2ZsdXNoaW5nX3N5bmM7XG5cdH1cbn1cblxuZnVuY3Rpb24gZmx1c2hfZWZmZWN0cygpIHtcblx0dmFyIHdhc191cGRhdGluZ19lZmZlY3QgPSBpc191cGRhdGluZ19lZmZlY3Q7XG5cdGlzX2ZsdXNoaW5nID0gdHJ1ZTtcblxuXHR2YXIgc291cmNlX3N0YWNrcyA9IERFViA/IG5ldyBTZXQoKSA6IG51bGw7XG5cblx0dHJ5IHtcblx0XHR2YXIgZmx1c2hfY291bnQgPSAwO1xuXHRcdHNldF9pc191cGRhdGluZ19lZmZlY3QodHJ1ZSk7XG5cblx0XHR3aGlsZSAocXVldWVkX3Jvb3RfZWZmZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgYmF0Y2ggPSBCYXRjaC5lbnN1cmUoKTtcblxuXHRcdFx0aWYgKGZsdXNoX2NvdW50KysgPiAxMDAwKSB7XG5cdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHR2YXIgdXBkYXRlcyA9IG5ldyBNYXAoKTtcblxuXHRcdFx0XHRcdGZvciAoY29uc3Qgc291cmNlIG9mIGJhdGNoLmN1cnJlbnQua2V5cygpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IFtzdGFjaywgdXBkYXRlXSBvZiBzb3VyY2UudXBkYXRlZCA/PyBbXSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZW50cnkgPSB1cGRhdGVzLmdldChzdGFjayk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFlbnRyeSkge1xuXHRcdFx0XHRcdFx0XHRcdGVudHJ5ID0geyBlcnJvcjogdXBkYXRlLmVycm9yLCBjb3VudDogMCB9O1xuXHRcdFx0XHRcdFx0XHRcdHVwZGF0ZXMuc2V0KHN0YWNrLCBlbnRyeSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRlbnRyeS5jb3VudCArPSB1cGRhdGUuY291bnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcy52YWx1ZXMoKSkge1xuXHRcdFx0XHRcdFx0aWYgKHVwZGF0ZS5lcnJvcikge1xuXHRcdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKHVwZGF0ZS5lcnJvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5maW5pdGVfbG9vcF9ndWFyZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRiYXRjaC5wcm9jZXNzKHF1ZXVlZF9yb290X2VmZmVjdHMpO1xuXHRcdFx0b2xkX3ZhbHVlcy5jbGVhcigpO1xuXG5cdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdGZvciAoY29uc3Qgc291cmNlIG9mIGJhdGNoLmN1cnJlbnQua2V5cygpKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtTZXQ8U291cmNlPn0gKi8gKHNvdXJjZV9zdGFja3MpLmFkZChzb3VyY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGlzX2ZsdXNoaW5nID0gZmFsc2U7XG5cdFx0c2V0X2lzX3VwZGF0aW5nX2VmZmVjdCh3YXNfdXBkYXRpbmdfZWZmZWN0KTtcblxuXHRcdGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cblx0XHRpZiAoREVWKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHNvdXJjZSBvZiAvKiogQHR5cGUge1NldDxTb3VyY2U+fSAqLyAoc291cmNlX3N0YWNrcykpIHtcblx0XHRcdFx0c291cmNlLnVwZGF0ZWQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBpbmZpbml0ZV9sb29wX2d1YXJkKCkge1xuXHR0cnkge1xuXHRcdGUuZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZCgpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdC8vIHN0YWNrIGNvbnRhaW5zIG5vIHVzZWZ1bCBpbmZvcm1hdGlvbiwgcmVwbGFjZSBpdFxuXHRcdFx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnc3RhY2snLCB7IHZhbHVlOiAnJyB9KTtcblx0XHR9XG5cblx0XHQvLyBCZXN0IGVmZm9ydDogaW52b2tlIHRoZSBib3VuZGFyeSBuZWFyZXN0IHRoZSBtb3N0IHJlY2VudFxuXHRcdC8vIGVmZmVjdCBhbmQgaG9wZSB0aGF0IGl0J3MgcmVsZXZhbnQgdG8gdGhlIGluZmluaXRlIGxvb3Bcblx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCk7XG5cdH1cbn1cblxuLyoqIEB0eXBlIHtTZXQ8RWZmZWN0PiB8IG51bGx9ICovXG5leHBvcnQgbGV0IGVhZ2VyX2Jsb2NrX2VmZmVjdHMgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RWZmZWN0Pn0gZWZmZWN0c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3F1ZXVlZF9lZmZlY3RzKGVmZmVjdHMpIHtcblx0dmFyIGxlbmd0aCA9IGVmZmVjdHMubGVuZ3RoO1xuXHRpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG5cblx0dmFyIGkgPSAwO1xuXG5cdHdoaWxlIChpIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIGVmZmVjdCA9IGVmZmVjdHNbaSsrXTtcblxuXHRcdGlmICgoZWZmZWN0LmYgJiAoREVTVFJPWUVEIHwgSU5FUlQpKSA9PT0gMCAmJiBpc19kaXJ0eShlZmZlY3QpKSB7XG5cdFx0XHRlYWdlcl9ibG9ja19lZmZlY3RzID0gbmV3IFNldCgpO1xuXG5cdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cblx0XHRcdC8vIEVmZmVjdHMgd2l0aCBubyBkZXBlbmRlbmNpZXMgb3IgdGVhcmRvd24gZG8gbm90IGdldCBhZGRlZCB0byB0aGUgZWZmZWN0IHRyZWUuXG5cdFx0XHQvLyBEZWZlcnJlZCBlZmZlY3RzIChlLmcuIGAkZWZmZWN0KC4uLilgKSBfYXJlXyBhZGRlZCB0byB0aGUgdHJlZSBiZWNhdXNlIHdlXG5cdFx0XHQvLyBkb24ndCBrbm93IGlmIHdlIG5lZWQgdG8ga2VlcCB0aGVtIHVudGlsIHRoZXkgYXJlIGV4ZWN1dGVkLiBEb2luZyB0aGUgY2hlY2tcblx0XHRcdC8vIGhlcmUgKHJhdGhlciB0aGFuIGluIGB1cGRhdGVfZWZmZWN0YCkgYWxsb3dzIHVzIHRvIHNraXAgdGhlIHdvcmsgZm9yXG5cdFx0XHQvLyBpbW1lZGlhdGUgZWZmZWN0cy5cblx0XHRcdGlmIChlZmZlY3QuZGVwcyA9PT0gbnVsbCAmJiBlZmZlY3QuZmlyc3QgPT09IG51bGwgJiYgZWZmZWN0Lm5vZGVzX3N0YXJ0ID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIGlmIHRoZXJlJ3Mgbm8gdGVhcmRvd24gb3IgYWJvcnQgY29udHJvbGxlciB3ZSBjb21wbGV0ZWx5IHVubGlua1xuXHRcdFx0XHQvLyB0aGUgZWZmZWN0IGZyb20gdGhlIGdyYXBoXG5cdFx0XHRcdGlmIChlZmZlY3QudGVhcmRvd24gPT09IG51bGwgJiYgZWZmZWN0LmFjID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHRoaXMgZWZmZWN0IGZyb20gdGhlIGdyYXBoXG5cdFx0XHRcdFx0dW5saW5rX2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGtlZXAgdGhlIGVmZmVjdCBpbiB0aGUgZ3JhcGgsIGJ1dCBmcmVlIHVwIHNvbWUgbWVtb3J5XG5cdFx0XHRcdFx0ZWZmZWN0LmZuID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB1cGRhdGVfZWZmZWN0KCkgaGFzIGEgZmx1c2hTeW5jKCkgaW4gaXQsIHdlIG1heSBoYXZlIGZsdXNoZWQgYW5vdGhlciBmbHVzaF9xdWV1ZWRfZWZmZWN0cygpLFxuXHRcdFx0Ly8gd2hpY2ggYWxyZWFkeSBoYW5kbGVkIHRoaXMgbG9naWMgYW5kIGRpZCBzZXQgZWFnZXJfYmxvY2tfZWZmZWN0cyB0byBudWxsLlxuXHRcdFx0aWYgKGVhZ2VyX2Jsb2NrX2VmZmVjdHM/LnNpemUgPiAwKSB7XG5cdFx0XHRcdG9sZF92YWx1ZXMuY2xlYXIoKTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGUgb2YgZWFnZXJfYmxvY2tfZWZmZWN0cykge1xuXHRcdFx0XHRcdC8vIFNraXAgZWFnZXIgZWZmZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHVubW91bnRlZFxuXHRcdFx0XHRcdGlmICgoZS5mICYgKERFU1RST1lFRCB8IElORVJUKSkgIT09IDApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGVmZmVjdHMgaW4gb3JkZXIgZnJvbSBhbmNlc3RvciB0byBkZXNjZW5kYW50LCBlbHNlIHdlIGNvdWxkIHJ1biBpbnRvIG51bGxwb2ludGVyc1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0W119ICovXG5cdFx0XHRcdFx0Y29uc3Qgb3JkZXJlZF9lZmZlY3RzID0gW2VdO1xuXHRcdFx0XHRcdGxldCBhbmNlc3RvciA9IGUucGFyZW50O1xuXHRcdFx0XHRcdHdoaWxlIChhbmNlc3RvciAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aWYgKGVhZ2VyX2Jsb2NrX2VmZmVjdHMuaGFzKGFuY2VzdG9yKSkge1xuXHRcdFx0XHRcdFx0XHRlYWdlcl9ibG9ja19lZmZlY3RzLmRlbGV0ZShhbmNlc3Rvcik7XG5cdFx0XHRcdFx0XHRcdG9yZGVyZWRfZWZmZWN0cy5wdXNoKGFuY2VzdG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSBvcmRlcmVkX2VmZmVjdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRcdGNvbnN0IGUgPSBvcmRlcmVkX2VmZmVjdHNbal07XG5cdFx0XHRcdFx0XHQvLyBTa2lwIGVhZ2VyIGVmZmVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiB1bm1vdW50ZWRcblx0XHRcdFx0XHRcdGlmICgoZS5mICYgKERFU1RST1lFRCB8IElORVJUKSkgIT09IDApIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0dXBkYXRlX2VmZmVjdChlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlYWdlcl9ibG9ja19lZmZlY3RzLmNsZWFyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZWFnZXJfYmxvY2tfZWZmZWN0cyA9IG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBpcyBzaW1pbGFyIHRvIGBtYXJrX3JlYWN0aW9uc2AsIGJ1dCBpdCBvbmx5IG1hcmtzIGFzeW5jL2Jsb2NrIGVmZmVjdHNcbiAqIGRlcGVuZGluZyBvbiBgdmFsdWVgIGFuZCBhdCBsZWFzdCBvbmUgb2YgdGhlIG90aGVyIGBzb3VyY2VzYCwgc28gdGhhdFxuICogdGhlc2UgZWZmZWN0cyBjYW4gcmUtcnVuIGFmdGVyIGFub3RoZXIgYmF0Y2ggaGFzIGJlZW4gY29tbWl0dGVkXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICogQHBhcmFtIHtTb3VyY2VbXX0gc291cmNlc1xuICogQHBhcmFtIHtTZXQ8VmFsdWU+fSBtYXJrZWRcbiAqIEBwYXJhbSB7TWFwPFJlYWN0aW9uLCBib29sZWFuPn0gY2hlY2tlZFxuICovXG5mdW5jdGlvbiBtYXJrX2VmZmVjdHModmFsdWUsIHNvdXJjZXMsIG1hcmtlZCwgY2hlY2tlZCkge1xuXHRpZiAobWFya2VkLmhhcyh2YWx1ZSkpIHJldHVybjtcblx0bWFya2VkLmFkZCh2YWx1ZSk7XG5cblx0aWYgKHZhbHVlLnJlYWN0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgcmVhY3Rpb24gb2YgdmFsdWUucmVhY3Rpb25zKSB7XG5cdFx0XHRjb25zdCBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0XHRcdGlmICgoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0XHRtYXJrX2VmZmVjdHMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAocmVhY3Rpb24pLCBzb3VyY2VzLCBtYXJrZWQsIGNoZWNrZWQpO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0KGZsYWdzICYgKEFTWU5DIHwgQkxPQ0tfRUZGRUNUKSkgIT09IDAgJiZcblx0XHRcdFx0KGZsYWdzICYgRElSVFkpID09PSAwICYmXG5cdFx0XHRcdGRlcGVuZHNfb24ocmVhY3Rpb24sIHNvdXJjZXMsIGNoZWNrZWQpXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIERJUlRZKTtcblx0XHRcdFx0c2NoZWR1bGVfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBXaGVuIGNvbW1pdHRpbmcgYSBmb3JrLCB3ZSBuZWVkIHRvIHRyaWdnZXIgZWFnZXIgZWZmZWN0cyBzbyB0aGF0XG4gKiBhbnkgYCRzdGF0ZS5lYWdlciguLi4pYCBleHByZXNzaW9ucyB1cGRhdGUgaW1tZWRpYXRlbHkuIFRoaXNcbiAqIGZ1bmN0aW9uIGFsbG93cyB1cyB0byBkaXNjb3ZlciB0aGVtXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICogQHBhcmFtIHtTZXQ8RWZmZWN0Pn0gZWZmZWN0c1xuICovXG5mdW5jdGlvbiBtYXJrX2VhZ2VyX2VmZmVjdHModmFsdWUsIGVmZmVjdHMpIHtcblx0aWYgKHZhbHVlLnJlYWN0aW9ucyA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdGZvciAoY29uc3QgcmVhY3Rpb24gb2YgdmFsdWUucmVhY3Rpb25zKSB7XG5cdFx0Y29uc3QgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdFx0aWYgKChmbGFncyAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHRtYXJrX2VhZ2VyX2VmZmVjdHMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAocmVhY3Rpb24pLCBlZmZlY3RzKTtcblx0XHR9IGVsc2UgaWYgKChmbGFncyAmIEVBR0VSX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBESVJUWSk7XG5cdFx0XHRlZmZlY3RzLmFkZCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdGlvbn0gcmVhY3Rpb25cbiAqIEBwYXJhbSB7U291cmNlW119IHNvdXJjZXNcbiAqIEBwYXJhbSB7TWFwPFJlYWN0aW9uLCBib29sZWFuPn0gY2hlY2tlZFxuICovXG5mdW5jdGlvbiBkZXBlbmRzX29uKHJlYWN0aW9uLCBzb3VyY2VzLCBjaGVja2VkKSB7XG5cdGNvbnN0IGRlcGVuZHMgPSBjaGVja2VkLmdldChyZWFjdGlvbik7XG5cdGlmIChkZXBlbmRzICE9PSB1bmRlZmluZWQpIHJldHVybiBkZXBlbmRzO1xuXG5cdGlmIChyZWFjdGlvbi5kZXBzICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCBkZXAgb2YgcmVhY3Rpb24uZGVwcykge1xuXHRcdFx0aWYgKHNvdXJjZXMuaW5jbHVkZXMoZGVwKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKChkZXAuZiAmIERFUklWRUQpICE9PSAwICYmIGRlcGVuZHNfb24oLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwKSwgc291cmNlcywgY2hlY2tlZCkpIHtcblx0XHRcdFx0Y2hlY2tlZC5zZXQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwKSwgdHJ1ZSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGNoZWNrZWQuc2V0KHJlYWN0aW9uLCBmYWxzZSk7XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBzaWduYWxcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVfZWZmZWN0KHNpZ25hbCkge1xuXHR2YXIgZWZmZWN0ID0gKGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IHNpZ25hbCk7XG5cblx0d2hpbGUgKGVmZmVjdC5wYXJlbnQgIT09IG51bGwpIHtcblx0XHRlZmZlY3QgPSBlZmZlY3QucGFyZW50O1xuXHRcdHZhciBmbGFncyA9IGVmZmVjdC5mO1xuXG5cdFx0Ly8gaWYgdGhlIGVmZmVjdCBpcyBiZWluZyBzY2hlZHVsZWQgYmVjYXVzZSBhIHBhcmVudCAoZWFjaC9hd2FpdC9ldGMpIGJsb2NrXG5cdFx0Ly8gdXBkYXRlZCBhbiBpbnRlcm5hbCBzb3VyY2UsIGJhaWwgb3V0IG9yIHdlJ2xsIGNhdXNlIGEgc2Vjb25kIGZsdXNoXG5cdFx0aWYgKFxuXHRcdFx0aXNfZmx1c2hpbmcgJiZcblx0XHRcdGVmZmVjdCA9PT0gYWN0aXZlX2VmZmVjdCAmJlxuXHRcdFx0KGZsYWdzICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCAmJlxuXHRcdFx0KGZsYWdzICYgSEVBRF9FRkZFQ1QpID09PSAwXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKChmbGFncyAmIChST09UX0VGRkVDVCB8IEJSQU5DSF9FRkZFQ1QpKSAhPT0gMCkge1xuXHRcdFx0aWYgKChmbGFncyAmIENMRUFOKSA9PT0gMCkgcmV0dXJuO1xuXHRcdFx0ZWZmZWN0LmYgXj0gQ0xFQU47XG5cdFx0fVxuXHR9XG5cblx0cXVldWVkX3Jvb3RfZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG59XG5cbi8qKiBAdHlwZSB7U291cmNlPG51bWJlcj5bXX0gKi9cbmxldCBlYWdlcl92ZXJzaW9ucyA9IFtdO1xuXG5mdW5jdGlvbiBlYWdlcl9mbHVzaCgpIHtcblx0dHJ5IHtcblx0XHRmbHVzaFN5bmMoKCkgPT4ge1xuXHRcdFx0Zm9yIChjb25zdCB2ZXJzaW9uIG9mIGVhZ2VyX3ZlcnNpb25zKSB7XG5cdFx0XHRcdHVwZGF0ZSh2ZXJzaW9uKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSBmaW5hbGx5IHtcblx0XHRlYWdlcl92ZXJzaW9ucyA9IFtdO1xuXHR9XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYCRzdGF0ZS5lYWdlcihmbigpKWBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhZ2VyKGZuKSB7XG5cdHZhciB2ZXJzaW9uID0gc291cmNlKDApO1xuXHR2YXIgaW5pdGlhbCA9IHRydWU7XG5cdHZhciB2YWx1ZSA9IC8qKiBAdHlwZSB7VH0gKi8gKHVuZGVmaW5lZCk7XG5cblx0Z2V0KHZlcnNpb24pO1xuXG5cdGVhZ2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKGluaXRpYWwpIHtcblx0XHRcdC8vIHRoZSBmaXJzdCB0aW1lIHRoaXMgcnVucywgd2UgY3JlYXRlIGFuIGVhZ2VyIGVmZmVjdFxuXHRcdFx0Ly8gdGhhdCB3aWxsIHJ1biBlYWdlcmx5IHdoZW5ldmVyIHRoZSBleHByZXNzaW9uIGNoYW5nZXNcblx0XHRcdHZhciBwcmV2aW91c19iYXRjaF92YWx1ZXMgPSBiYXRjaF92YWx1ZXM7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGJhdGNoX3ZhbHVlcyA9IG51bGw7XG5cdFx0XHRcdHZhbHVlID0gZm4oKTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGJhdGNoX3ZhbHVlcyA9IHByZXZpb3VzX2JhdGNoX3ZhbHVlcztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHRoZSBzZWNvbmQgdGltZSB0aGlzIGVmZmVjdCBydW5zLCBpdCdzIHRvIHNjaGVkdWxlIGFcblx0XHQvLyBgdmVyc2lvbmAgdXBkYXRlLiBzaW5jZSB0aGlzIHdpbGwgcmVjcmVhdGUgdGhlIGVmZmVjdCxcblx0XHQvLyB3ZSBkb24ndCBuZWVkIHRvIGV2YWx1YXRlIHRoZSBleHByZXNzaW9uIGhlcmVcblx0XHRpZiAoZWFnZXJfdmVyc2lvbnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRxdWV1ZV9taWNyb190YXNrKGVhZ2VyX2ZsdXNoKTtcblx0XHR9XG5cblx0XHRlYWdlcl92ZXJzaW9ucy5wdXNoKHZlcnNpb24pO1xuXHR9KTtcblxuXHRpbml0aWFsID0gZmFsc2U7XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSAnZm9yaycsIGluIHdoaWNoIHN0YXRlIGNoYW5nZXMgYXJlIGV2YWx1YXRlZCBidXQgbm90IGFwcGxpZWQgdG8gdGhlIERPTS5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBzcGVjdWxhdGl2ZWx5IGxvYWRpbmcgZGF0YSAoZm9yIGV4YW1wbGUpIHdoZW4geW91IHN1c3BlY3QgdGhhdFxuICogdGhlIHVzZXIgaXMgYWJvdXQgdG8gdGFrZSBzb21lIGFjdGlvbi5cbiAqXG4gKiBGcmFtZXdvcmtzIGxpa2UgU3ZlbHRlS2l0IGNhbiB1c2UgdGhpcyB0byBwcmVsb2FkIGRhdGEgd2hlbiB0aGUgdXNlciB0b3VjaGVzIG9yXG4gKiBob3ZlcnMgb3ZlciBhIGxpbmssIG1ha2luZyBhbnkgc3Vic2VxdWVudCBuYXZpZ2F0aW9uIGZlZWwgaW5zdGFudGFuZW91cy5cbiAqXG4gKiBUaGUgYGZuYCBwYXJhbWV0ZXIgaXMgYSBzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IG1vZGlmaWVzIHNvbWUgc3RhdGUuIFRoZVxuICogc3RhdGUgY2hhbmdlcyB3aWxsIGJlIHJldmVydGVkIGFmdGVyIHRoZSBmb3JrIGlzIGluaXRpYWxpc2VkLCB0aGVuIHJlYXBwbGllZFxuICogaWYgYW5kIHdoZW4gdGhlIGZvcmsgaXMgZXZlbnR1YWxseSBjb21taXR0ZWQuXG4gKlxuICogV2hlbiBpdCBiZWNvbWVzIGNsZWFyIHRoYXQgYSBmb3JrIHdpbGwgX25vdF8gYmUgY29tbWl0dGVkIChlLmcuIGJlY2F1c2UgdGhlXG4gKiB1c2VyIG5hdmlnYXRlZCBlbHNld2hlcmUpLCBpdCBtdXN0IGJlIGRpc2NhcmRlZCB0byBhdm9pZCBsZWFraW5nIG1lbW9yeS5cbiAqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7Rm9ya31cbiAqIEBzaW5jZSA1LjQyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JrKGZuKSB7XG5cdGlmICghYXN5bmNfbW9kZV9mbGFnKSB7XG5cdFx0ZS5leHBlcmltZW50YWxfYXN5bmNfcmVxdWlyZWQoJ2ZvcmsnKTtcblx0fVxuXG5cdGlmIChjdXJyZW50X2JhdGNoICE9PSBudWxsKSB7XG5cdFx0ZS5mb3JrX3RpbWluZygpO1xuXHR9XG5cblx0dmFyIGJhdGNoID0gQmF0Y2guZW5zdXJlKCk7XG5cdGJhdGNoLmlzX2ZvcmsgPSB0cnVlO1xuXHRiYXRjaF92YWx1ZXMgPSBuZXcgTWFwKCk7XG5cblx0dmFyIGNvbW1pdHRlZCA9IGZhbHNlO1xuXHR2YXIgc2V0dGxlZCA9IGJhdGNoLnNldHRsZWQoKTtcblxuXHRmbHVzaFN5bmMoZm4pO1xuXG5cdGJhdGNoX3ZhbHVlcyA9IG51bGw7XG5cblx0Ly8gcmV2ZXJ0IHN0YXRlIGNoYW5nZXNcblx0Zm9yICh2YXIgW3NvdXJjZSwgdmFsdWVdIG9mIGJhdGNoLnByZXZpb3VzKSB7XG5cdFx0c291cmNlLnYgPSB2YWx1ZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y29tbWl0OiBhc3luYyAoKSA9PiB7XG5cdFx0XHRpZiAoY29tbWl0dGVkKSB7XG5cdFx0XHRcdGF3YWl0IHNldHRsZWQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFiYXRjaGVzLmhhcyhiYXRjaCkpIHtcblx0XHRcdFx0ZS5mb3JrX2Rpc2NhcmRlZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21taXR0ZWQgPSB0cnVlO1xuXG5cdFx0XHRiYXRjaC5pc19mb3JrID0gZmFsc2U7XG5cblx0XHRcdC8vIGFwcGx5IGNoYW5nZXNcblx0XHRcdGZvciAodmFyIFtzb3VyY2UsIHZhbHVlXSBvZiBiYXRjaC5jdXJyZW50KSB7XG5cdFx0XHRcdHNvdXJjZS52ID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRyaWdnZXIgYW55IGAkc3RhdGUuZWFnZXIoLi4uKWAgZXhwcmVzc2lvbnMgd2l0aCB0aGUgbmV3IHN0YXRlLlxuXHRcdFx0Ly8gZWFnZXIgZWZmZWN0cyBkb24ndCBnZXQgc2NoZWR1bGVkIGxpa2Ugb3RoZXIgZWZmZWN0cywgc28gd2Vcblx0XHRcdC8vIGNhbid0IGp1c3QgZW5jb3VudGVyIHRoZW0gZHVyaW5nIHRyYXZlcnNhbCwgd2UgbmVlZCB0b1xuXHRcdFx0Ly8gcHJvYWN0aXZlbHkgZmx1c2ggdGhlbVxuXHRcdFx0Ly8gVE9ETyBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIGltcGxlbWVudGF0aW9uP1xuXHRcdFx0Zmx1c2hTeW5jKCgpID0+IHtcblx0XHRcdFx0LyoqIEB0eXBlIHtTZXQ8RWZmZWN0Pn0gKi9cblx0XHRcdFx0dmFyIGVhZ2VyX2VmZmVjdHMgPSBuZXcgU2V0KCk7XG5cblx0XHRcdFx0Zm9yICh2YXIgc291cmNlIG9mIGJhdGNoLmN1cnJlbnQua2V5cygpKSB7XG5cdFx0XHRcdFx0bWFya19lYWdlcl9lZmZlY3RzKHNvdXJjZSwgZWFnZXJfZWZmZWN0cyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXRfZWFnZXJfZWZmZWN0cyhlYWdlcl9lZmZlY3RzKTtcblx0XHRcdFx0Zmx1c2hfZWFnZXJfZWZmZWN0cygpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGJhdGNoLnJldml2ZSgpO1xuXHRcdFx0YXdhaXQgc2V0dGxlZDtcblx0XHR9LFxuXHRcdGRpc2NhcmQ6ICgpID0+IHtcblx0XHRcdGlmICghY29tbWl0dGVkICYmIGJhdGNoZXMuaGFzKGJhdGNoKSkge1xuXHRcdFx0XHRiYXRjaGVzLmRlbGV0ZShiYXRjaCk7XG5cdFx0XHRcdGJhdGNoLmRpc2NhcmQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogRm9yY2libHkgcmVtb3ZlIGFsbCBjdXJyZW50IGJhdGNoZXMsIHRvIHByZXZlbnQgY3Jvc3MtdGFsayBiZXR3ZWVuIHRlc3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcblx0YmF0Y2hlcy5jbGVhcigpO1xufVxuIiwgImltcG9ydCB7IGdldCwgdGljaywgdW50cmFjayB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9ydW50aW1lLmpzJztcbmltcG9ydCB7IGVmZmVjdF90cmFja2luZywgcmVuZGVyX2VmZmVjdCB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgc291cmNlLCBpbmNyZW1lbnQgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IHRhZyB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvZG9tL3Rhc2suanMnO1xuXG4vKipcbiAqIFJldHVybnMgYSBgc3Vic2NyaWJlYCBmdW5jdGlvbiB0aGF0IGludGVncmF0ZXMgZXh0ZXJuYWwgZXZlbnQtYmFzZWQgc3lzdGVtcyB3aXRoIFN2ZWx0ZSdzIHJlYWN0aXZpdHkuXG4gKiBJdCdzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGludGVncmF0aW5nIHdpdGggd2ViIEFQSXMgbGlrZSBgTWVkaWFRdWVyeWAsIGBJbnRlcnNlY3Rpb25PYnNlcnZlcmAsIG9yIGBXZWJTb2NrZXRgLlxuICpcbiAqIElmIGBzdWJzY3JpYmVgIGlzIGNhbGxlZCBpbnNpZGUgYW4gZWZmZWN0IChpbmNsdWRpbmcgaW5kaXJlY3RseSwgZm9yIGV4YW1wbGUgaW5zaWRlIGEgZ2V0dGVyKSxcbiAqIHRoZSBgc3RhcnRgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gYHVwZGF0ZWAgZnVuY3Rpb24uIFdoZW5ldmVyIGB1cGRhdGVgIGlzIGNhbGxlZCwgdGhlIGVmZmVjdCByZS1ydW5zLlxuICpcbiAqIElmIGBzdGFydGAgcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGVmZmVjdCBpcyBkZXN0cm95ZWQuXG4gKlxuICogSWYgYHN1YnNjcmliZWAgaXMgY2FsbGVkIGluIG11bHRpcGxlIGVmZmVjdHMsIGBzdGFydGAgd2lsbCBvbmx5IGJlIGNhbGxlZCBvbmNlIGFzIGxvbmcgYXMgdGhlIGVmZmVjdHNcbiAqIGFyZSBhY3RpdmUsIGFuZCB0aGUgcmV0dXJuZWQgdGVhcmRvd24gZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGNhbGxlZCB3aGVuIGFsbCBlZmZlY3RzIGFyZSBkZXN0cm95ZWQuXG4gKlxuICogSXQncyBiZXN0IHVuZGVyc3Rvb2Qgd2l0aCBhbiBleGFtcGxlLiBIZXJlJ3MgYW4gaW1wbGVtZW50YXRpb24gb2YgW2BNZWRpYVF1ZXJ5YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3N2ZWx0ZS1yZWFjdGl2aXR5I01lZGlhUXVlcnkpOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBjcmVhdGVTdWJzY3JpYmVyIH0gZnJvbSAnc3ZlbHRlL3JlYWN0aXZpdHknO1xuICogaW1wb3J0IHsgb24gfSBmcm9tICdzdmVsdGUvZXZlbnRzJztcbiAqXG4gKiBleHBvcnQgY2xhc3MgTWVkaWFRdWVyeSB7XG4gKiBcdCNxdWVyeTtcbiAqIFx0I3N1YnNjcmliZTtcbiAqXG4gKiBcdGNvbnN0cnVjdG9yKHF1ZXJ5KSB7XG4gKiBcdFx0dGhpcy4jcXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShgKCR7cXVlcnl9KWApO1xuICpcbiAqIFx0XHR0aGlzLiNzdWJzY3JpYmUgPSBjcmVhdGVTdWJzY3JpYmVyKCh1cGRhdGUpID0+IHtcbiAqIFx0XHRcdC8vIHdoZW4gdGhlIGBjaGFuZ2VgIGV2ZW50IG9jY3VycywgcmUtcnVuIGFueSBlZmZlY3RzIHRoYXQgcmVhZCBgdGhpcy5jdXJyZW50YFxuICogXHRcdFx0Y29uc3Qgb2ZmID0gb24odGhpcy4jcXVlcnksICdjaGFuZ2UnLCB1cGRhdGUpO1xuICpcbiAqIFx0XHRcdC8vIHN0b3AgbGlzdGVuaW5nIHdoZW4gYWxsIHRoZSBlZmZlY3RzIGFyZSBkZXN0cm95ZWRcbiAqIFx0XHRcdHJldHVybiAoKSA9PiBvZmYoKTtcbiAqIFx0XHR9KTtcbiAqIFx0fVxuICpcbiAqIFx0Z2V0IGN1cnJlbnQoKSB7XG4gKiBcdFx0Ly8gVGhpcyBtYWtlcyB0aGUgZ2V0dGVyIHJlYWN0aXZlLCBpZiByZWFkIGluIGFuIGVmZmVjdFxuICogXHRcdHRoaXMuI3N1YnNjcmliZSgpO1xuICpcbiAqIFx0XHQvLyBSZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHF1ZXJ5LCB3aGV0aGVyIG9yIG5vdCB3ZSdyZSBpbiBhbiBlZmZlY3RcbiAqIFx0XHRyZXR1cm4gdGhpcy4jcXVlcnkubWF0Y2hlcztcbiAqIFx0fVxuICogfVxuICogYGBgXG4gKiBAcGFyYW0geyh1cGRhdGU6ICgpID0+IHZvaWQpID0+ICgoKSA9PiB2b2lkKSB8IHZvaWR9IHN0YXJ0XG4gKiBAc2luY2UgNS43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZXIoc3RhcnQpIHtcblx0bGV0IHN1YnNjcmliZXJzID0gMDtcblx0bGV0IHZlcnNpb24gPSBzb3VyY2UoMCk7XG5cdC8qKiBAdHlwZSB7KCgpID0+IHZvaWQpIHwgdm9pZH0gKi9cblx0bGV0IHN0b3A7XG5cblx0aWYgKERFVikge1xuXHRcdHRhZyh2ZXJzaW9uLCAnY3JlYXRlU3Vic2NyaWJlciB2ZXJzaW9uJyk7XG5cdH1cblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChlZmZlY3RfdHJhY2tpbmcoKSkge1xuXHRcdFx0Z2V0KHZlcnNpb24pO1xuXG5cdFx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0aWYgKHN1YnNjcmliZXJzID09PSAwKSB7XG5cdFx0XHRcdFx0c3RvcCA9IHVudHJhY2soKCkgPT4gc3RhcnQoKCkgPT4gaW5jcmVtZW50KHZlcnNpb24pKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdWJzY3JpYmVycyArPSAxO1xuXG5cdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRcdFx0XHQvLyBPbmx5IGNvdW50IGRvd24gYWZ0ZXIgYSBtaWNyb3Rhc2ssIGVsc2Ugd2Ugd291bGQgcmVhY2ggMCBiZWZvcmUgb3VyIG93biByZW5kZXIgZWZmZWN0IHJlcnVucyxcblx0XHRcdFx0XHRcdC8vIGJ1dCByZWFjaCAxIGFnYWluIHdoZW4gdGhlIHRpY2sgY2FsbGJhY2sgb2YgdGhlIHByaW9yIHRlYXJkb3duIHJ1bnMuIFRoYXQgd291bGQgbWVhbiB3ZVxuXHRcdFx0XHRcdFx0Ly8gcmUtc3ViY3JpYmUgdW5uZWNlc3NhcmlseSBhbmQgY3JlYXRlIGEgbWVtb3J5IGxlYWsgYmVjYXVzZSB0aGUgb2xkIHN1YnNjcmlwdGlvbiBpcyBuZXZlciBjbGVhbmVkIHVwLlxuXHRcdFx0XHRcdFx0c3Vic2NyaWJlcnMgLT0gMTtcblxuXHRcdFx0XHRcdFx0aWYgKHN1YnNjcmliZXJzID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHN0b3A/LigpO1xuXHRcdFx0XHRcdFx0XHRzdG9wID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHQvLyBJbmNyZW1lbnQgdGhlIHZlcnNpb24gdG8gZW5zdXJlIGFueSBkZXBlbmRlbnQgZGVyaXZlZHMgYXJlIG1hcmtlZCBkaXJ0eSB3aGVuIHRoZSBzdWJzY3JpcHRpb24gaXMgcGlja2VkIHVwIGFnYWluIGxhdGVyLlxuXHRcdFx0XHRcdFx0XHQvLyBJZiB3ZSBkaWRuJ3QgZG8gdGhpcyB0aGVuIHRoZSBjb21wYXJpc29uIG9mIHdyaXRlIHZlcnNpb25zIHdvdWxkIGRldGVybWluZSB0aGF0IHRoZSBkZXJpdmVkIGhhcyBhIGxhdGVyIHZlcnNpb24gdGhhblxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgc3Vic2NyaWJlciwgYW5kIGl0IHdvdWxkIG5vdCBiZSByZS1ydW4uXG5cdFx0XHRcdFx0XHRcdGluY3JlbWVudCh2ZXJzaW9uKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgU291cmNlLCBUZW1wbGF0ZU5vZGUsIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7XG5cdEJPVU5EQVJZX0VGRkVDVCxcblx0Q09NTUVOVF9OT0RFLFxuXHRFRkZFQ1RfUFJFU0VSVkVELFxuXHRFRkZFQ1RfVFJBTlNQQVJFTlRcbn0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgSFlEUkFUSU9OX1NUQVJUX0VMU0UgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIHNldF9jb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgaGFuZGxlX2Vycm9yLCBpbnZva2VfZXJyb3JfYm91bmRhcnkgfSBmcm9tICcuLi8uLi9lcnJvci1oYW5kbGluZy5qcyc7XG5pbXBvcnQge1xuXHRibG9jayxcblx0YnJhbmNoLFxuXHRkZXN0cm95X2VmZmVjdCxcblx0bW92ZV9lZmZlY3QsXG5cdHBhdXNlX2VmZmVjdFxufSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRnZXQsXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0bmV4dCxcblx0c2tpcF9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZVxufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi8uLi9lcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IEJhdGNoIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5pbXBvcnQgeyBpbnRlcm5hbF9zZXQsIHNvdXJjZSB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyB0YWcgfSBmcm9tICcuLi8uLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpYmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVhY3Rpdml0eS9jcmVhdGUtc3Vic2NyaWJlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdCBvbmVycm9yPzogKGVycm9yOiB1bmtub3duLCByZXNldDogKCkgPT4gdm9pZCkgPT4gdm9pZDtcbiAqICAgZmFpbGVkPzogKGFuY2hvcjogTm9kZSwgZXJyb3I6ICgpID0+IHVua25vd24sIHJlc2V0OiAoKSA9PiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xuICogICBwZW5kaW5nPzogKGFuY2hvcjogTm9kZSkgPT4gdm9pZDtcbiAqIH19IEJvdW5kYXJ5UHJvcHNcbiAqL1xuXG52YXIgZmxhZ3MgPSBFRkZFQ1RfVFJBTlNQQVJFTlQgfCBFRkZFQ1RfUFJFU0VSVkVEIHwgQk9VTkRBUllfRUZGRUNUO1xuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0JvdW5kYXJ5UHJvcHN9IHByb3BzXG4gKiBAcGFyYW0geygoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gY2hpbGRyZW5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmRhcnkobm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdG5ldyBCb3VuZGFyeShub2RlLCBwcm9wcywgY2hpbGRyZW4pO1xufVxuXG5leHBvcnQgY2xhc3MgQm91bmRhcnkge1xuXHQvKiogQHR5cGUge0JvdW5kYXJ5IHwgbnVsbH0gKi9cblx0cGFyZW50O1xuXG5cdCNwZW5kaW5nID0gZmFsc2U7XG5cblx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovXG5cdCNhbmNob3I7XG5cblx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHQjaHlkcmF0ZV9vcGVuID0gaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbnVsbDtcblxuXHQvKiogQHR5cGUge0JvdW5kYXJ5UHJvcHN9ICovXG5cdCNwcm9wcztcblxuXHQvKiogQHR5cGUgeygoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gKi9cblx0I2NoaWxkcmVuO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHQjZWZmZWN0O1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0I21haW5fZWZmZWN0ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdCNwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHQjZmFpbGVkX2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgbnVsbH0gKi9cblx0I29mZnNjcmVlbl9mcmFnbWVudCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHQjcGVuZGluZ19hbmNob3IgPSBudWxsO1xuXG5cdCNsb2NhbF9wZW5kaW5nX2NvdW50ID0gMDtcblx0I3BlbmRpbmdfY291bnQgPSAwO1xuXG5cdCNpc19jcmVhdGluZ19mYWxsYmFjayA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBBIHNvdXJjZSBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgcGVuZGluZyBhc3luYyBkZXJpdmVkcy9leHByZXNzaW9ucy5cblx0ICogT25seSBjcmVhdGVkIGlmIGAkZWZmZWN0LnBlbmRpbmcoKWAgaXMgdXNlZCBpbnNpZGUgdGhlIGJvdW5kYXJ5LFxuXHQgKiBvdGhlcndpc2UgdXBkYXRpbmcgdGhlIHNvdXJjZSByZXN1bHRzIGluIG5lZWRsZXNzIGBCYXRjaC5lbnN1cmUoKWBcblx0ICogY2FsbHMgZm9sbG93ZWQgYnkgbm8tb3AgZmx1c2hlc1xuXHQgKiBAdHlwZSB7U291cmNlPG51bWJlcj4gfCBudWxsfVxuXHQgKi9cblx0I2VmZmVjdF9wZW5kaW5nID0gbnVsbDtcblxuXHQjZWZmZWN0X3BlbmRpbmdfc3Vic2NyaWJlciA9IGNyZWF0ZVN1YnNjcmliZXIoKCkgPT4ge1xuXHRcdHRoaXMuI2VmZmVjdF9wZW5kaW5nID0gc291cmNlKHRoaXMuI2xvY2FsX3BlbmRpbmdfY291bnQpO1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0dGFnKHRoaXMuI2VmZmVjdF9wZW5kaW5nLCAnJGVmZmVjdC5wZW5kaW5nKCknKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0dGhpcy4jZWZmZWN0X3BlbmRpbmcgPSBudWxsO1xuXHRcdH07XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuXHQgKiBAcGFyYW0ge0JvdW5kYXJ5UHJvcHN9IHByb3BzXG5cdCAqIEBwYXJhbSB7KChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSBjaGlsZHJlblxuXHQgKi9cblx0Y29uc3RydWN0b3Iobm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdFx0dGhpcy4jYW5jaG9yID0gbm9kZTtcblx0XHR0aGlzLiNwcm9wcyA9IHByb3BzO1xuXHRcdHRoaXMuI2NoaWxkcmVuID0gY2hpbGRyZW47XG5cblx0XHR0aGlzLnBhcmVudCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuYjtcblxuXHRcdHRoaXMuI3BlbmRpbmcgPSAhIXRoaXMuI3Byb3BzLnBlbmRpbmc7XG5cblx0XHR0aGlzLiNlZmZlY3QgPSBibG9jaygoKSA9PiB7XG5cdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmIgPSB0aGlzO1xuXG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdGNvbnN0IGNvbW1lbnQgPSB0aGlzLiNoeWRyYXRlX29wZW47XG5cdFx0XHRcdGh5ZHJhdGVfbmV4dCgpO1xuXG5cdFx0XHRcdGNvbnN0IHNlcnZlcl9yZW5kZXJlZF9wZW5kaW5nID1cblx0XHRcdFx0XHQvKiogQHR5cGUge0NvbW1lbnR9ICovIChjb21tZW50KS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoY29tbWVudCkuZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0U7XG5cblx0XHRcdFx0aWYgKHNlcnZlcl9yZW5kZXJlZF9wZW5kaW5nKSB7XG5cdFx0XHRcdFx0dGhpcy4jaHlkcmF0ZV9wZW5kaW5nX2NvbnRlbnQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLiNoeWRyYXRlX3Jlc29sdmVkX2NvbnRlbnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFuY2hvciA9IHRoaXMuI2dldF9hbmNob3IoKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoaXMuI21haW5fZWZmZWN0ID0gYnJhbmNoKCgpID0+IGNoaWxkcmVuKGFuY2hvcikpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuI3BlbmRpbmdfY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy4jc2hvd19wZW5kaW5nX3NuaXBwZXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLiNwZW5kaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0dGhpcy4jcGVuZGluZ19hbmNob3I/LnJlbW92ZSgpO1xuXHRcdFx0fTtcblx0XHR9LCBmbGFncyk7XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHR0aGlzLiNhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXHR9XG5cblx0I2h5ZHJhdGVfcmVzb2x2ZWRfY29udGVudCgpIHtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy4jbWFpbl9lZmZlY3QgPSBicmFuY2goKCkgPT4gdGhpcy4jY2hpbGRyZW4odGhpcy4jYW5jaG9yKSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3IoZXJyb3IpO1xuXHRcdH1cblxuXHRcdC8vIFNpbmNlIHNlcnZlciByZW5kZXJlZCByZXNvbHZlZCBjb250ZW50LCB3ZSBuZXZlciBzaG93IHBlbmRpbmcgc3RhdGVcblx0XHQvLyBFdmVuIGlmIGNsaWVudC1zaWRlIGFzeW5jIG9wZXJhdGlvbnMgYXJlIHN0aWxsIHJ1bm5pbmcsIHRoZSBjb250ZW50IGlzIGFscmVhZHkgZGlzcGxheWVkXG5cdFx0dGhpcy4jcGVuZGluZyA9IGZhbHNlO1xuXHR9XG5cblx0I2h5ZHJhdGVfcGVuZGluZ19jb250ZW50KCkge1xuXHRcdGNvbnN0IHBlbmRpbmcgPSB0aGlzLiNwcm9wcy5wZW5kaW5nO1xuXHRcdGlmICghcGVuZGluZykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBwZW5kaW5nKHRoaXMuI2FuY2hvcikpO1xuXG5cdFx0QmF0Y2guZW5xdWV1ZSgoKSA9PiB7XG5cdFx0XHR2YXIgYW5jaG9yID0gdGhpcy4jZ2V0X2FuY2hvcigpO1xuXG5cdFx0XHR0aGlzLiNtYWluX2VmZmVjdCA9IHRoaXMuI3J1bigoKSA9PiB7XG5cdFx0XHRcdEJhdGNoLmVuc3VyZSgpO1xuXHRcdFx0XHRyZXR1cm4gYnJhbmNoKCgpID0+IHRoaXMuI2NoaWxkcmVuKGFuY2hvcikpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICh0aGlzLiNwZW5kaW5nX2NvdW50ID4gMCkge1xuXHRcdFx0XHR0aGlzLiNzaG93X3BlbmRpbmdfc25pcHBldCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAodGhpcy4jcGVuZGluZ19lZmZlY3QpLCAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4jcGVuZGluZ19lZmZlY3QgPSBudWxsO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLiNwZW5kaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQjZ2V0X2FuY2hvcigpIHtcblx0XHR2YXIgYW5jaG9yID0gdGhpcy4jYW5jaG9yO1xuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmcpIHtcblx0XHRcdHRoaXMuI3BlbmRpbmdfYW5jaG9yID0gY3JlYXRlX3RleHQoKTtcblx0XHRcdHRoaXMuI2FuY2hvci5iZWZvcmUodGhpcy4jcGVuZGluZ19hbmNob3IpO1xuXG5cdFx0XHRhbmNob3IgPSB0aGlzLiNwZW5kaW5nX2FuY2hvcjtcblx0XHR9XG5cblx0XHRyZXR1cm4gYW5jaG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBlZmZlY3QgZXhpc3RzIGluc2lkZSBhIGJvdW5kYXJ5IHdob3NlIHBlbmRpbmcgc25pcHBldCBpcyBzaG93blxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzX3BlbmRpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3BlbmRpbmcgfHwgKCEhdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNfcGVuZGluZygpKTtcblx0fVxuXG5cdGhhc19wZW5kaW5nX3NuaXBwZXQoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy4jcHJvcHMucGVuZGluZztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0geygpID0+IEVmZmVjdCB8IG51bGx9IGZuXG5cdCAqL1xuXHQjcnVuKGZuKSB7XG5cdFx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdFx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHRcdHZhciBwcmV2aW91c19jdHggPSBjb21wb25lbnRfY29udGV4dDtcblxuXHRcdHNldF9hY3RpdmVfZWZmZWN0KHRoaXMuI2VmZmVjdCk7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbih0aGlzLiNlZmZlY3QpO1xuXHRcdHNldF9jb21wb25lbnRfY29udGV4dCh0aGlzLiNlZmZlY3QuY3R4KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZm4oKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRoYW5kbGVfZXJyb3IoZSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdFx0c2V0X2NvbXBvbmVudF9jb250ZXh0KHByZXZpb3VzX2N0eCk7XG5cdFx0fVxuXHR9XG5cblx0I3Nob3dfcGVuZGluZ19zbmlwcGV0KCkge1xuXHRcdGNvbnN0IHBlbmRpbmcgPSAvKiogQHR5cGUgeyhhbmNob3I6IE5vZGUpID0+IHZvaWR9ICovICh0aGlzLiNwcm9wcy5wZW5kaW5nKTtcblxuXHRcdGlmICh0aGlzLiNtYWluX2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0dGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50LmFwcGVuZCgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKHRoaXMuI3BlbmRpbmdfYW5jaG9yKSk7XG5cdFx0XHRtb3ZlX2VmZmVjdCh0aGlzLiNtYWluX2VmZmVjdCwgdGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jcGVuZGluZ19lZmZlY3QgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuI3BlbmRpbmdfZWZmZWN0ID0gYnJhbmNoKCgpID0+IHBlbmRpbmcodGhpcy4jYW5jaG9yKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHBlbmRpbmcgY291bnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBwZW5kaW5nIHNuaXBwZXQsXG5cdCAqIGlmIGFueSwgc3VjaCB0aGF0IHdlIGNhbiByZXBsYWNlIHRoZSBzbmlwcGV0IHdpdGggY29udGVudCBvbmNlIHdvcmsgaXMgZG9uZVxuXHQgKiBAcGFyYW0gezEgfCAtMX0gZFxuXHQgKi9cblx0I3VwZGF0ZV9wZW5kaW5nX2NvdW50KGQpIHtcblx0XHRpZiAoIXRoaXMuaGFzX3BlbmRpbmdfc25pcHBldCgpKSB7XG5cdFx0XHRpZiAodGhpcy5wYXJlbnQpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQuI3VwZGF0ZV9wZW5kaW5nX2NvdW50KGQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgaW4gYSBzY29wZSB3aXRoIG5vIHBlbmRpbmcgc25pcHBldFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuI3BlbmRpbmdfY291bnQgKz0gZDtcblxuXHRcdGlmICh0aGlzLiNwZW5kaW5nX2NvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLiNwZW5kaW5nID0gZmFsc2U7XG5cblx0XHRcdGlmICh0aGlzLiNwZW5kaW5nX2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QodGhpcy4jcGVuZGluZ19lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50KSB7XG5cdFx0XHRcdHRoaXMuI2FuY2hvci5iZWZvcmUodGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50KTtcblx0XHRcdFx0dGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBzb3VyY2UgdGhhdCBwb3dlcnMgYCRlZmZlY3QucGVuZGluZygpYCBpbnNpZGUgdGhpcyBib3VuZGFyeSxcblx0ICogYW5kIGNvbnRyb2xzIHdoZW4gdGhlIGN1cnJlbnQgYHBlbmRpbmdgIHNuaXBwZXQgKGlmIGFueSkgaXMgcmVtb3ZlZC5cblx0ICogRG8gbm90IGNhbGwgZnJvbSBpbnNpZGUgdGhlIGNsYXNzXG5cdCAqIEBwYXJhbSB7MSB8IC0xfSBkXG5cdCAqL1xuXHR1cGRhdGVfcGVuZGluZ19jb3VudChkKSB7XG5cdFx0dGhpcy4jdXBkYXRlX3BlbmRpbmdfY291bnQoZCk7XG5cblx0XHR0aGlzLiNsb2NhbF9wZW5kaW5nX2NvdW50ICs9IGQ7XG5cblx0XHRpZiAodGhpcy4jZWZmZWN0X3BlbmRpbmcpIHtcblx0XHRcdGludGVybmFsX3NldCh0aGlzLiNlZmZlY3RfcGVuZGluZywgdGhpcy4jbG9jYWxfcGVuZGluZ19jb3VudCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0X2VmZmVjdF9wZW5kaW5nKCkge1xuXHRcdHRoaXMuI2VmZmVjdF9wZW5kaW5nX3N1YnNjcmliZXIoKTtcblx0XHRyZXR1cm4gZ2V0KC8qKiBAdHlwZSB7U291cmNlPG51bWJlcj59ICovICh0aGlzLiNlZmZlY3RfcGVuZGluZykpO1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgKi9cblx0ZXJyb3IoZXJyb3IpIHtcblx0XHR2YXIgb25lcnJvciA9IHRoaXMuI3Byb3BzLm9uZXJyb3I7XG5cdFx0bGV0IGZhaWxlZCA9IHRoaXMuI3Byb3BzLmZhaWxlZDtcblxuXHRcdC8vIElmIHdlIGhhdmUgbm90aGluZyB0byBjYXB0dXJlIHRoZSBlcnJvciwgb3IgaWYgd2UgaGl0IGFuIGVycm9yIHdoaWxlXG5cdFx0Ly8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjaywgcmUtdGhyb3cgZm9yIGFub3RoZXIgYm91bmRhcnkgdG8gaGFuZGxlXG5cdFx0aWYgKHRoaXMuI2lzX2NyZWF0aW5nX2ZhbGxiYWNrIHx8ICghb25lcnJvciAmJiAhZmFpbGVkKSkge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI21haW5fZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCh0aGlzLiNtYWluX2VmZmVjdCk7XG5cdFx0XHR0aGlzLiNtYWluX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmdfZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCh0aGlzLiNwZW5kaW5nX2VmZmVjdCk7XG5cdFx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI2ZhaWxlZF9lZmZlY3QpIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KHRoaXMuI2ZhaWxlZF9lZmZlY3QpO1xuXHRcdFx0dGhpcy4jZmFpbGVkX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKHRoaXMuI2h5ZHJhdGVfb3BlbikpO1xuXHRcdFx0bmV4dCgpO1xuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShza2lwX25vZGVzKCkpO1xuXHRcdH1cblxuXHRcdHZhciBkaWRfcmVzZXQgPSBmYWxzZTtcblx0XHR2YXIgY2FsbGluZ19vbl9lcnJvciA9IGZhbHNlO1xuXG5cdFx0Y29uc3QgcmVzZXQgPSAoKSA9PiB7XG5cdFx0XHRpZiAoZGlkX3Jlc2V0KSB7XG5cdFx0XHRcdHcuc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X25vb3AoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkaWRfcmVzZXQgPSB0cnVlO1xuXG5cdFx0XHRpZiAoY2FsbGluZ19vbl9lcnJvcikge1xuXHRcdFx0XHRlLnN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9vbmVycm9yKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBmYWlsdXJlIGhhcHBlbmVkIHdoaWxlIGZsdXNoaW5nIGVmZmVjdHMsIGN1cnJlbnRfYmF0Y2ggY2FuIGJlIG51bGxcblx0XHRcdEJhdGNoLmVuc3VyZSgpO1xuXG5cdFx0XHR0aGlzLiNsb2NhbF9wZW5kaW5nX2NvdW50ID0gMDtcblxuXHRcdFx0aWYgKHRoaXMuI2ZhaWxlZF9lZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KHRoaXMuI2ZhaWxlZF9lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiNmYWlsZWRfZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGludGVudGlvbmFsbHkgZG8gbm90IHRyeSB0byBmaW5kIHRoZSBuZWFyZXN0IHBlbmRpbmcgYm91bmRhcnkuIElmIHRoaXMgYm91bmRhcnkgaGFzIG9uZSwgd2UnbGwgcmVuZGVyIGl0IG9uIHJlc2V0XG5cdFx0XHQvLyBidXQgaXQgd291bGQgYmUgcmVhbGx5IHdlaXJkIHRvIHNob3cgdGhlIHBhcmVudCdzIGJvdW5kYXJ5IG9uIGEgY2hpbGQgcmVzZXQuXG5cdFx0XHR0aGlzLiNwZW5kaW5nID0gdGhpcy5oYXNfcGVuZGluZ19zbmlwcGV0KCk7XG5cblx0XHRcdHRoaXMuI21haW5fZWZmZWN0ID0gdGhpcy4jcnVuKCgpID0+IHtcblx0XHRcdFx0dGhpcy4jaXNfY3JlYXRpbmdfZmFsbGJhY2sgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIGJyYW5jaCgoKSA9PiB0aGlzLiNjaGlsZHJlbih0aGlzLiNhbmNob3IpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGhpcy4jcGVuZGluZ19jb3VudCA+IDApIHtcblx0XHRcdFx0dGhpcy4jc2hvd19wZW5kaW5nX3NuaXBwZXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuI3BlbmRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdFx0XHRjYWxsaW5nX29uX2Vycm9yID0gdHJ1ZTtcblx0XHRcdG9uZXJyb3I/LihlcnJvciwgcmVzZXQpO1xuXHRcdFx0Y2FsbGluZ19vbl9lcnJvciA9IGZhbHNlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIHRoaXMuI2VmZmVjdCAmJiB0aGlzLiNlZmZlY3QucGFyZW50KTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0fVxuXG5cdFx0aWYgKGZhaWxlZCkge1xuXHRcdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRcdHRoaXMuI2ZhaWxlZF9lZmZlY3QgPSB0aGlzLiNydW4oKCkgPT4ge1xuXHRcdFx0XHRcdEJhdGNoLmVuc3VyZSgpO1xuXHRcdFx0XHRcdHRoaXMuI2lzX2NyZWF0aW5nX2ZhbGxiYWNrID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYnJhbmNoKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0ZmFpbGVkKFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuI2FuY2hvcixcblx0XHRcdFx0XHRcdFx0XHQoKSA9PiBlcnJvcixcblx0XHRcdFx0XHRcdFx0XHQoKSA9PiByZXNldFxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgLyoqIEB0eXBlIHtFZmZlY3R9ICovICh0aGlzLiNlZmZlY3QucGFyZW50KSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0dGhpcy4jaXNfY3JlYXRpbmdfZmFsbGJhY2sgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYm91bmRhcnkoKSB7XG5cdHJldHVybiAvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5iKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBlbmRpbmcoKSB7XG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0ZS5lZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uKCk7XG5cdH1cblxuXHR2YXIgYm91bmRhcnkgPSBhY3RpdmVfZWZmZWN0LmI7XG5cblx0aWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIDA7IC8vIFRPRE8gZXZlbnR1YWxseSB3ZSB3aWxsIG5lZWQgdGhpcyB0byBiZSBnbG9iYWxcblx0fVxuXG5cdHJldHVybiBib3VuZGFyeS5nZXRfZWZmZWN0X3BlbmRpbmcoKTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEVhY2hJdGVtLCBFYWNoU3RhdGUsIEVmZmVjdCwgTWF5YmVTb3VyY2UsIFNvdXJjZSwgVGVtcGxhdGVOb2RlLCBUcmFuc2l0aW9uTWFuYWdlciwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBCYXRjaCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnOyAqL1xuaW1wb3J0IHtcblx0RUFDSF9JTkRFWF9SRUFDVElWRSxcblx0RUFDSF9JU19BTklNQVRFRCxcblx0RUFDSF9JU19DT05UUk9MTEVELFxuXHRFQUNIX0lURU1fSU1NVVRBQkxFLFxuXHRFQUNIX0lURU1fUkVBQ1RJVkUsXG5cdEhZRFJBVElPTl9FTkQsXG5cdEhZRFJBVElPTl9TVEFSVF9FTFNFXG59IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRyZWFkX2h5ZHJhdGlvbl9pbnN0cnVjdGlvbixcblx0c2tpcF9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHtcblx0Y2xlYXJfdGV4dF9jb250ZW50LFxuXHRjcmVhdGVfdGV4dCxcblx0Z2V0X2ZpcnN0X2NoaWxkLFxuXHRnZXRfbmV4dF9zaWJsaW5nLFxuXHRzaG91bGRfZGVmZXJfYXBwZW5kXG59IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHtcblx0YmxvY2ssXG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnMsXG5cdHBhdXNlX2NoaWxkcmVuLFxuXHRwYXVzZV9lZmZlY3QsXG5cdHJlc3VtZV9lZmZlY3Rcbn0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSwgbXV0YWJsZV9zb3VyY2UsIGludGVybmFsX3NldCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBhcnJheV9mcm9tLCBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBDT01NRU5UX05PREUsIElORVJUIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRlcml2ZWRfc2FmZV9lcXVhbCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgY3VycmVudF9iYXRjaCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuXG4vKipcbiAqIFRoZSByb3cgb2YgYSBrZXllZCBlYWNoIGJsb2NrIHRoYXQgaXMgY3VycmVudGx5IHVwZGF0aW5nLiBXZSB0cmFjayB0aGlzXG4gKiBzbyB0aGF0IGBhbmltYXRlOmAgZGlyZWN0aXZlcyBoYXZlIHNvbWV0aGluZyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0b1xuICogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBjdXJyZW50X2VhY2hfaXRlbSA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gaXRlbSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2VhY2hfaXRlbShpdGVtKSB7XG5cdGN1cnJlbnRfZWFjaF9pdGVtID0gaXRlbTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gX1xuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGV4KF8sIGkpIHtcblx0cmV0dXJuIGk7XG59XG5cbi8qKlxuICogUGF1c2UgbXVsdGlwbGUgZWZmZWN0cyBzaW11bHRhbmVvdXNseSwgYW5kIGNvb3JkaW5hdGUgdGhlaXJcbiAqIHN1YnNlcXVlbnQgZGVzdHJ1Y3Rpb24uIFVzZWQgaW4gZWFjaCBibG9ja3NcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbVtdfSB0b19kZXN0cm95XG4gKiBAcGFyYW0ge251bGwgfCBOb2RlfSBjb250cm9sbGVkX2FuY2hvclxuICovXG5mdW5jdGlvbiBwYXVzZV9lZmZlY3RzKHN0YXRlLCB0b19kZXN0cm95LCBjb250cm9sbGVkX2FuY2hvcikge1xuXHQvKiogQHR5cGUge1RyYW5zaXRpb25NYW5hZ2VyW119ICovXG5cdHZhciB0cmFuc2l0aW9ucyA9IFtdO1xuXHR2YXIgbGVuZ3RoID0gdG9fZGVzdHJveS5sZW5ndGg7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHBhdXNlX2NoaWxkcmVuKHRvX2Rlc3Ryb3lbaV0uZSwgdHJhbnNpdGlvbnMsIHRydWUpO1xuXHR9XG5cblx0cnVuX291dF90cmFuc2l0aW9ucyh0cmFuc2l0aW9ucywgKCkgPT4ge1xuXHRcdC8vIElmIHdlJ3JlIGluIGEgY29udHJvbGxlZCBlYWNoIGJsb2NrIChpLmUuIHRoZSBibG9jayBpcyB0aGUgb25seSBjaGlsZCBvZiBhblxuXHRcdC8vIGVsZW1lbnQpLCBhbmQgd2UgYXJlIHJlbW92aW5nIGFsbCBpdGVtcywgX2FuZF8gdGhlcmUgYXJlIG5vIG91dCB0cmFuc2l0aW9ucyxcblx0XHQvLyB3ZSBjYW4gdXNlIHRoZSBmYXN0IHBhdGggXHUyMDE0IGVtcHR5aW5nIHRoZSBlbGVtZW50IGFuZCByZXBsYWNpbmcgdGhlIGFuY2hvclxuXHRcdHZhciBmYXN0X3BhdGggPSB0cmFuc2l0aW9ucy5sZW5ndGggPT09IDAgJiYgY29udHJvbGxlZF9hbmNob3IgIT09IG51bGw7XG5cblx0XHQvLyBUT0RPIG9ubHkgZGVzdHJveSBlZmZlY3RzIGlmIG5vIHBlbmRpbmcgYmF0Y2ggbmVlZHMgdGhlbS4gb3RoZXJ3aXNlLFxuXHRcdC8vIGp1c3Qgc2V0IGBpdGVtLm9gIGJhY2sgdG8gYGZhbHNlYFxuXG5cdFx0aWYgKGZhc3RfcGF0aCkge1xuXHRcdFx0dmFyIGFuY2hvciA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGNvbnRyb2xsZWRfYW5jaG9yKTtcblx0XHRcdHZhciBwYXJlbnRfbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGFuY2hvci5wYXJlbnROb2RlKTtcblxuXHRcdFx0Y2xlYXJfdGV4dF9jb250ZW50KHBhcmVudF9ub2RlKTtcblx0XHRcdHBhcmVudF9ub2RlLmFwcGVuZChhbmNob3IpO1xuXG5cdFx0XHRzdGF0ZS5pdGVtcy5jbGVhcigpO1xuXHRcdFx0bGluayhzdGF0ZSwgdG9fZGVzdHJveVswXS5wcmV2LCB0b19kZXN0cm95W2xlbmd0aCAtIDFdLm5leHQpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdG9fZGVzdHJveVtpXTtcblxuXHRcdFx0aWYgKCFmYXN0X3BhdGgpIHtcblx0XHRcdFx0c3RhdGUuaXRlbXMuZGVsZXRlKGl0ZW0uayk7XG5cdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0ucHJldiwgaXRlbS5uZXh0KTtcblx0XHRcdH1cblxuXHRcdFx0ZGVzdHJveV9lZmZlY3QoaXRlbS5lLCAhZmFzdF9wYXRoKTtcblx0XHR9XG5cblx0XHRpZiAoc3RhdGUuZmlyc3QgPT09IHRvX2Rlc3Ryb3lbMF0pIHtcblx0XHRcdHN0YXRlLmZpcnN0ID0gdG9fZGVzdHJveVswXS5wcmV2O1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7RWxlbWVudCB8IENvbW1lbnR9IG5vZGUgVGhlIG5leHQgc2libGluZyBub2RlLCBvciB0aGUgcGFyZW50IG5vZGUgaWYgdGhpcyBpcyBhICdjb250cm9sbGVkJyBibG9ja1xuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEBwYXJhbSB7KHZhbHVlOiBWLCBpbmRleDogbnVtYmVyKSA9PiBhbnl9IGdldF9rZXlcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSwgaXRlbTogTWF5YmVTb3VyY2U8Vj4sIGluZGV4OiBNYXliZVNvdXJjZTxudW1iZXI+KSA9PiB2b2lkfSByZW5kZXJfZm5cbiAqIEBwYXJhbSB7bnVsbCB8ICgoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gZmFsbGJhY2tfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaChub2RlLCBmbGFncywgZ2V0X2NvbGxlY3Rpb24sIGdldF9rZXksIHJlbmRlcl9mbiwgZmFsbGJhY2tfZm4gPSBudWxsKSB7XG5cdHZhciBhbmNob3IgPSBub2RlO1xuXG5cdC8qKiBAdHlwZSB7TWFwPGFueSwgRWFjaEl0ZW0+fSAqL1xuXHR2YXIgaXRlbXMgPSBuZXcgTWFwKCk7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9ICovXG5cdHZhciBmaXJzdCA9IG51bGw7XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSAoZmxhZ3MgJiBFQUNIX0lTX0NPTlRST0xMRUQpICE9PSAwO1xuXHR2YXIgaXNfcmVhY3RpdmVfdmFsdWUgPSAoZmxhZ3MgJiBFQUNIX0lURU1fUkVBQ1RJVkUpICE9PSAwO1xuXHR2YXIgaXNfcmVhY3RpdmVfaW5kZXggPSAoZmxhZ3MgJiBFQUNIX0lOREVYX1JFQUNUSVZFKSAhPT0gMDtcblxuXHRpZiAoaXNfY29udHJvbGxlZCkge1xuXHRcdHZhciBwYXJlbnRfbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUpO1xuXG5cdFx0YW5jaG9yID0gaHlkcmF0aW5nXG5cdFx0XHQ/IHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtDb21tZW50IHwgVGV4dH0gKi8gKGdldF9maXJzdF9jaGlsZChwYXJlbnRfbm9kZSkpKVxuXHRcdFx0OiBwYXJlbnRfbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblx0fVxuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7eyBmcmFnbWVudDogRG9jdW1lbnRGcmFnbWVudCB8IG51bGwsIGVmZmVjdDogRWZmZWN0IH0gfCBudWxsfSAqL1xuXHR2YXIgZmFsbGJhY2sgPSBudWxsO1xuXG5cdC8vIFRPRE86IGlkZWFsbHkgd2UgY291bGQgdXNlIGRlcml2ZWQgZm9yIHJ1bmVzIG1vZGUgYnV0IGJlY2F1c2Ugb2YgdGhlIGFiaWxpdHlcblx0Ly8gdG8gdXNlIGEgc3RvcmUgd2hpY2ggY2FuIGJlIG11dGF0ZWQsIHdlIGNhbid0IGRvIHRoYXQgaGVyZSBhcyBtdXRhdGluZyBhIHN0b3JlXG5cdC8vIHdpbGwgc3RpbGwgcmVzdWx0IGluIHRoZSBjb2xsZWN0aW9uIGFycmF5IGJlaW5nIHRoZSBzYW1lIGZyb20gdGhlIHN0b3JlXG5cdHZhciBlYWNoX2FycmF5ID0gZGVyaXZlZF9zYWZlX2VxdWFsKCgpID0+IHtcblx0XHR2YXIgY29sbGVjdGlvbiA9IGdldF9jb2xsZWN0aW9uKCk7XG5cblx0XHRyZXR1cm4gaXNfYXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogY29sbGVjdGlvbiA9PSBudWxsID8gW10gOiBhcnJheV9mcm9tKGNvbGxlY3Rpb24pO1xuXHR9KTtcblxuXHQvKiogQHR5cGUge1ZbXX0gKi9cblx0dmFyIGFycmF5O1xuXG5cdHZhciBmaXJzdF9ydW4gPSB0cnVlO1xuXG5cdGZ1bmN0aW9uIGNvbW1pdCgpIHtcblx0XHRyZWNvbmNpbGUoc3RhdGUsIGFycmF5LCBhbmNob3IsIGZsYWdzLCBnZXRfa2V5KTtcblxuXHRcdGlmIChmYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoZmFsbGJhY2suZnJhZ21lbnQpIHtcblx0XHRcdFx0XHRhbmNob3IuYmVmb3JlKGZhbGxiYWNrLmZyYWdtZW50KTtcblx0XHRcdFx0XHRmYWxsYmFjay5mcmFnbWVudCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdW1lX2VmZmVjdChmYWxsYmFjay5lZmZlY3QpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWZmZWN0LmZpcnN0ID0gZmFsbGJhY2suZWZmZWN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KGZhbGxiYWNrLmVmZmVjdCwgKCkgPT4ge1xuXHRcdFx0XHRcdC8vIFRPRE8gb25seSBudWxsIG91dCBpZiBubyBwZW5kaW5nIGJhdGNoIG5lZWRzIGl0LFxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSByZS1hZGQgYGZhbGxiYWNrLmZyYWdtZW50YCBhbmQgbW92ZSB0aGVcblx0XHRcdFx0XHQvLyBlZmZlY3QgaW50byBpdFxuXHRcdFx0XHRcdGZhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGVmZmVjdCA9IGJsb2NrKCgpID0+IHtcblx0XHRhcnJheSA9IC8qKiBAdHlwZSB7VltdfSAqLyAoZ2V0KGVhY2hfYXJyYXkpKTtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG5cdFx0LyoqIGB0cnVlYCBpZiB0aGVyZSB3YXMgYSBoeWRyYXRpb24gbWlzbWF0Y2guIE5lZWRzIHRvIGJlIGEgYGxldGAgb3IgZWxzZSBpdCBpc24ndCB0cmVlc2hha2VuIG91dCAqL1xuXHRcdGxldCBtaXNtYXRjaCA9IGZhbHNlO1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0dmFyIGlzX2Vsc2UgPSByZWFkX2h5ZHJhdGlvbl9pbnN0cnVjdGlvbihhbmNob3IpID09PSBIWURSQVRJT05fU1RBUlRfRUxTRTtcblxuXHRcdFx0aWYgKGlzX2Vsc2UgIT09IChsZW5ndGggPT09IDApKSB7XG5cdFx0XHRcdC8vIGh5ZHJhdGlvbiBtaXNtYXRjaCBcdTIwMTQgcmVtb3ZlIHRoZSBzZXJ2ZXItcmVuZGVyZWQgRE9NIGFuZCBzdGFydCBvdmVyXG5cdFx0XHRcdGFuY2hvciA9IHNraXBfbm9kZXMoKTtcblxuXHRcdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGtleXMgPSBuZXcgU2V0KCk7XG5cdFx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXHRcdHZhciBwcmV2ID0gbnVsbDtcblx0XHR2YXIgZGVmZXIgPSBzaG91bGRfZGVmZXJfYXBwZW5kKCk7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGh5ZHJhdGluZyAmJlxuXHRcdFx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJlxuXHRcdFx0XHQvKiogQHR5cGUge0NvbW1lbnR9ICovIChoeWRyYXRlX25vZGUpLmRhdGEgPT09IEhZRFJBVElPTl9FTkRcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBUaGUgc2VydmVyIHJlbmRlcmVkIGZld2VyIGl0ZW1zIHRoYW4gZXhwZWN0ZWQsXG5cdFx0XHRcdC8vIHNvIGJyZWFrIG91dCBhbmQgY29udGludWUgYXBwZW5kaW5nIG5vbi1oeWRyYXRlZCBpdGVtc1xuXHRcdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdHZhciBrZXkgPSBnZXRfa2V5KHZhbHVlLCBpKTtcblxuXHRcdFx0dmFyIGl0ZW0gPSBmaXJzdF9ydW4gPyBudWxsIDogaXRlbXMuZ2V0KGtleSk7XG5cblx0XHRcdGlmIChpdGVtKSB7XG5cdFx0XHRcdC8vIHVwZGF0ZSBiZWZvcmUgcmVjb25jaWxpYXRpb24sIHRvIHRyaWdnZXIgYW55IGFzeW5jIHVwZGF0ZXNcblx0XHRcdFx0aWYgKGlzX3JlYWN0aXZlX3ZhbHVlKSB7XG5cdFx0XHRcdFx0aW50ZXJuYWxfc2V0KGl0ZW0udiwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzX3JlYWN0aXZlX2luZGV4KSB7XG5cdFx0XHRcdFx0aW50ZXJuYWxfc2V0KC8qKiBAdHlwZSB7VmFsdWU8bnVtYmVyPn0gKi8gKGl0ZW0uaSksIGkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGl0ZW0uaSA9IGk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZGVmZXIpIHtcblx0XHRcdFx0XHRiYXRjaC5za2lwcGVkX2VmZmVjdHMuZGVsZXRlKGl0ZW0uZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGl0ZW0gPSBjcmVhdGVfaXRlbShcblx0XHRcdFx0XHRmaXJzdF9ydW4gPyBhbmNob3IgOiBudWxsLFxuXHRcdFx0XHRcdHByZXYsXG5cdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0cmVuZGVyX2ZuLFxuXHRcdFx0XHRcdGZsYWdzLFxuXHRcdFx0XHRcdGdldF9jb2xsZWN0aW9uXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKGZpcnN0X3J1bikge1xuXHRcdFx0XHRcdGl0ZW0ubyA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBpdGVtO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwcmV2Lm5leHQgPSBpdGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHByZXYgPSBpdGVtO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aXRlbXMuc2V0KGtleSwgaXRlbSk7XG5cdFx0XHR9XG5cblx0XHRcdGtleXMuYWRkKGtleSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxlbmd0aCA9PT0gMCAmJiBmYWxsYmFja19mbiAmJiAhZmFsbGJhY2spIHtcblx0XHRcdGlmIChmaXJzdF9ydW4pIHtcblx0XHRcdFx0ZmFsbGJhY2sgPSB7XG5cdFx0XHRcdFx0ZnJhZ21lbnQ6IG51bGwsXG5cdFx0XHRcdFx0ZWZmZWN0OiBicmFuY2goKCkgPT4gZmFsbGJhY2tfZm4oYW5jaG9yKSlcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGNyZWF0ZV90ZXh0KCk7XG5cdFx0XHRcdGZyYWdtZW50LmFwcGVuZCh0YXJnZXQpO1xuXG5cdFx0XHRcdGZhbGxiYWNrID0ge1xuXHRcdFx0XHRcdGZyYWdtZW50LFxuXHRcdFx0XHRcdGVmZmVjdDogYnJhbmNoKCgpID0+IGZhbGxiYWNrX2ZuKHRhcmdldCkpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcmVtb3ZlIGV4Y2VzcyBub2Rlc1xuXHRcdGlmIChoeWRyYXRpbmcgJiYgbGVuZ3RoID4gMCkge1xuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShza2lwX25vZGVzKCkpO1xuXHRcdH1cblxuXHRcdGlmICghZmlyc3RfcnVuKSB7XG5cdFx0XHRpZiAoZGVmZXIpIHtcblx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBpdGVtcykge1xuXHRcdFx0XHRcdGlmICgha2V5cy5oYXMoa2V5KSkge1xuXHRcdFx0XHRcdFx0YmF0Y2guc2tpcHBlZF9lZmZlY3RzLmFkZChpdGVtLmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhdGNoLm9uY29tbWl0KGNvbW1pdCk7XG5cdFx0XHRcdGJhdGNoLm9uZGlzY2FyZCgoKSA9PiB7XG5cdFx0XHRcdFx0Ly8gVE9ETyBwcmVzdW1hYmx5IHdlIG5lZWQgdG8gZG8gc29tZXRoaW5nIGhlcmU/XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29tbWl0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1pc21hdGNoKSB7XG5cdFx0XHQvLyBjb250aW51ZSBpbiBoeWRyYXRpb24gbW9kZVxuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHdlIG1vdW50IHRoZSBlYWNoIGJsb2NrIGZvciB0aGUgZmlyc3QgdGltZSwgdGhlIGNvbGxlY3Rpb24gd29uJ3QgYmVcblx0XHQvLyBjb25uZWN0ZWQgdG8gdGhpcyBlZmZlY3QgYXMgdGhlIGVmZmVjdCBoYXNuJ3QgZmluaXNoZWQgcnVubmluZyB5ZXQgYW5kIGl0cyBkZXBzXG5cdFx0Ly8gd29uJ3QgYmUgYXNzaWduZWQuIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdGhhdCB3aGVuIHJlY29uY2lsaW5nIHRoZSBlYWNoIGJsb2NrXG5cdFx0Ly8gdGhhdCBhIG11dGF0aW9uIG9jY3VycmVkIGFuZCBpdCdzIG1hZGUgdGhlIGNvbGxlY3Rpb24gTUFZQkVfRElSVFksIHNvIHJlYWRpbmcgdGhlXG5cdFx0Ly8gY29sbGVjdGlvbiBhZ2FpbiBjYW4gcHJvdmlkZSBjb25zaXN0ZW5jeSB0byB0aGUgcmVhY3RpdmUgZ3JhcGggYWdhaW4gYXMgdGhlIGRlcml2ZWRzXG5cdFx0Ly8gd2lsbCBub3cgYmUgYENMRUFOYC5cblx0XHRnZXQoZWFjaF9hcnJheSk7XG5cdH0pO1xuXG5cdC8qKiBAdHlwZSB7RWFjaFN0YXRlfSAqL1xuXHR2YXIgc3RhdGUgPSB7IGVmZmVjdCwgZmxhZ3MsIGl0ZW1zLCBmaXJzdCB9O1xuXG5cdGZpcnN0X3J1biA9IGZhbHNlO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGQsIHJlbW92ZSwgb3IgcmVvcmRlciBpdGVtcyBvdXRwdXQgYnkgYW4gZWFjaCBibG9jayBhcyBpdHMgaW5wdXQgY2hhbmdlc1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtBcnJheTxWPn0gYXJyYXlcbiAqIEBwYXJhbSB7RWxlbWVudCB8IENvbW1lbnQgfCBUZXh0fSBhbmNob3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHsodmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IGFueX0gZ2V0X2tleVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJlY29uY2lsZShzdGF0ZSwgYXJyYXksIGFuY2hvciwgZmxhZ3MsIGdldF9rZXkpIHtcblx0dmFyIGlzX2FuaW1hdGVkID0gKGZsYWdzICYgRUFDSF9JU19BTklNQVRFRCkgIT09IDA7XG5cblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGl0ZW1zID0gc3RhdGUuaXRlbXM7XG5cdHZhciBjdXJyZW50ID0gc3RhdGUuZmlyc3Q7XG5cblx0LyoqIEB0eXBlIHt1bmRlZmluZWQgfCBTZXQ8RWFjaEl0ZW0+fSAqL1xuXHR2YXIgc2VlbjtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH0gKi9cblx0dmFyIHByZXYgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgU2V0PEVhY2hJdGVtPn0gKi9cblx0dmFyIHRvX2FuaW1hdGU7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbVtdfSAqL1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW1bXX0gKi9cblx0dmFyIHN0YXNoZWQgPSBbXTtcblxuXHQvKiogQHR5cGUge1Z9ICovXG5cdHZhciB2YWx1ZTtcblxuXHQvKiogQHR5cGUge2FueX0gKi9cblx0dmFyIGtleTtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgaXRlbTtcblxuXHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0dmFyIGk7XG5cblx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdFx0a2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cdFx0XHRpdGVtID0gLyoqIEB0eXBlIHtFYWNoSXRlbX0gKi8gKGl0ZW1zLmdldChrZXkpKTtcblxuXHRcdFx0Ly8gb2Zmc2NyZWVuID09IGNvbWluZyBpbiBub3csIG5vIGFuaW1hdGlvbiBpbiB0aGF0IGNhc2UsXG5cdFx0XHQvLyBlbHNlIHRoaXMgd291bGQgaGFwcGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzE3MTgxXG5cdFx0XHRpZiAoaXRlbS5vKSB7XG5cdFx0XHRcdGl0ZW0uYT8ubWVhc3VyZSgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5hZGQoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRrZXkgPSBnZXRfa2V5KHZhbHVlLCBpKTtcblxuXHRcdGl0ZW0gPSAvKiogQHR5cGUge0VhY2hJdGVtfSAqLyAoaXRlbXMuZ2V0KGtleSkpO1xuXG5cdFx0c3RhdGUuZmlyc3QgPz89IGl0ZW07XG5cblx0XHRpZiAoIWl0ZW0ubykge1xuXHRcdFx0aXRlbS5vID0gdHJ1ZTtcblxuXHRcdFx0dmFyIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0IDogY3VycmVudDtcblxuXHRcdFx0bGluayhzdGF0ZSwgcHJldiwgaXRlbSk7XG5cdFx0XHRsaW5rKHN0YXRlLCBpdGVtLCBuZXh0KTtcblxuXHRcdFx0bW92ZShpdGVtLCBuZXh0LCBhbmNob3IpO1xuXHRcdFx0cHJldiA9IGl0ZW07XG5cblx0XHRcdG1hdGNoZWQgPSBbXTtcblx0XHRcdHN0YXNoZWQgPSBbXTtcblxuXHRcdFx0Y3VycmVudCA9IHByZXYubmV4dDtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICgoaXRlbS5lLmYgJiBJTkVSVCkgIT09IDApIHtcblx0XHRcdHJlc3VtZV9lZmZlY3QoaXRlbS5lKTtcblx0XHRcdGlmIChpc19hbmltYXRlZCkge1xuXHRcdFx0XHRpdGVtLmE/LnVuZml4KCk7XG5cdFx0XHRcdCh0b19hbmltYXRlID8/PSBuZXcgU2V0KCkpLmRlbGV0ZShpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXRlbSAhPT0gY3VycmVudCkge1xuXHRcdFx0aWYgKHNlZW4gIT09IHVuZGVmaW5lZCAmJiBzZWVuLmhhcyhpdGVtKSkge1xuXHRcdFx0XHRpZiAobWF0Y2hlZC5sZW5ndGggPCBzdGFzaGVkLmxlbmd0aCkge1xuXHRcdFx0XHRcdC8vIG1vcmUgZWZmaWNpZW50IHRvIG1vdmUgbGF0ZXIgaXRlbXMgdG8gdGhlIGZyb250XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gc3Rhc2hlZFswXTtcblx0XHRcdFx0XHR2YXIgajtcblxuXHRcdFx0XHRcdHByZXYgPSBzdGFydC5wcmV2O1xuXG5cdFx0XHRcdFx0dmFyIGEgPSBtYXRjaGVkWzBdO1xuXHRcdFx0XHRcdHZhciBiID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdO1xuXG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1hdGNoZWQubGVuZ3RoOyBqICs9IDEpIHtcblx0XHRcdFx0XHRcdG1vdmUobWF0Y2hlZFtqXSwgc3RhcnQsIGFuY2hvcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IHN0YXNoZWQubGVuZ3RoOyBqICs9IDEpIHtcblx0XHRcdFx0XHRcdHNlZW4uZGVsZXRlKHN0YXNoZWRbal0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGEucHJldiwgYi5uZXh0KTtcblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBwcmV2LCBhKTtcblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBiLCBzdGFydCk7XG5cblx0XHRcdFx0XHRjdXJyZW50ID0gc3RhcnQ7XG5cdFx0XHRcdFx0cHJldiA9IGI7XG5cdFx0XHRcdFx0aSAtPSAxO1xuXG5cdFx0XHRcdFx0bWF0Y2hlZCA9IFtdO1xuXHRcdFx0XHRcdHN0YXNoZWQgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBtb3JlIGVmZmljaWVudCB0byBtb3ZlIGVhcmxpZXIgaXRlbXMgdG8gdGhlIGJhY2tcblx0XHRcdFx0XHRzZWVuLmRlbGV0ZShpdGVtKTtcblx0XHRcdFx0XHRtb3ZlKGl0ZW0sIGN1cnJlbnQsIGFuY2hvcik7XG5cblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBpdGVtLnByZXYsIGl0ZW0ubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbSwgcHJldiA9PT0gbnVsbCA/IHN0YXRlLmZpcnN0IDogcHJldi5uZXh0KTtcblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBwcmV2LCBpdGVtKTtcblxuXHRcdFx0XHRcdHByZXYgPSBpdGVtO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG1hdGNoZWQgPSBbXTtcblx0XHRcdHN0YXNoZWQgPSBbXTtcblxuXHRcdFx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5rICE9PSBrZXkpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIGVhY2ggYmxvY2sgaXNuJ3QgaW5lcnQgYW5kIGFuIGl0ZW0gaGFzIGFuIGVmZmVjdCB0aGF0IGlzIGFscmVhZHkgaW5lcnQsXG5cdFx0XHRcdC8vIHNraXAgb3ZlciBhZGRpbmcgaXQgdG8gb3VyIHNlZW4gU2V0IGFzIHRoZSBpdGVtIGlzIGFscmVhZHkgYmVpbmcgaGFuZGxlZFxuXHRcdFx0XHRpZiAoKGN1cnJlbnQuZS5mICYgSU5FUlQpID09PSAwKSB7XG5cdFx0XHRcdFx0KHNlZW4gPz89IG5ldyBTZXQoKSkuYWRkKGN1cnJlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXNoZWQucHVzaChjdXJyZW50KTtcblx0XHRcdFx0Y3VycmVudCA9IGN1cnJlbnQubmV4dDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGN1cnJlbnQgPT09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW0gPSBjdXJyZW50O1xuXHRcdH1cblxuXHRcdG1hdGNoZWQucHVzaChpdGVtKTtcblx0XHRwcmV2ID0gaXRlbTtcblx0XHRjdXJyZW50ID0gaXRlbS5uZXh0O1xuXHR9XG5cblx0bGV0IGhhc19vZmZzY3JlZW5faXRlbXMgPSBpdGVtcy5zaXplID4gbGVuZ3RoO1xuXG5cdGlmIChjdXJyZW50ICE9PSBudWxsIHx8IHNlZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciB0b19kZXN0cm95ID0gc2VlbiA9PT0gdW5kZWZpbmVkID8gW10gOiBhcnJheV9mcm9tKHNlZW4pO1xuXG5cdFx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0LCB0aGVuIGluZXJ0IGVmZmVjdHMgYXJlIGN1cnJlbnRseSBvdXRyb2luZyBhbmQgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHRyYW5zaXRpb24gaXMgZmluaXNoZWRcblx0XHRcdGlmICgoY3VycmVudC5lLmYgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdFx0dG9fZGVzdHJveS5wdXNoKGN1cnJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQubmV4dDtcblx0XHR9XG5cblx0XHR2YXIgZGVzdHJveV9sZW5ndGggPSB0b19kZXN0cm95Lmxlbmd0aDtcblxuXHRcdGhhc19vZmZzY3JlZW5faXRlbXMgPSBpdGVtcy5zaXplIC0gZGVzdHJveV9sZW5ndGggPiBsZW5ndGg7XG5cblx0XHRpZiAoZGVzdHJveV9sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgY29udHJvbGxlZF9hbmNob3IgPSAoZmxhZ3MgJiBFQUNIX0lTX0NPTlRST0xMRUQpICE9PSAwICYmIGxlbmd0aCA9PT0gMCA/IGFuY2hvciA6IG51bGw7XG5cblx0XHRcdGlmIChpc19hbmltYXRlZCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVzdHJveV9sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHRvX2Rlc3Ryb3lbaV0uYT8ubWVhc3VyZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRlc3Ryb3lfbGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0XHR0b19kZXN0cm95W2ldLmE/LmZpeCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHBhdXNlX2VmZmVjdHMoc3RhdGUsIHRvX2Rlc3Ryb3ksIGNvbnRyb2xsZWRfYW5jaG9yKTtcblx0XHR9XG5cdH1cblxuXHQvLyBBcHBlbmQgb2Zmc2NyZWVuIGl0ZW1zIGF0IHRoZSBlbmRcblx0aWYgKGhhc19vZmZzY3JlZW5faXRlbXMpIHtcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMudmFsdWVzKCkpIHtcblx0XHRcdGlmICghaXRlbS5vKSB7XG5cdFx0XHRcdGxpbmsoc3RhdGUsIHByZXYsIGl0ZW0pO1xuXHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRzdGF0ZS5lZmZlY3QubGFzdCA9IHByZXYgJiYgcHJldi5lO1xuXG5cdGlmIChpc19hbmltYXRlZCkge1xuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKHRvX2FuaW1hdGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdFx0Zm9yIChpdGVtIG9mIHRvX2FuaW1hdGUpIHtcblx0XHRcdFx0aXRlbS5hPy5hcHBseSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Tm9kZSB8IG51bGx9IGFuY2hvclxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IHByZXZcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7dW5rbm93bn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSwgaXRlbTogViB8IFNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFZhbHVlPG51bWJlcj4sIGNvbGxlY3Rpb246ICgpID0+IFZbXSkgPT4gdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHJldHVybnMge0VhY2hJdGVtfVxuICovXG5mdW5jdGlvbiBjcmVhdGVfaXRlbShhbmNob3IsIHByZXYsIHZhbHVlLCBrZXksIGluZGV4LCByZW5kZXJfZm4sIGZsYWdzLCBnZXRfY29sbGVjdGlvbikge1xuXHR2YXIgcHJldmlvdXNfZWFjaF9pdGVtID0gY3VycmVudF9lYWNoX2l0ZW07XG5cdHZhciByZWFjdGl2ZSA9IChmbGFncyAmIEVBQ0hfSVRFTV9SRUFDVElWRSkgIT09IDA7XG5cdHZhciBtdXRhYmxlID0gKGZsYWdzICYgRUFDSF9JVEVNX0lNTVVUQUJMRSkgPT09IDA7XG5cblx0dmFyIHYgPSByZWFjdGl2ZSA/IChtdXRhYmxlID8gbXV0YWJsZV9zb3VyY2UodmFsdWUsIGZhbHNlLCBmYWxzZSkgOiBzb3VyY2UodmFsdWUpKSA6IHZhbHVlO1xuXHR2YXIgaSA9IChmbGFncyAmIEVBQ0hfSU5ERVhfUkVBQ1RJVkUpID09PSAwID8gaW5kZXggOiBzb3VyY2UoaW5kZXgpO1xuXG5cdGlmIChERVYgJiYgcmVhY3RpdmUpIHtcblx0XHQvLyBGb3IgdHJhY2luZyBwdXJwb3Nlcywgd2UgbmVlZCB0byBsaW5rIHRoZSBzb3VyY2Ugc2lnbmFsIHdlIGNyZWF0ZSB3aXRoIHRoZVxuXHRcdC8vIGNvbGxlY3Rpb24gKyBpbmRleCBzbyB0aGF0IHRyYWNpbmcgd29ya3MgYXMgaW50ZW5kZWRcblx0XHQvKiogQHR5cGUge1ZhbHVlfSAqLyAodikudHJhY2UgPSAoKSA9PiB7XG5cdFx0XHR2YXIgY29sbGVjdGlvbl9pbmRleCA9IHR5cGVvZiBpID09PSAnbnVtYmVyJyA/IGluZGV4IDogaS52O1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdGdldF9jb2xsZWN0aW9uKClbY29sbGVjdGlvbl9pbmRleF07XG5cdFx0fTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW19ICovXG5cdHZhciBpdGVtID0ge1xuXHRcdGksXG5cdFx0dixcblx0XHRrOiBrZXksXG5cdFx0YTogbnVsbCxcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZTogbnVsbCxcblx0XHRvOiBmYWxzZSxcblx0XHRwcmV2LFxuXHRcdG5leHQ6IG51bGxcblx0fTtcblxuXHRjdXJyZW50X2VhY2hfaXRlbSA9IGl0ZW07XG5cblx0dHJ5IHtcblx0XHRpZiAoYW5jaG9yID09PSBudWxsKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmQoKGFuY2hvciA9IGNyZWF0ZV90ZXh0KCkpKTtcblx0XHR9XG5cblx0XHRpdGVtLmUgPSBicmFuY2goKCkgPT4gcmVuZGVyX2ZuKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGFuY2hvciksIHYsIGksIGdldF9jb2xsZWN0aW9uKSk7XG5cblx0XHRpZiAocHJldiAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gd2Ugb25seSBuZWVkIHRvIHNldCBgcHJldi5uZXh0ID0gaXRlbWAsIGJlY2F1c2Vcblx0XHRcdC8vIGBpdGVtLnByZXYgPSBwcmV2YCB3YXMgc2V0IG9uIGluaXRpYWxpemF0aW9uLlxuXHRcdFx0Ly8gdGhlIGVmZmVjdHMgdGhlbXNlbHZlcyBhcmUgYWxyZWFkeSBsaW5rZWRcblx0XHRcdHByZXYubmV4dCA9IGl0ZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0gZmluYWxseSB7XG5cdFx0Y3VycmVudF9lYWNoX2l0ZW0gPSBwcmV2aW91c19lYWNoX2l0ZW07XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VhY2hJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gbmV4dFxuICogQHBhcmFtIHtUZXh0IHwgRWxlbWVudCB8IENvbW1lbnR9IGFuY2hvclxuICovXG5mdW5jdGlvbiBtb3ZlKGl0ZW0sIG5leHQsIGFuY2hvcikge1xuXHR2YXIgZW5kID0gaXRlbS5uZXh0ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChpdGVtLm5leHQuZS5ub2Rlc19zdGFydCkgOiBhbmNob3I7XG5cblx0dmFyIGRlc3QgPSBuZXh0ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChuZXh0LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXHR2YXIgbm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaXRlbS5lLm5vZGVzX3N0YXJ0KTtcblxuXHR3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBub2RlICE9PSBlbmQpIHtcblx0XHR2YXIgbmV4dF9ub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblx0XHRkZXN0LmJlZm9yZShub2RlKTtcblx0XHRub2RlID0gbmV4dF9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqL1xuZnVuY3Rpb24gbGluayhzdGF0ZSwgcHJldiwgbmV4dCkge1xuXHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdHN0YXRlLmZpcnN0ID0gbmV4dDtcblx0XHRzdGF0ZS5lZmZlY3QuZmlyc3QgPSBuZXh0ICYmIG5leHQuZTtcblx0fSBlbHNlIHtcblx0XHRpZiAocHJldi5lLm5leHQpIHtcblx0XHRcdHByZXYuZS5uZXh0LnByZXYgPSBudWxsO1xuXHRcdH1cblxuXHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0cHJldi5lLm5leHQgPSBuZXh0ICYmIG5leHQuZTtcblx0fVxuXG5cdGlmIChuZXh0ICE9PSBudWxsKSB7XG5cdFx0aWYgKG5leHQuZS5wcmV2KSB7XG5cdFx0XHRuZXh0LmUucHJldi5uZXh0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdG5leHQuZS5wcmV2ID0gcHJldiAmJiBwcmV2LmU7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVNUUk9ZRUQsIFNUQUxFX1JFQUNUSU9OIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRjb21wb25lbnRfY29udGV4dCxcblx0ZGV2X3N0YWNrLFxuXHRpc19ydW5lcyxcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0LFxuXHRzZXRfZGV2X3N0YWNrXG59IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgZ2V0X2JvdW5kYXJ5IH0gZnJvbSAnLi4vZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcyc7XG5pbXBvcnQgeyBpbnZva2VfZXJyb3JfYm91bmRhcnkgfSBmcm9tICcuLi9lcnJvci1oYW5kbGluZy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGN1cnJlbnRfYmF0Y2ggfSBmcm9tICcuL2JhdGNoLmpzJztcbmltcG9ydCB7XG5cdGFzeW5jX2Rlcml2ZWQsXG5cdGN1cnJlbnRfYXN5bmNfZWZmZWN0LFxuXHRkZXJpdmVkLFxuXHRkZXJpdmVkX3NhZmVfZXF1YWwsXG5cdHNldF9mcm9tX2FzeW5jX2Rlcml2ZWRcbn0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5pbXBvcnQgeyBhYm9ydGVkIH0gZnJvbSAnLi9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlLCBza2lwX25vZGVzIH0gZnJvbSAnLi4vZG9tL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2VhY2hfaXRlbSwgc2V0X2N1cnJlbnRfZWFjaF9pdGVtIH0gZnJvbSAnLi4vZG9tL2Jsb2Nrcy9lYWNoLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U8dm9pZD4+fSBibG9ja2Vyc1xuICogQHBhcmFtIHtBcnJheTwoKSA9PiBhbnk+fSBzeW5jXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IFByb21pc2U8YW55Pj59IGFzeW5jXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFZhbHVlW10pID0+IGFueX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYmxvY2tlcnMsIHN5bmMsIGFzeW5jLCBmbikge1xuXHRjb25zdCBkID0gaXNfcnVuZXMoKSA/IGRlcml2ZWQgOiBkZXJpdmVkX3NhZmVfZXF1YWw7XG5cblx0aWYgKGFzeW5jLmxlbmd0aCA9PT0gMCAmJiBibG9ja2Vycy5sZW5ndGggPT09IDApIHtcblx0XHRmbihzeW5jLm1hcChkKSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGJhdGNoID0gY3VycmVudF9iYXRjaDtcblx0dmFyIHBhcmVudCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0dmFyIHJlc3RvcmUgPSBjYXB0dXJlKCk7XG5cblx0ZnVuY3Rpb24gcnVuKCkge1xuXHRcdFByb21pc2UuYWxsKGFzeW5jLm1hcCgoZXhwcmVzc2lvbikgPT4gYXN5bmNfZGVyaXZlZChleHByZXNzaW9uKSkpXG5cdFx0XHQudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRcdHJlc3RvcmUoKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZuKFsuLi5zeW5jLm1hcChkKSwgLi4ucmVzdWx0XSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gaWdub3JlIGVycm9ycyBpbiBibG9ja3MgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcblx0XHRcdFx0XHRpZiAoKHBhcmVudC5mICYgREVTVFJPWUVEKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBwYXJlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhdGNoPy5kZWFjdGl2YXRlKCk7XG5cdFx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PiB7XG5cdFx0XHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgcGFyZW50KTtcblx0XHRcdH0pO1xuXHR9XG5cblx0aWYgKGJsb2NrZXJzLmxlbmd0aCA+IDApIHtcblx0XHRQcm9taXNlLmFsbChibG9ja2VycykudGhlbigoKSA9PiB7XG5cdFx0XHRyZXN0b3JlKCk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBydW4oKTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGJhdGNoPy5kZWFjdGl2YXRlKCk7XG5cdFx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRydW4oKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZTx2b2lkPj59IGJsb2NrZXJzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFZhbHVlW10pID0+IGFueX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hZnRlcl9ibG9ja2VycyhibG9ja2VycywgZm4pIHtcblx0dmFyIGVhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtOyAvLyBUT0RPIHNob3VsZCB0aGlzIGJlIHBhcnQgb2YgY2FwdHVyZT9cblx0ZmxhdHRlbihibG9ja2VycywgW10sIFtdLCAodikgPT4ge1xuXHRcdHNldF9jdXJyZW50X2VhY2hfaXRlbShlYWNoX2l0ZW0pO1xuXHRcdGZuKHYpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgY3VycmVudCBlZmZlY3QgY29udGV4dCBzbyB0aGF0IHdlIGNhbiByZXN0b3JlIGl0IGFmdGVyXG4gKiBzb21lIGFzeW5jaHJvbm91cyB3b3JrIGhhcyBoYXBwZW5lZCAoc28gdGhhdCBlLmcuIGBhd2FpdCBhICsgYmBcbiAqIGNhdXNlcyBgYmAgdG8gYmUgcmVnaXN0ZXJlZCBhcyBhIGRlcGVuZGVuY3kpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZSgpIHtcblx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0dmFyIHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdHZhciBwcmV2aW91c19iYXRjaCA9IGN1cnJlbnRfYmF0Y2g7XG5cblx0aWYgKERFVikge1xuXHRcdHZhciBwcmV2aW91c19kZXZfc3RhY2sgPSBkZXZfc3RhY2s7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gcmVzdG9yZShhY3RpdmF0ZV9iYXRjaCA9IHRydWUpIHtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdHNldF9jb21wb25lbnRfY29udGV4dChwcmV2aW91c19jb21wb25lbnRfY29udGV4dCk7XG5cdFx0aWYgKGFjdGl2YXRlX2JhdGNoKSBwcmV2aW91c19iYXRjaD8uYWN0aXZhdGUoKTtcblxuXHRcdGlmIChERVYpIHtcblx0XHRcdHNldF9mcm9tX2FzeW5jX2Rlcml2ZWQobnVsbCk7XG5cdFx0XHRzZXRfZGV2X3N0YWNrKHByZXZpb3VzX2Rldl9zdGFjayk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFdyYXBzIGFuIGBhd2FpdGAgZXhwcmVzc2lvbiBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGVmZmVjdCBjb250ZXh0IHRoYXQgd2FzXG4gKiBhY3RpdmUgYmVmb3JlIHRoZSBleHByZXNzaW9uIGV2YWx1YXRlZCBjYW4gYmUgcmVhcHBsaWVkIGFmdGVyd2FyZHMgXHUyMDE0XG4gKiBgYXdhaXQgYSArIGJgIGJlY29tZXMgYChhd2FpdCAkLnNhdmUoYSkpKCkgKyBiYFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UHJvbWlzZTxUPn0gcHJvbWlzZVxuICogQHJldHVybnMge1Byb21pc2U8KCkgPT4gVD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlKHByb21pc2UpIHtcblx0dmFyIHJlc3RvcmUgPSBjYXB0dXJlKCk7XG5cdHZhciB2YWx1ZSA9IGF3YWl0IHByb21pc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRyZXN0b3JlKCk7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJlc2V0IGBjdXJyZW50X2FzeW5jX2VmZmVjdGAgYWZ0ZXIgdGhlIGBwcm9taXNlYCByZXNvbHZlcywgc29cbiAqIHRoYXQgd2UgY2FuIGVtaXQgYGF3YWl0X3JlYWN0aXZpdHlfbG9zc2Agd2FybmluZ3NcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1Byb21pc2U8VD59IHByb21pc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPCgpID0+IFQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhY2tfcmVhY3Rpdml0eV9sb3NzKHByb21pc2UpIHtcblx0dmFyIHByZXZpb3VzX2FzeW5jX2VmZmVjdCA9IGN1cnJlbnRfYXN5bmNfZWZmZWN0O1xuXHR2YXIgdmFsdWUgPSBhd2FpdCBwcm9taXNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0c2V0X2Zyb21fYXN5bmNfZGVyaXZlZChwcmV2aW91c19hc3luY19lZmZlY3QpO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBVc2VkIGluIGBmb3IgYXdhaXRgIGxvb3BzIGluIERFViwgc29cbiAqIHRoYXQgd2UgY2FuIGVtaXQgYGF3YWl0X3JlYWN0aXZpdHlfbG9zc2Agd2FybmluZ3NcbiAqIGFmdGVyIGVhY2ggYGFzeW5jX2l0ZXJhdG9yYCByZXN1bHQgcmVzb2x2ZXMgYW5kXG4gKiBhZnRlciB0aGUgYGFzeW5jX2l0ZXJhdG9yYCByZXR1cm4gcmVzb2x2ZXMgKGlmIGl0IHJ1bnMpXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFRSZXR1cm5cbiAqIEBwYXJhbSB7SXRlcmFibGU8VD4gfCBBc3luY0l0ZXJhYmxlPFQ+fSBpdGVyYWJsZVxuICogQHJldHVybnMge0FzeW5jR2VuZXJhdG9yPFQsIFRSZXR1cm4gfCB1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGZvcl9hd2FpdF90cmFja19yZWFjdGl2aXR5X2xvc3MoaXRlcmFibGUpIHtcblx0Ly8gVGhpcyBpcyBiYXNlZCBvbiB0aGUgYWxnb3JpdGhtcyBkZXNjcmliZWQgaW4gRUNNQS0yNjI6XG5cdC8vIEZvckluL09mQm9keUV2YWx1YXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvbXVsdGlwYWdlL2VjbWFzY3JpcHQtbGFuZ3VhZ2Utc3RhdGVtZW50cy1hbmQtZGVjbGFyYXRpb25zLmh0bWwjc2VjLXJ1bnRpbWUtc2VtYW50aWNzLWZvcmluLWRpdi1vZmJvZHlldmFsdWF0aW9uLWxocy1zdG10LWl0ZXJhdG9yLWxoc2tpbmQtbGFiZWxzZXRcblx0Ly8gQXN5bmNJdGVyYXRvckNsb3NlXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyL211bHRpcGFnZS9hYnN0cmFjdC1vcGVyYXRpb25zLmh0bWwjc2VjLWFzeW5jaXRlcmF0b3JjbG9zZVxuXG5cdC8qKiBAdHlwZSB7QXN5bmNJdGVyYXRvcjxULCBUUmV0dXJuPn0gKi9cblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXT8uKCkgPz8gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXT8uKCk7XG5cblx0aWYgKGl0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBub3QgYXN5bmMgaXRlcmFibGUnKTtcblx0fVxuXG5cdC8qKiBXaGV0aGVyIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBpdGVyYXRvciB3YXMgXCJub3JtYWxcIiwgbWVhbmluZyBpdCB3YXNuJ3QgZW5kZWQgdmlhIGBicmVha2Agb3IgYSBzaW1pbGFyIG1ldGhvZCAqL1xuXHRsZXQgbm9ybWFsX2NvbXBsZXRpb24gPSBmYWxzZTtcblx0dHJ5IHtcblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gKGF3YWl0IHRyYWNrX3JlYWN0aXZpdHlfbG9zcyhpdGVyYXRvci5uZXh0KCkpKSgpO1xuXHRcdFx0aWYgKGRvbmUpIHtcblx0XHRcdFx0bm9ybWFsX2NvbXBsZXRpb24gPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHlpZWxkIHZhbHVlO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHQvLyBJZiB0aGUgaXRlcmF0b3IgaGFkIGEgbm9ybWFsIGNvbXBsZXRpb24gYW5kIGByZXR1cm5gIGlzIGRlZmluZWQgb24gdGhlIGl0ZXJhdG9yLCBjYWxsIGl0IGFuZCByZXR1cm4gdGhlIHZhbHVlXG5cdFx0aWYgKG5vcm1hbF9jb21wbGV0aW9uICYmIGl0ZXJhdG9yLnJldHVybiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5zYWZlLWZpbmFsbHlcblx0XHRcdHJldHVybiAvKiogQHR5cGUge1RSZXR1cm59ICovICgoYXdhaXQgdHJhY2tfcmVhY3Rpdml0eV9sb3NzKGl0ZXJhdG9yLnJldHVybigpKSkoKS52YWx1ZSk7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNldF9jb250ZXh0KCkge1xuXHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0KG51bGwpO1xuXG5cdGlmIChERVYpIHtcblx0XHRzZXRfZnJvbV9hc3luY19kZXJpdmVkKG51bGwpO1xuXHRcdHNldF9kZXZfc3RhY2sobnVsbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gYW5jaG9yXG4gKiBAcGFyYW0geyh0YXJnZXQ6IFRlbXBsYXRlTm9kZSkgPT4gUHJvbWlzZTx2b2lkPn0gZm5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jX2JvZHkoYW5jaG9yLCBmbikge1xuXHR2YXIgYm91bmRhcnkgPSBnZXRfYm91bmRhcnkoKTtcblx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXHR2YXIgYmxvY2tpbmcgPSAhYm91bmRhcnkuaXNfcGVuZGluZygpO1xuXG5cdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KDEpO1xuXHRiYXRjaC5pbmNyZW1lbnQoYmxvY2tpbmcpO1xuXG5cdHZhciBhY3RpdmUgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdHZhciB3YXNfaHlkcmF0aW5nID0gaHlkcmF0aW5nO1xuXHR2YXIgbmV4dF9oeWRyYXRlX25vZGUgPSB1bmRlZmluZWQ7XG5cblx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0XHRuZXh0X2h5ZHJhdGVfbm9kZSA9IHNraXBfbm9kZXMoZmFsc2UpO1xuXHR9XG5cblx0dHJ5IHtcblx0XHR2YXIgcHJvbWlzZSA9IGZuKGFuY2hvcik7XG5cdH0gZmluYWxseSB7XG5cdFx0aWYgKG5leHRfaHlkcmF0ZV9ub2RlKSB7XG5cdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKG5leHRfaHlkcmF0ZV9ub2RlKTtcblx0XHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdH1cblx0fVxuXG5cdHRyeSB7XG5cdFx0YXdhaXQgcHJvbWlzZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRpZiAoIWFib3J0ZWQoYWN0aXZlKSkge1xuXHRcdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBhY3RpdmUpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRib3VuZGFyeS51cGRhdGVfcGVuZGluZ19jb3VudCgtMSk7XG5cdFx0YmF0Y2guZGVjcmVtZW50KGJsb2NraW5nKTtcblxuXHRcdHVuc2V0X2NvbnRleHQoKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4+fSB0aHVua3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bih0aHVua3MpIHtcblx0Y29uc3QgcmVzdG9yZSA9IGNhcHR1cmUoKTtcblxuXHR2YXIgYm91bmRhcnkgPSBnZXRfYm91bmRhcnkoKTtcblx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXHR2YXIgYmxvY2tpbmcgPSAhYm91bmRhcnkuaXNfcGVuZGluZygpO1xuXG5cdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KDEpO1xuXHRiYXRjaC5pbmNyZW1lbnQoYmxvY2tpbmcpO1xuXG5cdHZhciBhY3RpdmUgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IHsgZXJyb3I6IGFueSB9fSAqL1xuXHR2YXIgZXJyb3JlZCA9IG51bGw7XG5cblx0LyoqIEBwYXJhbSB7YW55fSBlcnJvciAqL1xuXHRjb25zdCBoYW5kbGVfZXJyb3IgPSAoZXJyb3IpID0+IHtcblx0XHRlcnJvcmVkID0geyBlcnJvciB9OyAvLyB3cmFwIGluIG9iamVjdCBpbiBjYXNlIGEgcHJvbWlzZSByZWplY3RzIHdpdGggYSBmYWxzeSB2YWx1ZVxuXG5cdFx0aWYgKCFhYm9ydGVkKGFjdGl2ZSkpIHtcblx0XHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgYWN0aXZlKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGh1bmtzWzBdKCkpLmNhdGNoKGhhbmRsZV9lcnJvcik7XG5cblx0dmFyIHByb21pc2VzID0gW3Byb21pc2VdO1xuXG5cdGZvciAoY29uc3QgZm4gb2YgdGh1bmtzLnNsaWNlKDEpKSB7XG5cdFx0cHJvbWlzZSA9IHByb21pc2Vcblx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0aWYgKGVycm9yZWQpIHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcmVkLmVycm9yO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFib3J0ZWQoYWN0aXZlKSkge1xuXHRcdFx0XHRcdHRocm93IFNUQUxFX1JFQUNUSU9OO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXN0b3JlKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZuKCk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0Ly8gVE9ETyBkbyB3ZSBuZWVkIGl0IGhlcmUgYXMgd2VsbCBhcyBiZWxvdz9cblx0XHRcdFx0XHR1bnNldF9jb250ZXh0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goaGFuZGxlX2Vycm9yKVxuXHRcdFx0LmZpbmFsbHkoKCkgPT4ge1xuXHRcdFx0XHR1bnNldF9jb250ZXh0KCk7XG5cdFx0XHR9KTtcblxuXHRcdHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cdH1cblxuXHRwcm9taXNlXG5cdFx0Ly8gd2FpdCBvbmUgbW9yZSB0aWNrLCBzbyB0aGF0IHRlbXBsYXRlIGVmZmVjdHMgYXJlXG5cdFx0Ly8gZ3VhcmFudGVlZCB0byBydW4gYmVmb3JlIGAkZWZmZWN0KC4uLilgXG5cdFx0LnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpXG5cdFx0LmZpbmFsbHkoKCkgPT4ge1xuXHRcdFx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoLTEpO1xuXHRcdFx0YmF0Y2guZGVjcmVtZW50KGJsb2NraW5nKTtcblx0XHR9KTtcblxuXHRyZXR1cm4gcHJvbWlzZXM7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFNvdXJjZSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEJhdGNoIH0gZnJvbSAnLi9iYXRjaC5qcyc7ICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7XG5cdEVSUk9SX1ZBTFVFLFxuXHRDTEVBTixcblx0REVSSVZFRCxcblx0RElSVFksXG5cdEVGRkVDVF9QUkVTRVJWRUQsXG5cdE1BWUJFX0RJUlRZLFxuXHRTVEFMRV9SRUFDVElPTixcblx0QVNZTkMsXG5cdFdBU19NQVJLRUQsXG5cdENPTk5FQ1RFRCxcblx0REVTVFJPWUVEXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0YWN0aXZlX2VmZmVjdCxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVwZGF0ZV9yZWFjdGlvbixcblx0aW5jcmVtZW50X3dyaXRlX3ZlcnNpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRwdXNoX3JlYWN0aW9uX3ZhbHVlLFxuXHRpc19kZXN0cm95aW5nX2VmZmVjdFxufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGVxdWFscywgc2FmZV9lcXVhbHMgfSBmcm9tICcuL2VxdWFsaXR5LmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgYXN5bmNfZWZmZWN0LCBkZXN0cm95X2VmZmVjdCwgZWZmZWN0X3RyYWNraW5nLCB0ZWFyZG93biB9IGZyb20gJy4vZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBlYWdlcl9lZmZlY3RzLCBpbnRlcm5hbF9zZXQsIHNldF9lYWdlcl9lZmZlY3RzLCBzb3VyY2UgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZ2V0X2Vycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Rldi5qcyc7XG5pbXBvcnQgeyBhc3luY19tb2RlX2ZsYWcsIHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgQm91bmRhcnkgfSBmcm9tICcuLi9kb20vYmxvY2tzL2JvdW5kYXJ5LmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJhdGNoX3ZhbHVlcywgY3VycmVudF9iYXRjaCB9IGZyb20gJy4vYmF0Y2guanMnO1xuaW1wb3J0IHsgdW5zZXRfY29udGV4dCB9IGZyb20gJy4vYXN5bmMuanMnO1xuaW1wb3J0IHsgZGVmZXJyZWQgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5leHBvcnQgbGV0IGN1cnJlbnRfYXN5bmNfZWZmZWN0ID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7RWZmZWN0IHwgbnVsbH0gdiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9mcm9tX2FzeW5jX2Rlcml2ZWQodikge1xuXHRjdXJyZW50X2FzeW5jX2VmZmVjdCA9IHY7XG59XG5cbmV4cG9ydCBjb25zdCByZWNlbnRfYXN5bmNfZGVyaXZlZHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZm5cbiAqIEByZXR1cm5zIHtEZXJpdmVkPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKGZuKSB7XG5cdHZhciBmbGFncyA9IERFUklWRUQgfCBESVJUWTtcblx0dmFyIHBhcmVudF9kZXJpdmVkID1cblx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDBcblx0XHRcdD8gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKVxuXHRcdFx0OiBudWxsO1xuXG5cdGlmIChhY3RpdmVfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0Ly8gU2luY2UgZGVyaXZlZHMgYXJlIGV2YWx1YXRlZCBsYXppbHksIGFueSBlZmZlY3RzIGNyZWF0ZWQgaW5zaWRlIHRoZW0gYXJlXG5cdFx0Ly8gY3JlYXRlZCB0b28gbGF0ZSB0byBlbnN1cmUgdGhhdCB0aGUgcGFyZW50IGVmZmVjdCBpcyBhZGRlZCB0byB0aGUgdHJlZVxuXHRcdGFjdGl2ZV9lZmZlY3QuZiB8PSBFRkZFQ1RfUFJFU0VSVkVEO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtEZXJpdmVkPFY+fSAqL1xuXHRjb25zdCBzaWduYWwgPSB7XG5cdFx0Y3R4OiBjb21wb25lbnRfY29udGV4dCxcblx0XHRkZXBzOiBudWxsLFxuXHRcdGVmZmVjdHM6IG51bGwsXG5cdFx0ZXF1YWxzLFxuXHRcdGY6IGZsYWdzLFxuXHRcdGZuLFxuXHRcdHJlYWN0aW9uczogbnVsbCxcblx0XHRydjogMCxcblx0XHR2OiAvKiogQHR5cGUge1Z9ICovIChVTklOSVRJQUxJWkVEKSxcblx0XHR3djogMCxcblx0XHRwYXJlbnQ6IHBhcmVudF9kZXJpdmVkID8/IGFjdGl2ZV9lZmZlY3QsXG5cdFx0YWM6IG51bGxcblx0fTtcblxuXHRpZiAoREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnKSB7XG5cdFx0c2lnbmFsLmNyZWF0ZWQgPSBnZXRfZXJyb3IoJ2NyZWF0ZWQgYXQnKTtcblx0fVxuXG5cdHJldHVybiBzaWduYWw7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gViB8IFByb21pc2U8Vj59IGZuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xvY2F0aW9uXSBJZiBwcm92aWRlZCwgcHJpbnQgYSB3YXJuaW5nIGlmIHRoZSB2YWx1ZSBpcyBub3QgcmVhZCBpbW1lZGlhdGVseSBhZnRlciB1cGRhdGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNvdXJjZTxWPj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jX2Rlcml2ZWQoZm4sIGxvY2F0aW9uKSB7XG5cdGxldCBwYXJlbnQgPSAvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHRpZiAocGFyZW50ID09PSBudWxsKSB7XG5cdFx0ZS5hc3luY19kZXJpdmVkX29ycGhhbigpO1xuXHR9XG5cblx0dmFyIGJvdW5kYXJ5ID0gLyoqIEB0eXBlIHtCb3VuZGFyeX0gKi8gKHBhcmVudC5iKTtcblxuXHR2YXIgcHJvbWlzZSA9IC8qKiBAdHlwZSB7UHJvbWlzZTxWPn0gKi8gKC8qKiBAdHlwZSB7dW5rbm93bn0gKi8gKHVuZGVmaW5lZCkpO1xuXHR2YXIgc2lnbmFsID0gc291cmNlKC8qKiBAdHlwZSB7Vn0gKi8gKFVOSU5JVElBTElaRUQpKTtcblxuXHQvLyBvbmx5IHN1c3BlbmQgaW4gYXN5bmMgZGVyaXZlZHMgY3JlYXRlZCBvbiBpbml0aWFsaXNhdGlvblxuXHR2YXIgc2hvdWxkX3N1c3BlbmQgPSAhYWN0aXZlX3JlYWN0aW9uO1xuXG5cdC8qKiBAdHlwZSB7TWFwPEJhdGNoLCBSZXR1cm5UeXBlPHR5cGVvZiBkZWZlcnJlZDxWPj4+fSAqL1xuXHR2YXIgZGVmZXJyZWRzID0gbmV3IE1hcCgpO1xuXG5cdGFzeW5jX2VmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKERFVikgY3VycmVudF9hc3luY19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdFx0LyoqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBkZWZlcnJlZDxWPj59ICovXG5cdFx0dmFyIGQgPSBkZWZlcnJlZCgpO1xuXHRcdHByb21pc2UgPSBkLnByb21pc2U7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gSWYgdGhpcyBjb2RlIGlzIGNoYW5nZWQgYXQgc29tZSBwb2ludCwgbWFrZSBzdXJlIHRvIHN0aWxsIGFjY2VzcyB0aGUgdGhlbiBwcm9wZXJ0eVxuXHRcdFx0Ly8gb2YgZm4oKSB0byByZWFkIGFueSBzaWduYWxzIGl0IG1pZ2h0IGFjY2Vzcywgc28gdGhhdCB3ZSB0cmFjayB0aGVtIGFzIGRlcGVuZGVuY2llcy5cblx0XHRcdC8vIFdlIGNhbGwgYHVuc2V0X2NvbnRleHRgIHRvIHVuZG8gYW55IGBzYXZlYCBjYWxscyB0aGF0IGhhcHBlbiBpbnNpZGUgYGZuKClgXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoZm4oKSlcblx0XHRcdFx0LnRoZW4oZC5yZXNvbHZlLCBkLnJlamVjdClcblx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdGlmIChiYXRjaCA9PT0gY3VycmVudF9iYXRjaCAmJiBiYXRjaC5jb21taXR0ZWQpIHtcblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBiYXRjaCB3YXMgcmVqZWN0ZWQgYXMgc3RhbGUsIHdlIG5lZWQgdG8gY2xlYW51cFxuXHRcdFx0XHRcdFx0Ly8gYWZ0ZXIgYW55IGAkLnNhdmUoLi4uKWAgY2FsbHMgaW5zaWRlIGBmbigpYFxuXHRcdFx0XHRcdFx0YmF0Y2guZGVhY3RpdmF0ZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGQucmVqZWN0KGVycm9yKTtcblx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHR9XG5cblx0XHRpZiAoREVWKSBjdXJyZW50X2FzeW5jX2VmZmVjdCA9IG51bGw7XG5cblx0XHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAoY3VycmVudF9iYXRjaCk7XG5cblx0XHRpZiAoc2hvdWxkX3N1c3BlbmQpIHtcblx0XHRcdHZhciBibG9ja2luZyA9ICFib3VuZGFyeS5pc19wZW5kaW5nKCk7XG5cblx0XHRcdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KDEpO1xuXHRcdFx0YmF0Y2guaW5jcmVtZW50KGJsb2NraW5nKTtcblxuXHRcdFx0ZGVmZXJyZWRzLmdldChiYXRjaCk/LnJlamVjdChTVEFMRV9SRUFDVElPTik7XG5cdFx0XHRkZWZlcnJlZHMuZGVsZXRlKGJhdGNoKTsgLy8gZGVsZXRlIHRvIGVuc3VyZSBjb3JyZWN0IG9yZGVyIGluIE1hcCBpdGVyYXRpb24gYmVsb3dcblx0XHRcdGRlZmVycmVkcy5zZXQoYmF0Y2gsIGQpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3Jcblx0XHQgKi9cblx0XHRjb25zdCBoYW5kbGVyID0gKHZhbHVlLCBlcnJvciA9IHVuZGVmaW5lZCkgPT4ge1xuXHRcdFx0Y3VycmVudF9hc3luY19lZmZlY3QgPSBudWxsO1xuXG5cdFx0XHRiYXRjaC5hY3RpdmF0ZSgpO1xuXG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yICE9PSBTVEFMRV9SRUFDVElPTikge1xuXHRcdFx0XHRcdHNpZ25hbC5mIHw9IEVSUk9SX1ZBTFVFO1xuXG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgZXJyb3IgaXMgdGhlIHdyb25nIHR5cGUsIGJ1dCB3ZSBkb24ndCBjYXJlXG5cdFx0XHRcdFx0aW50ZXJuYWxfc2V0KHNpZ25hbCwgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoKHNpZ25hbC5mICYgRVJST1JfVkFMVUUpICE9PSAwKSB7XG5cdFx0XHRcdFx0c2lnbmFsLmYgXj0gRVJST1JfVkFMVUU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbnRlcm5hbF9zZXQoc2lnbmFsLCB2YWx1ZSk7XG5cblx0XHRcdFx0Ly8gQWxsIHByaW9yIGFzeW5jIGRlcml2ZWQgcnVucyBhcmUgbm93IHN0YWxlXG5cdFx0XHRcdGZvciAoY29uc3QgW2IsIGRdIG9mIGRlZmVycmVkcykge1xuXHRcdFx0XHRcdGRlZmVycmVkcy5kZWxldGUoYik7XG5cdFx0XHRcdFx0aWYgKGIgPT09IGJhdGNoKSBicmVhaztcblx0XHRcdFx0XHRkLnJlamVjdChTVEFMRV9SRUFDVElPTik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoREVWICYmIGxvY2F0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZWNlbnRfYXN5bmNfZGVyaXZlZHMuYWRkKHNpZ25hbCk7XG5cblx0XHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRcdGlmIChyZWNlbnRfYXN5bmNfZGVyaXZlZHMuaGFzKHNpZ25hbCkpIHtcblx0XHRcdFx0XHRcdFx0dy5hd2FpdF93YXRlcmZhbGwoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChzaWduYWwubGFiZWwpLCBsb2NhdGlvbik7XG5cdFx0XHRcdFx0XHRcdHJlY2VudF9hc3luY19kZXJpdmVkcy5kZWxldGUoc2lnbmFsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2hvdWxkX3N1c3BlbmQpIHtcblx0XHRcdFx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoLTEpO1xuXHRcdFx0XHRiYXRjaC5kZWNyZW1lbnQoYmxvY2tpbmcpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRkLnByb21pc2UudGhlbihoYW5kbGVyLCAoZSkgPT4gaGFuZGxlcihudWxsLCBlIHx8ICd1bmtub3duJykpO1xuXHR9KTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0Zm9yIChjb25zdCBkIG9mIGRlZmVycmVkcy52YWx1ZXMoKSkge1xuXHRcdFx0ZC5yZWplY3QoU1RBTEVfUkVBQ1RJT04pO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKERFVikge1xuXHRcdC8vIGFkZCBhIGZsYWcgdGhhdCBsZXRzIHRoaXMgYmUgcHJpbnRlZCBhcyBhIGRlcml2ZWRcblx0XHQvLyB3aGVuIHVzaW5nIGAkaW5zcGVjdC50cmFjZSgpYFxuXHRcdHNpZ25hbC5mIHw9IEFTWU5DO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWwpID0+IHtcblx0XHQvKiogQHBhcmFtIHtQcm9taXNlPFY+fSBwICovXG5cdFx0ZnVuY3Rpb24gbmV4dChwKSB7XG5cdFx0XHRmdW5jdGlvbiBnbygpIHtcblx0XHRcdFx0aWYgKHAgPT09IHByb21pc2UpIHtcblx0XHRcdFx0XHRmdWxmaWwoc2lnbmFsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBpZiB0aGUgZWZmZWN0IHJlLXJ1bnMgYmVmb3JlIHRoZSBpbml0aWFsIHByb21pc2Vcblx0XHRcdFx0XHQvLyByZXNvbHZlcywgZGVsYXkgcmVzb2x1dGlvbiB1bnRpbCB3ZSBoYXZlIGEgdmFsdWVcblx0XHRcdFx0XHRuZXh0KHByb21pc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHAudGhlbihnbywgZ28pO1xuXHRcdH1cblxuXHRcdG5leHQocHJvbWlzZSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0geygpID0+IFZ9IGZuXG4gKiBAcmV0dXJucyB7RGVyaXZlZDxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gdXNlcl9kZXJpdmVkKGZuKSB7XG5cdGNvbnN0IGQgPSBkZXJpdmVkKGZuKTtcblxuXHRpZiAoIWFzeW5jX21vZGVfZmxhZykgcHVzaF9yZWFjdGlvbl92YWx1ZShkKTtcblxuXHRyZXR1cm4gZDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWfSBmblxuICogQHJldHVybnMge0Rlcml2ZWQ8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRfc2FmZV9lcXVhbChmbikge1xuXHRjb25zdCBzaWduYWwgPSBkZXJpdmVkKGZuKTtcblx0c2lnbmFsLmVxdWFscyA9IHNhZmVfZXF1YWxzO1xuXHRyZXR1cm4gc2lnbmFsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyhkZXJpdmVkKSB7XG5cdHZhciBlZmZlY3RzID0gZGVyaXZlZC5lZmZlY3RzO1xuXG5cdGlmIChlZmZlY3RzICE9PSBudWxsKSB7XG5cdFx0ZGVyaXZlZC5lZmZlY3RzID0gbnVsbDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChlZmZlY3RzW2ldKSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSB1cGRhdGluZyBkZXJpdmVkcywgdXNlZCB0byBkZXRlY3QgaW5maW5pdGUgcmVjdXJzaW9uXG4gKiBpbiBkZXYgbW9kZSBhbmQgcHJvdmlkZSBhIG5pY2VyIGVycm9yIHRoYW4gJ3RvbyBtdWNoIHJlY3Vyc2lvbidcbiAqIEB0eXBlIHtEZXJpdmVkW119XG4gKi9cbmxldCBzdGFjayA9IFtdO1xuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge0VmZmVjdCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldF9kZXJpdmVkX3BhcmVudF9lZmZlY3QoZGVyaXZlZCkge1xuXHR2YXIgcGFyZW50ID0gZGVyaXZlZC5wYXJlbnQ7XG5cdHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRpZiAoKHBhcmVudC5mICYgREVSSVZFRCkgPT09IDApIHtcblx0XHRcdC8vIFRoZSBvcmlnaW5hbCBwYXJlbnQgZWZmZWN0IG1pZ2h0J3ZlIGJlZW4gZGVzdHJveWVkIGJ1dCB0aGUgZGVyaXZlZFxuXHRcdFx0Ly8gaXMgdXNlZCBlbHNld2hlcmUgbm93IC0gZG8gbm90IHJldHVybiB0aGUgZGVzdHJveWVkIGVmZmVjdCBpbiB0aGF0IGNhc2Vcblx0XHRcdHJldHVybiAocGFyZW50LmYgJiBERVNUUk9ZRUQpID09PSAwID8gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChwYXJlbnQpIDogbnVsbDtcblx0XHR9XG5cdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVfZGVyaXZlZChkZXJpdmVkKSB7XG5cdHZhciB2YWx1ZTtcblx0dmFyIHByZXZfYWN0aXZlX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0c2V0X2FjdGl2ZV9lZmZlY3QoZ2V0X2Rlcml2ZWRfcGFyZW50X2VmZmVjdChkZXJpdmVkKSk7XG5cblx0aWYgKERFVikge1xuXHRcdGxldCBwcmV2X2VhZ2VyX2VmZmVjdHMgPSBlYWdlcl9lZmZlY3RzO1xuXHRcdHNldF9lYWdlcl9lZmZlY3RzKG5ldyBTZXQoKSk7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChzdGFjay5pbmNsdWRlcyhkZXJpdmVkKSkge1xuXHRcdFx0XHRlLmRlcml2ZWRfcmVmZXJlbmNlc19zZWxmKCk7XG5cdFx0XHR9XG5cblx0XHRcdHN0YWNrLnB1c2goZGVyaXZlZCk7XG5cblx0XHRcdGRlcml2ZWQuZiAmPSB+V0FTX01BUktFRDtcblx0XHRcdGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzKGRlcml2ZWQpO1xuXHRcdFx0dmFsdWUgPSB1cGRhdGVfcmVhY3Rpb24oZGVyaXZlZCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZfYWN0aXZlX2VmZmVjdCk7XG5cdFx0XHRzZXRfZWFnZXJfZWZmZWN0cyhwcmV2X2VhZ2VyX2VmZmVjdHMpO1xuXHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRyeSB7XG5cdFx0XHRkZXJpdmVkLmYgJj0gfldBU19NQVJLRUQ7XG5cdFx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyhkZXJpdmVkKTtcblx0XHRcdHZhbHVlID0gdXBkYXRlX3JlYWN0aW9uKGRlcml2ZWQpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2X2FjdGl2ZV9lZmZlY3QpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2Rlcml2ZWQoZGVyaXZlZCkge1xuXHR2YXIgdmFsdWUgPSBleGVjdXRlX2Rlcml2ZWQoZGVyaXZlZCk7XG5cblx0aWYgKCFkZXJpdmVkLmVxdWFscyh2YWx1ZSkpIHtcblx0XHQvLyBpbiBhIGZvcmssIHdlIGRvbid0IHVwZGF0ZSB0aGUgdW5kZXJseWluZyB2YWx1ZSwganVzdCBgYmF0Y2hfdmFsdWVzYC5cblx0XHQvLyB0aGUgdW5kZXJseWluZyB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQgd2hlbiB0aGUgZm9yayBpcyBjb21taXR0ZWQuXG5cdFx0Ly8gb3RoZXJ3aXNlLCB0aGUgbmV4dCB0aW1lIHdlIGdldCBoZXJlIGFmdGVyIGEgJ3JlYWwgd29ybGQnIHN0YXRlXG5cdFx0Ly8gY2hhbmdlLCBgZGVyaXZlZC5lcXVhbHNgIG1heSBpbmNvcnJlY3RseSByZXR1cm4gYHRydWVgXG5cdFx0aWYgKCFjdXJyZW50X2JhdGNoPy5pc19mb3JrKSB7XG5cdFx0XHRkZXJpdmVkLnYgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRkZXJpdmVkLnd2ID0gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKTtcblx0fVxuXG5cdC8vIGRvbid0IG1hcmsgZGVyaXZlZCBjbGVhbiBpZiB3ZSdyZSByZWFkaW5nIGl0IGluc2lkZSBhXG5cdC8vIGNsZWFudXAgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2FjaGUgYSBzdGFsZSB2YWx1ZVxuXHRpZiAoaXNfZGVzdHJveWluZ19lZmZlY3QpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBEdXJpbmcgdGltZSB0cmF2ZWxpbmcgd2UgZG9uJ3Qgd2FudCB0byByZXNldCB0aGUgc3RhdHVzIHNvIHRoYXRcblx0Ly8gdHJhdmVyc2FsIG9mIHRoZSBncmFwaCBpbiB0aGUgb3RoZXIgYmF0Y2hlcyBzdGlsbCBoYXBwZW5zXG5cdGlmIChiYXRjaF92YWx1ZXMgIT09IG51bGwpIHtcblx0XHQvLyBvbmx5IGNhY2hlIHRoZSB2YWx1ZSBpZiB3ZSdyZSBpbiBhIHRyYWNraW5nIGNvbnRleHQsIG90aGVyd2lzZSB3ZSB3b24ndFxuXHRcdC8vIGNsZWFyIHRoZSBjYWNoZSBpbiBgbWFya19yZWFjdGlvbnNgIHdoZW4gZGVwZW5kZW5jaWVzIGFyZSB1cGRhdGVkXG5cdFx0aWYgKGVmZmVjdF90cmFja2luZygpIHx8IGN1cnJlbnRfYmF0Y2g/LmlzX2ZvcmspIHtcblx0XHRcdGJhdGNoX3ZhbHVlcy5zZXQoZGVyaXZlZCwgdmFsdWUpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR2YXIgc3RhdHVzID0gKGRlcml2ZWQuZiAmIENPTk5FQ1RFRCkgPT09IDAgPyBNQVlCRV9ESVJUWSA6IENMRUFOO1xuXHRcdHNldF9zaWduYWxfc3RhdHVzKGRlcml2ZWQsIHN0YXR1cyk7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCwgU291cmNlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7XG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0YWN0aXZlX2VmZmVjdCxcblx0dW50cmFja2VkX3dyaXRlcyxcblx0Z2V0LFxuXHRzZXRfdW50cmFja2VkX3dyaXRlcyxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVudHJhY2ssXG5cdGluY3JlbWVudF93cml0ZV92ZXJzaW9uLFxuXHR1cGRhdGVfZWZmZWN0LFxuXHRjdXJyZW50X3NvdXJjZXMsXG5cdGlzX2RpcnR5LFxuXHR1bnRyYWNraW5nLFxuXHRpc19kZXN0cm95aW5nX2VmZmVjdCxcblx0cHVzaF9yZWFjdGlvbl92YWx1ZSxcblx0c2V0X2lzX3VwZGF0aW5nX2VmZmVjdCxcblx0aXNfdXBkYXRpbmdfZWZmZWN0XG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZXF1YWxzLCBzYWZlX2VxdWFscyB9IGZyb20gJy4vZXF1YWxpdHkuanMnO1xuaW1wb3J0IHtcblx0Q0xFQU4sXG5cdERFUklWRUQsXG5cdERJUlRZLFxuXHRCUkFOQ0hfRUZGRUNULFxuXHRFQUdFUl9FRkZFQ1QsXG5cdE1BWUJFX0RJUlRZLFxuXHRCTE9DS19FRkZFQ1QsXG5cdFJPT1RfRUZGRUNULFxuXHRBU1lOQyxcblx0V0FTX01BUktFRCxcblx0Q09OTkVDVEVEXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcsIHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgdGFnX3Byb3h5IH0gZnJvbSAnLi4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgZ2V0X2Vycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Rldi5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCwgaXNfcnVuZXMgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IEJhdGNoLCBiYXRjaF92YWx1ZXMsIGVhZ2VyX2Jsb2NrX2VmZmVjdHMsIHNjaGVkdWxlX2VmZmVjdCB9IGZyb20gJy4vYmF0Y2guanMnO1xuaW1wb3J0IHsgcHJveHkgfSBmcm9tICcuLi9wcm94eS5qcyc7XG5pbXBvcnQgeyBleGVjdXRlX2Rlcml2ZWQgfSBmcm9tICcuL2Rlcml2ZWRzLmpzJztcblxuLyoqIEB0eXBlIHtTZXQ8YW55Pn0gKi9cbmV4cG9ydCBsZXQgZWFnZXJfZWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuLyoqIEB0eXBlIHtNYXA8U291cmNlLCBhbnk+fSAqL1xuZXhwb3J0IGNvbnN0IG9sZF92YWx1ZXMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQHBhcmFtIHtTZXQ8YW55Pn0gdlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2VhZ2VyX2VmZmVjdHModikge1xuXHRlYWdlcl9lZmZlY3RzID0gdjtcbn1cblxubGV0IGVhZ2VyX2VmZmVjdHNfZGVmZXJyZWQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldF9lYWdlcl9lZmZlY3RzX2RlZmVycmVkKCkge1xuXHRlYWdlcl9lZmZlY3RzX2RlZmVycmVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKiBAcGFyYW0ge0Vycm9yIHwgbnVsbH0gW3N0YWNrXVxuICogQHJldHVybnMge1NvdXJjZTxWPn1cbiAqL1xuLy8gVE9ETyByZW5hbWUgdGhpcyB0byBgc3RhdGVgIHRocm91Z2hvdXQgdGhlIGNvZGViYXNlXG5leHBvcnQgZnVuY3Rpb24gc291cmNlKHYsIHN0YWNrKSB7XG5cdC8qKiBAdHlwZSB7VmFsdWV9ICovXG5cdHZhciBzaWduYWwgPSB7XG5cdFx0ZjogMCwgLy8gVE9ETyBpZGVhbGx5IHdlIGNvdWxkIHNraXAgdGhpcyBhbHRvZ2V0aGVyLCBidXQgaXQgY2F1c2VzIHR5cGUgZXJyb3JzXG5cdFx0dixcblx0XHRyZWFjdGlvbnM6IG51bGwsXG5cdFx0ZXF1YWxzLFxuXHRcdHJ2OiAwLFxuXHRcdHd2OiAwXG5cdH07XG5cblx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZykge1xuXHRcdHNpZ25hbC5jcmVhdGVkID0gc3RhY2sgPz8gZ2V0X2Vycm9yKCdjcmVhdGVkIGF0Jyk7XG5cdFx0c2lnbmFsLnVwZGF0ZWQgPSBudWxsO1xuXHRcdHNpZ25hbC5zZXRfZHVyaW5nX2VmZmVjdCA9IGZhbHNlO1xuXHRcdHNpZ25hbC50cmFjZSA9IG51bGw7XG5cdH1cblxuXHRyZXR1cm4gc2lnbmFsO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZcbiAqIEBwYXJhbSB7RXJyb3IgfCBudWxsfSBbc3RhY2tdXG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlKHYsIHN0YWNrKSB7XG5cdGNvbnN0IHMgPSBzb3VyY2Uodiwgc3RhY2spO1xuXG5cdHB1c2hfcmVhY3Rpb25fdmFsdWUocyk7XG5cblx0cmV0dXJuIHM7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gaW5pdGlhbF92YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbaW1tdXRhYmxlXVxuICogQHJldHVybnMge1NvdXJjZTxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gbXV0YWJsZV9zb3VyY2UoaW5pdGlhbF92YWx1ZSwgaW1tdXRhYmxlID0gZmFsc2UsIHRyYWNrYWJsZSA9IHRydWUpIHtcblx0Y29uc3QgcyA9IHNvdXJjZShpbml0aWFsX3ZhbHVlKTtcblx0aWYgKCFpbW11dGFibGUpIHtcblx0XHRzLmVxdWFscyA9IHNhZmVfZXF1YWxzO1xuXHR9XG5cblx0Ly8gYmluZCB0aGUgc2lnbmFsIHRvIHRoZSBjb21wb25lbnQgY29udGV4dCwgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdC8vIHRyYWNrIHVwZGF0ZXMgdG8gdHJpZ2dlciBiZWZvcmVVcGRhdGUvYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzXG5cdGlmIChsZWdhY3lfbW9kZV9mbGFnICYmIHRyYWNrYWJsZSAmJiBjb21wb25lbnRfY29udGV4dCAhPT0gbnVsbCAmJiBjb21wb25lbnRfY29udGV4dC5sICE9PSBudWxsKSB7XG5cdFx0KGNvbXBvbmVudF9jb250ZXh0LmwucyA/Pz0gW10pLnB1c2gocyk7XG5cdH1cblxuXHRyZXR1cm4gcztcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWYWx1ZTxWPn0gc291cmNlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdXRhdGUoc291cmNlLCB2YWx1ZSkge1xuXHRzZXQoXG5cdFx0c291cmNlLFxuXHRcdHVudHJhY2soKCkgPT4gZ2V0KHNvdXJjZSkpXG5cdCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTb3VyY2U8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkX3Byb3h5XVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQoc291cmNlLCB2YWx1ZSwgc2hvdWxkX3Byb3h5ID0gZmFsc2UpIHtcblx0aWYgKFxuXHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdC8vIHNpbmNlIHdlIGFyZSB1bnRyYWNraW5nIHRoZSBmdW5jdGlvbiBpbnNpZGUgYCRpbnNwZWN0LndpdGhgIHdlIG5lZWQgdG8gYWRkIHRoaXMgY2hlY2tcblx0XHQvLyB0byBlbnN1cmUgd2UgZXJyb3IgaWYgc3RhdGUgaXMgc2V0IGluc2lkZSBhbiBpbnNwZWN0IGVmZmVjdFxuXHRcdCghdW50cmFja2luZyB8fCAoYWN0aXZlX3JlYWN0aW9uLmYgJiBFQUdFUl9FRkZFQ1QpICE9PSAwKSAmJlxuXHRcdGlzX3J1bmVzKCkgJiZcblx0XHQoYWN0aXZlX3JlYWN0aW9uLmYgJiAoREVSSVZFRCB8IEJMT0NLX0VGRkVDVCB8IEFTWU5DIHwgRUFHRVJfRUZGRUNUKSkgIT09IDAgJiZcblx0XHQhY3VycmVudF9zb3VyY2VzPy5pbmNsdWRlcyhzb3VyY2UpXG5cdCkge1xuXHRcdGUuc3RhdGVfdW5zYWZlX211dGF0aW9uKCk7XG5cdH1cblxuXHRsZXQgbmV3X3ZhbHVlID0gc2hvdWxkX3Byb3h5ID8gcHJveHkodmFsdWUpIDogdmFsdWU7XG5cblx0aWYgKERFVikge1xuXHRcdHRhZ19wcm94eShuZXdfdmFsdWUsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc291cmNlLmxhYmVsKSk7XG5cdH1cblxuXHRyZXR1cm4gaW50ZXJuYWxfc2V0KHNvdXJjZSwgbmV3X3ZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTb3VyY2U8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm5hbF9zZXQoc291cmNlLCB2YWx1ZSkge1xuXHRpZiAoIXNvdXJjZS5lcXVhbHModmFsdWUpKSB7XG5cdFx0dmFyIG9sZF92YWx1ZSA9IHNvdXJjZS52O1xuXG5cdFx0aWYgKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0KSB7XG5cdFx0XHRvbGRfdmFsdWVzLnNldChzb3VyY2UsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2xkX3ZhbHVlcy5zZXQoc291cmNlLCBvbGRfdmFsdWUpO1xuXHRcdH1cblxuXHRcdHNvdXJjZS52ID0gdmFsdWU7XG5cblx0XHR2YXIgYmF0Y2ggPSBCYXRjaC5lbnN1cmUoKTtcblx0XHRiYXRjaC5jYXB0dXJlKHNvdXJjZSwgb2xkX3ZhbHVlKTtcblxuXHRcdGlmIChERVYpIHtcblx0XHRcdGlmICh0cmFjaW5nX21vZGVfZmxhZyB8fCBhY3RpdmVfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHNvdXJjZS51cGRhdGVkID8/PSBuZXcgTWFwKCk7XG5cblx0XHRcdFx0Ly8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdoZW4gbm90IHVzaW5nICRpbnNwZWN0LnRyYWNlLCB3ZSBvbmx5IHN0YXJ0IGNvbGxlY3Rpbmcgc3RhY2sgdHJhY2VzXG5cdFx0XHRcdC8vIGFmdGVyIHRoZSBzYW1lIHNvdXJjZSBoYXMgYmVlbiB1cGRhdGVkIG1vcmUgdGhhbiA1IHRpbWVzIGluIHRoZSBzYW1lIGZsdXNoIGN5Y2xlLlxuXHRcdFx0XHRjb25zdCBjb3VudCA9IChzb3VyY2UudXBkYXRlZC5nZXQoJycpPy5jb3VudCA/PyAwKSArIDE7XG5cdFx0XHRcdHNvdXJjZS51cGRhdGVkLnNldCgnJywgeyBlcnJvcjogLyoqIEB0eXBlIHthbnl9ICovIChudWxsKSwgY291bnQgfSk7XG5cblx0XHRcdFx0aWYgKHRyYWNpbmdfbW9kZV9mbGFnIHx8IGNvdW50ID4gNSkge1xuXHRcdFx0XHRcdGNvbnN0IGVycm9yID0gZ2V0X2Vycm9yKCd1cGRhdGVkIGF0Jyk7XG5cblx0XHRcdFx0XHRpZiAoZXJyb3IgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGxldCBlbnRyeSA9IHNvdXJjZS51cGRhdGVkLmdldChlcnJvci5zdGFjayk7XG5cblx0XHRcdFx0XHRcdGlmICghZW50cnkpIHtcblx0XHRcdFx0XHRcdFx0ZW50cnkgPSB7IGVycm9yLCBjb3VudDogMCB9O1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UudXBkYXRlZC5zZXQoZXJyb3Iuc3RhY2ssIGVudHJ5KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZW50cnkuY291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGFjdGl2ZV9lZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdFx0c291cmNlLnNldF9kdXJpbmdfZWZmZWN0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoKHNvdXJjZS5mICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdC8vIGlmIHdlIGFyZSBhc3NpZ25pbmcgdG8gYSBkaXJ0eSBkZXJpdmVkIHdlIHNldCBpdCB0byBjbGVhbi9tYXliZSBkaXJ0eSBidXQgd2UgYWxzbyBlYWdlcmx5IGV4ZWN1dGUgaXQgdG8gdHJhY2sgdGhlIGRlcGVuZGVuY2llc1xuXHRcdFx0aWYgKChzb3VyY2UuZiAmIERJUlRZKSAhPT0gMCkge1xuXHRcdFx0XHRleGVjdXRlX2Rlcml2ZWQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc291cmNlKSk7XG5cdFx0XHR9XG5cblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHNvdXJjZSwgKHNvdXJjZS5mICYgQ09OTkVDVEVEKSAhPT0gMCA/IENMRUFOIDogTUFZQkVfRElSVFkpO1xuXHRcdH1cblxuXHRcdHNvdXJjZS53diA9IGluY3JlbWVudF93cml0ZV92ZXJzaW9uKCk7XG5cblx0XHQvLyBGb3IgZGVidWdnaW5nLCBpbiBjYXNlIHlvdSB3YW50IHRvIGtub3cgd2hpY2ggcmVhY3Rpb25zIGFyZSBiZWluZyBzY2hlZHVsZWQ6XG5cdFx0Ly8gbG9nX3JlYWN0aW9ucyhzb3VyY2UpO1xuXHRcdG1hcmtfcmVhY3Rpb25zKHNvdXJjZSwgRElSVFkpO1xuXG5cdFx0Ly8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjdXJyZW50IHJlYWN0aW9uIG1pZ2h0IG5vdCBoYXZlIHVwLXRvLWRhdGUgZGVwZW5kZW5jaWVzXG5cdFx0Ly8gd2hpbHN0IGl0J3MgYWN0aXZlbHkgcnVubmluZy4gU28gaW4gdGhlIGNhc2Ugb2YgZW5zdXJpbmcgaXQgcmVnaXN0ZXJzIHRoZSByZWFjdGlvblxuXHRcdC8vIHByb3Blcmx5IGZvciBpdHNlbGYsIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBjdXJyZW50IGVmZmVjdCBhY3R1YWxseSBnZXRzXG5cdFx0Ly8gc2NoZWR1bGVkLiBpLmU6IGAkZWZmZWN0KCgpID0+IHgrKylgXG5cdFx0aWYgKFxuXHRcdFx0aXNfcnVuZXMoKSAmJlxuXHRcdFx0YWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIENMRUFOKSAhPT0gMCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIChCUkFOQ0hfRUZGRUNUIHwgUk9PVF9FRkZFQ1QpKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0aWYgKHVudHJhY2tlZF93cml0ZXMgPT09IG51bGwpIHtcblx0XHRcdFx0c2V0X3VudHJhY2tlZF93cml0ZXMoW3NvdXJjZV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dW50cmFja2VkX3dyaXRlcy5wdXNoKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFiYXRjaC5pc19mb3JrICYmIGVhZ2VyX2VmZmVjdHMuc2l6ZSA+IDAgJiYgIWVhZ2VyX2VmZmVjdHNfZGVmZXJyZWQpIHtcblx0XHRcdGZsdXNoX2VhZ2VyX2VmZmVjdHMoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF9lYWdlcl9lZmZlY3RzKCkge1xuXHRlYWdlcl9lZmZlY3RzX2RlZmVycmVkID0gZmFsc2U7XG5cdHZhciBwcmV2X2lzX3VwZGF0aW5nX2VmZmVjdCA9IGlzX3VwZGF0aW5nX2VmZmVjdDtcblx0c2V0X2lzX3VwZGF0aW5nX2VmZmVjdCh0cnVlKTtcblxuXHRjb25zdCBpbnNwZWN0cyA9IEFycmF5LmZyb20oZWFnZXJfZWZmZWN0cyk7XG5cblx0dHJ5IHtcblx0XHRmb3IgKGNvbnN0IGVmZmVjdCBvZiBpbnNwZWN0cykge1xuXHRcdFx0Ly8gTWFyayBjbGVhbiBpbnNwZWN0LWVmZmVjdHMgYXMgbWF5YmUgZGlydHkgYW5kIHRoZW4gY2hlY2sgdGhlaXIgZGlydGluZXNzXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIGp1c3QgdXBkYXRpbmcgdGhlIGVmZmVjdHMgLSB0aGlzIHdheSB3ZSBhdm9pZCBvdmVyZmlyaW5nLlxuXHRcdFx0aWYgKChlZmZlY3QuZiAmIENMRUFOKSAhPT0gMCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIE1BWUJFX0RJUlRZKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzX2RpcnR5KGVmZmVjdCkpIHtcblx0XHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfaXNfdXBkYXRpbmdfZWZmZWN0KHByZXZfaXNfdXBkYXRpbmdfZWZmZWN0KTtcblx0fVxuXG5cdGVhZ2VyX2VmZmVjdHMuY2xlYXIoKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge251bWJlciB8IGJpZ2ludH0gVFxuICogQHBhcmFtIHtTb3VyY2U8VD59IHNvdXJjZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGUoc291cmNlLCBkID0gMSkge1xuXHR2YXIgdmFsdWUgPSBnZXQoc291cmNlKTtcblx0dmFyIHJlc3VsdCA9IGQgPT09IDEgPyB2YWx1ZSsrIDogdmFsdWUtLTtcblxuXHRzZXQoc291cmNlLCB2YWx1ZSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyIHwgYmlnaW50fSBUXG4gKiBAcGFyYW0ge1NvdXJjZTxUPn0gc291cmNlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmUoc291cmNlLCBkID0gMSkge1xuXHR2YXIgdmFsdWUgPSBnZXQoc291cmNlKTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiBzZXQoc291cmNlLCBkID09PSAxID8gKyt2YWx1ZSA6IC0tdmFsdWUpO1xufVxuXG4vKipcbiAqIFNpbGVudGx5ICh3aXRob3V0IHVzaW5nIGBnZXRgKSBpbmNyZW1lbnQgYSBzb3VyY2VcbiAqIEBwYXJhbSB7U291cmNlPG51bWJlcj59IHNvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jcmVtZW50KHNvdXJjZSkge1xuXHRzZXQoc291cmNlLCBzb3VyY2UudiArIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VmFsdWV9IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyBzaG91bGQgYmUgRElSVFkgb3IgTUFZQkVfRElSVFlcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBtYXJrX3JlYWN0aW9ucyhzaWduYWwsIHN0YXR1cykge1xuXHR2YXIgcmVhY3Rpb25zID0gc2lnbmFsLnJlYWN0aW9ucztcblx0aWYgKHJlYWN0aW9ucyA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdHZhciBydW5lcyA9IGlzX3J1bmVzKCk7XG5cdHZhciBsZW5ndGggPSByZWFjdGlvbnMubGVuZ3RoO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgcmVhY3Rpb24gPSByZWFjdGlvbnNbaV07XG5cdFx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRcdC8vIEluIGxlZ2FjeSBtb2RlLCBza2lwIHRoZSBjdXJyZW50IGVmZmVjdCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0aWYgKCFydW5lcyAmJiByZWFjdGlvbiA9PT0gYWN0aXZlX2VmZmVjdCkgY29udGludWU7XG5cblx0XHQvLyBJbnNwZWN0IGVmZmVjdHMgbmVlZCB0byBydW4gaW1tZWRpYXRlbHksIHNvIHRoYXQgdGhlIHN0YWNrIHRyYWNlIG1ha2VzIHNlbnNlXG5cdFx0aWYgKERFViAmJiAoZmxhZ3MgJiBFQUdFUl9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRlYWdlcl9lZmZlY3RzLmFkZChyZWFjdGlvbik7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2YXIgbm90X2RpcnR5ID0gKGZsYWdzICYgRElSVFkpID09PSAwO1xuXG5cdFx0Ly8gZG9uJ3Qgc2V0IGEgRElSVFkgcmVhY3Rpb24gdG8gTUFZQkVfRElSVFlcblx0XHRpZiAobm90X2RpcnR5KSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgc3RhdHVzKTtcblx0XHR9XG5cblx0XHRpZiAoKGZsYWdzICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAocmVhY3Rpb24pO1xuXG5cdFx0XHRiYXRjaF92YWx1ZXM/LmRlbGV0ZShkZXJpdmVkKTtcblxuXHRcdFx0aWYgKChmbGFncyAmIFdBU19NQVJLRUQpID09PSAwKSB7XG5cdFx0XHRcdC8vIE9ubHkgY29ubmVjdGVkIGRlcml2ZWRzIGNhbiBiZSByZWxpYWJseSB1bm1hcmtlZCByaWdodCBhd2F5XG5cdFx0XHRcdGlmIChmbGFncyAmIENPTk5FQ1RFRCkge1xuXHRcdFx0XHRcdHJlYWN0aW9uLmYgfD0gV0FTX01BUktFRDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hcmtfcmVhY3Rpb25zKGRlcml2ZWQsIE1BWUJFX0RJUlRZKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG5vdF9kaXJ0eSkge1xuXHRcdFx0aWYgKChmbGFncyAmIEJMT0NLX0VGRkVDVCkgIT09IDAgJiYgZWFnZXJfYmxvY2tfZWZmZWN0cyAhPT0gbnVsbCkge1xuXHRcdFx0XHRlYWdlcl9ibG9ja19lZmZlY3RzLmFkZCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKSk7XG5cdFx0XHR9XG5cblx0XHRcdHNjaGVkdWxlX2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKSk7XG5cdFx0fVxuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTb3VyY2UgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRnZXQsXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHVwZGF0ZV92ZXJzaW9uLFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF91cGRhdGVfdmVyc2lvbixcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0YXJyYXlfcHJvdG90eXBlLFxuXHRnZXRfZGVzY3JpcHRvcixcblx0Z2V0X3Byb3RvdHlwZV9vZixcblx0aXNfYXJyYXksXG5cdG9iamVjdF9wcm90b3R5cGVcbn0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdHN0YXRlIGFzIHNvdXJjZSxcblx0c2V0LFxuXHRpbmNyZW1lbnQsXG5cdGZsdXNoX2VhZ2VyX2VmZmVjdHMsXG5cdHNldF9lYWdlcl9lZmZlY3RzX2RlZmVycmVkXG59IGZyb20gJy4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IFBST1hZX1BBVEhfU1lNQk9MLCBTVEFURV9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgdGFnIH0gZnJvbSAnLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyBnZXRfZXJyb3IgfSBmcm9tICcuLi9zaGFyZWQvZGV2LmpzJztcbmltcG9ydCB7IHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuXG4vLyBUT0RPIG1vdmUgYWxsIHJlZ2V4ZXMgaW50byBzaGFyZWQgbW9kdWxlP1xuY29uc3QgcmVnZXhfaXNfdmFsaWRfaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJveHkodmFsdWUpIHtcblx0Ly8gaWYgbm9uLXByb3h5YWJsZSwgb3IgaXMgYWxyZWFkeSBhIHByb3h5LCByZXR1cm4gYHZhbHVlYFxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBTVEFURV9TWU1CT0wgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRjb25zdCBwcm90b3R5cGUgPSBnZXRfcHJvdG90eXBlX29mKHZhbHVlKTtcblxuXHRpZiAocHJvdG90eXBlICE9PSBvYmplY3RfcHJvdG90eXBlICYmIHByb3RvdHlwZSAhPT0gYXJyYXlfcHJvdG90eXBlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtNYXA8YW55LCBTb3VyY2U8YW55Pj59ICovXG5cdHZhciBzb3VyY2VzID0gbmV3IE1hcCgpO1xuXHR2YXIgaXNfcHJveGllZF9hcnJheSA9IGlzX2FycmF5KHZhbHVlKTtcblx0dmFyIHZlcnNpb24gPSBzb3VyY2UoMCk7XG5cblx0dmFyIHN0YWNrID0gREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnID8gZ2V0X2Vycm9yKCdjcmVhdGVkIGF0JykgOiBudWxsO1xuXHR2YXIgcGFyZW50X3ZlcnNpb24gPSB1cGRhdGVfdmVyc2lvbjtcblxuXHQvKipcblx0ICogRXhlY3V0ZXMgdGhlIHByb3h5IGluIHRoZSBjb250ZXh0IG9mIHRoZSByZWFjdGlvbiBpdCB3YXMgb3JpZ2luYWxseSBjcmVhdGVkIGluLCBpZiBhbnlcblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHBhcmFtIHsoKSA9PiBUfSBmblxuXHQgKi9cblx0dmFyIHdpdGhfcGFyZW50ID0gKGZuKSA9PiB7XG5cdFx0aWYgKHVwZGF0ZV92ZXJzaW9uID09PSBwYXJlbnRfdmVyc2lvbikge1xuXHRcdFx0cmV0dXJuIGZuKCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2hpbGQgc291cmNlIGlzIGJlaW5nIGNyZWF0ZWQgYWZ0ZXIgdGhlIGluaXRpYWwgcHJveHkgXHUyMDE0XG5cdFx0Ly8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCByZWFjdGlvblxuXHRcdHZhciByZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHR2YXIgdmVyc2lvbiA9IHVwZGF0ZV92ZXJzaW9uO1xuXG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHRzZXRfdXBkYXRlX3ZlcnNpb24ocGFyZW50X3ZlcnNpb24pO1xuXG5cdFx0dmFyIHJlc3VsdCA9IGZuKCk7XG5cblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHJlYWN0aW9uKTtcblx0XHRzZXRfdXBkYXRlX3ZlcnNpb24odmVyc2lvbik7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGlmIChpc19wcm94aWVkX2FycmF5KSB7XG5cdFx0Ly8gV2UgbmVlZCB0byBjcmVhdGUgdGhlIGxlbmd0aCBzb3VyY2UgZWFnZXJseSB0byBlbnN1cmUgdGhhdFxuXHRcdC8vIG11dGF0aW9ucyB0byB0aGUgYXJyYXkgYXJlIHByb3Blcmx5IHN5bmNlZCB3aXRoIG91ciBwcm94eVxuXHRcdHNvdXJjZXMuc2V0KCdsZW5ndGgnLCBzb3VyY2UoLyoqIEB0eXBlIHthbnlbXX0gKi8gKHZhbHVlKS5sZW5ndGgsIHN0YWNrKSk7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0dmFsdWUgPSAvKiogQHR5cGUge2FueX0gKi8gKGluc3BlY3RhYmxlX2FycmF5KC8qKiBAdHlwZSB7YW55W119ICovICh2YWx1ZSkpKTtcblx0XHR9XG5cdH1cblxuXHQvKiogVXNlZCBpbiBkZXYgZm9yICRpbnNwZWN0LnRyYWNlKCkgKi9cblx0dmFyIHBhdGggPSAnJztcblx0bGV0IHVwZGF0aW5nID0gZmFsc2U7XG5cdC8qKiBAcGFyYW0ge3N0cmluZ30gbmV3X3BhdGggKi9cblx0ZnVuY3Rpb24gdXBkYXRlX3BhdGgobmV3X3BhdGgpIHtcblx0XHRpZiAodXBkYXRpbmcpIHJldHVybjtcblx0XHR1cGRhdGluZyA9IHRydWU7XG5cdFx0cGF0aCA9IG5ld19wYXRoO1xuXG5cdFx0dGFnKHZlcnNpb24sIGAke3BhdGh9IHZlcnNpb25gKTtcblxuXHRcdC8vIHJlbmFtZSBhbGwgY2hpbGQgc291cmNlcyBhbmQgY2hpbGQgcHJveGllc1xuXHRcdGZvciAoY29uc3QgW3Byb3AsIHNvdXJjZV0gb2Ygc291cmNlcykge1xuXHRcdFx0dGFnKHNvdXJjZSwgZ2V0X2xhYmVsKHBhdGgsIHByb3ApKTtcblx0XHR9XG5cdFx0dXBkYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdHJldHVybiBuZXcgUHJveHkoLyoqIEB0eXBlIHthbnl9ICovICh2YWx1ZSksIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShfLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCEoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci5lbnVtZXJhYmxlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHdlIGRpc2FsbG93IG5vbi1iYXNpYyBkZXNjcmlwdG9ycywgYmVjYXVzZSB1bmxlc3MgdGhleSBhcmUgYXBwbGllZCB0byB0aGVcblx0XHRcdFx0Ly8gdGFyZ2V0IG9iamVjdCBcdTIwMTQgd2hpY2ggd2UgYXZvaWQsIHNvIHRoYXQgc3RhdGUgY2FuIGJlIGZvcmtlZCBcdTIwMTQgd2Ugd2lsbCBydW5cblx0XHRcdFx0Ly8gYWZvdWwgb2YgdGhlIHZhcmlvdXMgaW52YXJpYW50c1xuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eS9Qcm94eS9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IjaW52YXJpYW50c1xuXHRcdFx0XHRlLnN0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzID0gd2l0aF9wYXJlbnQoKCkgPT4ge1xuXHRcdFx0XHRcdHZhciBzID0gc291cmNlKGRlc2NyaXB0b3IudmFsdWUsIHN0YWNrKTtcblx0XHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdFx0XHRpZiAoREVWICYmIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0dGFnKHMsIGdldF9sYWJlbChwYXRoLCBwcm9wKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldChzLCBkZXNjcmlwdG9yLnZhbHVlLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAocHJvcCBpbiB0YXJnZXQpIHtcblx0XHRcdFx0XHRjb25zdCBzID0gd2l0aF9wYXJlbnQoKCkgPT4gc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKSk7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdFx0aW5jcmVtZW50KHZlcnNpb24pO1xuXG5cdFx0XHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRcdFx0dGFnKHMsIGdldF9sYWJlbChwYXRoLCBwcm9wKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXQocywgVU5JTklUSUFMSVpFRCk7XG5cdFx0XHRcdGluY3JlbWVudCh2ZXJzaW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG5cdFx0XHRpZiAocHJvcCA9PT0gU1RBVEVfU1lNQk9MKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKERFViAmJiBwcm9wID09PSBQUk9YWV9QQVRIX1NZTUJPTCkge1xuXHRcdFx0XHRyZXR1cm4gdXBkYXRlX3BhdGg7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgZXhpc3RzID0gcHJvcCBpbiB0YXJnZXQ7XG5cblx0XHRcdC8vIGNyZWF0ZSBhIHNvdXJjZSwgYnV0IG9ubHkgaWYgaXQncyBhbiBvd24gcHJvcGVydHkgYW5kIG5vdCBhIHByb3RvdHlwZSBwcm9wZXJ0eVxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCAmJiAoIWV4aXN0cyB8fCBnZXRfZGVzY3JpcHRvcih0YXJnZXQsIHByb3ApPy53cml0YWJsZSkpIHtcblx0XHRcdFx0cyA9IHdpdGhfcGFyZW50KCgpID0+IHtcblx0XHRcdFx0XHR2YXIgcCA9IHByb3h5KGV4aXN0cyA/IHRhcmdldFtwcm9wXSA6IFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHRcdHZhciBzID0gc291cmNlKHAsIHN0YWNrKTtcblxuXHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR2YXIgdiA9IGdldChzKTtcblx0XHRcdFx0cmV0dXJuIHYgPT09IFVOSU5JVElBTElaRUQgPyB1bmRlZmluZWQgOiB2O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG5cdFx0fSxcblxuXHRcdGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0aWYgKGRlc2NyaXB0b3IgJiYgJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHRcdGlmIChzKSBkZXNjcmlwdG9yLnZhbHVlID0gZ2V0KHMpO1xuXHRcdFx0fSBlbHNlIGlmIChkZXNjcmlwdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBzb3VyY2U/LnY7XG5cblx0XHRcdFx0aWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGVzY3JpcHRvcjtcblx0XHR9LFxuXG5cdFx0aGFzKHRhcmdldCwgcHJvcCkge1xuXHRcdFx0aWYgKHByb3AgPT09IFNUQVRFX1NZTUJPTCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdHZhciBoYXMgPSAocyAhPT0gdW5kZWZpbmVkICYmIHMudiAhPT0gVU5JTklUSUFMSVpFRCkgfHwgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRzICE9PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiYgKCFoYXMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzID0gd2l0aF9wYXJlbnQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0dmFyIHAgPSBoYXMgPyBwcm94eSh0YXJnZXRbcHJvcF0pIDogVU5JTklUSUFMSVpFRDtcblx0XHRcdFx0XHRcdHZhciBzID0gc291cmNlKHAsIHN0YWNrKTtcblxuXHRcdFx0XHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRcdFx0XHR0YWcocywgZ2V0X2xhYmVsKHBhdGgsIHByb3ApKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGdldChzKTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoYXM7XG5cdFx0fSxcblxuXHRcdHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdHZhciBoYXMgPSBwcm9wIGluIHRhcmdldDtcblxuXHRcdFx0Ly8gdmFyaWFibGUubGVuZ3RoID0gdmFsdWUgLT4gY2xlYXIgYWxsIHNpZ25hbHMgd2l0aCBpbmRleCA+PSB2YWx1ZVxuXHRcdFx0aWYgKGlzX3Byb3hpZWRfYXJyYXkgJiYgcHJvcCA9PT0gJ2xlbmd0aCcpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IHZhbHVlOyBpIDwgLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHMpLnY7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHZhciBvdGhlcl9zID0gc291cmNlcy5nZXQoaSArICcnKTtcblx0XHRcdFx0XHRpZiAob3RoZXJfcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzZXQob3RoZXJfcywgVU5JTklUSUFMSVpFRCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpIGluIHRhcmdldCkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGl0ZW0gZXhpc3RzIGluIHRoZSBvcmlnaW5hbCwgd2UgbmVlZCB0byBjcmVhdGUgYW4gdW5pbml0aWFsaXplZCBzb3VyY2UsXG5cdFx0XHRcdFx0XHQvLyBlbHNlIGEgbGF0ZXIgcmVhZCBvZiB0aGUgcHJvcGVydHkgd291bGQgcmVzdWx0IGluIGEgc291cmNlIGJlaW5nIGNyZWF0ZWQgd2l0aFxuXHRcdFx0XHRcdFx0Ly8gdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBpdGVtIGF0IHRoYXQgaW5kZXguXG5cdFx0XHRcdFx0XHRvdGhlcl9zID0gd2l0aF9wYXJlbnQoKCkgPT4gc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKSk7XG5cdFx0XHRcdFx0XHRzb3VyY2VzLnNldChpICsgJycsIG90aGVyX3MpO1xuXG5cdFx0XHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0XHRcdHRhZyhvdGhlcl9zLCBnZXRfbGFiZWwocGF0aCwgaSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlbid0IHlldCBjcmVhdGVkIGEgc291cmNlIGZvciB0aGlzIHByb3BlcnR5LCB3ZSBuZWVkIHRvIGVuc3VyZVxuXHRcdFx0Ly8gd2UgZG8gc28gb3RoZXJ3aXNlIGlmIHdlIHJlYWQgaXQgbGF0ZXIsIHRoZW4gdGhlIHdyaXRlIHdvbid0IGJlIHRyYWNrZWQgYW5kXG5cdFx0XHQvLyB0aGUgaGV1cmlzdGljcyBvZiBlZmZlY3RzIHdpbGwgYmUgZGlmZmVyZW50IHZzIGlmIHdlIGhhZCByZWFkIHRoZSBwcm94aWVkXG5cdFx0XHQvLyBvYmplY3QgcHJvcGVydHkgYmVmb3JlIHdyaXRpbmcgdG8gdGhhdCBwcm9wZXJ0eS5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKCFoYXMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpIHtcblx0XHRcdFx0XHRzID0gd2l0aF9wYXJlbnQoKCkgPT4gc291cmNlKHVuZGVmaW5lZCwgc3RhY2spKTtcblxuXHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZXQocywgcHJveHkodmFsdWUpKTtcblxuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYXMgPSBzLnYgIT09IFVOSU5JVElBTElaRUQ7XG5cblx0XHRcdFx0dmFyIHAgPSB3aXRoX3BhcmVudCgoKSA9PiBwcm94eSh2YWx1ZSkpO1xuXHRcdFx0XHRzZXQocywgcCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBuZXcgdmFsdWUgYmVmb3JlIHVwZGF0aW5nIGFueSBzaWduYWxzIHNvIHRoYXQgYW55IGxpc3RlbmVycyBnZXQgdGhlIG5ldyB2YWx1ZVxuXHRcdFx0aWYgKGRlc2NyaXB0b3I/LnNldCkge1xuXHRcdFx0XHRkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaGFzKSB7XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgbXV0YXRlZCBhbiBhcnJheSBkaXJlY3RseSwgd2UgbWlnaHQgbmVlZCB0b1xuXHRcdFx0XHQvLyBzaWduYWwgdGhhdCBsZW5ndGggaGFzIGFsc28gY2hhbmdlZC4gRG8gaXQgYmVmb3JlIHVwZGF0aW5nIG1ldGFkYXRhXG5cdFx0XHRcdC8vIHRvIGVuc3VyZSB0aGF0IGl0ZXJhdGluZyBvdmVyIHRoZSBhcnJheSBhcyBhIHJlc3VsdCBvZiBhIG1ldGFkYXRhIHVwZGF0ZVxuXHRcdFx0XHQvLyB3aWxsIG5vdCBjYXVzZSB0aGUgbGVuZ3RoIHRvIGJlIG91dCBvZiBzeW5jLlxuXHRcdFx0XHRpZiAoaXNfcHJveGllZF9hcnJheSAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YXIgbHMgPSAvKiogQHR5cGUge1NvdXJjZTxudW1iZXI+fSAqLyAoc291cmNlcy5nZXQoJ2xlbmd0aCcpKTtcblx0XHRcdFx0XHR2YXIgbiA9IE51bWJlcihwcm9wKTtcblxuXHRcdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKG4pICYmIG4gPj0gbHMudikge1xuXHRcdFx0XHRcdFx0c2V0KGxzLCBuICsgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5jcmVtZW50KHZlcnNpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRcdGdldCh2ZXJzaW9uKTtcblxuXHRcdFx0dmFyIG93bl9rZXlzID0gUmVmbGVjdC5vd25LZXlzKHRhcmdldCkuZmlsdGVyKChrZXkpID0+IHtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuZ2V0KGtleSk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2UudiAhPT0gVU5JTklUSUFMSVpFRDtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBba2V5LCBzb3VyY2VdIG9mIHNvdXJjZXMpIHtcblx0XHRcdFx0aWYgKHNvdXJjZS52ICE9PSBVTklOSVRJQUxJWkVEICYmICEoa2V5IGluIHRhcmdldCkpIHtcblx0XHRcdFx0XHRvd25fa2V5cy5wdXNoKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG93bl9rZXlzO1xuXHRcdH0sXG5cblx0XHRzZXRQcm90b3R5cGVPZigpIHtcblx0XHRcdGUuc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtzdHJpbmcgfCBzeW1ib2x9IHByb3BcbiAqL1xuZnVuY3Rpb24gZ2V0X2xhYmVsKHBhdGgsIHByb3ApIHtcblx0aWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykgcmV0dXJuIGAke3BhdGh9W1N5bWJvbCgke3Byb3AuZGVzY3JpcHRpb24gPz8gJyd9KV1gO1xuXHRpZiAocmVnZXhfaXNfdmFsaWRfaWRlbnRpZmllci50ZXN0KHByb3ApKSByZXR1cm4gYCR7cGF0aH0uJHtwcm9wfWA7XG5cdHJldHVybiAvXlxcZCskLy50ZXN0KHByb3ApID8gYCR7cGF0aH1bJHtwcm9wfV1gIDogYCR7cGF0aH1bJyR7cHJvcH0nXWA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcHJveGllZF92YWx1ZSh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlW1NUQVRFX1NZTUJPTF07XG5cdFx0fVxuXHR9IGNhdGNoIHtcblx0XHQvLyB0aGUgYWJvdmUgaWYgY2hlY2sgY2FuIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpbiBxdWVzdGlvblxuXHRcdC8vIGlzIHRoZSBjb250ZW50V2luZG93IG9mIGFuIGlmcmFtZSBvbiBhbm90aGVyIGRvbWFpbiwgaW4gd2hpY2hcblx0XHQvLyBjYXNlIHdlIHdhbnQgdG8ganVzdCByZXR1cm4gdGhlIHZhbHVlIChiZWNhdXNlIGl0J3MgZGVmaW5pdGVseVxuXHRcdC8vIG5vdCBhIHByb3hpZWQgdmFsdWUpIHNvIHdlIGRvbid0IGJyZWFrIGFueSBKYXZhU2NyaXB0IGludGVyYWN0aW5nXG5cdFx0Ly8gd2l0aCB0aGF0IGlmcmFtZSAoc3VjaCBhcyB2YXJpb3VzIHBheW1lbnQgY29tcGFuaWVzIGNsaWVudCBzaWRlXG5cdFx0Ly8gSmF2YVNjcmlwdCBsaWJyYXJpZXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGVpciBpZnJhbWVzIG9uIHRoZSBzYW1lXG5cdFx0Ly8gZG9tYWluKVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoYSwgYikge1xuXHRyZXR1cm4gT2JqZWN0LmlzKGdldF9wcm94aWVkX3ZhbHVlKGEpLCBnZXRfcHJveGllZF92YWx1ZShiKSk7XG59XG5cbmNvbnN0IEFSUkFZX01VVEFUSU5HX01FVEhPRFMgPSBuZXcgU2V0KFtcblx0J2NvcHlXaXRoaW4nLFxuXHQnZmlsbCcsXG5cdCdwb3AnLFxuXHQncHVzaCcsXG5cdCdyZXZlcnNlJyxcblx0J3NoaWZ0Jyxcblx0J3NvcnQnLFxuXHQnc3BsaWNlJyxcblx0J3Vuc2hpZnQnXG5dKTtcblxuLyoqXG4gKiBXcmFwIGFycmF5IG11dGF0aW5nIG1ldGhvZHMgc28gJGluc3BlY3QgaXMgdHJpZ2dlcmVkIG9ubHkgb25jZSBhbmRcbiAqIHRvIHByZXZlbnQgbG9nZ2luZyBhbiBhcnJheSBpbiBpbnRlcm1lZGlhdGUgc3RhdGUgKGUuZy4gd2l0aCBhbiBlbXB0eSBzbG90KVxuICogQHBhcmFtIHthbnlbXX0gYXJyYXlcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdGFibGVfYXJyYXkoYXJyYXkpIHtcblx0cmV0dXJuIG5ldyBQcm94eShhcnJheSwge1xuXHRcdGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcblx0XHRcdGlmICghQVJSQVlfTVVUQVRJTkdfTUVUSE9EUy5oYXMoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwcm9wKSkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0aGlzIHthbnlbXX1cblx0XHRcdCAqIEBwYXJhbSB7YW55W119IGFyZ3Ncblx0XHRcdCAqL1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0XHRcdHNldF9lYWdlcl9lZmZlY3RzX2RlZmVycmVkKCk7XG5cdFx0XHRcdHZhciByZXN1bHQgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0Zmx1c2hfZWFnZXJfZWZmZWN0cygpO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xufVxuIiwgImltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgZ2V0X3Byb3hpZWRfdmFsdWUgfSBmcm9tICcuLi9wcm94eS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncygpIHtcblx0Y29uc3QgYXJyYXlfcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXHQvLyBUaGUgUkVQTCBlbmRzIHVwIGhlcmUgb3ZlciBhbmQgb3ZlciwgYW5kIHRoaXMgcHJldmVudHMgaXQgZnJvbSBhZGRpbmcgbW9yZSBhbmQgbW9yZSBwYXRjaGVzXG5cdC8vIG9mIHRoZSBzYW1lIGtpbmQgdG8gdGhlIHByb3RvdHlwZSwgd2hpY2ggd291bGQgc2xvdyBkb3duIGV2ZXJ5dGhpbmcgb3ZlciB0aW1lLlxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGNsZWFudXAgPSBBcnJheS5fX3N2ZWx0ZV9jbGVhbnVwO1xuXHRpZiAoY2xlYW51cCkge1xuXHRcdGNsZWFudXAoKTtcblx0fVxuXG5cdGNvbnN0IHsgaW5kZXhPZiwgbGFzdEluZGV4T2YsIGluY2x1ZGVzIH0gPSBhcnJheV9wcm90b3R5cGU7XG5cblx0YXJyYXlfcHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbV9pbmRleCkge1xuXHRcdGNvbnN0IGluZGV4ID0gaW5kZXhPZi5jYWxsKHRoaXMsIGl0ZW0sIGZyb21faW5kZXgpO1xuXG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IGZyb21faW5kZXggPz8gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkuaW5kZXhPZiguLi4pJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH07XG5cblx0YXJyYXlfcHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21faW5kZXgpIHtcblx0XHQvLyB3ZSBuZWVkIHRvIHNwZWNpZnkgdGhpcy5sZW5ndGggLSAxIGJlY2F1c2UgaXQncyBwcm9iYWJseSB1c2luZyBzb21ldGhpbmcgbGlrZVxuXHRcdC8vIGBhcmd1bWVudHNgIGluc2lkZSBzbyBwYXNzaW5nIHVuZGVmaW5lZCBpcyBkaWZmZXJlbnQgZnJvbSBub3QgcGFzc2luZyBhbnl0aGluZ1xuXHRcdGNvbnN0IGluZGV4ID0gbGFzdEluZGV4T2YuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4ID8/IHRoaXMubGVuZ3RoIC0gMSk7XG5cblx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSAoZnJvbV9pbmRleCA/PyB0aGlzLmxlbmd0aCAtIDEpOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkubGFzdEluZGV4T2YoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdGFycmF5X3Byb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tX2luZGV4KSB7XG5cdFx0Y29uc3QgaGFzID0gaW5jbHVkZXMuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4KTtcblxuXHRcdGlmICghaGFzKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkuaW5jbHVkZXMoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhcztcblx0fTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdEFycmF5Ll9fc3ZlbHRlX2NsZWFudXAgPSAoKSA9PiB7XG5cdFx0YXJyYXlfcHJvdG90eXBlLmluZGV4T2YgPSBpbmRleE9mO1xuXHRcdGFycmF5X3Byb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuXHRcdGFycmF5X3Byb3RvdHlwZS5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHBhcmFtIHtib29sZWFufSBlcXVhbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpY3RfZXF1YWxzKGEsIGIsIGVxdWFsID0gdHJ1ZSkge1xuXHQvLyB0cnktY2F0Y2ggbmVlZGVkIGJlY2F1c2UgdGhpcyB0cmllcyB0byByZWFkIHByb3BlcnRpZXMgb2YgYGFgIGFuZCBgYmAsXG5cdC8vIHdoaWNoIGNvdWxkIGJlIGRpc2FsbG93ZWQgZm9yIGV4YW1wbGUgaW4gYSBzZWN1cmUgY29udGV4dFxuXHR0cnkge1xuXHRcdGlmICgoYSA9PT0gYikgIT09IChnZXRfcHJveGllZF92YWx1ZShhKSA9PT0gZ2V0X3Byb3hpZWRfdmFsdWUoYikpKSB7XG5cdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKGVxdWFsID8gJz09PScgOiAnIT09Jyk7XG5cdFx0fVxuXHR9IGNhdGNoIHt9XG5cblx0cmV0dXJuIChhID09PSBiKSA9PT0gZXF1YWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVxdWFsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiLCBlcXVhbCA9IHRydWUpIHtcblx0aWYgKChhID09IGIpICE9PSAoZ2V0X3Byb3hpZWRfdmFsdWUoYSkgPT0gZ2V0X3Byb3hpZWRfdmFsdWUoYikpKSB7XG5cdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaChlcXVhbCA/ICc9PScgOiAnIT0nKTtcblx0fVxuXG5cdHJldHVybiAoYSA9PSBiKSA9PT0gZXF1YWw7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZywgc2V0X2h5ZHJhdGVfbm9kZSB9IGZyb20gJy4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaW5pdF9hcnJheV9wcm90b3R5cGVfd2FybmluZ3MgfSBmcm9tICcuLi9kZXYvZXF1YWxpdHkuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IsIGlzX2V4dGVuc2libGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgVEVYVF9OT0RFLCBFRkZFQ1RfUkFOIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgZWFnZXJfYmxvY2tfZWZmZWN0cyB9IGZyb20gJy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuXG4vLyBleHBvcnQgdGhlc2UgZm9yIHJlZmVyZW5jZSBpbiB0aGUgY29tcGlsZWQgY29kZSwgbWFraW5nIGdsb2JhbCBuYW1lIGRlZHVwbGljYXRpb24gdW5uZWNlc3Nhcnlcbi8qKiBAdHlwZSB7V2luZG93fSAqL1xuZXhwb3J0IHZhciAkd2luZG93O1xuXG4vKiogQHR5cGUge0RvY3VtZW50fSAqL1xuZXhwb3J0IHZhciAkZG9jdW1lbnQ7XG5cbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbmV4cG9ydCB2YXIgaXNfZmlyZWZveDtcblxuLyoqIEB0eXBlIHsoKSA9PiBOb2RlIHwgbnVsbH0gKi9cbnZhciBmaXJzdF9jaGlsZF9nZXR0ZXI7XG4vKiogQHR5cGUgeygpID0+IE5vZGUgfCBudWxsfSAqL1xudmFyIG5leHRfc2libGluZ19nZXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGVzZSBsYXppbHkgdG8gYXZvaWQgaXNzdWVzIHdoZW4gdXNpbmcgdGhlIHJ1bnRpbWUgaW4gYSBzZXJ2ZXIgY29udGV4dFxuICogd2hlcmUgdGhlc2UgZ2xvYmFscyBhcmUgbm90IGF2YWlsYWJsZSB3aGlsZSBhdm9pZGluZyBhIHNlcGFyYXRlIHNlcnZlciBlbnRyeSBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9vcGVyYXRpb25zKCkge1xuXHRpZiAoJHdpbmRvdyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0JHdpbmRvdyA9IHdpbmRvdztcblx0JGRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cdGlzX2ZpcmVmb3ggPSAvRmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXHR2YXIgZWxlbWVudF9wcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcblx0dmFyIG5vZGVfcHJvdG90eXBlID0gTm9kZS5wcm90b3R5cGU7XG5cdHZhciB0ZXh0X3Byb3RvdHlwZSA9IFRleHQucHJvdG90eXBlO1xuXG5cdC8vIEB0cy1pZ25vcmVcblx0Zmlyc3RfY2hpbGRfZ2V0dGVyID0gZ2V0X2Rlc2NyaXB0b3Iobm9kZV9wcm90b3R5cGUsICdmaXJzdENoaWxkJykuZ2V0O1xuXHQvLyBAdHMtaWdub3JlXG5cdG5leHRfc2libGluZ19nZXR0ZXIgPSBnZXRfZGVzY3JpcHRvcihub2RlX3Byb3RvdHlwZSwgJ25leHRTaWJsaW5nJykuZ2V0O1xuXG5cdGlmIChpc19leHRlbnNpYmxlKGVsZW1lbnRfcHJvdG90eXBlKSkge1xuXHRcdC8vIHRoZSBmb2xsb3dpbmcgYXNzaWdubWVudHMgaW1wcm92ZSBwZXJmIG9mIGxvb2t1cHMgb24gRE9NIG5vZGVzXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnRfcHJvdG90eXBlLl9fY2xpY2sgPSB1bmRlZmluZWQ7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnRfcHJvdG90eXBlLl9fY2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX2F0dHJpYnV0ZXMgPSBudWxsO1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX3N0eWxlID0gdW5kZWZpbmVkO1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX2UgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoaXNfZXh0ZW5zaWJsZSh0ZXh0X3Byb3RvdHlwZSkpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0dGV4dF9wcm90b3R5cGUuX190ID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX3N2ZWx0ZV9tZXRhID0gbnVsbDtcblxuXHRcdGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3RleHQodmFsdWUgPSAnJykge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7Tm9kZX0gTlxuICogQHBhcmFtIHtOfSBub2RlXG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbi8qQF9fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9maXJzdF9jaGlsZChub2RlKSB7XG5cdHJldHVybiBmaXJzdF9jaGlsZF9nZXR0ZXIuY2FsbChub2RlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG4vKkBfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfbmV4dF9zaWJsaW5nKG5vZGUpIHtcblx0cmV0dXJuIG5leHRfc2libGluZ19nZXR0ZXIuY2FsbChub2RlKTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBpc190ZXh0XG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZChub2RlLCBpc190ZXh0KSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0cmV0dXJuIGdldF9maXJzdF9jaGlsZChub2RlKTtcblx0fVxuXG5cdHZhciBjaGlsZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGh5ZHJhdGVfbm9kZSkpO1xuXG5cdC8vIENoaWxkIGNhbiBiZSBudWxsIGlmIHdlIGhhdmUgYW4gZWxlbWVudCB3aXRoIGEgc2luZ2xlIGNoaWxkLCBsaWtlIGA8cD57dGV4dH08L3A+YCwgd2hlcmUgYHRleHRgIGlzIGVtcHR5XG5cdGlmIChjaGlsZCA9PT0gbnVsbCkge1xuXHRcdGNoaWxkID0gaHlkcmF0ZV9ub2RlLmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXHR9IGVsc2UgaWYgKGlzX3RleHQgJiYgY2hpbGQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblx0XHRjaGlsZD8uYmVmb3JlKHRleHQpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRzZXRfaHlkcmF0ZV9ub2RlKGNoaWxkKTtcblx0cmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAqIERvbid0IG1hcmsgdGhpcyBhcyBzaWRlLWVmZmVjdC1mcmVlLCBoeWRyYXRpb24gbmVlZHMgdG8gd2FsayBhbGwgbm9kZXNcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudCB8IFRlbXBsYXRlTm9kZSB8IFRlbXBsYXRlTm9kZVtdfSBmcmFnbWVudFxuICogQHBhcmFtIHtib29sZWFufSBbaXNfdGV4dF1cbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0X2NoaWxkKGZyYWdtZW50LCBpc190ZXh0ID0gZmFsc2UpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHQvLyB3aGVuIG5vdCBoeWRyYXRpbmcsIGBmcmFnbWVudGAgaXMgYSBgRG9jdW1lbnRGcmFnbWVudGAgKHRoZSByZXN1bHQgb2YgY2FsbGluZyBgb3Blbl9mcmFnYClcblx0XHR2YXIgZmlyc3QgPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZnJhZ21lbnQpKSk7XG5cblx0XHQvLyBUT0RPIHByZXZlbnQgdXNlciBjb21tZW50cyB3aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBwcmVzZXJ2ZUNvbW1lbnRzIGlzIHRydWVcblx0XHRpZiAoZmlyc3QgaW5zdGFuY2VvZiBDb21tZW50ICYmIGZpcnN0LmRhdGEgPT09ICcnKSByZXR1cm4gZ2V0X25leHRfc2libGluZyhmaXJzdCk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH1cblxuXHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgdGhlcmUgbWlnaHQgYmUgbm9cblx0Ly8gdGV4dCBub2RlIHRvIGh5ZHJhdGUgXHUyMDE0IHdlIG11c3QgdGhlcmVmb3JlIGNyZWF0ZSBvbmVcblx0aWYgKGlzX3RleHQgJiYgaHlkcmF0ZV9ub2RlPy5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG5cdFx0dmFyIHRleHQgPSBjcmVhdGVfdGV4dCgpO1xuXG5cdFx0aHlkcmF0ZV9ub2RlPy5iZWZvcmUodGV4dCk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSh0ZXh0KTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdHJldHVybiBoeWRyYXRlX25vZGU7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtib29sZWFufSBpc190ZXh0XG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWJsaW5nKG5vZGUsIGNvdW50ID0gMSwgaXNfdGV4dCA9IGZhbHNlKSB7XG5cdGxldCBuZXh0X3NpYmxpbmcgPSBoeWRyYXRpbmcgPyBoeWRyYXRlX25vZGUgOiBub2RlO1xuXHR2YXIgbGFzdF9zaWJsaW5nO1xuXG5cdHdoaWxlIChjb3VudC0tKSB7XG5cdFx0bGFzdF9zaWJsaW5nID0gbmV4dF9zaWJsaW5nO1xuXHRcdG5leHRfc2libGluZyA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhuZXh0X3NpYmxpbmcpKTtcblx0fVxuXG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0cmV0dXJuIG5leHRfc2libGluZztcblx0fVxuXG5cdC8vIGlmIGEgc2libGluZyB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgdGhlcmUgbWlnaHQgYmUgbm9cblx0Ly8gdGV4dCBub2RlIHRvIGh5ZHJhdGUgXHUyMDE0IHdlIG11c3QgdGhlcmVmb3JlIGNyZWF0ZSBvbmVcblx0aWYgKGlzX3RleHQgJiYgbmV4dF9zaWJsaW5nPy5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG5cdFx0dmFyIHRleHQgPSBjcmVhdGVfdGV4dCgpO1xuXHRcdC8vIElmIHRoZSBuZXh0IHNpYmxpbmcgaXMgYG51bGxgIGFuZCB3ZSdyZSBoYW5kbGluZyB0ZXh0IHRoZW4gaXQncyBiZWNhdXNlXG5cdFx0Ly8gdGhlIFNTUiBjb250ZW50IHdhcyBlbXB0eSBmb3IgdGhlIHRleHQsIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgYSBuZXcgdGV4dFxuXHRcdC8vIG5vZGUgYW5kIGluc2VydCBpdCBhZnRlciB0aGUgbGFzdCBzaWJsaW5nXG5cdFx0aWYgKG5leHRfc2libGluZyA9PT0gbnVsbCkge1xuXHRcdFx0bGFzdF9zaWJsaW5nPy5hZnRlcih0ZXh0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV4dF9zaWJsaW5nLmJlZm9yZSh0ZXh0KTtcblx0XHR9XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSh0ZXh0KTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdHNldF9oeWRyYXRlX25vZGUobmV4dF9zaWJsaW5nKTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobmV4dF9zaWJsaW5nKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcl90ZXh0X2NvbnRlbnQobm9kZSkge1xuXHRub2RlLnRleHRDb250ZW50ID0gJyc7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgd2UncmUgdXBkYXRpbmcgdGhlIGN1cnJlbnQgYmxvY2ssIGZvciBleGFtcGxlIGBjb25kaXRpb25gIGluXG4gKiBhbiBgeyNpZiBjb25kaXRpb259YCBibG9jayBqdXN0IGNoYW5nZWQuIEluIHRoaXMgY2FzZSwgdGhlIGJyYW5jaCBzaG91bGQgYmVcbiAqIGFwcGVuZGVkIChvciByZW1vdmVkKSBhdCB0aGUgc2FtZSB0aW1lIGFzIG90aGVyIHVwZGF0ZXMgd2l0aGluIHRoZVxuICogY3VycmVudCBgPHN2ZWx0ZTpib3VuZGFyeT5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRfZGVmZXJfYXBwZW5kKCkge1xuXHRpZiAoIWFzeW5jX21vZGVfZmxhZykgcmV0dXJuIGZhbHNlO1xuXHRpZiAoZWFnZXJfYmxvY2tfZWZmZWN0cyAhPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG5cdHZhciBmbGFncyA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuZjtcblx0cmV0dXJuIChmbGFncyAmIEVGRkVDVF9SQU4pICE9PSAwO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVzcGFjZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbaXNdXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2VsZW1lbnQodGFnLCBuYW1lc3BhY2UsIGlzKSB7XG5cdGxldCBvcHRpb25zID0gaXMgPyB7IGlzIH0gOiB1bmRlZmluZWQ7XG5cdGlmIChuYW1lc3BhY2UpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnLCBvcHRpb25zKTtcblx0fVxuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50KCkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2NvbW1lbnQoZGF0YSA9ICcnKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlID0gJycpIHtcblx0aWYgKGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBrZXksIHZhbHVlKTtcblx0XHRyZXR1cm47XG5cdH1cblx0cmV0dXJuIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xufVxuIiwgImltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjbGVhcl90ZXh0X2NvbnRlbnQsIGdldF9maXJzdF9jaGlsZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvZm9jdXMoZG9tLCB2YWx1ZSkge1xuXHRpZiAodmFsdWUpIHtcblx0XHRjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0XHRkb20uYXV0b2ZvY3VzID0gdHJ1ZTtcblxuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGJvZHkpIHtcblx0XHRcdFx0ZG9tLmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY2hpbGQgb2YgYSB0ZXh0YXJlYSBhY3R1YWxseSBjb3JyZXNwb25kcyB0byB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5LCBzbyB3ZSBuZWVkXG4gKiB0byByZW1vdmUgaXQgdXBvbiBoeWRyYXRpb24gdG8gYXZvaWQgYSBidWcgd2hlbiBzb21lb25lIHJlc2V0cyB0aGUgZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7SFRNTFRleHRBcmVhRWxlbWVudH0gZG9tXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV90ZXh0YXJlYV9jaGlsZChkb20pIHtcblx0aWYgKGh5ZHJhdGluZyAmJiBnZXRfZmlyc3RfY2hpbGQoZG9tKSAhPT0gbnVsbCkge1xuXHRcdGNsZWFyX3RleHRfY29udGVudChkb20pO1xuXHR9XG59XG5cbmxldCBsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKSB7XG5cdGlmICghbGlzdGVuaW5nX3RvX2Zvcm1fcmVzZXQpIHtcblx0XHRsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCA9IHRydWU7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdyZXNldCcsXG5cdFx0XHQoZXZ0KSA9PiB7XG5cdFx0XHRcdC8vIE5lZWRzIHRvIGhhcHBlbiBvbmUgdGljayBsYXRlciBvciBlbHNlIHRoZSBkb20gcHJvcGVydGllcyBvZiB0aGUgZm9ybVxuXHRcdFx0XHQvLyBlbGVtZW50cyBoYXZlIG5vdCB1cGRhdGVkIHRvIHRoZWlyIHJlc2V0IHZhbHVlcyB5ZXRcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCFldnQuZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBlIG9mIC8qKkB0eXBlIHtIVE1MRm9ybUVsZW1lbnR9ICovIChldnQudGFyZ2V0KS5lbGVtZW50cykge1xuXHRcdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0XHRcdGUuX19vbl9yPy4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdC8vIEluIHRoZSBjYXB0dXJlIHBoYXNlIHRvIGd1YXJhbnRlZSB3ZSBnZXQgbm90aWNlZCBvZiBpdCAobm8gcG9zc2liaWxpdHkgb2Ygc3RvcFByb3BhZ2F0aW9uKVxuXHRcdFx0eyBjYXB0dXJlOiB0cnVlIH1cblx0XHQpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyIH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5cbi8qKlxuICogRmlyZXMgdGhlIGhhbmRsZXIgb25jZSBpbW1lZGlhdGVseSAodW5sZXNzIGNvcnJlc3BvbmRpbmcgYXJnIGlzIHNldCB0byBgZmFsc2VgKSxcbiAqIHRoZW4gbGlzdGVucyB0byB0aGUgZ2l2ZW4gZXZlbnRzIHVudGlsIHRoZSByZW5kZXIgZWZmZWN0IGNvbnRleHQgaXMgZGVzdHJveWVkXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzXG4gKiBAcGFyYW0geyhldmVudD86IEV2ZW50KSA9PiB2b2lkfSBoYW5kbGVyXG4gKiBAcGFyYW0ge2FueX0gY2FsbF9oYW5kbGVyX2ltbWVkaWF0ZWx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudHMsIGhhbmRsZXIsIGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseSA9IHRydWUpIHtcblx0aWYgKGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseSkge1xuXHRcdGhhbmRsZXIoKTtcblx0fVxuXG5cdGZvciAodmFyIG5hbWUgb2YgZXZlbnRzKSB7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG5cdH1cblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0Zm9yICh2YXIgbmFtZSBvZiBldmVudHMpIHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dChmbikge1xuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZm4oKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogTGlzdGVuIHRvIHRoZSBnaXZlbiBldmVudCwgYW5kIHRoZW4gaW5zdGFudGlhdGUgYSBnbG9iYWwgZm9ybSByZXNldCBsaXN0ZW5lciBpZiBub3QgYWxyZWFkeSBkb25lLFxuICogdG8gbm90aWZ5IGFsbCBiaW5kaW5ncyB3aGVuIHRoZSBmb3JtIGlzIHJlc2V0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7KGlzX3Jlc2V0PzogdHJ1ZSkgPT4gdm9pZH0gaGFuZGxlclxuICogQHBhcmFtIHsoaXNfcmVzZXQ/OiB0cnVlKSA9PiB2b2lkfSBbb25fcmVzZXRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBvbl9yZXNldCA9IGhhbmRsZXIpIHtcblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCAoKSA9PiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoaGFuZGxlcikpO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IHByZXYgPSBlbGVtZW50Ll9fb25fcjtcblx0aWYgKHByZXYpIHtcblx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIGNoZWNrYm94IHRoYXQgY2FuIGhhdmUgbXVsdGlwbGUgYmluZHMgKGdyb3VwICYgY2hlY2tlZClcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX29uX3IgPSAoKSA9PiB7XG5cdFx0XHRwcmV2KCk7XG5cdFx0XHRvbl9yZXNldCh0cnVlKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50Ll9fb25fciA9ICgpID0+IG9uX3Jlc2V0KHRydWUpO1xuXHR9XG5cblx0YWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKTtcbn1cbiIsICIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIENvbXBvbmVudENvbnRleHRMZWdhY3ksIERlcml2ZWQsIEVmZmVjdCwgVGVtcGxhdGVOb2RlLCBUcmFuc2l0aW9uTWFuYWdlciB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRpc19kaXJ0eSxcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHR1cGRhdGVfZWZmZWN0LFxuXHRnZXQsXG5cdGlzX2Rlc3Ryb3lpbmdfZWZmZWN0LFxuXHRyZW1vdmVfcmVhY3Rpb25zLFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHR1bnRyYWNraW5nXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0RElSVFksXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdFJFTkRFUl9FRkZFQ1QsXG5cdEVGRkVDVCxcblx0REVTVFJPWUVELFxuXHRJTkVSVCxcblx0RUZGRUNUX1JBTixcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0RUZGRUNUX1RSQU5TUEFSRU5ULFxuXHRERVJJVkVELFxuXHRDTEVBTixcblx0RUFHRVJfRUZGRUNULFxuXHRIRUFEX0VGRkVDVCxcblx0TUFZQkVfRElSVFksXG5cdEVGRkVDVF9QUkVTRVJWRUQsXG5cdFNUQUxFX1JFQUNUSU9OLFxuXHRVU0VSX0VGRkVDVCxcblx0QVNZTkMsXG5cdENPTk5FQ1RFRCxcblx0TUFOQUdFRF9FRkZFQ1Rcbn0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL2RvbS9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24sIGRldl9zdGFjayB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGN1cnJlbnRfYmF0Y2gsIHNjaGVkdWxlX2VmZmVjdCB9IGZyb20gJy4vYmF0Y2guanMnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4vYXN5bmMuanMnO1xuaW1wb3J0IHsgd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0IH0gZnJvbSAnLi4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NoYXJlZC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsnJGVmZmVjdCcgfCAnJGVmZmVjdC5wcmUnIHwgJyRpbnNwZWN0J30gcnVuZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWZmZWN0KHJ1bmUpIHtcblx0aWYgKGFjdGl2ZV9lZmZlY3QgPT09IG51bGwpIHtcblx0XHRpZiAoYWN0aXZlX3JlYWN0aW9uID09PSBudWxsKSB7XG5cdFx0XHRlLmVmZmVjdF9vcnBoYW4ocnVuZSk7XG5cdFx0fVxuXG5cdFx0ZS5lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkKCk7XG5cdH1cblxuXHRpZiAoaXNfZGVzdHJveWluZ19lZmZlY3QpIHtcblx0XHRlLmVmZmVjdF9pbl90ZWFyZG93bihydW5lKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7RWZmZWN0fSBwYXJlbnRfZWZmZWN0XG4gKi9cbmZ1bmN0aW9uIHB1c2hfZWZmZWN0KGVmZmVjdCwgcGFyZW50X2VmZmVjdCkge1xuXHR2YXIgcGFyZW50X2xhc3QgPSBwYXJlbnRfZWZmZWN0Lmxhc3Q7XG5cdGlmIChwYXJlbnRfbGFzdCA9PT0gbnVsbCkge1xuXHRcdHBhcmVudF9lZmZlY3QubGFzdCA9IHBhcmVudF9lZmZlY3QuZmlyc3QgPSBlZmZlY3Q7XG5cdH0gZWxzZSB7XG5cdFx0cGFyZW50X2xhc3QubmV4dCA9IGVmZmVjdDtcblx0XHRlZmZlY3QucHJldiA9IHBhcmVudF9sYXN0O1xuXHRcdHBhcmVudF9lZmZlY3QubGFzdCA9IGVmZmVjdDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcGFyYW0ge251bGwgfCAoKCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKSl9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN5bmNcbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV9lZmZlY3QodHlwZSwgZm4sIHN5bmMpIHtcblx0dmFyIHBhcmVudCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0aWYgKERFVikge1xuXHRcdC8vIEVuc3VyZSB0aGUgcGFyZW50IGlzIG5ldmVyIGFuIGluc3BlY3QgZWZmZWN0XG5cdFx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiAocGFyZW50LmYgJiBFQUdFUl9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdGlmIChwYXJlbnQgIT09IG51bGwgJiYgKHBhcmVudC5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0dHlwZSB8PSBJTkVSVDtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHR2YXIgZWZmZWN0ID0ge1xuXHRcdGN0eDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0ZGVwczogbnVsbCxcblx0XHRub2Rlc19zdGFydDogbnVsbCxcblx0XHRub2Rlc19lbmQ6IG51bGwsXG5cdFx0ZjogdHlwZSB8IERJUlRZIHwgQ09OTkVDVEVELFxuXHRcdGZpcnN0OiBudWxsLFxuXHRcdGZuLFxuXHRcdGxhc3Q6IG51bGwsXG5cdFx0bmV4dDogbnVsbCxcblx0XHRwYXJlbnQsXG5cdFx0YjogcGFyZW50ICYmIHBhcmVudC5iLFxuXHRcdHByZXY6IG51bGwsXG5cdFx0dGVhcmRvd246IG51bGwsXG5cdFx0dHJhbnNpdGlvbnM6IG51bGwsXG5cdFx0d3Y6IDAsXG5cdFx0YWM6IG51bGxcblx0fTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbiA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbjtcblx0fVxuXG5cdGlmIChzeW5jKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdGVmZmVjdC5mIHw9IEVGRkVDVF9SQU47XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGZuICE9PSBudWxsKSB7XG5cdFx0c2NoZWR1bGVfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdHZhciBlID0gZWZmZWN0O1xuXG5cdC8vIGlmIGFuIGVmZmVjdCBoYXMgYWxyZWFkeSByYW4gYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBrZXB0IGluIHRoZSB0cmVlXG5cdC8vIChiZWNhdXNlIGl0IHdvbid0IHJlLXJ1biwgaGFzIG5vIERPTSwgYW5kIGhhcyBubyB0ZWFyZG93biBldGMpXG5cdC8vIHRoZW4gd2Ugc2tpcCBpdCBhbmQgZ28gdG8gaXRzIGNoaWxkIChpZiBhbnkpXG5cdGlmIChcblx0XHRzeW5jICYmXG5cdFx0ZS5kZXBzID09PSBudWxsICYmXG5cdFx0ZS50ZWFyZG93biA9PT0gbnVsbCAmJlxuXHRcdGUubm9kZXNfc3RhcnQgPT09IG51bGwgJiZcblx0XHRlLmZpcnN0ID09PSBlLmxhc3QgJiYgLy8gZWl0aGVyIGBudWxsYCwgb3IgYSBzaW5ndWxhciBjaGlsZFxuXHRcdChlLmYgJiBFRkZFQ1RfUFJFU0VSVkVEKSA9PT0gMFxuXHQpIHtcblx0XHRlID0gZS5maXJzdDtcblx0XHRpZiAoKHR5cGUgJiBCTE9DS19FRkZFQ1QpICE9PSAwICYmICh0eXBlICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCAmJiBlICE9PSBudWxsKSB7XG5cdFx0XHRlLmYgfD0gRUZGRUNUX1RSQU5TUEFSRU5UO1xuXHRcdH1cblx0fVxuXG5cdGlmIChlICE9PSBudWxsKSB7XG5cdFx0ZS5wYXJlbnQgPSBwYXJlbnQ7XG5cblx0XHRpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRwdXNoX2VmZmVjdChlLCBwYXJlbnQpO1xuXHRcdH1cblxuXHRcdC8vIGlmIHdlJ3JlIGluIGEgZGVyaXZlZCwgYWRkIHRoZSBlZmZlY3QgdGhlcmUgdG9vXG5cdFx0aWYgKFxuXHRcdFx0YWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmXG5cdFx0XHQoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCAmJlxuXHRcdFx0KHR5cGUgJiBST09UX0VGRkVDVCkgPT09IDBcblx0XHQpIHtcblx0XHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKTtcblx0XHRcdChkZXJpdmVkLmVmZmVjdHMgPz89IFtdKS5wdXNoKGUpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlZmZlY3Q7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3QudHJhY2tpbmcoKWBcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3RyYWNraW5nKCkge1xuXHRyZXR1cm4gYWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmICF1bnRyYWNraW5nO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlYXJkb3duKGZuKSB7XG5cdGNvbnN0IGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCwgbnVsbCwgZmFsc2UpO1xuXHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIENMRUFOKTtcblx0ZWZmZWN0LnRlYXJkb3duID0gZm47XG5cdHJldHVybiBlZmZlY3Q7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3QoLi4uKWBcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXJfZWZmZWN0KGZuKSB7XG5cdHZhbGlkYXRlX2VmZmVjdCgnJGVmZmVjdCcpO1xuXG5cdGlmIChERVYpIHtcblx0XHRkZWZpbmVfcHJvcGVydHkoZm4sICduYW1lJywge1xuXHRcdFx0dmFsdWU6ICckZWZmZWN0J1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gTm9uLW5lc3RlZCBgJGVmZmVjdCguLi4pYCBpbiBhIGNvbXBvbmVudCBzaG91bGQgYmUgZGVmZXJyZWRcblx0Ly8gdW50aWwgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkXG5cdHZhciBmbGFncyA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuZjtcblx0dmFyIGRlZmVyID0gIWFjdGl2ZV9yZWFjdGlvbiAmJiAoZmxhZ3MgJiBCUkFOQ0hfRUZGRUNUKSAhPT0gMCAmJiAoZmxhZ3MgJiBFRkZFQ1RfUkFOKSA9PT0gMDtcblxuXHRpZiAoZGVmZXIpIHtcblx0XHQvLyBUb3AtbGV2ZWwgYCRlZmZlY3QoLi4uKWAgaW4gYW4gdW5tb3VudGVkIGNvbXBvbmVudCBcdTIwMTQgZGVmZXIgdW50aWwgbW91bnRcblx0XHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblx0XHQoY29udGV4dC5lID8/PSBbXSkucHVzaChmbik7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRXZlcnl0aGluZyBlbHNlIFx1MjAxNCBjcmVhdGUgaW1tZWRpYXRlbHlcblx0XHRyZXR1cm4gY3JlYXRlX3VzZXJfZWZmZWN0KGZuKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV91c2VyX2VmZmVjdChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChFRkZFQ1QgfCBVU0VSX0VGRkVDVCwgZm4sIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdC5wcmUoLi4uKWBcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VyX3ByZV9lZmZlY3QoZm4pIHtcblx0dmFsaWRhdGVfZWZmZWN0KCckZWZmZWN0LnByZScpO1xuXHRpZiAoREVWKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGZuLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnJGVmZmVjdC5wcmUnXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCB8IFVTRVJfRUZGRUNULCBmbiwgdHJ1ZSk7XG59XG5cbi8qKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuICovXG5leHBvcnQgZnVuY3Rpb24gZWFnZXJfZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEVBR0VSX0VGRkVDVCwgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnJvb3QoLi4uKWBcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3Jvb3QoZm4pIHtcblx0QmF0Y2guZW5zdXJlKCk7XG5cdGNvbnN0IGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoUk9PVF9FRkZFQ1QgfCBFRkZFQ1RfUFJFU0VSVkVELCBmbiwgdHJ1ZSk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHR9O1xufVxuXG4vKipcbiAqIEFuIGVmZmVjdCByb290IHdob3NlIGNoaWxkcmVuIGNhbiB0cmFuc2l0aW9uIG91dFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhvcHRpb25zPzogeyBvdXRybz86IGJvb2xlYW4gfSkgPT4gUHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9yb290KGZuKSB7XG5cdEJhdGNoLmVuc3VyZSgpO1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJPT1RfRUZGRUNUIHwgRUZGRUNUX1BSRVNFUlZFRCwgZm4sIHRydWUpO1xuXG5cdHJldHVybiAob3B0aW9ucyA9IHt9KSA9PiB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWwpID0+IHtcblx0XHRcdGlmIChvcHRpb25zLm91dHJvKSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHRcdGZ1bGZpbCh1bmRlZmluZWQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdGZ1bGZpbCh1bmRlZmluZWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoRUZGRUNULCBmbiwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkOiAuLmBcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBkZXBzXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcHJlX2VmZmVjdChkZXBzLCBmbikge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblxuXHQvKiogQHR5cGUge3sgZWZmZWN0OiBudWxsIHwgRWZmZWN0LCByYW46IGJvb2xlYW4sIGRlcHM6ICgpID0+IGFueSB9fSAqL1xuXHR2YXIgdG9rZW4gPSB7IGVmZmVjdDogbnVsbCwgcmFuOiBmYWxzZSwgZGVwcyB9O1xuXG5cdGNvbnRleHQubC4kLnB1c2godG9rZW4pO1xuXG5cdHRva2VuLmVmZmVjdCA9IHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGRlcHMoKTtcblxuXHRcdC8vIElmIHRoaXMgbGVnYWN5IHByZSBlZmZlY3QgaGFzIGFscmVhZHkgcnVuIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSByZXNldCwgdGhlblxuXHRcdC8vIGJhaWwgb3V0IHRvIGVtdWxhdGUgdGhlIHNhbWUgYmVoYXZpb3IuXG5cdFx0aWYgKHRva2VuLnJhbikgcmV0dXJuO1xuXG5cdFx0dG9rZW4ucmFuID0gdHJ1ZTtcblx0XHR1bnRyYWNrKGZuKTtcblx0fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcHJlX2VmZmVjdF9yZXNldCgpIHtcblx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0Ly8gUnVuIGRpcnR5IGAkOmAgc3RhdGVtZW50c1xuXHRcdGZvciAodmFyIHRva2VuIG9mIGNvbnRleHQubC4kKSB7XG5cdFx0XHR0b2tlbi5kZXBzKCk7XG5cblx0XHRcdHZhciBlZmZlY3QgPSB0b2tlbi5lZmZlY3Q7XG5cblx0XHRcdC8vIElmIHRoZSBlZmZlY3QgaXMgQ0xFQU4sIHRoZW4gbWFrZSBpdCBNQVlCRV9ESVJUWS4gVGhpcyBlbnN1cmVzIHdlIHRyYXZlcnNlIHRocm91Z2hcblx0XHRcdC8vIHRoZSBlZmZlY3RzIGRlcGVuZGVuY2llcyBhbmQgY29ycmVjdGx5IGVuc3VyZSBlYWNoIGRlcGVuZGVuY3kgaXMgdXAtdG8tZGF0ZS5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgIT09IDApIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBNQVlCRV9ESVJUWSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc19kaXJ0eShlZmZlY3QpKSB7XG5cdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0dG9rZW4ucmFuID0gZmFsc2U7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNfZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEFTWU5DIHwgRUZGRUNUX1BSRVNFUlZFRCwgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJfZWZmZWN0KGZuLCBmbGFncyA9IDApIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCB8IGZsYWdzLCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoLi4uZXhwcmVzc2lvbnM6IGFueSkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gYW55Pn0gc3luY1xuICogQHBhcmFtIHtBcnJheTwoKSA9PiBQcm9taXNlPGFueT4+fSBhc3luY1xuICogQHBhcmFtIHtBcnJheTxQcm9taXNlPHZvaWQ+Pn0gYmxvY2tlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlX2VmZmVjdChmbiwgc3luYyA9IFtdLCBhc3luYyA9IFtdLCBibG9ja2VycyA9IFtdKSB7XG5cdGZsYXR0ZW4oYmxvY2tlcnMsIHN5bmMsIGFzeW5jLCAodmFsdWVzKSA9PiB7XG5cdFx0Y3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNULCAoKSA9PiBmbiguLi52YWx1ZXMubWFwKGdldCkpLCB0cnVlKTtcblx0fSk7XG59XG5cbi8qKlxuICogTGlrZSBgdGVtcGxhdGVfZWZmZWN0YCwgYnV0IHdpdGggYW4gZWZmZWN0IHdoaWNoIGlzIGRlZmVycmVkIHVudGlsIHRoZSBiYXRjaCBjb21taXRzXG4gKiBAcGFyYW0geyguLi5leHByZXNzaW9uczogYW55KSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtBcnJheTwoKSA9PiBhbnk+fSBzeW5jXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IFByb21pc2U8YW55Pj59IGFzeW5jXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U8dm9pZD4+fSBibG9ja2Vyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmZXJyZWRfdGVtcGxhdGVfZWZmZWN0KGZuLCBzeW5jID0gW10sIGFzeW5jID0gW10sIGJsb2NrZXJzID0gW10pIHtcblx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXHR2YXIgaXNfYXN5bmMgPSBhc3luYy5sZW5ndGggPiAwIHx8IGJsb2NrZXJzLmxlbmd0aCA+IDA7XG5cblx0aWYgKGlzX2FzeW5jKSBiYXRjaC5pbmNyZW1lbnQodHJ1ZSk7XG5cblx0ZmxhdHRlbihibG9ja2Vycywgc3luYywgYXN5bmMsICh2YWx1ZXMpID0+IHtcblx0XHRjcmVhdGVfZWZmZWN0KEVGRkVDVCwgKCkgPT4gZm4oLi4udmFsdWVzLm1hcChnZXQpKSwgZmFsc2UpO1xuXHRcdGlmIChpc19hc3luYykgYmF0Y2guZGVjcmVtZW50KHRydWUpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmxvY2soZm4sIGZsYWdzID0gMCkge1xuXHR2YXIgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChCTE9DS19FRkZFQ1QgfCBmbGFncywgZm4sIHRydWUpO1xuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmRldl9zdGFjayA9IGRldl9zdGFjaztcblx0fVxuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYW5hZ2VkKGZuLCBmbGFncyA9IDApIHtcblx0dmFyIGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoTUFOQUdFRF9FRkZFQ1QgfCBmbGFncywgZm4sIHRydWUpO1xuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmRldl9zdGFjayA9IGRldl9zdGFjaztcblx0fVxuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoKGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEJSQU5DSF9FRkZFQ1QgfCBFRkZFQ1RfUFJFU0VSVkVELCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZV9lZmZlY3RfdGVhcmRvd24oZWZmZWN0KSB7XG5cdHZhciB0ZWFyZG93biA9IGVmZmVjdC50ZWFyZG93bjtcblx0aWYgKHRlYXJkb3duICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgcHJldmlvdXNseV9kZXN0cm95aW5nX2VmZmVjdCA9IGlzX2Rlc3Ryb3lpbmdfZWZmZWN0O1xuXHRcdGNvbnN0IHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHRcdHNldF9pc19kZXN0cm95aW5nX2VmZmVjdCh0cnVlKTtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRcdHRyeSB7XG5cdFx0XHR0ZWFyZG93bi5jYWxsKG51bGwpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QocHJldmlvdXNseV9kZXN0cm95aW5nX2VmZmVjdCk7XG5cdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbW92ZV9kb21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9lZmZlY3RfY2hpbGRyZW4oc2lnbmFsLCByZW1vdmVfZG9tID0gZmFsc2UpIHtcblx0dmFyIGVmZmVjdCA9IHNpZ25hbC5maXJzdDtcblx0c2lnbmFsLmZpcnN0ID0gc2lnbmFsLmxhc3QgPSBudWxsO1xuXG5cdHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcblx0XHRjb25zdCBjb250cm9sbGVyID0gZWZmZWN0LmFjO1xuXG5cdFx0aWYgKGNvbnRyb2xsZXIgIT09IG51bGwpIHtcblx0XHRcdHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0XHRcdGNvbnRyb2xsZXIuYWJvcnQoU1RBTEVfUkVBQ1RJT04pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblxuXHRcdGlmICgoZWZmZWN0LmYgJiBST09UX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdC8vIHRoaXMgaXMgbm93IGFuIGluZGVwZW5kZW50IHJvb3Rcblx0XHRcdGVmZmVjdC5wYXJlbnQgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QsIHJlbW92ZV9kb20pO1xuXHRcdH1cblxuXHRcdGVmZmVjdCA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2tfZWZmZWN0X2NoaWxkcmVuKHNpZ25hbCkge1xuXHR2YXIgZWZmZWN0ID0gc2lnbmFsLmZpcnN0O1xuXG5cdHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcblx0XHR2YXIgbmV4dCA9IGVmZmVjdC5uZXh0O1xuXHRcdGlmICgoZWZmZWN0LmYgJiBCUkFOQ0hfRUZGRUNUKSA9PT0gMCkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHR9XG5cdFx0ZWZmZWN0ID0gbmV4dDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZV9kb21dXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCwgcmVtb3ZlX2RvbSA9IHRydWUpIHtcblx0dmFyIHJlbW92ZWQgPSBmYWxzZTtcblxuXHRpZiAoXG5cdFx0KHJlbW92ZV9kb20gfHwgKGVmZmVjdC5mICYgSEVBRF9FRkZFQ1QpICE9PSAwKSAmJlxuXHRcdGVmZmVjdC5ub2Rlc19zdGFydCAhPT0gbnVsbCAmJlxuXHRcdGVmZmVjdC5ub2Rlc19lbmQgIT09IG51bGxcblx0KSB7XG5cdFx0cmVtb3ZlX2VmZmVjdF9kb20oZWZmZWN0Lm5vZGVzX3N0YXJ0LCAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGVmZmVjdC5ub2Rlc19lbmQpKTtcblx0XHRyZW1vdmVkID0gdHJ1ZTtcblx0fVxuXG5cdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCwgcmVtb3ZlX2RvbSAmJiAhcmVtb3ZlZCk7XG5cdHJlbW92ZV9yZWFjdGlvbnMoZWZmZWN0LCAwKTtcblx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBERVNUUk9ZRUQpO1xuXG5cdHZhciB0cmFuc2l0aW9ucyA9IGVmZmVjdC50cmFuc2l0aW9ucztcblxuXHRpZiAodHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgdHJhbnNpdGlvbnMpIHtcblx0XHRcdHRyYW5zaXRpb24uc3RvcCgpO1xuXHRcdH1cblx0fVxuXG5cdGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCk7XG5cblx0dmFyIHBhcmVudCA9IGVmZmVjdC5wYXJlbnQ7XG5cblx0Ly8gSWYgdGhlIHBhcmVudCBkb2Vzbid0IGhhdmUgYW55IGNoaWxkcmVuLCB0aGVuIHNraXAgdGhpcyB3b3JrIGFsdG9nZXRoZXJcblx0aWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZmlyc3QgIT09IG51bGwpIHtcblx0XHR1bmxpbmtfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbiA9IG51bGw7XG5cdH1cblxuXHQvLyBgZmlyc3RgIGFuZCBgY2hpbGRgIGFyZSBudWxsZWQgb3V0IGluIGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuXG5cdC8vIHdlIGRvbid0IG51bGwgb3V0IGBwYXJlbnRgIHNvIHRoYXQgZXJyb3IgcHJvcGFnYXRpb24gY2FuIHdvcmsgY29ycmVjdGx5XG5cdGVmZmVjdC5uZXh0ID1cblx0XHRlZmZlY3QucHJldiA9XG5cdFx0ZWZmZWN0LnRlYXJkb3duID1cblx0XHRlZmZlY3QuY3R4ID1cblx0XHRlZmZlY3QuZGVwcyA9XG5cdFx0ZWZmZWN0LmZuID1cblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPVxuXHRcdGVmZmVjdC5ub2Rlc19lbmQgPVxuXHRcdGVmZmVjdC5hYyA9XG5cdFx0XHRudWxsO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZSB8IG51bGx9IG5vZGVcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBlbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9lZmZlY3RfZG9tKG5vZGUsIGVuZCkge1xuXHR3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuXHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gKi9cblx0XHR2YXIgbmV4dCA9IG5vZGUgPT09IGVuZCA/IG51bGwgOiAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXG5cdFx0bm9kZS5yZW1vdmUoKTtcblx0XHRub2RlID0gbmV4dDtcblx0fVxufVxuXG4vKipcbiAqIERldGFjaCBhbiBlZmZlY3QgZnJvbSB0aGUgZWZmZWN0IHRyZWUsIGZyZWVpbmcgdXAgbWVtb3J5IGFuZFxuICogcmVkdWNpbmcgdGhlIGFtb3VudCBvZiB3b3JrIHRoYXQgaGFwcGVucyBvbiBzdWJzZXF1ZW50IHRyYXZlcnNhbHNcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlua19lZmZlY3QoZWZmZWN0KSB7XG5cdHZhciBwYXJlbnQgPSBlZmZlY3QucGFyZW50O1xuXHR2YXIgcHJldiA9IGVmZmVjdC5wcmV2O1xuXHR2YXIgbmV4dCA9IGVmZmVjdC5uZXh0O1xuXG5cdGlmIChwcmV2ICE9PSBudWxsKSBwcmV2Lm5leHQgPSBuZXh0O1xuXHRpZiAobmV4dCAhPT0gbnVsbCkgbmV4dC5wcmV2ID0gcHJldjtcblxuXHRpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0aWYgKHBhcmVudC5maXJzdCA9PT0gZWZmZWN0KSBwYXJlbnQuZmlyc3QgPSBuZXh0O1xuXHRcdGlmIChwYXJlbnQubGFzdCA9PT0gZWZmZWN0KSBwYXJlbnQubGFzdCA9IHByZXY7XG5cdH1cbn1cblxuLyoqXG4gKiBXaGVuIGEgYmxvY2sgZWZmZWN0IGlzIHJlbW92ZWQsIHdlIGRvbid0IGltbWVkaWF0ZWx5IGRlc3Ryb3kgaXQgb3IgeWFuayBpdFxuICogb3V0IG9mIHRoZSBET00sIGJlY2F1c2UgaXQgbWlnaHQgaGF2ZSB0cmFuc2l0aW9ucy4gSW5zdGVhZCwgd2UgJ3BhdXNlJyBpdC5cbiAqIEl0IHN0YXlzIGFyb3VuZCAoaW4gbWVtb3J5LCBhbmQgaW4gdGhlIERPTSkgdW50aWwgb3V0cm8gdHJhbnNpdGlvbnMgaGF2ZVxuICogY29tcGxldGVkLCBhbmQgaWYgdGhlIHN0YXRlIGNoYW5nZSBpcyByZXZlcnNlZCB0aGVuIHdlIF9yZXN1bWVfIGl0LlxuICogQSBwYXVzZWQgZWZmZWN0IGRvZXMgbm90IHVwZGF0ZSwgYW5kIHRoZSBET00gc3VidHJlZSBiZWNvbWVzIGluZXJ0LlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXN0cm95XVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF1c2VfZWZmZWN0KGVmZmVjdCwgY2FsbGJhY2ssIGRlc3Ryb3kgPSB0cnVlKSB7XG5cdC8qKiBAdHlwZSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gKi9cblx0dmFyIHRyYW5zaXRpb25zID0gW107XG5cblx0cGF1c2VfY2hpbGRyZW4oZWZmZWN0LCB0cmFuc2l0aW9ucywgdHJ1ZSk7XG5cblx0cnVuX291dF90cmFuc2l0aW9ucyh0cmFuc2l0aW9ucywgKCkgPT4ge1xuXHRcdGlmIChkZXN0cm95KSBkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2l0aW9uTWFuYWdlcltdfSB0cmFuc2l0aW9uc1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuX291dF90cmFuc2l0aW9ucyh0cmFuc2l0aW9ucywgZm4pIHtcblx0dmFyIHJlbWFpbmluZyA9IHRyYW5zaXRpb25zLmxlbmd0aDtcblx0aWYgKHJlbWFpbmluZyA+IDApIHtcblx0XHR2YXIgY2hlY2sgPSAoKSA9PiAtLXJlbWFpbmluZyB8fCBmbigpO1xuXHRcdGZvciAodmFyIHRyYW5zaXRpb24gb2YgdHJhbnNpdGlvbnMpIHtcblx0XHRcdHRyYW5zaXRpb24ub3V0KGNoZWNrKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm4oKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gdHJhbnNpdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdXNlX2NoaWxkcmVuKGVmZmVjdCwgdHJhbnNpdGlvbnMsIGxvY2FsKSB7XG5cdGlmICgoZWZmZWN0LmYgJiBJTkVSVCkgIT09IDApIHJldHVybjtcblx0ZWZmZWN0LmYgXj0gSU5FUlQ7XG5cblx0aWYgKGVmZmVjdC50cmFuc2l0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgdHJhbnNpdGlvbiBvZiBlZmZlY3QudHJhbnNpdGlvbnMpIHtcblx0XHRcdGlmICh0cmFuc2l0aW9uLmlzX2dsb2JhbCB8fCBsb2NhbCkge1xuXHRcdFx0XHR0cmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBjaGlsZCA9IGVmZmVjdC5maXJzdDtcblxuXHR3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0XHR2YXIgc2libGluZyA9IGNoaWxkLm5leHQ7XG5cdFx0dmFyIHRyYW5zcGFyZW50ID1cblx0XHRcdChjaGlsZC5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCB8fFxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGJyYW5jaCBlZmZlY3Qgd2l0aG91dCBhIGJsb2NrIGVmZmVjdCBwYXJlbnQsXG5cdFx0XHQvLyBpdCBtZWFucyB0aGUgcGFyZW50IGJsb2NrIGVmZmVjdCB3YXMgcHJ1bmVkLiBJbiB0aGF0IGNhc2UsXG5cdFx0XHQvLyB0cmFuc3BhcmVuY3kgaW5mb3JtYXRpb24gd2FzIHRyYW5zZmVycmVkIHRvIHRoZSBicmFuY2ggZWZmZWN0LlxuXHRcdFx0KChjaGlsZC5mICYgQlJBTkNIX0VGRkVDVCkgIT09IDAgJiYgKGVmZmVjdC5mICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCk7XG5cdFx0Ly8gVE9ETyB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgcGF1c2VfY2hpbGRyZW4gcmVjdXJzaXZlbHkgd2l0aCBhIGxpbmtlZCBsaXN0IGluIHBsYWNlXG5cdFx0Ly8gaXQncyBzbGlnaHRseSBtb3JlIGludm9sdmVkIHRob3VnaCBhcyB3ZSBoYXZlIHRvIGFjY291bnQgZm9yIGB0cmFuc3BhcmVudGAgY2hhbmdpbmdcblx0XHQvLyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRcdHBhdXNlX2NoaWxkcmVuKGNoaWxkLCB0cmFuc2l0aW9ucywgdHJhbnNwYXJlbnQgPyBsb2NhbCA6IGZhbHNlKTtcblx0XHRjaGlsZCA9IHNpYmxpbmc7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYHBhdXNlX2VmZmVjdGAuIFdlIGNhbGwgdGhpcyBpZiAoZm9yIGV4YW1wbGUpXG4gKiBgeGAgYmVjb21lcyBmYWxzeSB0aGVuIHRydXRoeTogYHsjaWYgeH0uLi57L2lmfWBcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3VtZV9lZmZlY3QoZWZmZWN0KSB7XG5cdHJlc3VtZV9jaGlsZHJlbihlZmZlY3QsIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jYWxcbiAqL1xuZnVuY3Rpb24gcmVzdW1lX2NoaWxkcmVuKGVmZmVjdCwgbG9jYWwpIHtcblx0aWYgKChlZmZlY3QuZiAmIElORVJUKSA9PT0gMCkgcmV0dXJuO1xuXHRlZmZlY3QuZiBePSBJTkVSVDtcblxuXHQvLyBJZiBhIGRlcGVuZGVuY3kgb2YgdGhpcyBlZmZlY3QgY2hhbmdlZCB3aGlsZSBpdCB3YXMgcGF1c2VkLFxuXHQvLyBzY2hlZHVsZSB0aGUgZWZmZWN0IHRvIHVwZGF0ZS4gd2UgZG9uJ3QgdXNlIGBpc19kaXJ0eWBcblx0Ly8gaGVyZSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gZWFnZXJseSByZWNvbXB1dGUgYSBkZXJpdmVkIGxpa2Vcblx0Ly8gYHsjaWYgZm9vfXtmb28uYmFyKCl9ey9pZn1gIGlmIGBmb29gIGlzIG5vdyBgdW5kZWZpbmVkXG5cdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgPT09IDApIHtcblx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIERJUlRZKTtcblx0XHRzY2hlZHVsZV9lZmZlY3QoZWZmZWN0KTtcblx0fVxuXG5cdHZhciBjaGlsZCA9IGVmZmVjdC5maXJzdDtcblxuXHR3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0XHR2YXIgc2libGluZyA9IGNoaWxkLm5leHQ7XG5cdFx0dmFyIHRyYW5zcGFyZW50ID0gKGNoaWxkLmYgJiBFRkZFQ1RfVFJBTlNQQVJFTlQpICE9PSAwIHx8IChjaGlsZC5mICYgQlJBTkNIX0VGRkVDVCkgIT09IDA7XG5cdFx0Ly8gVE9ETyB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgcmVzdW1lX2NoaWxkcmVuIHJlY3Vyc2l2ZWx5IHdpdGggYSBsaW5rZWQgbGlzdCBpbiBwbGFjZVxuXHRcdC8vIGl0J3Mgc2xpZ2h0bHkgbW9yZSBpbnZvbHZlZCB0aG91Z2ggYXMgd2UgaGF2ZSB0byBhY2NvdW50IGZvciBgdHJhbnNwYXJlbnRgIGNoYW5naW5nXG5cdFx0Ly8gdGhyb3VnaCB0aGUgdHJlZS5cblx0XHRyZXN1bWVfY2hpbGRyZW4oY2hpbGQsIHRyYW5zcGFyZW50ID8gbG9jYWwgOiBmYWxzZSk7XG5cdFx0Y2hpbGQgPSBzaWJsaW5nO1xuXHR9XG5cblx0aWYgKGVmZmVjdC50cmFuc2l0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgdHJhbnNpdGlvbiBvZiBlZmZlY3QudHJhbnNpdGlvbnMpIHtcblx0XHRcdGlmICh0cmFuc2l0aW9uLmlzX2dsb2JhbCB8fCBsb2NhbCkge1xuXHRcdFx0XHR0cmFuc2l0aW9uLmluKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydGVkKGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkpIHtcblx0cmV0dXJuIChlZmZlY3QuZiAmIERFU1RST1lFRCkgIT09IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gbW92ZV9lZmZlY3QoZWZmZWN0LCBmcmFnbWVudCkge1xuXHR2YXIgbm9kZSA9IGVmZmVjdC5ub2Rlc19zdGFydDtcblx0dmFyIGVuZCA9IGVmZmVjdC5ub2Rlc19lbmQ7XG5cblx0d2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZSB8IG51bGx9ICovXG5cdFx0dmFyIG5leHQgPSBub2RlID09PSBlbmQgPyBudWxsIDogLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblxuXHRcdGZyYWdtZW50LmFwcGVuZChub2RlKTtcblx0XHRub2RlID0gbmV4dDtcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgaW50ZXJuYWxfc2V0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4vcnVudGltZS5qcyc7XG5cbi8qKlxuICogQHR5cGUge1NldDxWYWx1ZT4gfCBudWxsfVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGxldCBjYXB0dXJlZF9zaWduYWxzID0gbnVsbDtcblxuLyoqXG4gKiBDYXB0dXJlIGFuIGFycmF5IG9mIGFsbCB0aGUgc2lnbmFscyB0aGF0IGFyZSByZWFkIHdoZW4gYGZuYCBpcyBjYWxsZWRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVfc2lnbmFscyhmbikge1xuXHR2YXIgcHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscyA9IGNhcHR1cmVkX3NpZ25hbHM7XG5cblx0dHJ5IHtcblx0XHRjYXB0dXJlZF9zaWduYWxzID0gbmV3IFNldCgpO1xuXG5cdFx0dW50cmFjayhmbik7XG5cblx0XHRpZiAocHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscyAhPT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgc2lnbmFsIG9mIGNhcHR1cmVkX3NpZ25hbHMpIHtcblx0XHRcdFx0cHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscy5hZGQoc2lnbmFsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FwdHVyZWRfc2lnbmFscztcblx0fSBmaW5hbGx5IHtcblx0XHRjYXB0dXJlZF9zaWduYWxzID0gcHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscztcblx0fVxufVxuXG4vKipcbiAqIEludm9rZXMgYSBmdW5jdGlvbiBhbmQgY2FwdHVyZXMgYWxsIHNpZ25hbHMgdGhhdCBhcmUgcmVhZCBkdXJpbmcgdGhlIGludm9jYXRpb24sXG4gKiB0aGVuIGludmFsaWRhdGVzIHRoZW0uXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlX2lubmVyX3NpZ25hbHMoZm4pIHtcblx0Zm9yICh2YXIgc2lnbmFsIG9mIGNhcHR1cmVfc2lnbmFscyhmbikpIHtcblx0XHRpbnRlcm5hbF9zZXQoc2lnbmFsLCBzaWduYWwudik7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCwgUmVhY3Rpb24sIFNpZ25hbCwgU291cmNlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9ycywgZ2V0X3Byb3RvdHlwZV9vZiwgaW5kZXhfb2YgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0ZGVzdHJveV9ibG9ja19lZmZlY3RfY2hpbGRyZW4sXG5cdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuLFxuXHRlZmZlY3RfdHJhY2tpbmcsXG5cdGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duXG59IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdERJUlRZLFxuXHRNQVlCRV9ESVJUWSxcblx0Q0xFQU4sXG5cdERFUklWRUQsXG5cdERFU1RST1lFRCxcblx0QlJBTkNIX0VGRkVDVCxcblx0U1RBVEVfU1lNQk9MLFxuXHRCTE9DS19FRkZFQ1QsXG5cdFJPT1RfRUZGRUNULFxuXHRDT05ORUNURUQsXG5cdFJFQUNUSU9OX0lTX1VQREFUSU5HLFxuXHRTVEFMRV9SRUFDVElPTixcblx0RVJST1JfVkFMVUUsXG5cdFdBU19NQVJLRUQsXG5cdE1BTkFHRURfRUZGRUNUXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG9sZF92YWx1ZXMgfSBmcm9tICcuL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQge1xuXHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyxcblx0ZXhlY3V0ZV9kZXJpdmVkLFxuXHRjdXJyZW50X2FzeW5jX2VmZmVjdCxcblx0cmVjZW50X2FzeW5jX2Rlcml2ZWRzLFxuXHR1cGRhdGVfZGVyaXZlZFxufSBmcm9tICcuL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnLCB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IHRyYWNpbmdfZXhwcmVzc2lvbnMgfSBmcm9tICcuL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IGdldF9lcnJvciB9IGZyb20gJy4uL3NoYXJlZC9kZXYuanMnO1xuaW1wb3J0IHtcblx0Y29tcG9uZW50X2NvbnRleHQsXG5cdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbixcblx0ZGV2X3N0YWNrLFxuXHRpc19ydW5lcyxcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0LFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRzZXRfZGV2X3N0YWNrXG59IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHtcblx0QmF0Y2gsXG5cdGJhdGNoX3ZhbHVlcyxcblx0Y3VycmVudF9iYXRjaCxcblx0Zmx1c2hTeW5jLFxuXHRzY2hlZHVsZV9lZmZlY3Rcbn0gZnJvbSAnLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcbmltcG9ydCB7IGhhbmRsZV9lcnJvciB9IGZyb20gJy4vZXJyb3ItaGFuZGxpbmcuanMnO1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBjYXB0dXJlZF9zaWduYWxzIH0gZnJvbSAnLi9sZWdhY3kuanMnO1xuaW1wb3J0IHsgd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0IH0gZnJvbSAnLi9kb20vZWxlbWVudHMvYmluZGluZ3Mvc2hhcmVkLmpzJztcblxuZXhwb3J0IGxldCBpc191cGRhdGluZ19lZmZlY3QgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaXNfdXBkYXRpbmdfZWZmZWN0KHZhbHVlKSB7XG5cdGlzX3VwZGF0aW5nX2VmZmVjdCA9IHZhbHVlO1xufVxuXG5leHBvcnQgbGV0IGlzX2Rlc3Ryb3lpbmdfZWZmZWN0ID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0KHZhbHVlKSB7XG5cdGlzX2Rlc3Ryb3lpbmdfZWZmZWN0ID0gdmFsdWU7XG59XG5cbi8qKiBAdHlwZSB7bnVsbCB8IFJlYWN0aW9ufSAqL1xuZXhwb3J0IGxldCBhY3RpdmVfcmVhY3Rpb24gPSBudWxsO1xuXG5leHBvcnQgbGV0IHVudHJhY2tpbmcgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7bnVsbCB8IFJlYWN0aW9ufSByZWFjdGlvbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hY3RpdmVfcmVhY3Rpb24ocmVhY3Rpb24pIHtcblx0YWN0aXZlX3JlYWN0aW9uID0gcmVhY3Rpb247XG59XG5cbi8qKiBAdHlwZSB7bnVsbCB8IEVmZmVjdH0gKi9cbmV4cG9ydCBsZXQgYWN0aXZlX2VmZmVjdCA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge251bGwgfCBFZmZlY3R9IGVmZmVjdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hY3RpdmVfZWZmZWN0KGVmZmVjdCkge1xuXHRhY3RpdmVfZWZmZWN0ID0gZWZmZWN0O1xufVxuXG4vKipcbiAqIFdoZW4gc291cmNlcyBhcmUgY3JlYXRlZCB3aXRoaW4gYSByZWFjdGlvbiwgcmVhZGluZyBhbmQgd3JpdGluZ1xuICogdGhlbSB3aXRoaW4gdGhhdCByZWFjdGlvbiBzaG91bGQgbm90IGNhdXNlIGEgcmUtcnVuXG4gKiBAdHlwZSB7bnVsbCB8IFNvdXJjZVtdfVxuICovXG5leHBvcnQgbGV0IGN1cnJlbnRfc291cmNlcyA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1c2hfcmVhY3Rpb25fdmFsdWUodmFsdWUpIHtcblx0aWYgKGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAoIWFzeW5jX21vZGVfZmxhZyB8fCAoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCkpIHtcblx0XHRpZiAoY3VycmVudF9zb3VyY2VzID09PSBudWxsKSB7XG5cdFx0XHRjdXJyZW50X3NvdXJjZXMgPSBbdmFsdWVdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJyZW50X3NvdXJjZXMucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogVGhlIGRlcGVuZGVuY2llcyBvZiB0aGUgcmVhY3Rpb24gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQuIEluIG1hbnkgY2FzZXMsXG4gKiB0aGUgZGVwZW5kZW5jaWVzIGFyZSB1bmNoYW5nZWQgYmV0d2VlbiBydW5zLCBhbmQgc28gdGhpcyB3aWxsIGJlIGBudWxsYCB1bmxlc3NcbiAqIGFuZCB1bnRpbCBhIG5ldyBkZXBlbmRlbmN5IGlzIGFjY2Vzc2VkIFx1MjAxNCB3ZSB0cmFjayB0aGlzIHZpYSBgc2tpcHBlZF9kZXBzYFxuICogQHR5cGUge251bGwgfCBWYWx1ZVtdfVxuICovXG5sZXQgbmV3X2RlcHMgPSBudWxsO1xuXG5sZXQgc2tpcHBlZF9kZXBzID0gMDtcblxuLyoqXG4gKiBUcmFja3Mgd3JpdGVzIHRoYXQgdGhlIGVmZmVjdCBpdCdzIGV4ZWN1dGVkIGluIGRvZXNuJ3QgbGlzdGVuIHRvIHlldCxcbiAqIHNvIHRoYXQgdGhlIGRlcGVuZGVuY3kgY2FuIGJlIGFkZGVkIHRvIHRoZSBlZmZlY3QgbGF0ZXIgb24gaWYgaXQgdGhlbiByZWFkcyBpdFxuICogQHR5cGUge251bGwgfCBTb3VyY2VbXX1cbiAqL1xuZXhwb3J0IGxldCB1bnRyYWNrZWRfd3JpdGVzID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7bnVsbCB8IFNvdXJjZVtdfSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF91bnRyYWNrZWRfd3JpdGVzKHZhbHVlKSB7XG5cdHVudHJhY2tlZF93cml0ZXMgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfSBVc2VkIGJ5IHNvdXJjZXMgYW5kIGRlcml2ZWRzIGZvciBoYW5kbGluZyB1cGRhdGVzLlxuICogVmVyc2lvbiBzdGFydHMgZnJvbSAxIHNvIHRoYXQgdW5vd25lZCBkZXJpdmVkcyBkaWZmZXJlbnRpYXRlIGJldHdlZW4gYSBjcmVhdGVkIGVmZmVjdCBhbmQgYSBydW4gb25lIGZvciB0cmFjaW5nXG4gKiovXG5leHBvcnQgbGV0IHdyaXRlX3ZlcnNpb24gPSAxO1xuXG4vKiogQHR5cGUge251bWJlcn0gVXNlZCB0byB2ZXJzaW9uIGVhY2ggcmVhZCBvZiBhIHNvdXJjZSBvZiBkZXJpdmVkIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGRlcGVkZW5jaWVzIGluc2lkZSBhIHJlYWN0aW9uICovXG5sZXQgcmVhZF92ZXJzaW9uID0gMDtcblxuZXhwb3J0IGxldCB1cGRhdGVfdmVyc2lvbiA9IHJlYWRfdmVyc2lvbjtcblxuLyoqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF91cGRhdGVfdmVyc2lvbih2YWx1ZSkge1xuXHR1cGRhdGVfdmVyc2lvbiA9IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKSB7XG5cdHJldHVybiArK3dyaXRlX3ZlcnNpb247XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZGVyaXZlZCBvciBlZmZlY3QgaXMgZGlydHkuXG4gKiBJZiBpdCBpcyBNQVlCRV9ESVJUWSwgd2lsbCBzZXQgdGhlIHN0YXR1cyB0byBDTEVBTlxuICogQHBhcmFtIHtSZWFjdGlvbn0gcmVhY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZGlydHkocmVhY3Rpb24pIHtcblx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRpZiAoKGZsYWdzICYgRElSVFkpICE9PSAwKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoZmxhZ3MgJiBERVJJVkVEKSB7XG5cdFx0cmVhY3Rpb24uZiAmPSB+V0FTX01BUktFRDtcblx0fVxuXG5cdGlmICgoZmxhZ3MgJiBNQVlCRV9ESVJUWSkgIT09IDApIHtcblx0XHR2YXIgZGVwZW5kZW5jaWVzID0gcmVhY3Rpb24uZGVwcztcblxuXHRcdGlmIChkZXBlbmRlbmNpZXMgIT09IG51bGwpIHtcblx0XHRcdHZhciBsZW5ndGggPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuXG5cdFx0XHRcdGlmIChpc19kaXJ0eSgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChkZXBlbmRlbmN5KSkpIHtcblx0XHRcdFx0XHR1cGRhdGVfZGVyaXZlZCgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChkZXBlbmRlbmN5KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZGVwZW5kZW5jeS53diA+IHJlYWN0aW9uLnd2KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHQoZmxhZ3MgJiBDT05ORUNURUQpICE9PSAwICYmXG5cdFx0XHQvLyBEdXJpbmcgdGltZSB0cmF2ZWxpbmcgd2UgZG9uJ3Qgd2FudCB0byByZXNldCB0aGUgc3RhdHVzIHNvIHRoYXRcblx0XHRcdC8vIHRyYXZlcnNhbCBvZiB0aGUgZ3JhcGggaW4gdGhlIG90aGVyIGJhdGNoZXMgc3RpbGwgaGFwcGVuc1xuXHRcdFx0YmF0Y2hfdmFsdWVzID09PSBudWxsXG5cdFx0KSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgQ0xFQU4pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzaWduYWxcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jvb3RdXG4gKi9cbmZ1bmN0aW9uIHNjaGVkdWxlX3Bvc3NpYmxlX2VmZmVjdF9zZWxmX2ludmFsaWRhdGlvbihzaWduYWwsIGVmZmVjdCwgcm9vdCA9IHRydWUpIHtcblx0dmFyIHJlYWN0aW9ucyA9IHNpZ25hbC5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgPT09IG51bGwpIHJldHVybjtcblxuXHRpZiAoIWFzeW5jX21vZGVfZmxhZyAmJiBjdXJyZW50X3NvdXJjZXM/LmluY2x1ZGVzKHNpZ25hbCkpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJlYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciByZWFjdGlvbiA9IHJlYWN0aW9uc1tpXTtcblxuXHRcdGlmICgocmVhY3Rpb24uZiAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHRzY2hlZHVsZV9wb3NzaWJsZV9lZmZlY3Rfc2VsZl9pbnZhbGlkYXRpb24oLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAocmVhY3Rpb24pLCBlZmZlY3QsIGZhbHNlKTtcblx0XHR9IGVsc2UgaWYgKGVmZmVjdCA9PT0gcmVhY3Rpb24pIHtcblx0XHRcdGlmIChyb290KSB7XG5cdFx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBESVJUWSk7XG5cdFx0XHR9IGVsc2UgaWYgKChyZWFjdGlvbi5mICYgQ0xFQU4pICE9PSAwKSB7XG5cdFx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBNQVlCRV9ESVJUWSk7XG5cdFx0XHR9XG5cdFx0XHRzY2hlZHVsZV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChyZWFjdGlvbikpO1xuXHRcdH1cblx0fVxufVxuXG4vKiogQHBhcmFtIHtSZWFjdGlvbn0gcmVhY3Rpb24gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcmVhY3Rpb24ocmVhY3Rpb24pIHtcblx0dmFyIHByZXZpb3VzX2RlcHMgPSBuZXdfZGVwcztcblx0dmFyIHByZXZpb3VzX3NraXBwZWRfZGVwcyA9IHNraXBwZWRfZGVwcztcblx0dmFyIHByZXZpb3VzX3VudHJhY2tlZF93cml0ZXMgPSB1bnRyYWNrZWRfd3JpdGVzO1xuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19zb3VyY2VzID0gY3VycmVudF9zb3VyY2VzO1xuXHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0dmFyIHByZXZpb3VzX3VudHJhY2tpbmcgPSB1bnRyYWNraW5nO1xuXHR2YXIgcHJldmlvdXNfdXBkYXRlX3ZlcnNpb24gPSB1cGRhdGVfdmVyc2lvbjtcblxuXHR2YXIgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdG5ld19kZXBzID0gLyoqIEB0eXBlIHtudWxsIHwgVmFsdWVbXX0gKi8gKG51bGwpO1xuXHRza2lwcGVkX2RlcHMgPSAwO1xuXHR1bnRyYWNrZWRfd3JpdGVzID0gbnVsbDtcblx0YWN0aXZlX3JlYWN0aW9uID0gKGZsYWdzICYgKEJSQU5DSF9FRkZFQ1QgfCBST09UX0VGRkVDVCkpID09PSAwID8gcmVhY3Rpb24gOiBudWxsO1xuXG5cdGN1cnJlbnRfc291cmNlcyA9IG51bGw7XG5cdHNldF9jb21wb25lbnRfY29udGV4dChyZWFjdGlvbi5jdHgpO1xuXHR1bnRyYWNraW5nID0gZmFsc2U7XG5cdHVwZGF0ZV92ZXJzaW9uID0gKytyZWFkX3ZlcnNpb247XG5cblx0aWYgKHJlYWN0aW9uLmFjICE9PSBudWxsKSB7XG5cdFx0d2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KCgpID0+IHtcblx0XHRcdC8qKiBAdHlwZSB7QWJvcnRDb250cm9sbGVyfSAqLyAocmVhY3Rpb24uYWMpLmFib3J0KFNUQUxFX1JFQUNUSU9OKTtcblx0XHR9KTtcblxuXHRcdHJlYWN0aW9uLmFjID0gbnVsbDtcblx0fVxuXG5cdHRyeSB7XG5cdFx0cmVhY3Rpb24uZiB8PSBSRUFDVElPTl9JU19VUERBVElORztcblx0XHR2YXIgZm4gPSAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyAocmVhY3Rpb24uZm4pO1xuXHRcdHZhciByZXN1bHQgPSBmbigpO1xuXHRcdHZhciBkZXBzID0gcmVhY3Rpb24uZGVwcztcblxuXHRcdGlmIChuZXdfZGVwcyAhPT0gbnVsbCkge1xuXHRcdFx0dmFyIGk7XG5cblx0XHRcdHJlbW92ZV9yZWFjdGlvbnMocmVhY3Rpb24sIHNraXBwZWRfZGVwcyk7XG5cblx0XHRcdGlmIChkZXBzICE9PSBudWxsICYmIHNraXBwZWRfZGVwcyA+IDApIHtcblx0XHRcdFx0ZGVwcy5sZW5ndGggPSBza2lwcGVkX2RlcHMgKyBuZXdfZGVwcy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBuZXdfZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRlcHNbc2tpcHBlZF9kZXBzICsgaV0gPSBuZXdfZGVwc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVhY3Rpb24uZGVwcyA9IGRlcHMgPSBuZXdfZGVwcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzX3VwZGF0aW5nX2VmZmVjdCAmJiBlZmZlY3RfdHJhY2tpbmcoKSAmJiAocmVhY3Rpb24uZiAmIENPTk5FQ1RFRCkgIT09IDApIHtcblx0XHRcdFx0Zm9yIChpID0gc2tpcHBlZF9kZXBzOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdChkZXBzW2ldLnJlYWN0aW9ucyA/Pz0gW10pLnB1c2gocmVhY3Rpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChkZXBzICE9PSBudWxsICYmIHNraXBwZWRfZGVwcyA8IGRlcHMubGVuZ3RoKSB7XG5cdFx0XHRyZW1vdmVfcmVhY3Rpb25zKHJlYWN0aW9uLCBza2lwcGVkX2RlcHMpO1xuXHRcdFx0ZGVwcy5sZW5ndGggPSBza2lwcGVkX2RlcHM7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgaW5zaWRlIGFuIGVmZmVjdCBhbmQgd2UgaGF2ZSB1bnRyYWNrZWQgd3JpdGVzLCB0aGVuIHdlIG5lZWQgdG9cblx0XHQvLyBlbnN1cmUgdGhhdCBpZiBhbnkgb2YgdGhvc2UgdW50cmFja2VkIHdyaXRlcyByZXN1bHQgaW4gcmUtaW52YWxpZGF0aW9uXG5cdFx0Ly8gb2YgdGhlIGN1cnJlbnQgZWZmZWN0LCB0aGVuIHRoYXQgaGFwcGVucyBhY2NvcmRpbmdseVxuXHRcdGlmIChcblx0XHRcdGlzX3J1bmVzKCkgJiZcblx0XHRcdHVudHJhY2tlZF93cml0ZXMgIT09IG51bGwgJiZcblx0XHRcdCF1bnRyYWNraW5nICYmXG5cdFx0XHRkZXBzICE9PSBudWxsICYmXG5cdFx0XHQocmVhY3Rpb24uZiAmIChERVJJVkVEIHwgTUFZQkVfRElSVFkgfCBESVJUWSkpID09PSAwXG5cdFx0KSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgLyoqIEB0eXBlIHtTb3VyY2VbXX0gKi8gKHVudHJhY2tlZF93cml0ZXMpLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNjaGVkdWxlX3Bvc3NpYmxlX2VmZmVjdF9zZWxmX2ludmFsaWRhdGlvbihcblx0XHRcdFx0XHR1bnRyYWNrZWRfd3JpdGVzW2ldLFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgYXJlIHJldHVybmluZyB0byBhbiBwcmV2aW91cyByZWFjdGlvbiB0aGVuXG5cdFx0Ly8gd2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIHJlYWQgdmVyc2lvbiB0byBlbnN1cmUgdGhhdFxuXHRcdC8vIGFueSBkZXBlbmRlbmNpZXMgaW4gdGhpcyByZWFjdGlvbiBhcmVuJ3QgbWFya2VkIHdpdGhcblx0XHQvLyB0aGUgc2FtZSB2ZXJzaW9uXG5cdFx0aWYgKHByZXZpb3VzX3JlYWN0aW9uICE9PSBudWxsICYmIHByZXZpb3VzX3JlYWN0aW9uICE9PSByZWFjdGlvbikge1xuXHRcdFx0cmVhZF92ZXJzaW9uKys7XG5cblx0XHRcdGlmICh1bnRyYWNrZWRfd3JpdGVzICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cHJldmlvdXNfdW50cmFja2VkX3dyaXRlcyA9IHVudHJhY2tlZF93cml0ZXM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJldmlvdXNfdW50cmFja2VkX3dyaXRlcy5wdXNoKC4uLi8qKiBAdHlwZSB7U291cmNlW119ICovICh1bnRyYWNrZWRfd3JpdGVzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoKHJlYWN0aW9uLmYgJiBFUlJPUl9WQUxVRSkgIT09IDApIHtcblx0XHRcdHJlYWN0aW9uLmYgXj0gRVJST1JfVkFMVUU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gaGFuZGxlX2Vycm9yKGVycm9yKTtcblx0fSBmaW5hbGx5IHtcblx0XHRyZWFjdGlvbi5mIF49IFJFQUNUSU9OX0lTX1VQREFUSU5HO1xuXHRcdG5ld19kZXBzID0gcHJldmlvdXNfZGVwcztcblx0XHRza2lwcGVkX2RlcHMgPSBwcmV2aW91c19za2lwcGVkX2RlcHM7XG5cdFx0dW50cmFja2VkX3dyaXRlcyA9IHByZXZpb3VzX3VudHJhY2tlZF93cml0ZXM7XG5cdFx0YWN0aXZlX3JlYWN0aW9uID0gcHJldmlvdXNfcmVhY3Rpb247XG5cdFx0Y3VycmVudF9zb3VyY2VzID0gcHJldmlvdXNfc291cmNlcztcblx0XHRzZXRfY29tcG9uZW50X2NvbnRleHQocHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdHVudHJhY2tpbmcgPSBwcmV2aW91c191bnRyYWNraW5nO1xuXHRcdHVwZGF0ZV92ZXJzaW9uID0gcHJldmlvdXNfdXBkYXRlX3ZlcnNpb247XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWFjdGlvbn0gc2lnbmFsXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBkZXBlbmRlbmN5XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlX3JlYWN0aW9uKHNpZ25hbCwgZGVwZW5kZW5jeSkge1xuXHRsZXQgcmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgIT09IG51bGwpIHtcblx0XHR2YXIgaW5kZXggPSBpbmRleF9vZi5jYWxsKHJlYWN0aW9ucywgc2lnbmFsKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR2YXIgbmV3X2xlbmd0aCA9IHJlYWN0aW9ucy5sZW5ndGggLSAxO1xuXHRcdFx0aWYgKG5ld19sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU3dhcCB3aXRoIGxhc3QgZWxlbWVudCBhbmQgdGhlbiByZW1vdmUuXG5cdFx0XHRcdHJlYWN0aW9uc1tpbmRleF0gPSByZWFjdGlvbnNbbmV3X2xlbmd0aF07XG5cdFx0XHRcdHJlYWN0aW9ucy5wb3AoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBJZiB0aGUgZGVyaXZlZCBoYXMgbm8gcmVhY3Rpb25zLCB0aGVuIHdlIGNhbiBkaXNjb25uZWN0IGl0IGZyb20gdGhlIGdyYXBoLFxuXHQvLyBhbGxvd2luZyBpdCB0byBlaXRoZXIgcmVjb25uZWN0IGluIHRoZSBmdXR1cmUsIG9yIGJlIEdDJ2QgYnkgdGhlIFZNLlxuXHRpZiAoXG5cdFx0cmVhY3Rpb25zID09PSBudWxsICYmXG5cdFx0KGRlcGVuZGVuY3kuZiAmIERFUklWRUQpICE9PSAwICYmXG5cdFx0Ly8gRGVzdHJveWluZyBhIGNoaWxkIGVmZmVjdCB3aGlsZSB1cGRhdGluZyBhIHBhcmVudCBlZmZlY3QgY2FuIGNhdXNlIGEgZGVwZW5kZW5jeSB0byBhcHBlYXJcblx0XHQvLyB0byBiZSB1bnVzZWQsIHdoZW4gaW4gZmFjdCBpdCBpcyB1c2VkIGJ5IHRoZSBjdXJyZW50bHktdXBkYXRpbmcgcGFyZW50LiBDaGVja2luZyBgbmV3X2RlcHNgXG5cdFx0Ly8gYWxsb3dzIHVzIHRvIHNraXAgdGhlIGV4cGVuc2l2ZSB3b3JrIG9mIGRpc2Nvbm5lY3RpbmcgYW5kIGltbWVkaWF0ZWx5IHJlY29ubmVjdGluZyBpdFxuXHRcdChuZXdfZGVwcyA9PT0gbnVsbCB8fCAhbmV3X2RlcHMuaW5jbHVkZXMoZGVwZW5kZW5jeSkpXG5cdCkge1xuXHRcdHNldF9zaWduYWxfc3RhdHVzKGRlcGVuZGVuY3ksIE1BWUJFX0RJUlRZKTtcblx0XHQvLyBJZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZGVyaXZlZCB0aGF0IGlzIG93bmVkIGJ5IGFuIGVmZmVjdCwgdGhlbiBtYXJrIGl0IGFzIGJlaW5nXG5cdFx0Ly8gZGlzY29ubmVjdGVkIGFuZCByZW1vdmUgdGhlIG1hcmsgZmxhZywgYXMgaXQgY2Fubm90IGJlIHJlbGlhYmx5IHJlbW92ZWQgb3RoZXJ3aXNlXG5cdFx0aWYgKChkZXBlbmRlbmN5LmYgJiBDT05ORUNURUQpICE9PSAwKSB7XG5cdFx0XHRkZXBlbmRlbmN5LmYgXj0gQ09OTkVDVEVEO1xuXHRcdFx0ZGVwZW5kZW5jeS5mICY9IH5XQVNfTUFSS0VEO1xuXHRcdH1cblx0XHQvLyBEaXNjb25uZWN0IGFueSByZWFjdGlvbnMgb3duZWQgYnkgdGhpcyByZWFjdGlvblxuXHRcdGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzKC8qKiBAdHlwZSB7RGVyaXZlZH0gKiovIChkZXBlbmRlbmN5KSk7XG5cdFx0cmVtb3ZlX3JlYWN0aW9ucygvKiogQHR5cGUge0Rlcml2ZWR9ICoqLyAoZGVwZW5kZW5jeSksIDApO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdGlvbn0gc2lnbmFsXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRfaW5kZXhcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX3JlYWN0aW9ucyhzaWduYWwsIHN0YXJ0X2luZGV4KSB7XG5cdHZhciBkZXBlbmRlbmNpZXMgPSBzaWduYWwuZGVwcztcblx0aWYgKGRlcGVuZGVuY2llcyA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdGZvciAodmFyIGkgPSBzdGFydF9pbmRleDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuXHRcdHJlbW92ZV9yZWFjdGlvbihzaWduYWwsIGRlcGVuZGVuY2llc1tpXSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9lZmZlY3QoZWZmZWN0KSB7XG5cdHZhciBmbGFncyA9IGVmZmVjdC5mO1xuXG5cdGlmICgoZmxhZ3MgJiBERVNUUk9ZRUQpICE9PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBDTEVBTik7XG5cblx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdHZhciB3YXNfdXBkYXRpbmdfZWZmZWN0ID0gaXNfdXBkYXRpbmdfZWZmZWN0O1xuXG5cdGFjdGl2ZV9lZmZlY3QgPSBlZmZlY3Q7XG5cdGlzX3VwZGF0aW5nX2VmZmVjdCA9IHRydWU7XG5cblx0aWYgKERFVikge1xuXHRcdHZhciBwcmV2aW91c19jb21wb25lbnRfZm4gPSBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb247XG5cdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihlZmZlY3QuY29tcG9uZW50X2Z1bmN0aW9uKTtcblx0XHR2YXIgcHJldmlvdXNfc3RhY2sgPSAvKiogQHR5cGUge2FueX0gKi8gKGRldl9zdGFjayk7XG5cdFx0Ly8gb25seSBibG9jayBlZmZlY3RzIGhhdmUgYSBkZXYgc3RhY2ssIGtlZXAgdGhlIGN1cnJlbnQgb25lIG90aGVyd2lzZVxuXHRcdHNldF9kZXZfc3RhY2soZWZmZWN0LmRldl9zdGFjayA/PyBkZXZfc3RhY2spO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAoKGZsYWdzICYgKEJMT0NLX0VGRkVDVCB8IE1BTkFHRURfRUZGRUNUKSkgIT09IDApIHtcblx0XHRcdGRlc3Ryb3lfYmxvY2tfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCk7XG5cdFx0fVxuXG5cdFx0ZXhlY3V0ZV9lZmZlY3RfdGVhcmRvd24oZWZmZWN0KTtcblx0XHR2YXIgdGVhcmRvd24gPSB1cGRhdGVfcmVhY3Rpb24oZWZmZWN0KTtcblx0XHRlZmZlY3QudGVhcmRvd24gPSB0eXBlb2YgdGVhcmRvd24gPT09ICdmdW5jdGlvbicgPyB0ZWFyZG93biA6IG51bGw7XG5cdFx0ZWZmZWN0Lnd2ID0gd3JpdGVfdmVyc2lvbjtcblxuXHRcdC8vIEluIERFViwgaW5jcmVtZW50IHZlcnNpb25zIG9mIGFueSBzb3VyY2VzIHRoYXQgd2VyZSB3cml0dGVuIHRvIGR1cmluZyB0aGUgZWZmZWN0LFxuXHRcdC8vIHNvIHRoYXQgdGhleSBhcmUgY29ycmVjdGx5IG1hcmtlZCBhcyBkaXJ0eSB3aGVuIHRoZSBlZmZlY3QgcmUtcnVuc1xuXHRcdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcgJiYgKGVmZmVjdC5mICYgRElSVFkpICE9PSAwICYmIGVmZmVjdC5kZXBzICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBkZXAgb2YgZWZmZWN0LmRlcHMpIHtcblx0XHRcdFx0aWYgKGRlcC5zZXRfZHVyaW5nX2VmZmVjdCkge1xuXHRcdFx0XHRcdGRlcC53diA9IGluY3JlbWVudF93cml0ZV92ZXJzaW9uKCk7XG5cdFx0XHRcdFx0ZGVwLnNldF9kdXJpbmdfZWZmZWN0ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfdXBkYXRpbmdfZWZmZWN0ID0gd2FzX3VwZGF0aW5nX2VmZmVjdDtcblx0XHRhY3RpdmVfZWZmZWN0ID0gcHJldmlvdXNfZWZmZWN0O1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihwcmV2aW91c19jb21wb25lbnRfZm4pO1xuXHRcdFx0c2V0X2Rldl9zdGFjayhwcmV2aW91c19zdGFjayk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFueSBwZW5kaW5nIHN0YXRlIGNoYW5nZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRpY2soKSB7XG5cdGlmIChhc3luY19tb2RlX2ZsYWcpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKGYpID0+IHtcblx0XHRcdC8vIFJhY2UgdGhlbSBhZ2FpbnN0IGVhY2ggb3RoZXIgLSBpbiBhbG1vc3QgYWxsIGNhc2VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aWxsIGZpcmUgZmlyc3QsXG5cdFx0XHQvLyBidXQgZS5nLiBpbiBjYXNlIHRoZSB3aW5kb3cgaXMgbm90IGZvY3VzZWQgb3IgYSB2aWV3IHRyYW5zaXRpb24gaGFwcGVucywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0XHQvLyB3aWxsIGJlIGRlbGF5ZWQgYW5kIHNldFRpbWVvdXQgaGVscHMgdXMgcmVzb2x2ZSBmYXN0IGVub3VnaCBpbiB0aGF0IGNhc2Vcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBmKCkpO1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiBmKCkpO1xuXHRcdH0pO1xuXHR9XG5cblx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0Ly8gQnkgY2FsbGluZyBmbHVzaFN5bmMgd2UgZ3VhcmFudGVlIHRoYXQgYW55IHBlbmRpbmcgc3RhdGUgY2hhbmdlcyBhcmUgYXBwbGllZCBhZnRlciBvbmUgdGljay5cblx0Ly8gVE9ETyBsb29rIGludG8gd2hldGhlciB3ZSBjYW4gbWFrZSBmbHVzaGluZyBzdWJzZXF1ZW50IHVwZGF0ZXMgc3luY2hyb25vdXNseSBpbiB0aGUgZnV0dXJlLlxuXHRmbHVzaFN5bmMoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYW55IHN0YXRlIGNoYW5nZXMsIGFuZCBhc3luY2hyb25vdXMgd29yayByZXN1bHRpbmcgZnJvbSB0aGVtLFxuICogaGF2ZSByZXNvbHZlZCBhbmQgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqIEBzaW5jZSA1LjM2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR0bGVkKCkge1xuXHRyZXR1cm4gQmF0Y2guZW5zdXJlKCkuc2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBzaWduYWxcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHNpZ25hbCkge1xuXHR2YXIgZmxhZ3MgPSBzaWduYWwuZjtcblx0dmFyIGlzX2Rlcml2ZWQgPSAoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMDtcblxuXHRjYXB0dXJlZF9zaWduYWxzPy5hZGQoc2lnbmFsKTtcblxuXHQvLyBSZWdpc3RlciB0aGUgZGVwZW5kZW5jeSBvbiB0aGUgY3VycmVudCByZWFjdGlvbiBzaWduYWwuXG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgIXVudHJhY2tpbmcpIHtcblx0XHQvLyBpZiB3ZSdyZSBpbiBhIGRlcml2ZWQgdGhhdCBpcyBiZWluZyByZWFkIGluc2lkZSBhbiBfYXN5bmNfIGRlcml2ZWQsXG5cdFx0Ly8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBlZmZlY3Qgd2FzIGFscmVhZHkgZGVzdHJveWVkLiBJbiB0aGlzIGNhc2UsXG5cdFx0Ly8gd2UgZG9uJ3QgYWRkIHRoZSBkZXBlbmRlbmN5LCBiZWNhdXNlIHRoYXQgd291bGQgY3JlYXRlIGEgbWVtb3J5IGxlYWtcblx0XHR2YXIgZGVzdHJveWVkID0gYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJiAoYWN0aXZlX2VmZmVjdC5mICYgREVTVFJPWUVEKSAhPT0gMDtcblxuXHRcdGlmICghZGVzdHJveWVkICYmICFjdXJyZW50X3NvdXJjZXM/LmluY2x1ZGVzKHNpZ25hbCkpIHtcblx0XHRcdHZhciBkZXBzID0gYWN0aXZlX3JlYWN0aW9uLmRlcHM7XG5cblx0XHRcdGlmICgoYWN0aXZlX3JlYWN0aW9uLmYgJiBSRUFDVElPTl9JU19VUERBVElORykgIT09IDApIHtcblx0XHRcdFx0Ly8gd2UncmUgaW4gdGhlIGVmZmVjdCBpbml0L3VwZGF0ZSBjeWNsZVxuXHRcdFx0XHRpZiAoc2lnbmFsLnJ2IDwgcmVhZF92ZXJzaW9uKSB7XG5cdFx0XHRcdFx0c2lnbmFsLnJ2ID0gcmVhZF92ZXJzaW9uO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHNpZ25hbCBpcyBhY2Nlc3NpbmcgdGhlIHNhbWUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lXG5cdFx0XHRcdFx0Ly8gb3JkZXIgYXMgaXQgZGlkIGxhc3QgdGltZSwgaW5jcmVtZW50IGBza2lwcGVkX2RlcHNgXG5cdFx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gdXBkYXRpbmcgYG5ld19kZXBzYCwgd2hpY2ggY3JlYXRlcyBHQyBjb3N0XG5cdFx0XHRcdFx0aWYgKG5ld19kZXBzID09PSBudWxsICYmIGRlcHMgIT09IG51bGwgJiYgZGVwc1tza2lwcGVkX2RlcHNdID09PSBzaWduYWwpIHtcblx0XHRcdFx0XHRcdHNraXBwZWRfZGVwcysrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobmV3X2RlcHMgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdG5ld19kZXBzID0gW3NpZ25hbF07XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghbmV3X2RlcHMuaW5jbHVkZXMoc2lnbmFsKSkge1xuXHRcdFx0XHRcdFx0bmV3X2RlcHMucHVzaChzaWduYWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gd2UncmUgYWRkaW5nIGEgZGVwZW5kZW5jeSBvdXRzaWRlIHRoZSBpbml0L3VwZGF0ZSBjeWNsZVxuXHRcdFx0XHQvLyAoaS5lLiBhZnRlciBhbiBgYXdhaXRgKVxuXHRcdFx0XHQoYWN0aXZlX3JlYWN0aW9uLmRlcHMgPz89IFtdKS5wdXNoKHNpZ25hbCk7XG5cblx0XHRcdFx0dmFyIHJlYWN0aW9ucyA9IHNpZ25hbC5yZWFjdGlvbnM7XG5cblx0XHRcdFx0aWYgKHJlYWN0aW9ucyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHNpZ25hbC5yZWFjdGlvbnMgPSBbYWN0aXZlX3JlYWN0aW9uXTtcblx0XHRcdFx0fSBlbHNlIGlmICghcmVhY3Rpb25zLmluY2x1ZGVzKGFjdGl2ZV9yZWFjdGlvbikpIHtcblx0XHRcdFx0XHRyZWFjdGlvbnMucHVzaChhY3RpdmVfcmVhY3Rpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdC8vIFRPRE8gcmVpbnN0YXRlIHRoaXMsIGJ1dCBtYWtlIGl0IGFjdHVhbGx5IHdvcmtcblx0XHQvLyBpZiAoY3VycmVudF9hc3luY19lZmZlY3QpIHtcblx0XHQvLyBcdHZhciB0cmFja2luZyA9IChjdXJyZW50X2FzeW5jX2VmZmVjdC5mICYgUkVBQ1RJT05fSVNfVVBEQVRJTkcpICE9PSAwO1xuXHRcdC8vIFx0dmFyIHdhc19yZWFkID0gY3VycmVudF9hc3luY19lZmZlY3QuZGVwcz8uaW5jbHVkZXMoc2lnbmFsKTtcblxuXHRcdC8vIFx0aWYgKCF0cmFja2luZyAmJiAhdW50cmFja2luZyAmJiAhd2FzX3JlYWQpIHtcblx0XHQvLyBcdFx0dy5hd2FpdF9yZWFjdGl2aXR5X2xvc3MoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChzaWduYWwubGFiZWwpKTtcblxuXHRcdC8vIFx0XHR2YXIgdHJhY2UgPSBnZXRfZXJyb3IoJ3RyYWNlZCBhdCcpO1xuXHRcdC8vIFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdC8vIFx0XHRpZiAodHJhY2UpIGNvbnNvbGUud2Fybih0cmFjZSk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfVxuXG5cdFx0cmVjZW50X2FzeW5jX2Rlcml2ZWRzLmRlbGV0ZShzaWduYWwpO1xuXG5cdFx0aWYgKFxuXHRcdFx0dHJhY2luZ19tb2RlX2ZsYWcgJiZcblx0XHRcdCF1bnRyYWNraW5nICYmXG5cdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zICE9PSBudWxsICYmXG5cdFx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiZcblx0XHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMucmVhY3Rpb24gPT09IGFjdGl2ZV9yZWFjdGlvblxuXHRcdCkge1xuXHRcdFx0Ly8gVXNlZCB3aGVuIG1hcHBpbmcgc3RhdGUgYmV0d2VlbiBzcGVjaWFsIGJsb2NrcyBsaWtlIGBlYWNoYFxuXHRcdFx0aWYgKHNpZ25hbC50cmFjZSkge1xuXHRcdFx0XHRzaWduYWwudHJhY2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0cmFjZSA9IGdldF9lcnJvcigndHJhY2VkIGF0Jyk7XG5cblx0XHRcdFx0aWYgKHRyYWNlKSB7XG5cdFx0XHRcdFx0dmFyIGVudHJ5ID0gdHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzLmdldChzaWduYWwpO1xuXG5cdFx0XHRcdFx0aWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGVudHJ5ID0geyB0cmFjZXM6IFtdIH07XG5cdFx0XHRcdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXMuc2V0KHNpZ25hbCwgZW50cnkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBsYXN0ID0gZW50cnkudHJhY2VzW2VudHJ5LnRyYWNlcy5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdC8vIHRyYWNlcyBjYW4gYmUgZHVwbGljYXRlZCwgZS5nLiBieSBgc25hcHNob3RgIGludm9raW5nIGJvdGhcblx0XHRcdFx0XHQvLyBib3RoIGBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGFuZCBgZ2V0YCB0cmFwcyBhdCBvbmNlXG5cdFx0XHRcdFx0aWYgKHRyYWNlLnN0YWNrICE9PSBsYXN0Py5zdGFjaykge1xuXHRcdFx0XHRcdFx0ZW50cnkudHJhY2VzLnB1c2godHJhY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChpc19kZXN0cm95aW5nX2VmZmVjdCkge1xuXHRcdGlmIChvbGRfdmFsdWVzLmhhcyhzaWduYWwpKSB7XG5cdFx0XHRyZXR1cm4gb2xkX3ZhbHVlcy5nZXQoc2lnbmFsKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfZGVyaXZlZCkge1xuXHRcdFx0dmFyIGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpO1xuXG5cdFx0XHR2YXIgdmFsdWUgPSBkZXJpdmVkLnY7XG5cblx0XHRcdC8vIGlmIHRoZSBkZXJpdmVkIGlzIGRpcnR5IGFuZCBoYXMgcmVhY3Rpb25zLCBvciBkZXBlbmRzIG9uIHRoZSB2YWx1ZXMgdGhhdCBqdXN0IGNoYW5nZWQsIHJlLWV4ZWN1dGVcblx0XHRcdC8vIChhIGRlcml2ZWQgY2FuIGJlIG1heWJlX2RpcnR5IGR1ZSB0byB0aGUgZWZmZWN0IGRlc3Ryb3kgcmVtb3ZpbmcgaXRzIGxhc3QgcmVhY3Rpb24pXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCgoZGVyaXZlZC5mICYgQ0xFQU4pID09PSAwICYmIGRlcml2ZWQucmVhY3Rpb25zICE9PSBudWxsKSB8fFxuXHRcdFx0XHRkZXBlbmRzX29uX29sZF92YWx1ZXMoZGVyaXZlZClcblx0XHRcdCkge1xuXHRcdFx0XHR2YWx1ZSA9IGV4ZWN1dGVfZGVyaXZlZChkZXJpdmVkKTtcblx0XHRcdH1cblxuXHRcdFx0b2xkX3ZhbHVlcy5zZXQoZGVyaXZlZCwgdmFsdWUpO1xuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKFxuXHRcdGlzX2Rlcml2ZWQgJiZcblx0XHQoIWJhdGNoX3ZhbHVlcz8uaGFzKHNpZ25hbCkgfHwgKGN1cnJlbnRfYmF0Y2g/LmlzX2ZvcmsgJiYgIWVmZmVjdF90cmFja2luZygpKSlcblx0KSB7XG5cdFx0ZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCk7XG5cblx0XHRpZiAoaXNfZGlydHkoZGVyaXZlZCkpIHtcblx0XHRcdHVwZGF0ZV9kZXJpdmVkKGRlcml2ZWQpO1xuXHRcdH1cblxuXHRcdGlmIChpc191cGRhdGluZ19lZmZlY3QgJiYgZWZmZWN0X3RyYWNraW5nKCkgJiYgKGRlcml2ZWQuZiAmIENPTk5FQ1RFRCkgPT09IDApIHtcblx0XHRcdHJlY29ubmVjdChkZXJpdmVkKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoYmF0Y2hfdmFsdWVzPy5oYXMoc2lnbmFsKSkge1xuXHRcdHJldHVybiBiYXRjaF92YWx1ZXMuZ2V0KHNpZ25hbCk7XG5cdH1cblxuXHRpZiAoKHNpZ25hbC5mICYgRVJST1JfVkFMVUUpICE9PSAwKSB7XG5cdFx0dGhyb3cgc2lnbmFsLnY7XG5cdH1cblxuXHRyZXR1cm4gc2lnbmFsLnY7XG59XG5cbi8qKlxuICogKFJlKWNvbm5lY3QgYSBkaXNjb25uZWN0ZWQgZGVyaXZlZCwgc28gdGhhdCBpdCBpcyBub3RpZmllZFxuICogb2YgY2hhbmdlcyBpbiBgbWFya19yZWFjdGlvbnNgXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqL1xuZnVuY3Rpb24gcmVjb25uZWN0KGRlcml2ZWQpIHtcblx0aWYgKGRlcml2ZWQuZGVwcyA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdGRlcml2ZWQuZiBePSBDT05ORUNURUQ7XG5cblx0Zm9yIChjb25zdCBkZXAgb2YgZGVyaXZlZC5kZXBzKSB7XG5cdFx0KGRlcC5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKGRlcml2ZWQpO1xuXG5cdFx0aWYgKChkZXAuZiAmIERFUklWRUQpICE9PSAwICYmIChkZXAuZiAmIENPTk5FQ1RFRCkgPT09IDApIHtcblx0XHRcdHJlY29ubmVjdCgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChkZXApKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZCAqL1xuZnVuY3Rpb24gZGVwZW5kc19vbl9vbGRfdmFsdWVzKGRlcml2ZWQpIHtcblx0aWYgKGRlcml2ZWQudiA9PT0gVU5JTklUSUFMSVpFRCkgcmV0dXJuIHRydWU7IC8vIHdlIGRvbid0IGtub3csIHNvIGFzc3VtZSB0aGUgd29yc3Rcblx0aWYgKGRlcml2ZWQuZGVwcyA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG5cdGZvciAoY29uc3QgZGVwIG9mIGRlcml2ZWQuZGVwcykge1xuXHRcdGlmIChvbGRfdmFsdWVzLmhhcyhkZXApKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoKGRlcC5mICYgREVSSVZFRCkgIT09IDAgJiYgZGVwZW5kc19vbl9vbGRfdmFsdWVzKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcCkpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTGlrZSBgZ2V0YCwgYnV0IGNoZWNrcyBmb3IgYHVuZGVmaW5lZGAuIFVzZWQgZm9yIGB2YXJgIGRlY2xhcmF0aW9ucyBiZWNhdXNlIHRoZXkgY2FuIGJlIGFjY2Vzc2VkIGJlZm9yZSBiZWluZyBkZWNsYXJlZFxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VmFsdWU8Vj4gfCB1bmRlZmluZWR9IHNpZ25hbFxuICogQHJldHVybnMge1YgfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX2dldChzaWduYWwpIHtcblx0cmV0dXJuIHNpZ25hbCAmJiBnZXQoc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBXaGVuIHVzZWQgaW5zaWRlIGEgW2AkZGVyaXZlZGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZGVyaXZlZCkgb3IgW2AkZWZmZWN0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRlZmZlY3QpLFxuICogYW55IHN0YXRlIHJlYWQgaW5zaWRlIGBmbmAgd2lsbCBub3QgYmUgdHJlYXRlZCBhcyBhIGRlcGVuZGVuY3kuXG4gKlxuICogYGBgdHNcbiAqICRlZmZlY3QoKCkgPT4ge1xuICogICAvLyB0aGlzIHdpbGwgcnVuIHdoZW4gYGRhdGFgIGNoYW5nZXMsIGJ1dCBub3Qgd2hlbiBgdGltZWAgY2hhbmdlc1xuICogICBzYXZlKGRhdGEsIHtcbiAqICAgICB0aW1lc3RhbXA6IHVudHJhY2soKCkgPT4gdGltZSlcbiAqICAgfSk7XG4gKiB9KTtcbiAqIGBgYFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW50cmFjayhmbikge1xuXHR2YXIgcHJldmlvdXNfdW50cmFja2luZyA9IHVudHJhY2tpbmc7XG5cdHRyeSB7XG5cdFx0dW50cmFja2luZyA9IHRydWU7XG5cdFx0cmV0dXJuIGZuKCk7XG5cdH0gZmluYWxseSB7XG5cdFx0dW50cmFja2luZyA9IHByZXZpb3VzX3VudHJhY2tpbmc7XG5cdH1cbn1cblxuY29uc3QgU1RBVFVTX01BU0sgPSB+KERJUlRZIHwgTUFZQkVfRElSVFkgfCBDTEVBTik7XG5cbi8qKlxuICogQHBhcmFtIHtTaWduYWx9IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc2lnbmFsX3N0YXR1cyhzaWduYWwsIHN0YXR1cykge1xuXHRzaWduYWwuZiA9IChzaWduYWwuZiAmIFNUQVRVU19NQVNLKSB8IHN0YXR1cztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+fSBvYmpcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nIHwgc3ltYm9sPn0ga2V5c1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZV9mcm9tX29iamVjdChvYmosIGtleXMpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPn0gKi9cblx0dmFyIHJlc3VsdCA9IHt9O1xuXG5cdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuXHRcdFx0cmVzdWx0W2tleV0gPSBvYmpba2V5XTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKHZhciBzeW1ib2wgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKSB7XG5cdFx0aWYgKE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltYm9sKSAmJiAha2V5cy5pbmNsdWRlcyhzeW1ib2wpKSB7XG5cdFx0XHRyZXN1bHRbc3ltYm9sXSA9IG9ialtzeW1ib2xdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUG9zc2libHkgdHJhdmVyc2UgYW4gb2JqZWN0IGFuZCByZWFkIGFsbCBpdHMgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkncmUgYWxsIHJlYWN0aXZlIGluIGNhc2UgdGhpcyBpcyBgJHN0YXRlYC5cbiAqIERvZXMgb25seSBjaGVjayBmaXJzdCBsZXZlbCBvZiBhbiBvYmplY3QgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKGhldXJpc3RpYyBzaG91bGQgYmUgZ29vZCBmb3IgOTklIG9mIGFsbCBjYXNlcykuXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcF9yZWFkX3N0YXRlKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8ICF2YWx1ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdGRlZXBfcmVhZCh2YWx1ZSk7XG5cdH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0Zm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRjb25zdCBwcm9wID0gdmFsdWVba2V5XTtcblx0XHRcdGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAmJiBTVEFURV9TWU1CT0wgaW4gcHJvcCkge1xuXHRcdFx0XHRkZWVwX3JlYWQocHJvcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogRGVlcGx5IHRyYXZlcnNlIGFuIG9iamVjdCBhbmQgcmVhZCBhbGwgaXRzIHByb3BlcnRpZXNcbiAqIHNvIHRoYXQgdGhleSdyZSBhbGwgcmVhY3RpdmUgaW4gY2FzZSB0aGlzIGlzIGAkc3RhdGVgXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7U2V0PGFueT59IHZpc2l0ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcF9yZWFkKHZhbHVlLCB2aXNpdGVkID0gbmV3IFNldCgpKSB7XG5cdGlmIChcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHQvLyBXZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlIERPTSBlbGVtZW50c1xuXHRcdCEodmFsdWUgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkgJiZcblx0XHQhdmlzaXRlZC5oYXModmFsdWUpXG5cdCkge1xuXHRcdHZpc2l0ZWQuYWRkKHZhbHVlKTtcblx0XHQvLyBXaGVuIHdvcmtpbmcgd2l0aCBhIHBvc3NpYmxlIFN2ZWx0ZURhdGUsIHRoaXNcblx0XHQvLyB3aWxsIGVuc3VyZSB3ZSBjYXB0dXJlIGNoYW5nZXMgdG8gaXQuXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0dmFsdWUuZ2V0VGltZSgpO1xuXHRcdH1cblx0XHRmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlZXBfcmVhZCh2YWx1ZVtrZXldLCB2aXNpdGVkKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gY29udGludWVcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKHZhbHVlKTtcblx0XHRpZiAoXG5cdFx0XHRwcm90byAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IEFycmF5LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IE1hcC5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBTZXQucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gRGF0ZS5wcm90b3R5cGVcblx0XHQpIHtcblx0XHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gZ2V0X2Rlc2NyaXB0b3JzKHByb3RvKTtcblx0XHRcdGZvciAobGV0IGtleSBpbiBkZXNjcmlwdG9ycykge1xuXHRcdFx0XHRjb25zdCBnZXQgPSBkZXNjcmlwdG9yc1trZXldLmdldDtcblx0XHRcdFx0aWYgKGdldCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRnZXQuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gY29udGludWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IEFjdGlvbiwgQWN0aW9uUmV0dXJuIH0gZnJvbSAnLi4vYWN0aW9uL3B1YmxpYycgKi9cbi8qKiBAaW1wb3J0IHsgQXR0YWNobWVudCB9IGZyb20gJy4vcHVibGljJyAqL1xuaW1wb3J0IHsgbm9vcCwgcmVuZGVyX2VmZmVjdCB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgQVRUQUNITUVOVF9LRVkgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uL2luZGV4LWNsaWVudC5qcyc7XG5pbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGtleSB0aGF0IHdpbGwgYmUgcmVjb2duaXNlZCBhcyBhbiBhdHRhY2htZW50IHdoZW4gdGhlIG9iamVjdCBpcyBzcHJlYWQgb250byBhbiBlbGVtZW50LFxuICogYXMgYSBwcm9ncmFtbWF0aWMgYWx0ZXJuYXRpdmUgdG8gdXNpbmcgYHtAYXR0YWNoIC4uLn1gLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGxpYnJhcnkgYXV0aG9ycywgdGhvdWdoXG4gKiBpcyBnZW5lcmFsbHkgbm90IG5lZWRlZCB3aGVuIGJ1aWxkaW5nIGFuIGFwcC5cbiAqXG4gKiBgYGBzdmVsdGVcbiAqIDxzY3JpcHQ+XG4gKiBcdGltcG9ydCB7IGNyZWF0ZUF0dGFjaG1lbnRLZXkgfSBmcm9tICdzdmVsdGUvYXR0YWNobWVudHMnO1xuICpcbiAqIFx0Y29uc3QgcHJvcHMgPSB7XG4gKiBcdFx0Y2xhc3M6ICdjb29sJyxcbiAqIFx0XHRvbmNsaWNrOiAoKSA9PiBhbGVydCgnY2xpY2tlZCcpLFxuICogXHRcdFtjcmVhdGVBdHRhY2htZW50S2V5KCldOiAobm9kZSkgPT4ge1xuICogXHRcdFx0bm9kZS50ZXh0Q29udGVudCA9ICdhdHRhY2hlZCEnO1xuICogXHRcdH1cbiAqIFx0fTtcbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxidXR0b24gey4uLnByb3BzfT5jbGljayBtZTwvYnV0dG9uPlxuICogYGBgXG4gKiBAc2luY2UgNS4yOVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXR0YWNobWVudEtleSgpIHtcblx0cmV0dXJuIFN5bWJvbChBVFRBQ0hNRU5UX0tFWSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gW2FjdGlvbl0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3VzZSkgaW50byBhbiBbYXR0YWNobWVudF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL0BhdHRhY2gpIGtlZXBpbmcgdGhlIHNhbWUgYmVoYXZpb3IuXG4gKiBJdCdzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBzdGFydCB1c2luZyBhdHRhY2htZW50cyBvbiBjb21wb25lbnRzIGJ1dCB5b3UgaGF2ZSBhY3Rpb25zIHByb3ZpZGVkIGJ5IGEgbGlicmFyeS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IF9yZXR1cm5zXyB0aGUgYXJndW1lbnQgdG8gdGhlXG4gKiBhY3Rpb24gZnVuY3Rpb24sIG5vdCB0aGUgYXJndW1lbnQgaXRzZWxmLlxuICpcbiAqIGBgYHN2ZWx0ZVxuICogPCEtLSB3aXRoIGFuIGFjdGlvbiAtLT5cbiAqIDxkaXYgdXNlOmZvbz17YmFyfT4uLi48L2Rpdj5cbiAqXG4gKiA8IS0tIHdpdGggYW4gYXR0YWNobWVudCAtLT5cbiAqIDxkaXYge0BhdHRhY2ggZnJvbUFjdGlvbihmb28sICgpID0+IGJhcil9Pi4uLjwvZGl2PlxuICogYGBgXG4gKiBAdGVtcGxhdGUge0V2ZW50VGFyZ2V0fSBFXG4gKiBAdGVtcGxhdGUge3Vua25vd259IFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtBY3Rpb248RSwgVD4gfCAoKGVsZW1lbnQ6IEUsIGFyZzogVCkgPT4gdm9pZCB8IEFjdGlvblJldHVybjxUPil9IGFjdGlvbiBUaGUgYWN0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0geygpID0+IFR9IGZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBhcmd1bWVudCBmb3IgdGhlIGFjdGlvblxuICogQHJldHVybnMge0F0dGFjaG1lbnQ8RT59XG4gKi9cbi8qKlxuICogQ29udmVydHMgYW4gW2FjdGlvbl0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3VzZSkgaW50byBhbiBbYXR0YWNobWVudF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL0BhdHRhY2gpIGtlZXBpbmcgdGhlIHNhbWUgYmVoYXZpb3IuXG4gKiBJdCdzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBzdGFydCB1c2luZyBhdHRhY2htZW50cyBvbiBjb21wb25lbnRzIGJ1dCB5b3UgaGF2ZSBhY3Rpb25zIHByb3ZpZGVkIGJ5IGEgbGlicmFyeS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IF9yZXR1cm5zXyB0aGUgYXJndW1lbnQgdG8gdGhlXG4gKiBhY3Rpb24gZnVuY3Rpb24sIG5vdCB0aGUgYXJndW1lbnQgaXRzZWxmLlxuICpcbiAqIGBgYHN2ZWx0ZVxuICogPCEtLSB3aXRoIGFuIGFjdGlvbiAtLT5cbiAqIDxkaXYgdXNlOmZvbz17YmFyfT4uLi48L2Rpdj5cbiAqXG4gKiA8IS0tIHdpdGggYW4gYXR0YWNobWVudCAtLT5cbiAqIDxkaXYge0BhdHRhY2ggZnJvbUFjdGlvbihmb28sICgpID0+IGJhcil9Pi4uLjwvZGl2PlxuICogYGBgXG4gKiBAdGVtcGxhdGUge0V2ZW50VGFyZ2V0fSBFXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7QWN0aW9uPEUsIHZvaWQ+IHwgKChlbGVtZW50OiBFKSA9PiB2b2lkIHwgQWN0aW9uUmV0dXJuPHZvaWQ+KX0gYWN0aW9uIFRoZSBhY3Rpb24gZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBdHRhY2htZW50PEU+fVxuICovXG4vKipcbiAqIENvbnZlcnRzIGFuIFthY3Rpb25dKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS91c2UpIGludG8gYW4gW2F0dGFjaG1lbnRdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9AYXR0YWNoKSBrZWVwaW5nIHRoZSBzYW1lIGJlaGF2aW9yLlxuICogSXQncyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gc3RhcnQgdXNpbmcgYXR0YWNobWVudHMgb24gY29tcG9uZW50cyBidXQgeW91IGhhdmUgYWN0aW9ucyBwcm92aWRlZCBieSBhIGxpYnJhcnkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCBfcmV0dXJuc18gdGhlIGFyZ3VtZW50IHRvIHRoZVxuICogYWN0aW9uIGZ1bmN0aW9uLCBub3QgdGhlIGFyZ3VtZW50IGl0c2VsZi5cbiAqXG4gKiBgYGBzdmVsdGVcbiAqIDwhLS0gd2l0aCBhbiBhY3Rpb24gLS0+XG4gKiA8ZGl2IHVzZTpmb289e2Jhcn0+Li4uPC9kaXY+XG4gKlxuICogPCEtLSB3aXRoIGFuIGF0dGFjaG1lbnQgLS0+XG4gKiA8ZGl2IHtAYXR0YWNoIGZyb21BY3Rpb24oZm9vLCAoKSA9PiBiYXIpfT4uLi48L2Rpdj5cbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSB7RXZlbnRUYXJnZXR9IEVcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gVFxuICogQHBhcmFtIHtBY3Rpb248RSwgVD4gfCAoKGVsZW1lbnQ6IEUsIGFyZzogVCkgPT4gdm9pZCB8IEFjdGlvblJldHVybjxUPil9IGFjdGlvbiBUaGUgYWN0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0geygpID0+IFR9IGZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBhcmd1bWVudCBmb3IgdGhlIGFjdGlvblxuICogQHJldHVybnMge0F0dGFjaG1lbnQ8RT59XG4gKiBAc2luY2UgNS4zMlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFjdGlvbihhY3Rpb24sIGZuID0gLyoqIEB0eXBlIHsoKSA9PiBUfSAqLyAobm9vcCkpIHtcblx0cmV0dXJuIChlbGVtZW50KSA9PiB7XG5cdFx0Y29uc3QgeyB1cGRhdGUsIGRlc3Ryb3kgfSA9IHVudHJhY2soKCkgPT4gYWN0aW9uKGVsZW1lbnQsIGZuKCkpID8/IHt9KTtcblxuXHRcdGlmICh1cGRhdGUpIHtcblx0XHRcdHZhciByYW4gPSBmYWxzZTtcblx0XHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBhcmcgPSBmbigpO1xuXHRcdFx0XHRpZiAocmFuKSB1cGRhdGUoYXJnKTtcblx0XHRcdH0pO1xuXHRcdFx0cmFuID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoZGVzdHJveSkge1xuXHRcdFx0dGVhcmRvd24oZGVzdHJveSk7XG5cdFx0fVxuXHR9O1xufVxuIiwgImNvbnN0IHJlZ2V4X3JldHVybl9jaGFyYWN0ZXJzID0gL1xcci9nO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKHN0cikge1xuXHRzdHIgPSBzdHIucmVwbGFjZShyZWdleF9yZXR1cm5fY2hhcmFjdGVycywgJycpO1xuXHRsZXQgaGFzaCA9IDUzODE7XG5cdGxldCBpID0gc3RyLmxlbmd0aDtcblxuXHR3aGlsZSAoaS0tKSBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcblx0cmV0dXJuIChoYXNoID4+PiAwKS50b1N0cmluZygzNik7XG59XG5cbmNvbnN0IFZPSURfRUxFTUVOVF9OQU1FUyA9IFtcblx0J2FyZWEnLFxuXHQnYmFzZScsXG5cdCdicicsXG5cdCdjb2wnLFxuXHQnY29tbWFuZCcsXG5cdCdlbWJlZCcsXG5cdCdocicsXG5cdCdpbWcnLFxuXHQnaW5wdXQnLFxuXHQna2V5Z2VuJyxcblx0J2xpbmsnLFxuXHQnbWV0YScsXG5cdCdwYXJhbScsXG5cdCdzb3VyY2UnLFxuXHQndHJhY2snLFxuXHQnd2JyJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgb2YgYSB2b2lkIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc192b2lkKG5hbWUpIHtcblx0cmV0dXJuIFZPSURfRUxFTUVOVF9OQU1FUy5pbmNsdWRlcyhuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IFJFU0VSVkVEX1dPUkRTID0gW1xuXHQnYXJndW1lbnRzJyxcblx0J2F3YWl0Jyxcblx0J2JyZWFrJyxcblx0J2Nhc2UnLFxuXHQnY2F0Y2gnLFxuXHQnY2xhc3MnLFxuXHQnY29uc3QnLFxuXHQnY29udGludWUnLFxuXHQnZGVidWdnZXInLFxuXHQnZGVmYXVsdCcsXG5cdCdkZWxldGUnLFxuXHQnZG8nLFxuXHQnZWxzZScsXG5cdCdlbnVtJyxcblx0J2V2YWwnLFxuXHQnZXhwb3J0Jyxcblx0J2V4dGVuZHMnLFxuXHQnZmFsc2UnLFxuXHQnZmluYWxseScsXG5cdCdmb3InLFxuXHQnZnVuY3Rpb24nLFxuXHQnaWYnLFxuXHQnaW1wbGVtZW50cycsXG5cdCdpbXBvcnQnLFxuXHQnaW4nLFxuXHQnaW5zdGFuY2VvZicsXG5cdCdpbnRlcmZhY2UnLFxuXHQnbGV0Jyxcblx0J25ldycsXG5cdCdudWxsJyxcblx0J3BhY2thZ2UnLFxuXHQncHJpdmF0ZScsXG5cdCdwcm90ZWN0ZWQnLFxuXHQncHVibGljJyxcblx0J3JldHVybicsXG5cdCdzdGF0aWMnLFxuXHQnc3VwZXInLFxuXHQnc3dpdGNoJyxcblx0J3RoaXMnLFxuXHQndGhyb3cnLFxuXHQndHJ1ZScsXG5cdCd0cnknLFxuXHQndHlwZW9mJyxcblx0J3ZhcicsXG5cdCd2b2lkJyxcblx0J3doaWxlJyxcblx0J3dpdGgnLFxuXHQneWllbGQnXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGB3b3JkYCBpcyBhIHJlc2VydmVkIEphdmFTY3JpcHQga2V5d29yZFxuICogQHBhcmFtIHtzdHJpbmd9IHdvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Jlc2VydmVkKHdvcmQpIHtcblx0cmV0dXJuIFJFU0VSVkVEX1dPUkRTLmluY2x1ZGVzKHdvcmQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jYXB0dXJlX2V2ZW50KG5hbWUpIHtcblx0cmV0dXJuIG5hbWUuZW5kc1dpdGgoJ2NhcHR1cmUnKSAmJiBuYW1lICE9PSAnZ290cG9pbnRlcmNhcHR1cmUnICYmIG5hbWUgIT09ICdsb3N0cG9pbnRlcmNhcHR1cmUnO1xufVxuXG4vKiogTGlzdCBvZiBFbGVtZW50IGV2ZW50cyB0aGF0IHdpbGwgYmUgZGVsZWdhdGVkICovXG5jb25zdCBERUxFR0FURURfRVZFTlRTID0gW1xuXHQnYmVmb3JlaW5wdXQnLFxuXHQnY2xpY2snLFxuXHQnY2hhbmdlJyxcblx0J2RibGNsaWNrJyxcblx0J2NvbnRleHRtZW51Jyxcblx0J2ZvY3VzaW4nLFxuXHQnZm9jdXNvdXQnLFxuXHQnaW5wdXQnLFxuXHQna2V5ZG93bicsXG5cdCdrZXl1cCcsXG5cdCdtb3VzZWRvd24nLFxuXHQnbW91c2Vtb3ZlJyxcblx0J21vdXNlb3V0Jyxcblx0J21vdXNlb3ZlcicsXG5cdCdtb3VzZXVwJyxcblx0J3BvaW50ZXJkb3duJyxcblx0J3BvaW50ZXJtb3ZlJyxcblx0J3BvaW50ZXJvdXQnLFxuXHQncG9pbnRlcm92ZXInLFxuXHQncG9pbnRlcnVwJyxcblx0J3RvdWNoZW5kJyxcblx0J3RvdWNobW92ZScsXG5cdCd0b3VjaHN0YXJ0J1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgZXZlbnRfbmFtZWAgaXMgYSBkZWxlZ2F0ZWQgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5fZGVsZWdhdGVfZXZlbnQoZXZlbnRfbmFtZSkge1xuXHRyZXR1cm4gREVMRUdBVEVEX0VWRU5UUy5pbmNsdWRlcyhldmVudF9uYW1lKTtcbn1cblxuLyoqXG4gKiBBdHRyaWJ1dGVzIHRoYXQgYXJlIGJvb2xlYW4sIGkuZS4gdGhleSBhcmUgcHJlc2VudCBvciBub3QgcHJlc2VudC5cbiAqL1xuY29uc3QgRE9NX0JPT0xFQU5fQVRUUklCVVRFUyA9IFtcblx0J2FsbG93ZnVsbHNjcmVlbicsXG5cdCdhc3luYycsXG5cdCdhdXRvZm9jdXMnLFxuXHQnYXV0b3BsYXknLFxuXHQnY2hlY2tlZCcsXG5cdCdjb250cm9scycsXG5cdCdkZWZhdWx0Jyxcblx0J2Rpc2FibGVkJyxcblx0J2Zvcm1ub3ZhbGlkYXRlJyxcblx0J2luZGV0ZXJtaW5hdGUnLFxuXHQnaW5lcnQnLFxuXHQnaXNtYXAnLFxuXHQnbG9vcCcsXG5cdCdtdWx0aXBsZScsXG5cdCdtdXRlZCcsXG5cdCdub21vZHVsZScsXG5cdCdub3ZhbGlkYXRlJyxcblx0J29wZW4nLFxuXHQncGxheXNpbmxpbmUnLFxuXHQncmVhZG9ubHknLFxuXHQncmVxdWlyZWQnLFxuXHQncmV2ZXJzZWQnLFxuXHQnc2VhbWxlc3MnLFxuXHQnc2VsZWN0ZWQnLFxuXHQnd2Via2l0ZGlyZWN0b3J5Jyxcblx0J2RlZmVyJyxcblx0J2Rpc2FibGVwaWN0dXJlaW5waWN0dXJlJyxcblx0J2Rpc2FibGVyZW1vdGVwbGF5YmFjaydcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19ib29sZWFuX2F0dHJpYnV0ZShuYW1lKSB7XG5cdHJldHVybiBET01fQk9PTEVBTl9BVFRSSUJVVEVTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBzaG91bGQgYmUgYWxpYXNlZCB0byB0aGVpciBwcm9wZXJ0eSBuYW1lc1xuICogYmVjYXVzZSB0aGV5IGJlaGF2ZSBkaWZmZXJlbnRseSBiZXR3ZWVuIHNldHRpbmcgdGhlbSBhcyBhbiBhdHRyaWJ1dGUgYW5kXG4gKiBzZXR0aW5nIHRoZW0gYXMgYSBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgQVRUUklCVVRFX0FMSUFTRVMgPSB7XG5cdC8vIG5vIGBjbGFzczogJ2NsYXNzTmFtZSdgIGJlY2F1c2Ugd2UgaGFuZGxlIHRoYXQgc2VwYXJhdGVseVxuXHRmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcblx0aXNtYXA6ICdpc01hcCcsXG5cdG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuXHRwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcblx0cmVhZG9ubHk6ICdyZWFkT25seScsXG5cdGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG5cdGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuXHRzcmNvYmplY3Q6ICdzcmNPYmplY3QnLFxuXHRub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG5cdGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbHNjcmVlbicsXG5cdGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuXHRkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVfYXR0cmlidXRlKG5hbWUpIHtcblx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0cmV0dXJuIEFUVFJJQlVURV9BTElBU0VTW25hbWVdID8/IG5hbWU7XG59XG5cbmNvbnN0IERPTV9QUk9QRVJUSUVTID0gW1xuXHQuLi5ET01fQk9PTEVBTl9BVFRSSUJVVEVTLFxuXHQnZm9ybU5vVmFsaWRhdGUnLFxuXHQnaXNNYXAnLFxuXHQnbm9Nb2R1bGUnLFxuXHQncGxheXNJbmxpbmUnLFxuXHQncmVhZE9ubHknLFxuXHQndmFsdWUnLFxuXHQndm9sdW1lJyxcblx0J2RlZmF1bHRWYWx1ZScsXG5cdCdkZWZhdWx0Q2hlY2tlZCcsXG5cdCdzcmNPYmplY3QnLFxuXHQnbm9WYWxpZGF0ZScsXG5cdCdhbGxvd0Z1bGxzY3JlZW4nLFxuXHQnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuXHQnZGlzYWJsZVJlbW90ZVBsYXliYWNrJ1xuXTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZG9tX3Byb3BlcnR5KG5hbWUpIHtcblx0cmV0dXJuIERPTV9QUk9QRVJUSUVTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBOT05fU1RBVElDX1BST1BFUlRJRVMgPSBbJ2F1dG9mb2N1cycsICdtdXRlZCcsICdkZWZhdWx0VmFsdWUnLCAnZGVmYXVsdENoZWNrZWQnXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYXR0cmlidXRlIGNhbm5vdCBiZSBzZXQgdGhyb3VnaCB0aGUgdGVtcGxhdGVcbiAqIHN0cmluZywgaS5lLiBuZWVkcyBzb21lIGtpbmQgb2YgSmF2YVNjcmlwdCBoYW5kbGluZyB0byB3b3JrLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbm5vdF9iZV9zZXRfc3RhdGljYWxseShuYW1lKSB7XG5cdHJldHVybiBOT05fU1RBVElDX1BST1BFUlRJRVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbi8qKlxuICogU3Vic2V0IG9mIGRlbGVnYXRlZCBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBhc3NpdmUgYnkgZGVmYXVsdC5cbiAqIFRoZXNlIHR3byBhcmUgYWxyZWFkeSBwYXNzaXZlIHZpYSBicm93c2VyIGRlZmF1bHRzIG9uIHdpbmRvdywgZG9jdW1lbnQgYW5kIGJvZHkuXG4gKiBCdXQgc2luY2VcbiAqIC0gd2UncmUgZGVsZWdhdGluZyB0aGVtXG4gKiAtIHRoZXkgaGFwcGVuIG9mdGVuXG4gKiAtIHRoZXkgYXBwbHkgdG8gbW9iaWxlIHdoaWNoIGlzIGdlbmVyYWxseSBsZXNzIHBlcmZvcm1hbnRcbiAqIHdlJ3JlIG1hcmtpbmcgdGhlbSBhcyBwYXNzaXZlIGJ5IGRlZmF1bHQgZm9yIG90aGVyIGVsZW1lbnRzLCB0b28uXG4gKi9cbmNvbnN0IFBBU1NJVkVfRVZFTlRTID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZSddO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGBuYW1lYCBpcyBhIHBhc3NpdmUgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wYXNzaXZlX2V2ZW50KG5hbWUpIHtcblx0cmV0dXJuIFBBU1NJVkVfRVZFTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBDT05URU5UX0VESVRBQkxFX0JJTkRJTkdTID0gWyd0ZXh0Q29udGVudCcsICdpbm5lckhUTUwnLCAnaW5uZXJUZXh0J107XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2NvbnRlbnRfZWRpdGFibGVfYmluZGluZyhuYW1lKSB7XG5cdHJldHVybiBDT05URU5UX0VESVRBQkxFX0JJTkRJTkdTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBMT0FEX0VSUk9SX0VMRU1FTlRTID0gW1xuXHQnYm9keScsXG5cdCdlbWJlZCcsXG5cdCdpZnJhbWUnLFxuXHQnaW1nJyxcblx0J2xpbmsnLFxuXHQnb2JqZWN0Jyxcblx0J3NjcmlwdCcsXG5cdCdzdHlsZScsXG5cdCd0cmFjaydcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgZW1pdHMgYGxvYWRgIGFuZCBgZXJyb3JgIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2xvYWRfZXJyb3JfZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBMT0FEX0VSUk9SX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBTVkdfRUxFTUVOVFMgPSBbXG5cdCdhbHRHbHlwaCcsXG5cdCdhbHRHbHlwaERlZicsXG5cdCdhbHRHbHlwaEl0ZW0nLFxuXHQnYW5pbWF0ZScsXG5cdCdhbmltYXRlQ29sb3InLFxuXHQnYW5pbWF0ZU1vdGlvbicsXG5cdCdhbmltYXRlVHJhbnNmb3JtJyxcblx0J2NpcmNsZScsXG5cdCdjbGlwUGF0aCcsXG5cdCdjb2xvci1wcm9maWxlJyxcblx0J2N1cnNvcicsXG5cdCdkZWZzJyxcblx0J2Rlc2MnLFxuXHQnZGlzY2FyZCcsXG5cdCdlbGxpcHNlJyxcblx0J2ZlQmxlbmQnLFxuXHQnZmVDb2xvck1hdHJpeCcsXG5cdCdmZUNvbXBvbmVudFRyYW5zZmVyJyxcblx0J2ZlQ29tcG9zaXRlJyxcblx0J2ZlQ29udm9sdmVNYXRyaXgnLFxuXHQnZmVEaWZmdXNlTGlnaHRpbmcnLFxuXHQnZmVEaXNwbGFjZW1lbnRNYXAnLFxuXHQnZmVEaXN0YW50TGlnaHQnLFxuXHQnZmVEcm9wU2hhZG93Jyxcblx0J2ZlRmxvb2QnLFxuXHQnZmVGdW5jQScsXG5cdCdmZUZ1bmNCJyxcblx0J2ZlRnVuY0cnLFxuXHQnZmVGdW5jUicsXG5cdCdmZUdhdXNzaWFuQmx1cicsXG5cdCdmZUltYWdlJyxcblx0J2ZlTWVyZ2UnLFxuXHQnZmVNZXJnZU5vZGUnLFxuXHQnZmVNb3JwaG9sb2d5Jyxcblx0J2ZlT2Zmc2V0Jyxcblx0J2ZlUG9pbnRMaWdodCcsXG5cdCdmZVNwZWN1bGFyTGlnaHRpbmcnLFxuXHQnZmVTcG90TGlnaHQnLFxuXHQnZmVUaWxlJyxcblx0J2ZlVHVyYnVsZW5jZScsXG5cdCdmaWx0ZXInLFxuXHQnZm9udCcsXG5cdCdmb250LWZhY2UnLFxuXHQnZm9udC1mYWNlLWZvcm1hdCcsXG5cdCdmb250LWZhY2UtbmFtZScsXG5cdCdmb250LWZhY2Utc3JjJyxcblx0J2ZvbnQtZmFjZS11cmknLFxuXHQnZm9yZWlnbk9iamVjdCcsXG5cdCdnJyxcblx0J2dseXBoJyxcblx0J2dseXBoUmVmJyxcblx0J2hhdGNoJyxcblx0J2hhdGNocGF0aCcsXG5cdCdoa2VybicsXG5cdCdpbWFnZScsXG5cdCdsaW5lJyxcblx0J2xpbmVhckdyYWRpZW50Jyxcblx0J21hcmtlcicsXG5cdCdtYXNrJyxcblx0J21lc2gnLFxuXHQnbWVzaGdyYWRpZW50Jyxcblx0J21lc2hwYXRjaCcsXG5cdCdtZXNocm93Jyxcblx0J21ldGFkYXRhJyxcblx0J21pc3NpbmctZ2x5cGgnLFxuXHQnbXBhdGgnLFxuXHQncGF0aCcsXG5cdCdwYXR0ZXJuJyxcblx0J3BvbHlnb24nLFxuXHQncG9seWxpbmUnLFxuXHQncmFkaWFsR3JhZGllbnQnLFxuXHQncmVjdCcsXG5cdCdzZXQnLFxuXHQnc29saWRjb2xvcicsXG5cdCdzdG9wJyxcblx0J3N2ZycsXG5cdCdzd2l0Y2gnLFxuXHQnc3ltYm9sJyxcblx0J3RleHQnLFxuXHQndGV4dFBhdGgnLFxuXHQndHJlZicsXG5cdCd0c3BhbicsXG5cdCd1bmtub3duJyxcblx0J3VzZScsXG5cdCd2aWV3Jyxcblx0J3ZrZXJuJ1xuXTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5leHBvcnQgZnVuY3Rpb24gaXNfc3ZnKG5hbWUpIHtcblx0cmV0dXJuIFNWR19FTEVNRU5UUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgTUFUSE1MX0VMRU1FTlRTID0gW1xuXHQnYW5ub3RhdGlvbicsXG5cdCdhbm5vdGF0aW9uLXhtbCcsXG5cdCdtYWN0aW9uJyxcblx0J21hdGgnLFxuXHQnbWVycm9yJyxcblx0J21mcmFjJyxcblx0J21pJyxcblx0J21tdWx0aXNjcmlwdHMnLFxuXHQnbW4nLFxuXHQnbW8nLFxuXHQnbW92ZXInLFxuXHQnbXBhZGRlZCcsXG5cdCdtcGhhbnRvbScsXG5cdCdtcHJlc2NyaXB0cycsXG5cdCdtcm9vdCcsXG5cdCdtcm93Jyxcblx0J21zJyxcblx0J21zcGFjZScsXG5cdCdtc3FydCcsXG5cdCdtc3R5bGUnLFxuXHQnbXN1YicsXG5cdCdtc3Vic3VwJyxcblx0J21zdXAnLFxuXHQnbXRhYmxlJyxcblx0J210ZCcsXG5cdCdtdGV4dCcsXG5cdCdtdHInLFxuXHQnbXVuZGVyJyxcblx0J211bmRlcm92ZXInLFxuXHQnc2VtYW50aWNzJ1xuXTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5leHBvcnQgZnVuY3Rpb24gaXNfbWF0aG1sKG5hbWUpIHtcblx0cmV0dXJuIE1BVEhNTF9FTEVNRU5UUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgU1RBVEVfQ1JFQVRJT05fUlVORVMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQnJHN0YXRlJyxcblx0JyRzdGF0ZS5yYXcnLFxuXHQnJGRlcml2ZWQnLFxuXHQnJGRlcml2ZWQuYnknXG5dKTtcblxuY29uc3QgUlVORVMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQuLi5TVEFURV9DUkVBVElPTl9SVU5FUyxcblx0JyRzdGF0ZS5lYWdlcicsXG5cdCckc3RhdGUuc25hcHNob3QnLFxuXHQnJHByb3BzJyxcblx0JyRwcm9wcy5pZCcsXG5cdCckYmluZGFibGUnLFxuXHQnJGVmZmVjdCcsXG5cdCckZWZmZWN0LnByZScsXG5cdCckZWZmZWN0LnRyYWNraW5nJyxcblx0JyRlZmZlY3Qucm9vdCcsXG5cdCckZWZmZWN0LnBlbmRpbmcnLFxuXHQnJGluc3BlY3QnLFxuXHQnJGluc3BlY3QoKS53aXRoJyxcblx0JyRpbnNwZWN0LnRyYWNlJyxcblx0JyRob3N0J1xuXSk7XG5cbi8qKiBAdHlwZWRlZiB7dHlwZW9mIFJVTkVTW251bWJlcl19IFJ1bmVOYW1lICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuYW1lIGlzIFJ1bmVOYW1lfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcnVuZShuYW1lKSB7XG5cdHJldHVybiBSVU5FUy5pbmNsdWRlcygvKiogQHR5cGUge1J1bmVOYW1lfSAqLyAobmFtZSkpO1xufVxuXG4vKiogQHR5cGVkZWYge3R5cGVvZiBTVEFURV9DUkVBVElPTl9SVU5FU1tudW1iZXJdfSBTdGF0ZUNyZWF0aW9uUnVuZU5hbWUgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25hbWUgaXMgU3RhdGVDcmVhdGlvblJ1bmVOYW1lfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfc3RhdGVfY3JlYXRpb25fcnVuZShuYW1lKSB7XG5cdHJldHVybiBTVEFURV9DUkVBVElPTl9SVU5FUy5pbmNsdWRlcygvKiogQHR5cGUge1N0YXRlQ3JlYXRpb25SdW5lTmFtZX0gKi8gKG5hbWUpKTtcbn1cblxuLyoqIExpc3Qgb2YgZWxlbWVudHMgdGhhdCByZXF1aXJlIHJhdyBjb250ZW50cyBhbmQgc2hvdWxkIG5vdCBoYXZlIFNTUiBjb21tZW50cyBwdXQgaW4gdGhlbSAqL1xuY29uc3QgUkFXX1RFWFRfRUxFTUVOVFMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWyd0ZXh0YXJlYScsICdzY3JpcHQnLCAnc3R5bGUnLCAndGl0bGUnXSk7XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Jhd190ZXh0X2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gUkFXX1RFWFRfRUxFTUVOVFMuaW5jbHVkZXMoLyoqIEB0eXBlIHt0eXBlb2YgUkFXX1RFWFRfRUxFTUVOVFNbbnVtYmVyXX0gKi8gKG5hbWUpKTtcbn1cblxuLyoqXG4gKiBQcmV2ZW50IGRldnRvb2xzIHRyeWluZyB0byBtYWtlIGBsb2NhdGlvbmAgYSBjbGlja2FibGUgbGluayBieSBpbnNlcnRpbmcgYSB6ZXJvLXdpZHRoIHNwYWNlXG4gKiBAdGVtcGxhdGUge3N0cmluZyB8IHVuZGVmaW5lZH0gVFxuICogQHBhcmFtIHtUfSBsb2NhdGlvblxuICogQHJldHVybnMge1R9O1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVfbG9jYXRpb24obG9jYXRpb24pIHtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VH0gKi8gKGxvY2F0aW9uPy5yZXBsYWNlKC9cXC8vZywgJy9cXHUyMDBiJykpO1xufVxuIiwgImltcG9ydCB7IHNhbml0aXplX2xvY2F0aW9uIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi93YXJuaW5ncy5qcyc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiLCBwcm9wZXJ0eSwgbG9jYXRpb24pIHtcblx0aWYgKGEgIT09IGIpIHtcblx0XHR3LmFzc2lnbm1lbnRfdmFsdWVfc3RhbGUocHJvcGVydHksIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc2FuaXRpemVfbG9jYXRpb24obG9jYXRpb24pKSk7XG5cdH1cblxuXHRyZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIGxvY2F0aW9uKSB7XG5cdHJldHVybiBjb21wYXJlKFxuXHRcdChvYmplY3RbcHJvcGVydHldID0gdmFsdWUpLFxuXHRcdHVudHJhY2soKCkgPT4gb2JqZWN0W3Byb3BlcnR5XSksXG5cdFx0cHJvcGVydHksXG5cdFx0bG9jYXRpb25cblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25fYW5kKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBsb2NhdGlvbikge1xuXHRyZXR1cm4gY29tcGFyZShcblx0XHQob2JqZWN0W3Byb3BlcnR5XSAmJj0gdmFsdWUpLFxuXHRcdHVudHJhY2soKCkgPT4gb2JqZWN0W3Byb3BlcnR5XSksXG5cdFx0cHJvcGVydHksXG5cdFx0bG9jYXRpb25cblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25fb3Iob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIGxvY2F0aW9uKSB7XG5cdHJldHVybiBjb21wYXJlKFxuXHRcdChvYmplY3RbcHJvcGVydHldIHx8PSB2YWx1ZSksXG5cdFx0dW50cmFjaygoKSA9PiBvYmplY3RbcHJvcGVydHldKSxcblx0XHRwcm9wZXJ0eSxcblx0XHRsb2NhdGlvblxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbl9udWxsaXNoKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBsb2NhdGlvbikge1xuXHRyZXR1cm4gY29tcGFyZShcblx0XHQob2JqZWN0W3Byb3BlcnR5XSA/Pz0gdmFsdWUpLFxuXHRcdHVudHJhY2soKCkgPT4gb2JqZWN0W3Byb3BlcnR5XSksXG5cdFx0cHJvcGVydHksXG5cdFx0bG9jYXRpb25cblx0KTtcbn1cbiIsICIvKiogQHR5cGUge01hcDxTdHJpbmcsIFNldDxIVE1MU3R5bGVFbGVtZW50Pj59ICovXG52YXIgYWxsX3N0eWxlcyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFzaFxuICogQHBhcmFtIHtIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJfc3R5bGUoaGFzaCwgc3R5bGUpIHtcblx0dmFyIHN0eWxlcyA9IGFsbF9zdHlsZXMuZ2V0KGhhc2gpO1xuXG5cdGlmICghc3R5bGVzKSB7XG5cdFx0c3R5bGVzID0gbmV3IFNldCgpO1xuXHRcdGFsbF9zdHlsZXMuc2V0KGhhc2gsIHN0eWxlcyk7XG5cdH1cblxuXHRzdHlsZXMuYWRkKHN0eWxlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cF9zdHlsZXMoaGFzaCkge1xuXHR2YXIgc3R5bGVzID0gYWxsX3N0eWxlcy5nZXQoaGFzaCk7XG5cdGlmICghc3R5bGVzKSByZXR1cm47XG5cblx0Zm9yIChjb25zdCBzdHlsZSBvZiBzdHlsZXMpIHtcblx0XHRzdHlsZS5yZW1vdmUoKTtcblx0fVxuXG5cdGFsbF9zdHlsZXMuZGVsZXRlKGhhc2gpO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgU291cmNlTG9jYXRpb24gfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFLCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFLCBFTEVNRU5UX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBIWURSQVRJT05fRU5ELCBIWURSQVRJT05fU1RBUlQsIEhZRFJBVElPTl9TVEFSVF9FTFNFIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2RvbS9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgZGV2X3N0YWNrIH0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGZuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAqIEBwYXJhbSB7U291cmNlTG9jYXRpb25bXX0gbG9jYXRpb25zXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xvY2F0aW9ucyhmbiwgZmlsZW5hbWUsIGxvY2F0aW9ucykge1xuXHRyZXR1cm4gKC8qKiBAdHlwZSB7YW55W119ICovIC4uLmFyZ3MpID0+IHtcblx0XHRjb25zdCBkb20gPSBmbiguLi5hcmdzKTtcblxuXHRcdHZhciBub2RlID0gaHlkcmF0aW5nID8gZG9tIDogZG9tLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID8gZG9tLmZpcnN0Q2hpbGQgOiBkb207XG5cdFx0YXNzaWduX2xvY2F0aW9ucyhub2RlLCBmaWxlbmFtZSwgbG9jYXRpb25zKTtcblxuXHRcdHJldHVybiBkb207XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAqIEBwYXJhbSB7U291cmNlTG9jYXRpb259IGxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbl9sb2NhdGlvbihlbGVtZW50LCBmaWxlbmFtZSwgbG9jYXRpb24pIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG5cdFx0cGFyZW50OiBkZXZfc3RhY2ssXG5cdFx0bG9jOiB7IGZpbGU6IGZpbGVuYW1lLCBsaW5lOiBsb2NhdGlvblswXSwgY29sdW1uOiBsb2NhdGlvblsxXSB9XG5cdH07XG5cblx0aWYgKGxvY2F0aW9uWzJdKSB7XG5cdFx0YXNzaWduX2xvY2F0aW9ucyhlbGVtZW50LmZpcnN0Q2hpbGQsIGZpbGVuYW1lLCBsb2NhdGlvblsyXSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGUgfCBudWxsfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAqIEBwYXJhbSB7U291cmNlTG9jYXRpb25bXX0gbG9jYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbl9sb2NhdGlvbnMobm9kZSwgZmlsZW5hbWUsIGxvY2F0aW9ucykge1xuXHR2YXIgaSA9IDA7XG5cdHZhciBkZXB0aCA9IDA7XG5cblx0d2hpbGUgKG5vZGUgJiYgaSA8IGxvY2F0aW9ucy5sZW5ndGgpIHtcblx0XHRpZiAoaHlkcmF0aW5nICYmIG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuXHRcdFx0dmFyIGNvbW1lbnQgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChub2RlKTtcblx0XHRcdGlmIChjb21tZW50LmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVCB8fCBjb21tZW50LmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFKSBkZXB0aCArPSAxO1xuXHRcdFx0ZWxzZSBpZiAoY29tbWVudC5kYXRhWzBdID09PSBIWURSQVRJT05fRU5EKSBkZXB0aCAtPSAxO1xuXHRcdH1cblxuXHRcdGlmIChkZXB0aCA9PT0gMCAmJiBub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcblx0XHRcdGFzc2lnbl9sb2NhdGlvbigvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKSwgZmlsZW5hbWUsIGxvY2F0aW9uc1tpKytdKTtcblx0XHR9XG5cblx0XHRub2RlID0gbm9kZS5uZXh0U2libGluZztcblx0fVxufVxuIiwgImltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0IH0gZnJvbSAnLi9iaW5kaW5ncy9zaGFyZWQuanMnO1xuXG4vKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuZXhwb3J0IGNvbnN0IGFsbF9yZWdpc3RlcmVkX2V2ZW50cyA9IG5ldyBTZXQoKTtcblxuLyoqIEB0eXBlIHtTZXQ8KGV2ZW50czogQXJyYXk8c3RyaW5nPikgPT4gdm9pZD59ICovXG5leHBvcnQgY29uc3Qgcm9vdF9ldmVudF9oYW5kbGVzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIFNTUiBhZGRzIG9ubG9hZCBhbmQgb25lcnJvciBhdHRyaWJ1dGVzIHRvIGNhdGNoIHRob3NlIGV2ZW50cyBiZWZvcmUgdGhlIGh5ZHJhdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB0aG9zZSBjYXNlcywgcmVtb3ZlcyB0aGUgYXR0cmlidXRlcyBhbmQgcmVwbGF5cyB0aGUgZXZlbnRzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYXlfZXZlbnRzKGRvbSkge1xuXHRpZiAoIWh5ZHJhdGluZykgcmV0dXJuO1xuXG5cdGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ29ubG9hZCcpO1xuXHRkb20ucmVtb3ZlQXR0cmlidXRlKCdvbmVycm9yJyk7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgZXZlbnQgPSBkb20uX19lO1xuXHRpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRkb20uX19lID0gdW5kZWZpbmVkO1xuXHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdGlmIChkb20uaXNDb25uZWN0ZWQpIHtcblx0XHRcdFx0ZG9tLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGRvbVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBbaGFuZGxlcl1cbiAqIEBwYXJhbSB7QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGRvbSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG5cdC8qKlxuXHQgKiBAdGhpcyB7RXZlbnRUYXJnZXR9XG5cdCAqL1xuXHRmdW5jdGlvbiB0YXJnZXRfaGFuZGxlcigvKiogQHR5cGUge0V2ZW50fSAqLyBldmVudCkge1xuXHRcdGlmICghb3B0aW9ucy5jYXB0dXJlKSB7XG5cdFx0XHQvLyBPbmx5IGNhbGwgaW4gdGhlIGJ1YmJsZSBwaGFzZSwgZWxzZSBkZWxlZ2F0ZWQgZXZlbnRzIHdvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGNhcHR1cmluZyBldmVudHNcblx0XHRcdGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbi5jYWxsKGRvbSwgZXZlbnQpO1xuXHRcdH1cblx0XHRpZiAoIWV2ZW50LmNhbmNlbEJ1YmJsZSkge1xuXHRcdFx0cmV0dXJuIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyPy5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIENocm9tZSBoYXMgYSBidWcgd2hlcmUgcG9pbnRlciBldmVudHMgZG9uJ3Qgd29yayB3aGVuIGF0dGFjaGVkIHRvIGEgRE9NIGVsZW1lbnQgdGhhdCBoYXMgYmVlbiBjbG9uZWRcblx0Ly8gd2l0aCBjbG9uZU5vZGUoKSBhbmQgdGhlIERPTSBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBkb2N1bWVudC4gVG8gZW5zdXJlIHRoZSBldmVudCB3b3Jrcywgd2Vcblx0Ly8gZGVmZXIgdGhlIGF0dGFjaG1lbnQgdGlsbCBhZnRlciBpdCdzIGJlZW4gYXBwZW5kZWQgdG8gdGhlIGRvY3VtZW50LiBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIENocm9tZSBmaXhlc1xuXHQvLyB0aGlzIGJ1Zy4gVGhlIHNhbWUgYXBwbGllcyB0byB3aGVlbCBldmVudHMgYW5kIHRvdWNoIGV2ZW50cy5cblx0aWYgKFxuXHRcdGV2ZW50X25hbWUuc3RhcnRzV2l0aCgncG9pbnRlcicpIHx8XG5cdFx0ZXZlbnRfbmFtZS5zdGFydHNXaXRoKCd0b3VjaCcpIHx8XG5cdFx0ZXZlbnRfbmFtZSA9PT0gJ3doZWVsJ1xuXHQpIHtcblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRkb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0X2hhbmRsZXI7XG59XG5cbi8qKlxuICogQXR0YWNoZXMgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50IGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBoYW5kbGVyLiBVc2luZyB0aGlzXG4gKiByYXRoZXIgdGhhbiBgYWRkRXZlbnRMaXN0ZW5lcmAgd2lsbCBwcmVzZXJ2ZSB0aGUgY29ycmVjdCBvcmRlciByZWxhdGl2ZSB0byBoYW5kbGVycyBhZGRlZCBkZWNsYXJhdGl2ZWx5XG4gKiAod2l0aCBhdHRyaWJ1dGVzIGxpa2UgYG9uY2xpY2tgKSwgd2hpY2ggdXNlIGV2ZW50IGRlbGVnYXRpb24gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBoYW5kbGVyXG4gKiBAcGFyYW0ge0FkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuXHR2YXIgdGFyZ2V0X2hhbmRsZXIgPSBjcmVhdGVfZXZlbnQodHlwZSwgZWxlbWVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBbaGFuZGxlcl1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhcHR1cmVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXNzaXZlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUpIHtcblx0dmFyIG9wdGlvbnMgPSB7IGNhcHR1cmUsIHBhc3NpdmUgfTtcblx0dmFyIHRhcmdldF9oYW5kbGVyID0gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGRvbSwgaGFuZGxlciwgb3B0aW9ucyk7XG5cblx0aWYgKFxuXHRcdGRvbSA9PT0gZG9jdW1lbnQuYm9keSB8fFxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRkb20gPT09IHdpbmRvdyB8fFxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRkb20gPT09IGRvY3VtZW50IHx8XG5cdFx0Ly8gRmlyZWZveCBoYXMgcXVpcmt5IGJlaGF2aW9yLCBpdCBjYW4gaGFwcGVuIHRoYXQgd2Ugc3RpbGwgZ2V0IFwiY2FucGxheVwiIGV2ZW50cyB3aGVuIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgcmVtb3ZlZFxuXHRcdGRvbSBpbnN0YW5jZW9mIEhUTUxNZWRpYUVsZW1lbnRcblx0KSB7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZWdhdGUoZXZlbnRzKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YWxsX3JlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudHNbaV0pO1xuXHR9XG5cblx0Zm9yICh2YXIgZm4gb2Ygcm9vdF9ldmVudF9oYW5kbGVzKSB7XG5cdFx0Zm4oZXZlbnRzKTtcblx0fVxufVxuXG4vLyB1c2VkIHRvIHN0b3JlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBwcm9wYWdhdGVkIGV2ZW50XG4vLyB0byBwcmV2ZW50IGdhcmJhZ2UgY29sbGVjdGlvbiBiZXR3ZWVuIG1pY3JvdGFza3MgaW4gRmlyZWZveFxuLy8gSWYgdGhlIGV2ZW50IG9iamVjdCBpcyBHQ2VkIHRvbyBlYXJseSwgdGhlIGV4cGFuZG8gX19yb290IHByb3BlcnR5XG4vLyBzZXQgb24gdGhlIGV2ZW50IG9iamVjdCBpcyBsb3N0LCBjYXVzaW5nIHRoZSBldmVudCBkZWxlZ2F0aW9uXG4vLyB0byBwcm9jZXNzIHRoZSBldmVudCB0d2ljZVxubGV0IGxhc3RfcHJvcGFnYXRlZF9ldmVudCA9IG51bGw7XG5cbi8qKlxuICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG5cdHZhciBoYW5kbGVyX2VsZW1lbnQgPSB0aGlzO1xuXHR2YXIgb3duZXJfZG9jdW1lbnQgPSAvKiogQHR5cGUge05vZGV9ICovIChoYW5kbGVyX2VsZW1lbnQpLm93bmVyRG9jdW1lbnQ7XG5cdHZhciBldmVudF9uYW1lID0gZXZlbnQudHlwZTtcblx0dmFyIHBhdGggPSBldmVudC5jb21wb3NlZFBhdGg/LigpIHx8IFtdO1xuXHR2YXIgY3VycmVudF90YXJnZXQgPSAvKiogQHR5cGUge251bGwgfCBFbGVtZW50fSAqLyAocGF0aFswXSB8fCBldmVudC50YXJnZXQpO1xuXG5cdGxhc3RfcHJvcGFnYXRlZF9ldmVudCA9IGV2ZW50O1xuXG5cdC8vIGNvbXBvc2VkUGF0aCBjb250YWlucyBsaXN0IG9mIG5vZGVzIHRoZSBldmVudCBoYXMgcHJvcGFnYXRlZCB0aHJvdWdoLlxuXHQvLyBXZSBjaGVjayBfX3Jvb3QgdG8gc2tpcCBhbGwgbm9kZXMgYmVsb3cgaXQgaW4gY2FzZSB0aGlzIGlzIGFcblx0Ly8gcGFyZW50IG9mIHRoZSBfX3Jvb3Qgbm9kZSwgd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlcmUncyBuZXN0ZWRcblx0Ly8gbW91bnRlZCBhcHBzLiBJbiB0aGlzIGNhc2Ugd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGV2ZW50cyBtdWx0aXBsZSB0aW1lcy5cblx0dmFyIHBhdGhfaWR4ID0gMDtcblxuXHQvLyB0aGUgYGxhc3RfcHJvcGFnYXRlZF9ldmVudCA9PT0gZXZlbnRgIGNoZWNrIGlzIHJlZHVuZGFudCwgYnV0XG5cdC8vIHdpdGhvdXQgaXQgdGhlIHZhcmlhYmxlIHdpbGwgYmUgRENFJ2QgYW5kIHRoaW5ncyB3aWxsXG5cdC8vIGZhaWwgbXlzdGVyaW91c2x5IGluIEZpcmVmb3hcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBpcyBhZGRlZCBiZWxvd1xuXHR2YXIgaGFuZGxlZF9hdCA9IGxhc3RfcHJvcGFnYXRlZF9ldmVudCA9PT0gZXZlbnQgJiYgZXZlbnQuX19yb290O1xuXG5cdGlmIChoYW5kbGVkX2F0KSB7XG5cdFx0dmFyIGF0X2lkeCA9IHBhdGguaW5kZXhPZihoYW5kbGVkX2F0KTtcblx0XHRpZiAoXG5cdFx0XHRhdF9pZHggIT09IC0xICYmXG5cdFx0XHQoaGFuZGxlcl9lbGVtZW50ID09PSBkb2N1bWVudCB8fCBoYW5kbGVyX2VsZW1lbnQgPT09IC8qKiBAdHlwZSB7YW55fSAqLyAod2luZG93KSlcblx0XHQpIHtcblx0XHRcdC8vIFRoaXMgaXMgdGhlIGZhbGxiYWNrIGRvY3VtZW50IGxpc3RlbmVyIG9yIGEgd2luZG93IGxpc3RlbmVyLCBidXQgdGhlIGV2ZW50IHdhcyBhbHJlYWR5IGhhbmRsZWRcblx0XHRcdC8vIC0+IGlnbm9yZSwgYnV0IHNldCBoYW5kbGVfYXQgdG8gZG9jdW1lbnQvd2luZG93IHNvIHRoYXQgd2UncmUgcmVzZXR0aW5nIHRoZSBldmVudFxuXHRcdFx0Ly8gY2hhaW4gaW4gY2FzZSBzb21lb25lIG1hbnVhbGx5IGRpc3BhdGNoZXMgdGhlIHNhbWUgZXZlbnQgb2JqZWN0IGFnYWluLlxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0ZXZlbnQuX19yb290ID0gaGFuZGxlcl9lbGVtZW50O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFdlJ3JlIGRlbGliZXJhdGVseSBub3Qgc2tpcHBpbmcgaWYgdGhlIGluZGV4IGlzIGhpZ2hlciwgYmVjYXVzZVxuXHRcdC8vIHNvbWVvbmUgY291bGQgY3JlYXRlIGFuIGV2ZW50IHByb2dyYW1tYXRpY2FsbHkgYW5kIGVtaXQgaXQgbXVsdGlwbGUgdGltZXMsXG5cdFx0Ly8gaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGhhbmRsZSB0aGUgd2hvbGUgcHJvcGFnYXRpb24gY2hhaW4gcHJvcGVybHkgZWFjaCB0aW1lLlxuXHRcdC8vICh0aGlzIHdpbGwgb25seSBiZSBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkIG11bHRpcGxlIHRpbWVzIGFuZFxuXHRcdC8vIHRoZSBmYWxsYmFjayBkb2N1bWVudCBsaXN0ZW5lciBpc24ndCByZWFjaGVkIGluIGJldHdlZW4sIGJ1dCB0aGF0J3Mgc3VwZXIgcmFyZSlcblx0XHR2YXIgaGFuZGxlcl9pZHggPSBwYXRoLmluZGV4T2YoaGFuZGxlcl9lbGVtZW50KTtcblx0XHRpZiAoaGFuZGxlcl9pZHggPT09IC0xKSB7XG5cdFx0XHQvLyBoYW5kbGVfaWR4IGNhbiB0aGVvcmV0aWNhbGx5IGJlIC0xIChoYXBwZW5lZCBpbiBzb21lIEpTRE9NIHRlc3Rpbmcgc2NlbmFyaW9zIHdpdGggYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHdpbmRvdyBvYmplY3QpXG5cdFx0XHQvLyBzbyBndWFyZCBhZ2FpbnN0IHRoYXQsIHRvbywgYW5kIGFzc3VtZSB0aGF0IGV2ZXJ5dGhpbmcgd2FzIGhhbmRsZWQgYXQgdGhpcyBwb2ludC5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoYXRfaWR4IDw9IGhhbmRsZXJfaWR4KSB7XG5cdFx0XHRwYXRoX2lkeCA9IGF0X2lkeDtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50X3RhcmdldCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKHBhdGhbcGF0aF9pZHhdIHx8IGV2ZW50LnRhcmdldCk7XG5cdC8vIHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBkZWxlZ2F0ZWQgZXZlbnQgcGVyIGVsZW1lbnQsIGFuZCB3ZSBlaXRoZXIgYWxyZWFkeSBoYW5kbGVkIHRoZSBjdXJyZW50IHRhcmdldCxcblx0Ly8gb3IgdGhpcyBpcyB0aGUgdmVyeSBmaXJzdCB0YXJnZXQgaW4gdGhlIGNoYWluIHdoaWNoIGhhcyBhIG5vbi1kZWxlZ2F0ZWQgbGlzdGVuZXIsIGluIHdoaWNoIGNhc2UgaXQncyBzYWZlXG5cdC8vIHRvIGhhbmRsZSBhIHBvc3NpYmxlIGRlbGVnYXRlZCBldmVudCBvbiBpdCBsYXRlciAodGhyb3VnaCB0aGUgcm9vdCBkZWxlZ2F0aW9uIGxpc3RlbmVyIGZvciBleGFtcGxlKS5cblx0aWYgKGN1cnJlbnRfdGFyZ2V0ID09PSBoYW5kbGVyX2VsZW1lbnQpIHJldHVybjtcblxuXHQvLyBQcm94eSBjdXJyZW50VGFyZ2V0IHRvIGNvcnJlY3QgdGFyZ2V0XG5cdGRlZmluZV9wcm9wZXJ0eShldmVudCwgJ2N1cnJlbnRUYXJnZXQnLCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiBjdXJyZW50X3RhcmdldCB8fCBvd25lcl9kb2N1bWVudDtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFRoaXMgc3RhcnRlZCBiZWNhdXNlIG9mIENocm9taXVtIGlzc3VlIGh0dHBzOi8vY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlLzUxMjg2OTY4MjM1NDU4NTYsXG5cdC8vIHdoZXJlIHJlbW92YWwgb3IgbW92aW5nIG9mIG9mIHRoZSBET00gY2FuIGNhdXNlIHN5bmMgYGJsdXJgIGV2ZW50cyB0byBmaXJlLCB3aGljaCBjYW4gY2F1c2UgbG9naWNcblx0Ly8gdG8gcnVuIGluc2lkZSB0aGUgY3VycmVudCBgYWN0aXZlX3JlYWN0aW9uYCwgd2hpY2ggaXNuJ3Qgd2hhdCB3ZSB3YW50IGF0IGFsbC4gSG93ZXZlciwgb24gcmVmbGVjdGlvbixcblx0Ly8gaXQncyBwcm9iYWJseSBiZXN0IHRoYXQgYWxsIGV2ZW50IGhhbmRsZWQgYnkgU3ZlbHRlIGhhdmUgdGhpcyBiZWhhdmlvdXIsIGFzIHdlIGRvbid0IHJlYWxseSB3YW50XG5cdC8vIGFuIGV2ZW50IGhhbmRsZXIgdG8gcnVuIGluIHRoZSBjb250ZXh0IG9mIGFub3RoZXIgcmVhY3Rpb24gb3IgZWZmZWN0LlxuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblxuXHR0cnkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHt1bmtub3dufVxuXHRcdCAqL1xuXHRcdHZhciB0aHJvd19lcnJvcjtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7dW5rbm93bltdfVxuXHRcdCAqL1xuXHRcdHZhciBvdGhlcl9lcnJvcnMgPSBbXTtcblxuXHRcdHdoaWxlIChjdXJyZW50X3RhcmdldCAhPT0gbnVsbCkge1xuXHRcdFx0LyoqIEB0eXBlIHtudWxsIHwgRWxlbWVudH0gKi9cblx0XHRcdHZhciBwYXJlbnRfZWxlbWVudCA9XG5cdFx0XHRcdGN1cnJlbnRfdGFyZ2V0LmFzc2lnbmVkU2xvdCB8fFxuXHRcdFx0XHRjdXJyZW50X3RhcmdldC5wYXJlbnROb2RlIHx8XG5cdFx0XHRcdC8qKiBAdHlwZSB7YW55fSAqLyAoY3VycmVudF90YXJnZXQpLmhvc3QgfHxcblx0XHRcdFx0bnVsbDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHR2YXIgZGVsZWdhdGVkID0gY3VycmVudF90YXJnZXRbJ19fJyArIGV2ZW50X25hbWVdO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRkZWxlZ2F0ZWQgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdCghKC8qKiBAdHlwZSB7YW55fSAqLyAoY3VycmVudF90YXJnZXQpLmRpc2FibGVkKSB8fFxuXHRcdFx0XHRcdFx0Ly8gRE9NIGNvdWxkJ3ZlIGJlZW4gdXBkYXRlZCBhbHJlYWR5IGJ5IHRoZSB0aW1lIHRoaXMgaXMgcmVhY2hlZCwgc28gd2UgY2hlY2sgdGhpcyBhcyB3ZWxsXG5cdFx0XHRcdFx0XHQvLyAtPiB0aGUgdGFyZ2V0IGNvdWxkIG5vdCBoYXZlIGJlZW4gZGlzYWJsZWQgYmVjYXVzZSBpdCBlbWl0cyB0aGUgZXZlbnQgaW4gdGhlIGZpcnN0IHBsYWNlXG5cdFx0XHRcdFx0XHRldmVudC50YXJnZXQgPT09IGN1cnJlbnRfdGFyZ2V0KVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkZWxlZ2F0ZWQuY2FsbChjdXJyZW50X3RhcmdldCwgZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRpZiAodGhyb3dfZXJyb3IpIHtcblx0XHRcdFx0XHRvdGhlcl9lcnJvcnMucHVzaChlcnJvcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3dfZXJyb3IgPSBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGV2ZW50LmNhbmNlbEJ1YmJsZSB8fCBwYXJlbnRfZWxlbWVudCA9PT0gaGFuZGxlcl9lbGVtZW50IHx8IHBhcmVudF9lbGVtZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudF90YXJnZXQgPSBwYXJlbnRfZWxlbWVudDtcblx0XHR9XG5cblx0XHRpZiAodGhyb3dfZXJyb3IpIHtcblx0XHRcdGZvciAobGV0IGVycm9yIG9mIG90aGVyX2Vycm9ycykge1xuXHRcdFx0XHQvLyBUaHJvdyB0aGUgcmVzdCBvZiB0aGUgZXJyb3JzLCBvbmUtYnktb25lIG9uIGEgbWljcm90YXNrXG5cdFx0XHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyB0aHJvd19lcnJvcjtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBpcyB1c2VkIGFib3ZlXG5cdFx0ZXZlbnQuX19yb290ID0gaGFuZGxlcl9lbGVtZW50O1xuXHRcdC8vIEB0cy1pZ25vcmUgcmVtb3ZlIHByb3h5IG9uIGN1cnJlbnRUYXJnZXRcblx0XHRkZWxldGUgZXZlbnQuY3VycmVudFRhcmdldDtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogSW4gZGV2LCB3YXJuIGlmIGFuIGV2ZW50IGhhbmRsZXIgaXMgbm90IGEgZnVuY3Rpb24sIGFzIGl0IG1lYW5zIHRoZVxuICogdXNlciBwcm9iYWJseSBjYWxsZWQgdGhlIGhhbmRsZXIgb3IgZm9yZ290IHRvIGFkZCBhIGAoKSA9PmBcbiAqIEBwYXJhbSB7KCkgPT4gKGV2ZW50OiBFdmVudCwgLi4uYXJnczogYW55KSA9PiB2b2lkfSB0aHVua1xuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudFxuICogQHBhcmFtIHtbRXZlbnQsIC4uLmFueV19IGFyZ3NcbiAqIEBwYXJhbSB7YW55fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gW2xvY11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZV9wYXJlbnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseShcblx0dGh1bmssXG5cdGVsZW1lbnQsXG5cdGFyZ3MsXG5cdGNvbXBvbmVudCxcblx0bG9jLFxuXHRoYXNfc2lkZV9lZmZlY3RzID0gZmFsc2UsXG5cdHJlbW92ZV9wYXJlbnMgPSBmYWxzZVxuKSB7XG5cdGxldCBoYW5kbGVyO1xuXHRsZXQgZXJyb3I7XG5cblx0dHJ5IHtcblx0XHRoYW5kbGVyID0gdGh1bmsoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGVycm9yID0gZTtcblx0fVxuXG5cdGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJyAmJiAoaGFzX3NpZGVfZWZmZWN0cyB8fCBoYW5kbGVyICE9IG51bGwgfHwgZXJyb3IpKSB7XG5cdFx0Y29uc3QgZmlsZW5hbWUgPSBjb21wb25lbnQ/LltGSUxFTkFNRV07XG5cdFx0Y29uc3QgbG9jYXRpb24gPSBsb2MgPyBgIGF0ICR7ZmlsZW5hbWV9OiR7bG9jWzBdfToke2xvY1sxXX1gIDogYCBpbiAke2ZpbGVuYW1lfWA7XG5cdFx0Y29uc3QgcGhhc2UgPSBhcmdzWzBdPy5ldmVudFBoYXNlIDwgRXZlbnQuQlVCQkxJTkdfUEhBU0UgPyAnY2FwdHVyZScgOiAnJztcblx0XHRjb25zdCBldmVudF9uYW1lID0gYXJnc1swXT8udHlwZSArIHBoYXNlO1xuXHRcdGNvbnN0IGRlc2NyaXB0aW9uID0gYFxcYCR7ZXZlbnRfbmFtZX1cXGAgaGFuZGxlciR7bG9jYXRpb259YDtcblx0XHRjb25zdCBzdWdnZXN0aW9uID0gcmVtb3ZlX3BhcmVucyA/ICdyZW1vdmUgdGhlIHRyYWlsaW5nIGAoKWAnIDogJ2FkZCBhIGxlYWRpbmcgYCgpID0+YCc7XG5cblx0XHR3LmV2ZW50X2hhbmRsZXJfaW52YWxpZChkZXNjcmlwdGlvbiwgc3VnZ2VzdGlvbik7XG5cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHRoYW5kbGVyPy5hcHBseShlbGVtZW50LCBhcmdzKTtcbn1cbiIsICIvKiogQHBhcmFtIHtzdHJpbmd9IGh0bWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpIHtcblx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRlbGVtLmlubmVySFRNTCA9IGh0bWwucmVwbGFjZUFsbCgnPCE+JywgJzwhLS0tLT4nKTsgLy8gWEhUTUwgY29tcGxpYW5jZVxuXHRyZXR1cm4gZWxlbS5jb250ZW50O1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZVN0cnVjdHVyZSB9IGZyb20gJy4vdHlwZXMnICovXG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlIH0gZnJvbSAnLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHtcblx0Y3JlYXRlX3RleHQsXG5cdGdldF9maXJzdF9jaGlsZCxcblx0aXNfZmlyZWZveCxcblx0Y3JlYXRlX2VsZW1lbnQsXG5cdGNyZWF0ZV9mcmFnbWVudCxcblx0Y3JlYXRlX2NvbW1lbnQsXG5cdHNldF9hdHRyaWJ1dGVcbn0gZnJvbSAnLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwgfSBmcm9tICcuL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0TkFNRVNQQUNFX01BVEhNTCxcblx0TkFNRVNQQUNFX1NWRyxcblx0VEVNUExBVEVfRlJBR01FTlQsXG5cdFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSxcblx0VEVNUExBVEVfVVNFX01BVEhNTCxcblx0VEVNUExBVEVfVVNFX1NWR1xufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFLCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFLCBFRkZFQ1RfUkFOLCBURVhUX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZSB8IG51bGx9IGVuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpIHtcblx0dmFyIGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cdGlmIChlZmZlY3Qubm9kZXNfc3RhcnQgPT09IG51bGwpIHtcblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPSBzdGFydDtcblx0XHRlZmZlY3Qubm9kZXNfZW5kID0gZW5kO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21faHRtbChjb250ZW50LCBmbGFncykge1xuXHR2YXIgaXNfZnJhZ21lbnQgPSAoZmxhZ3MgJiBURU1QTEFURV9GUkFHTUVOVCkgIT09IDA7XG5cdHZhciB1c2VfaW1wb3J0X25vZGUgPSAoZmxhZ3MgJiBURU1QTEFURV9VU0VfSU1QT1JUX05PREUpICE9PSAwO1xuXG5cdC8qKiBAdHlwZSB7Tm9kZX0gKi9cblx0dmFyIG5vZGU7XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBmaXJzdCBpdGVtIGlzIGEgdGV4dC9lbGVtZW50IG5vZGUuIElmIG5vdCwgd2UgbmVlZCB0b1xuXHQgKiBjcmVhdGUgYW4gYWRkaXRpb25hbCBjb21tZW50IG5vZGUgdG8gYWN0IGFzIGBlZmZlY3Qubm9kZXMuc3RhcnRgXG5cdCAqL1xuXHR2YXIgaGFzX3N0YXJ0ID0gIWNvbnRlbnQuc3RhcnRzV2l0aCgnPCE+Jyk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBudWxsKTtcblx0XHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bm9kZSA9IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwoaGFzX3N0YXJ0ID8gY29udGVudCA6ICc8IT4nICsgY29udGVudCk7XG5cdFx0XHRpZiAoIWlzX2ZyYWdtZW50KSBub2RlID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKTtcblx0XHR9XG5cblx0XHR2YXIgY2xvbmUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKFxuXHRcdFx0dXNlX2ltcG9ydF9ub2RlIHx8IGlzX2ZpcmVmb3ggPyBkb2N1bWVudC5pbXBvcnROb2RlKG5vZGUsIHRydWUpIDogbm9kZS5jbG9uZU5vZGUodHJ1ZSlcblx0XHQpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHsnc3ZnJyB8ICdtYXRoJ30gbnNcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGZyb21fbmFtZXNwYWNlKGNvbnRlbnQsIGZsYWdzLCBucyA9ICdzdmcnKSB7XG5cdC8qKlxuXHQgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZmlyc3QgaXRlbSBpcyBhIHRleHQvZWxlbWVudCBub2RlLiBJZiBub3QsIHdlIG5lZWQgdG9cblx0ICogY3JlYXRlIGFuIGFkZGl0aW9uYWwgY29tbWVudCBub2RlIHRvIGFjdCBhcyBgZWZmZWN0Lm5vZGVzLnN0YXJ0YFxuXHQgKi9cblx0dmFyIGhhc19zdGFydCA9ICFjb250ZW50LnN0YXJ0c1dpdGgoJzwhPicpO1xuXG5cdHZhciBpc19mcmFnbWVudCA9IChmbGFncyAmIFRFTVBMQVRFX0ZSQUdNRU5UKSAhPT0gMDtcblx0dmFyIHdyYXBwZWQgPSBgPCR7bnN9PiR7aGFzX3N0YXJ0ID8gY29udGVudCA6ICc8IT4nICsgY29udGVudH08LyR7bnN9PmA7XG5cblx0LyoqIEB0eXBlIHtFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gKi9cblx0dmFyIG5vZGU7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBudWxsKTtcblx0XHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovIChjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKHdyYXBwZWQpKTtcblx0XHRcdHZhciByb290ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGZyYWdtZW50KSk7XG5cblx0XHRcdGlmIChpc19mcmFnbWVudCkge1xuXHRcdFx0XHRub2RlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHR3aGlsZSAoZ2V0X2ZpcnN0X2NoaWxkKHJvb3QpKSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZCgvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQocm9vdCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChyb290KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNsb25lID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG5cblx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdHZhciBzdGFydCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGNsb25lKSk7XG5cdFx0XHR2YXIgZW5kID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjbG9uZS5sYXN0Q2hpbGQpO1xuXG5cdFx0XHRhc3NpZ25fbm9kZXMoc3RhcnQsIGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhjbG9uZSwgY2xvbmUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbG9uZTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21fc3ZnKGNvbnRlbnQsIGZsYWdzKSB7XG5cdHJldHVybiBmcm9tX25hbWVzcGFjZShjb250ZW50LCBmbGFncywgJ3N2ZycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZnJvbV9tYXRobWwoY29udGVudCwgZmxhZ3MpIHtcblx0cmV0dXJuIGZyb21fbmFtZXNwYWNlKGNvbnRlbnQsIGZsYWdzLCAnbWF0aCcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVTdHJ1Y3R1cmVbXX0gc3RydWN0dXJlXG4gKiBAcGFyYW0ge3R5cGVvZiBOQU1FU1BBQ0VfU1ZHIHwgdHlwZW9mIE5BTUVTUEFDRV9NQVRITUwgfCB1bmRlZmluZWR9IFtuc11cbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnRfZnJvbV90cmVlKHN0cnVjdHVyZSwgbnMpIHtcblx0dmFyIGZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50KCk7XG5cblx0Zm9yICh2YXIgaXRlbSBvZiBzdHJ1Y3R1cmUpIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmQoY3JlYXRlX3RleHQoaXRlbSkpO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgYHByZXNlcnZlQ29tbWVudHMgPT09IHRydWVgLCBjb21tZW50cyBhcmUgcmVwcmVzZW50ZWQgYXMgYFsnLy8gPGRhdGE+J11gXG5cdFx0aWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtWzBdWzBdID09PSAnLycpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZChjcmVhdGVfY29tbWVudChpdGVtID8gaXRlbVswXS5zbGljZSgzKSA6ICcnKSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb25zdCBbbmFtZSwgYXR0cmlidXRlcywgLi4uY2hpbGRyZW5dID0gaXRlbTtcblxuXHRcdGNvbnN0IG5hbWVzcGFjZSA9IG5hbWUgPT09ICdzdmcnID8gTkFNRVNQQUNFX1NWRyA6IG5hbWUgPT09ICdtYXRoJyA/IE5BTUVTUEFDRV9NQVRITUwgOiBucztcblxuXHRcdHZhciBlbGVtZW50ID0gY3JlYXRlX2VsZW1lbnQobmFtZSwgbmFtZXNwYWNlLCBhdHRyaWJ1dGVzPy5pcyk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShlbGVtZW50LCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciB0YXJnZXQgPVxuXHRcdFx0XHRlbGVtZW50LnRhZ05hbWUgPT09ICdURU1QTEFURSdcblx0XHRcdFx0XHQ/IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKGVsZW1lbnQpLmNvbnRlbnRcblx0XHRcdFx0XHQ6IGVsZW1lbnQ7XG5cblx0XHRcdHRhcmdldC5hcHBlbmQoXG5cdFx0XHRcdGZyYWdtZW50X2Zyb21fdHJlZShjaGlsZHJlbiwgZWxlbWVudC50YWdOYW1lID09PSAnZm9yZWlnbk9iamVjdCcgPyB1bmRlZmluZWQgOiBuYW1lc3BhY2UpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGZyYWdtZW50LmFwcGVuZChlbGVtZW50KTtcblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RlbXBsYXRlU3RydWN0dXJlW119IHN0cnVjdHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcmV0dXJucyB7KCkgPT4gTm9kZSB8IE5vZGVbXX1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZnJvbV90cmVlKHN0cnVjdHVyZSwgZmxhZ3MpIHtcblx0dmFyIGlzX2ZyYWdtZW50ID0gKGZsYWdzICYgVEVNUExBVEVfRlJBR01FTlQpICE9PSAwO1xuXHR2YXIgdXNlX2ltcG9ydF9ub2RlID0gKGZsYWdzICYgVEVNUExBVEVfVVNFX0lNUE9SVF9OT0RFKSAhPT0gMDtcblxuXHQvKiogQHR5cGUge05vZGV9ICovXG5cdHZhciBub2RlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0XHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xuXHRcdH1cblxuXHRcdGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IG5zID1cblx0XHRcdFx0KGZsYWdzICYgVEVNUExBVEVfVVNFX1NWRykgIT09IDBcblx0XHRcdFx0XHQ/IE5BTUVTUEFDRV9TVkdcblx0XHRcdFx0XHQ6IChmbGFncyAmIFRFTVBMQVRFX1VTRV9NQVRITUwpICE9PSAwXG5cdFx0XHRcdFx0XHQ/IE5BTUVTUEFDRV9NQVRITUxcblx0XHRcdFx0XHRcdDogdW5kZWZpbmVkO1xuXG5cdFx0XHRub2RlID0gZnJhZ21lbnRfZnJvbV90cmVlKHN0cnVjdHVyZSwgbnMpO1xuXHRcdFx0aWYgKCFpc19mcmFnbWVudCkgbm9kZSA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNsb25lID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChcblx0XHRcdHVzZV9pbXBvcnRfbm9kZSB8fCBpc19maXJlZm94ID8gZG9jdW1lbnQuaW1wb3J0Tm9kZShub2RlLCB0cnVlKSA6IG5vZGUuY2xvbmVOb2RlKHRydWUpXG5cdFx0KTtcblxuXHRcdGlmIChpc19mcmFnbWVudCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQoY2xvbmUpKTtcblx0XHRcdHZhciBlbmQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGNsb25lLmxhc3RDaGlsZCk7XG5cblx0XHRcdGFzc2lnbl9ub2RlcyhzdGFydCwgZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXNzaWduX25vZGVzKGNsb25lLCBjbG9uZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gRWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoX3NjcmlwdChmbikge1xuXHRyZXR1cm4gKCkgPT4gcnVuX3NjcmlwdHMoZm4oKSk7XG59XG5cbi8qKlxuICogQ3JlYXRpbmcgYSBkb2N1bWVudCBmcmFnbWVudCBmcm9tIEhUTUwgdGhhdCBjb250YWlucyBzY3JpcHQgdGFncyB3aWxsIG5vdCBleGVjdXRlXG4gKiB0aGUgc2NyaXB0cy4gV2UgbmVlZCB0byByZXBsYWNlIHRoZSBzY3JpcHQgdGFncyB3aXRoIG5ldyBvbmVzIHNvIHRoYXQgdGhleSBhcmUgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7Tm9kZSB8IE5vZGVbXX1cbiAqL1xuZnVuY3Rpb24gcnVuX3NjcmlwdHMobm9kZSkge1xuXHQvLyBzY3JpcHRzIHdlcmUgU1NSJ2QsIGluIHdoaWNoIGNhc2UgdGhleSB3aWxsIHJ1blxuXHRpZiAoaHlkcmF0aW5nKSByZXR1cm4gbm9kZTtcblxuXHRjb25zdCBpc19mcmFnbWVudCA9IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG5cdGNvbnN0IHNjcmlwdHMgPVxuXHRcdC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS50YWdOYW1lID09PSAnU0NSSVBUJ1xuXHRcdFx0PyBbLyoqIEB0eXBlIHtIVE1MU2NyaXB0RWxlbWVudH0gKi8gKG5vZGUpXVxuXHRcdFx0OiBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdCcpO1xuXHRjb25zdCBlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdGZvciAoY29uc3Qgc2NyaXB0IG9mIHNjcmlwdHMpIHtcblx0XHRjb25zdCBjbG9uZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdGZvciAodmFyIGF0dHJpYnV0ZSBvZiBzY3JpcHQuYXR0cmlidXRlcykge1xuXHRcdFx0Y2xvbmUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xuXHRcdH1cblxuXHRcdGNsb25lLnRleHRDb250ZW50ID0gc2NyaXB0LnRleHRDb250ZW50O1xuXG5cdFx0Ly8gVGhlIHNjcmlwdCBoYXMgY2hhbmdlZCAtIGlmIGl0J3MgYXQgdGhlIGVkZ2VzLCB0aGUgZWZmZWN0IG5vdyBwb2ludHMgYXQgZGVhZCBub2Rlc1xuXHRcdGlmIChpc19mcmFnbWVudCA/IG5vZGUuZmlyc3RDaGlsZCA9PT0gc2NyaXB0IDogbm9kZSA9PT0gc2NyaXB0KSB7XG5cdFx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPSBjbG9uZTtcblx0XHR9XG5cdFx0aWYgKGlzX2ZyYWdtZW50ID8gbm9kZS5sYXN0Q2hpbGQgPT09IHNjcmlwdCA6IG5vZGUgPT09IHNjcmlwdCkge1xuXHRcdFx0ZWZmZWN0Lm5vZGVzX2VuZCA9IGNsb25lO1xuXHRcdH1cblxuXHRcdHNjcmlwdC5yZXBsYWNlV2l0aChjbG9uZSk7XG5cdH1cblx0cmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0KHZhbHVlID0gJycpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHR2YXIgdCA9IGNyZWF0ZV90ZXh0KHZhbHVlICsgJycpO1xuXHRcdGFzc2lnbl9ub2Rlcyh0LCB0KTtcblx0XHRyZXR1cm4gdDtcblx0fVxuXG5cdHZhciBub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdGlmIChub2RlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcblx0XHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgd2UgbmVlZCB0byBpbnNlcnQgYW4gZW1wdHkgdGV4dCBub2RlXG5cdFx0bm9kZS5iZWZvcmUoKG5vZGUgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShub2RlKTtcblx0fVxuXG5cdGFzc2lnbl9ub2Rlcyhub2RlLCBub2RlKTtcblx0cmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RlbXBsYXRlTm9kZSB8IERvY3VtZW50RnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KCkge1xuXHQvLyB3ZSdyZSBub3QgZGVsZWdhdGluZyB0byBgdGVtcGxhdGVgIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdH1cblxuXHR2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0dmFyIHN0YXJ0ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG5cdHZhciBhbmNob3IgPSBjcmVhdGVfdGV4dCgpO1xuXHRmcmFnLmFwcGVuZChzdGFydCwgYW5jaG9yKTtcblxuXHRhc3NpZ25fbm9kZXMoc3RhcnQsIGFuY2hvcik7XG5cblx0cmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogQXNzaWduIHRoZSBjcmVhdGVkIChvciBpbiBoeWRyYXRpb24gbW9kZSwgdHJhdmVyc2VkKSBkb20gZWxlbWVudHMgdG8gdGhlIGN1cnJlbnQgYmxvY2tcbiAqIGFuZCBpbnNlcnQgdGhlIGVsZW1lbnRzIGludG8gdGhlIGRvbSAoaW4gY2xpZW50IG1vZGUpLlxuICogQHBhcmFtIHtUZXh0IHwgQ29tbWVudCB8IEVsZW1lbnR9IGFuY2hvclxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQoYW5jaG9yLCBkb20pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdHZhciBlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXHRcdC8vIFdoZW4gaHlkcmF0aW5nIGFuZCBvdXRlciBjb21wb25lbnQgYW5kIGFuIGlubmVyIGNvbXBvbmVudCBpcyBhc3luYywgaS5lLiBibG9ja2VkIG9uIGEgcHJvbWlzZSxcblx0XHQvLyB0aGVuIGJ5IHRoZSB0aW1lIHRoZSBpbm5lciByZXNvbHZlcyB3ZSBoYXZlIGFscmVhZHkgYWR2YW5jZWQgdG8gdGhlIGVuZCBvZiB0aGUgaHlkcmF0ZWQgbm9kZXNcblx0XHQvLyBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC4gQ2hlY2sgZm9yIGRlZmluZWQgZm9yIHRoYXQgcmVhc29uIHRvIGF2b2lkIHJld2luZGluZyB0aGUgcGFyZW50J3MgZW5kIG1hcmtlci5cblx0XHRpZiAoKGVmZmVjdC5mICYgRUZGRUNUX1JBTikgPT09IDAgfHwgZWZmZWN0Lm5vZGVzX2VuZCA9PT0gbnVsbCkge1xuXHRcdFx0ZWZmZWN0Lm5vZGVzX2VuZCA9IGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKGFuY2hvciA9PT0gbnVsbCkge1xuXHRcdC8vIGVkZ2UgY2FzZSBcdTIwMTQgdm9pZCBgPHN2ZWx0ZTplbGVtZW50PmAgd2l0aCBjb250ZW50XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YW5jaG9yLmJlZm9yZSgvKiogQHR5cGUge05vZGV9ICovIChkb20pKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgKG9yIGh5ZHJhdGUpIGFuIHVuaXF1ZSBVSUQgZm9yIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19pZCgpIHtcblx0aWYgKFxuXHRcdGh5ZHJhdGluZyAmJlxuXHRcdGh5ZHJhdGVfbm9kZSAmJlxuXHRcdGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmXG5cdFx0aHlkcmF0ZV9ub2RlLnRleHRDb250ZW50Py5zdGFydHNXaXRoKGAkYClcblx0KSB7XG5cdFx0Y29uc3QgaWQgPSBoeWRyYXRlX25vZGUudGV4dENvbnRlbnQuc3Vic3RyaW5nKDEpO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdHJldHVybiBpZDtcblx0fVxuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyB3YXkgd2UgZW5zdXJlIHRoZSBpZCBpcyB1bmlxdWUgZXZlbiBhY3Jvc3MgU3ZlbHRlIHJ1bnRpbWVzXG5cdCh3aW5kb3cuX19zdmVsdGUgPz89IHt9KS51aWQgPz89IDE7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gYGMke3dpbmRvdy5fX3N2ZWx0ZS51aWQrK31gO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudFR5cGUsIFN2ZWx0ZUNvbXBvbmVudCwgTW91bnRPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW5kZXguanMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7XG5cdGNsZWFyX3RleHRfY29udGVudCxcblx0Y3JlYXRlX3RleHQsXG5cdGdldF9maXJzdF9jaGlsZCxcblx0Z2V0X25leHRfc2libGluZyxcblx0aW5pdF9vcGVyYXRpb25zXG59IGZyb20gJy4vZG9tL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgSFlEUkFUSU9OX0VORCwgSFlEUkFUSU9OX0VSUk9SLCBIWURSQVRJT05fU1RBUlQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBwdXNoLCBwb3AsIGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9yb290IH0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUsIHNldF9oeWRyYXRpbmcgfSBmcm9tICcuL2RvbS9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgYXJyYXlfZnJvbSB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRhbGxfcmVnaXN0ZXJlZF9ldmVudHMsXG5cdGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbixcblx0cm9vdF9ldmVudF9oYW5kbGVzXG59IGZyb20gJy4vZG9tL2VsZW1lbnRzL2V2ZW50cy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuL2RvbS90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgeyBpc19wYXNzaXZlX2V2ZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFLCBTVEFURV9TWU1CT0wgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBib3VuZGFyeSB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcyc7XG5cbi8qKlxuICogVGhpcyBpcyBub3JtYWxseSB0cnVlIFx1MjAxNCBibG9jayBlZmZlY3RzIHNob3VsZCBydW4gdGhlaXIgaW50cm8gdHJhbnNpdGlvbnMgXHUyMDE0XG4gKiBidXQgaXMgZmFsc2UgZHVyaW5nIGh5ZHJhdGlvbiAodW5sZXNzIGBvcHRpb25zLmludHJvYCBpcyBgdHJ1ZWApIGFuZFxuICogd2hlbiBjcmVhdGluZyB0aGUgY2hpbGRyZW4gb2YgYSBgPHN2ZWx0ZTplbGVtZW50PmAgdGhhdCBqdXN0IGNoYW5nZWQgdGFnXG4gKi9cbmV4cG9ydCBsZXQgc2hvdWxkX2ludHJvID0gdHJ1ZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc2hvdWxkX2ludHJvKHZhbHVlKSB7XG5cdHNob3VsZF9pbnRybyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF90ZXh0KHRleHQsIHZhbHVlKSB7XG5cdC8vIEZvciBvYmplY3RzLCB3ZSBhcHBseSBzdHJpbmcgY29lcmNpb24gKHdoaWNoIG1pZ2h0IG1ha2UgdGhpbmdzIGxpa2UgJHN0YXRlIGFycmF5IHJlZmVyZW5jZXMgaW4gdGhlIHRlbXBsYXRlIHJlYWN0aXZlKSBiZWZvcmUgZGlmZmluZ1xuXHR2YXIgc3RyID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlICsgJycgOiB2YWx1ZTtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRpZiAoc3RyICE9PSAodGV4dC5fX3QgPz89IHRleHQubm9kZVZhbHVlKSkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHR0ZXh0Ll9fdCA9IHN0cjtcblx0XHR0ZXh0Lm5vZGVWYWx1ZSA9IHN0ciArICcnO1xuXHR9XG59XG5cbi8qKlxuICogTW91bnRzIGEgY29tcG9uZW50IHRvIHRoZSBnaXZlbiB0YXJnZXQgYW5kIHJldHVybnMgdGhlIGV4cG9ydHMgYW5kIHBvdGVudGlhbGx5IHRoZSBwcm9wcyAoaWYgY29tcGlsZWQgd2l0aCBgYWNjZXNzb3JzOiB0cnVlYCkgb2YgdGhlIGNvbXBvbmVudC5cbiAqIFRyYW5zaXRpb25zIHdpbGwgcGxheSBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIHVubGVzcyB0aGUgYGludHJvYCBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzPj4gfCBDb21wb25lbnQ8UHJvcHMsIEV4cG9ydHMsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHtNb3VudE9wdGlvbnM8UHJvcHM+fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50KGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRyZXR1cm4gX21vdW50KGNvbXBvbmVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSHlkcmF0ZXMgYSBjb21wb25lbnQgb24gdGhlIGdpdmVuIHRhcmdldCBhbmQgcmV0dXJucyB0aGUgZXhwb3J0cyBhbmQgcG90ZW50aWFsbHkgdGhlIHByb3BzIChpZiBjb21waWxlZCB3aXRoIGBhY2Nlc3NvcnM6IHRydWVgKSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzPj4gfCBDb21wb25lbnQ8UHJvcHMsIEV4cG9ydHMsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7fSBleHRlbmRzIFByb3BzID8ge1xuICogXHRcdHRhcmdldDogRG9jdW1lbnQgfCBFbGVtZW50IHwgU2hhZG93Um9vdDtcbiAqIFx0XHRwcm9wcz86IFByb3BzO1xuICogXHRcdGV2ZW50cz86IFJlY29yZDxzdHJpbmcsIChlOiBhbnkpID0+IGFueT47XG4gKiAgXHRjb250ZXh0PzogTWFwPGFueSwgYW55PjtcbiAqIFx0XHRpbnRybz86IGJvb2xlYW47XG4gKiBcdFx0cmVjb3Zlcj86IGJvb2xlYW47XG4gKiBcdH0gOiB7XG4gKiBcdFx0dGFyZ2V0OiBEb2N1bWVudCB8IEVsZW1lbnQgfCBTaGFkb3dSb290O1xuICogXHRcdHByb3BzOiBQcm9wcztcbiAqIFx0XHRldmVudHM/OiBSZWNvcmQ8c3RyaW5nLCAoZTogYW55KSA9PiBhbnk+O1xuICogIFx0Y29udGV4dD86IE1hcDxhbnksIGFueT47XG4gKiBcdFx0aW50cm8/OiBib29sZWFuO1xuICogXHRcdHJlY292ZXI/OiBib29sZWFuO1xuICogXHR9fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdGluaXRfb3BlcmF0aW9ucygpO1xuXHRvcHRpb25zLmludHJvID0gb3B0aW9ucy5pbnRybyA/PyBmYWxzZTtcblx0Y29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cdGNvbnN0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdGNvbnN0IHByZXZpb3VzX2h5ZHJhdGVfbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHR0cnkge1xuXHRcdHZhciBhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZCh0YXJnZXQpKTtcblx0XHR3aGlsZSAoXG5cdFx0XHRhbmNob3IgJiZcblx0XHRcdChhbmNob3Iubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSB8fCAvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpLmRhdGEgIT09IEhZRFJBVElPTl9TVEFSVClcblx0XHQpIHtcblx0XHRcdGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhhbmNob3IpKTtcblx0XHR9XG5cblx0XHRpZiAoIWFuY2hvcikge1xuXHRcdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHRcdH1cblxuXHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpKTtcblxuXHRcdGNvbnN0IGluc3RhbmNlID0gX21vdW50KGNvbXBvbmVudCwgeyAuLi5vcHRpb25zLCBhbmNob3IgfSk7XG5cblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblxuXHRcdHJldHVybiAvKiogIEB0eXBlIHtFeHBvcnRzfSAqLyAoaW5zdGFuY2UpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIHJlLXRocm93IFN2ZWx0ZSBlcnJvcnMgLSB0aGV5IGFyZSBjZXJ0YWlubHkgbm90IHJlbGF0ZWQgdG8gaHlkcmF0aW9uXG5cdFx0aWYgKFxuXHRcdFx0ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuXHRcdFx0ZXJyb3IubWVzc2FnZS5zcGxpdCgnXFxuJykuc29tZSgobGluZSkgPT4gbGluZS5zdGFydHNXaXRoKCdodHRwczovL3N2ZWx0ZS5kZXYvZS8nKSlcblx0XHQpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0XHRpZiAoZXJyb3IgIT09IEhZRFJBVElPTl9FUlJPUikge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIGh5ZHJhdGU6ICcsIGVycm9yKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5yZWNvdmVyID09PSBmYWxzZSkge1xuXHRcdFx0ZS5oeWRyYXRpb25fZmFpbGVkKCk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgYWJvdmUsIHRoZSBvcGVyYXRpb25zIG1pZ2h0IG5vdCB5ZXQgaGF2ZSBiZWVuIGluaXRpYWxpc2VkLlxuXHRcdGluaXRfb3BlcmF0aW9ucygpO1xuXHRcdGNsZWFyX3RleHRfY29udGVudCh0YXJnZXQpO1xuXG5cdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0cmV0dXJuIG1vdW50KGNvbXBvbmVudCwgb3B0aW9ucyk7XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2h5ZHJhdGluZyh3YXNfaHlkcmF0aW5nKTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHByZXZpb3VzX2h5ZHJhdGVfbm9kZSk7XG5cdH1cbn1cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuY29uc3QgZG9jdW1lbnRfbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxhbnk+PiB8IENvbXBvbmVudDxhbnk+fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7TW91bnRPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZnVuY3Rpb24gX21vdW50KENvbXBvbmVudCwgeyB0YXJnZXQsIGFuY2hvciwgcHJvcHMgPSB7fSwgZXZlbnRzLCBjb250ZXh0LCBpbnRybyA9IHRydWUgfSkge1xuXHRpbml0X29wZXJhdGlvbnMoKTtcblxuXHQvKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuXHR2YXIgcmVnaXN0ZXJlZF9ldmVudHMgPSBuZXcgU2V0KCk7XG5cblx0LyoqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzICovXG5cdHZhciBldmVudF9oYW5kbGUgPSAoZXZlbnRzKSA9PiB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBldmVudF9uYW1lID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRpZiAocmVnaXN0ZXJlZF9ldmVudHMuaGFzKGV2ZW50X25hbWUpKSBjb250aW51ZTtcblx0XHRcdHJlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudF9uYW1lKTtcblxuXHRcdFx0dmFyIHBhc3NpdmUgPSBpc19wYXNzaXZlX2V2ZW50KGV2ZW50X25hbWUpO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIGJvdGggdGhlIGNvbnRhaW5lciBhbmQgdGhlIGRvY3VtZW50LlxuXHRcdFx0Ly8gVGhlIGNvbnRhaW5lciBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyBmcm9tIHdpdGhpbiBpbiBjYXNlXG5cdFx0XHQvLyB0aGUgb3V0ZXIgY29udGVudCBzdG9wcyBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG5cdFx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblxuXHRcdFx0dmFyIG4gPSBkb2N1bWVudF9saXN0ZW5lcnMuZ2V0KGV2ZW50X25hbWUpO1xuXG5cdFx0XHRpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIFRoZSBkb2N1bWVudCBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZSBmcm9tIGVsZW1lbnRzIHRoYXQgd2VyZVxuXHRcdFx0XHQvLyBtYW51YWxseSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBjb250YWluZXIgKGUuZy4gdmlhIG1hbnVhbCBwb3J0YWxzKS5cblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbiArIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRldmVudF9oYW5kbGUoYXJyYXlfZnJvbShhbGxfcmVnaXN0ZXJlZF9ldmVudHMpKTtcblx0cm9vdF9ldmVudF9oYW5kbGVzLmFkZChldmVudF9oYW5kbGUpO1xuXG5cdC8qKiBAdHlwZSB7RXhwb3J0c30gKi9cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciB3aWxsIGJlIGRlZmluZWQgYmVjYXVzZSB0aGUgcmVuZGVyIGVmZmVjdCBydW5zIHN5bmNocm9ub3VzbHlcblx0dmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxuXHR2YXIgdW5tb3VudCA9IGNvbXBvbmVudF9yb290KCgpID0+IHtcblx0XHR2YXIgYW5jaG9yX25vZGUgPSBhbmNob3IgPz8gdGFyZ2V0LmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXG5cdFx0Ym91bmRhcnkoXG5cdFx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGFuY2hvcl9ub2RlKSxcblx0XHRcdHtcblx0XHRcdFx0cGVuZGluZzogKCkgPT4ge31cblx0XHRcdH0sXG5cdFx0XHQoYW5jaG9yX25vZGUpID0+IHtcblx0XHRcdFx0aWYgKGNvbnRleHQpIHtcblx0XHRcdFx0XHRwdXNoKHt9KTtcblx0XHRcdFx0XHR2YXIgY3R4ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdFx0XHRcdGN0eC5jID0gY29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0XHQvLyBXZSBjYW4ndCBzcHJlYWQgdGhlIG9iamVjdCBvciBlbHNlIHdlJ2QgbG9zZSB0aGUgc3RhdGUgcHJveHkgc3R1ZmYsIGlmIGl0IGlzIG9uZVxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7YW55fSAqLyAocHJvcHMpLiQkZXZlbnRzID0gZXZlbnRzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRcdGFzc2lnbl9ub2RlcygvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGFuY2hvcl9ub2RlKSwgbnVsbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaG91bGRfaW50cm8gPSBpbnRybztcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgcHVibGljIHR5cGluZ3MgYXJlIG5vdCB3aGF0IHRoZSBhY3R1YWwgZnVuY3Rpb24gbG9va3MgbGlrZVxuXHRcdFx0XHRjb21wb25lbnQgPSBDb21wb25lbnQoYW5jaG9yX25vZGUsIHByb3BzKSB8fCB7fTtcblx0XHRcdFx0c2hvdWxkX2ludHJvID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBoeWRyYXRlX25vZGU7XG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRoeWRyYXRlX25vZGUgPT09IG51bGwgfHxcblx0XHRcdFx0XHRcdGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFIHx8XG5cdFx0XHRcdFx0XHQvKiogQHR5cGUge0NvbW1lbnR9ICovIChoeWRyYXRlX25vZGUpLmRhdGEgIT09IEhZRFJBVElPTl9FTkRcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0XHRcdFx0XHR0aHJvdyBIWURSQVRJT05fRVJST1I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbnRleHQpIHtcblx0XHRcdFx0XHRwb3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Zm9yICh2YXIgZXZlbnRfbmFtZSBvZiByZWdpc3RlcmVkX2V2ZW50cykge1xuXHRcdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24pO1xuXG5cdFx0XHRcdHZhciBuID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkb2N1bWVudF9saXN0ZW5lcnMuZ2V0KGV2ZW50X25hbWUpKTtcblxuXHRcdFx0XHRpZiAoLS1uID09PSAwKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24pO1xuXHRcdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5kZWxldGUoZXZlbnRfbmFtZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCBuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyb290X2V2ZW50X2hhbmRsZXMuZGVsZXRlKGV2ZW50X2hhbmRsZSk7XG5cblx0XHRcdGlmIChhbmNob3Jfbm9kZSAhPT0gYW5jaG9yKSB7XG5cdFx0XHRcdGFuY2hvcl9ub2RlLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKGFuY2hvcl9ub2RlKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRtb3VudGVkX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudCwgdW5tb3VudCk7XG5cdHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBvZiB0aGUgY29tcG9uZW50cyB0aGF0IHdlcmUgbW91bnRlZCBvciBoeWRyYXRlZC5cbiAqIFVzZXMgYSBgV2Vha01hcGAgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICovXG5sZXQgbW91bnRlZF9jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCB0aGF0IHdhcyBwcmV2aW91c2x5IG1vdW50ZWQgdXNpbmcgYG1vdW50YCBvciBgaHlkcmF0ZWAuXG4gKlxuICogU2luY2UgNS4xMy4wLCBpZiBgb3B0aW9ucy5vdXRyb2AgaXMgYHRydWVgLCBbdHJhbnNpdGlvbnNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS90cmFuc2l0aW9uKSB3aWxsIHBsYXkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gKlxuICogUmV0dXJucyBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGFmdGVyIHRyYW5zaXRpb25zIGhhdmUgY29tcGxldGVkIGlmIGBvcHRpb25zLm91dHJvYCBpcyB0cnVlLCBvciBpbW1lZGlhdGVseSBvdGhlcndpc2UgKHByaW9yIHRvIDUuMTMuMCwgcmV0dXJucyBgdm9pZGApLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBtb3VudCwgdW5tb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG4gKiBpbXBvcnQgQXBwIGZyb20gJy4vQXBwLnN2ZWx0ZSc7XG4gKlxuICogY29uc3QgYXBwID0gbW91bnQoQXBwLCB7IHRhcmdldDogZG9jdW1lbnQuYm9keSB9KTtcbiAqXG4gKiAvLyBsYXRlci4uLlxuICogdW5tb3VudChhcHAsIHsgb3V0cm86IHRydWUgfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gY29tcG9uZW50XG4gKiBAcGFyYW0ge3sgb3V0cm8/OiBib29sZWFuIH19IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRjb25zdCBmbiA9IG1vdW50ZWRfY29tcG9uZW50cy5nZXQoY29tcG9uZW50KTtcblxuXHRpZiAoZm4pIHtcblx0XHRtb3VudGVkX2NvbXBvbmVudHMuZGVsZXRlKGNvbXBvbmVudCk7XG5cdFx0cmV0dXJuIGZuKG9wdGlvbnMpO1xuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdGlmIChTVEFURV9TWU1CT0wgaW4gY29tcG9uZW50KSB7XG5cdFx0XHR3LnN0YXRlX3Byb3h5X3VubW91bnQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dy5saWZlY3ljbGVfZG91YmxlX3VubW91bnQoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTb3VyY2UsIEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEZJTEVOQU1FLCBITVIgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcgfSBmcm9tICcuLi9kb20vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIGRlc3Ryb3lfZWZmZWN0IH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSB9IGZyb20gJy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBzZXRfc2hvdWxkX2ludHJvIH0gZnJvbSAnLi4vcmVuZGVyLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7KGFuY2hvcjogQ29tbWVudCwgcHJvcHM6IGFueSkgPT4gYW55fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBvcmlnaW5hbFxuICogQHBhcmFtIHsoKSA9PiBTb3VyY2U8Q29tcG9uZW50Pn0gZ2V0X3NvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaG1yKG9yaWdpbmFsLCBnZXRfc291cmNlKSB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gYW5jaG9yXG5cdCAqIEBwYXJhbSB7YW55fSBwcm9wc1xuXHQgKi9cblx0ZnVuY3Rpb24gd3JhcHBlcihhbmNob3IsIHByb3BzKSB7XG5cdFx0bGV0IGluc3RhbmNlID0ge307XG5cblx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi9cblx0XHRsZXQgZWZmZWN0O1xuXG5cdFx0bGV0IHJhbiA9IGZhbHNlO1xuXG5cdFx0YmxvY2soKCkgPT4ge1xuXHRcdFx0Y29uc3Qgc291cmNlID0gZ2V0X3NvdXJjZSgpO1xuXHRcdFx0Y29uc3QgY29tcG9uZW50ID0gZ2V0KHNvdXJjZSk7XG5cblx0XHRcdGlmIChlZmZlY3QpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRmb3IgKHZhciBrIGluIGluc3RhbmNlKSBkZWxldGUgaW5zdGFuY2Vba107XG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdGVmZmVjdCA9IGJyYW5jaCgoKSA9PiB7XG5cdFx0XHRcdC8vIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbnZhbGlkYXRlZCwgcmVwbGFjZSBpdCB3aXRob3V0IHRyYW5zaXRpb25zXG5cdFx0XHRcdGlmIChyYW4pIHNldF9zaG91bGRfaW50cm8oZmFsc2UpO1xuXG5cdFx0XHRcdC8vIHByZXNlcnZlIGdldHRlcnMvc2V0dGVyc1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcblx0XHRcdFx0XHRpbnN0YW5jZSxcblx0XHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhcblx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRcdG5ldy50YXJnZXQgPyBuZXcgY29tcG9uZW50KGFuY2hvciwgcHJvcHMpIDogY29tcG9uZW50KGFuY2hvciwgcHJvcHMpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChyYW4pIHNldF9zaG91bGRfaW50cm8odHJ1ZSk7XG5cdFx0XHR9KTtcblx0XHR9LCBFRkZFQ1RfVFJBTlNQQVJFTlQpO1xuXG5cdFx0cmFuID0gdHJ1ZTtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHdyYXBwZXJbRklMRU5BTUVdID0gb3JpZ2luYWxbRklMRU5BTUVdO1xuXG5cdC8vIEB0cy1pZ25vcmVcblx0d3JhcHBlcltITVJdID0ge1xuXHRcdC8vIFdoZW4gd2UgYWNjZXB0IGFuIHVwZGF0ZSwgd2Ugc2V0IHRoZSBvcmlnaW5hbCBzb3VyY2UgdG8gdGhlIG5ldyBjb21wb25lbnRcblx0XHRvcmlnaW5hbCxcblx0XHQvLyBUaGUgYGdldF9zb3VyY2VgIHBhcmFtZXRlciByZWFkcyBgd3JhcHBlcltITVJdLnNvdXJjZWAsIGJ1dCBpbiB0aGUgYGFjY2VwdGBcblx0XHQvLyBmdW5jdGlvbiB3ZSBhbHdheXMgcmVwbGFjZSBpdCB3aXRoIGBwcmV2aW91c1tITVJdLnNvdXJjZWAsIHdoaWNoIGluIHByYWN0aWNlXG5cdFx0Ly8gbWVhbnMgd2Ugb25seSBldmVyIHVwZGF0ZSB0aGUgb3JpZ2luYWxcblx0XHRzb3VyY2U6IHNvdXJjZShvcmlnaW5hbClcblx0fTtcblxuXHRyZXR1cm4gd3JhcHBlcjtcbn1cbiIsICIvKiogQHR5cGVkZWYge3sgZmlsZTogc3RyaW5nLCBsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyIH19IExvY2F0aW9uICovXG5cbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IExFR0FDWV9QUk9QUywgU1RBVEVfU1lNQk9MIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgc2FuaXRpemVfbG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogU2V0cyB1cCBhIHZhbGlkYXRvciB0aGF0XG4gKiAtIHRyYXZlcnNlcyB0aGUgcGF0aCBvZiBhIHByb3AgdG8gZmluZCBvdXQgaWYgaXQgaXMgYWxsb3dlZCB0byBiZSBtdXRhdGVkXG4gKiAtIGNoZWNrcyB0aGF0IHRoZSBiaW5kaW5nIGNoYWluIGlzIG5vdCBpbnRlcnJ1cHRlZFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX293bmVyc2hpcF92YWxpZGF0b3IocHJvcHMpIHtcblx0Y29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uO1xuXHRjb25zdCBwYXJlbnQgPSBjb21wb25lbnRfY29udGV4dD8ucD8uZnVuY3Rpb247XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuXHRcdCAqIEBwYXJhbSB7YW55W119IHBhdGhcblx0XHQgKiBAcGFyYW0ge2FueX0gcmVzdWx0XG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGxpbmVcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uXG5cdFx0ICovXG5cdFx0bXV0YXRpb246IChwcm9wLCBwYXRoLCByZXN1bHQsIGxpbmUsIGNvbHVtbikgPT4ge1xuXHRcdFx0Y29uc3QgbmFtZSA9IHBhdGhbMF07XG5cdFx0XHRpZiAoaXNfYm91bmRfb3JfdW5zZXQocHJvcHMsIG5hbWUpIHx8ICFwYXJlbnQpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0XHRsZXQgdmFsdWUgPSBwcm9wcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhdGhbaV1dO1xuXHRcdFx0XHRpZiAoIXZhbHVlPy5bU1RBVEVfU1lNQk9MXSkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbG9jYXRpb24gPSBzYW5pdGl6ZV9sb2NhdGlvbihgJHtjb21wb25lbnRbRklMRU5BTUVdfToke2xpbmV9OiR7Y29sdW1ufWApO1xuXG5cdFx0XHR3Lm93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uKG5hbWUsIGxvY2F0aW9uLCBwcm9wLCBwYXJlbnRbRklMRU5BTUVdKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7YW55fSBrZXlcblx0XHQgKiBAcGFyYW0ge2FueX0gY2hpbGRfY29tcG9uZW50XG5cdFx0ICogQHBhcmFtIHsoKSA9PiBhbnl9IHZhbHVlXG5cdFx0ICovXG5cdFx0YmluZGluZzogKGtleSwgY2hpbGRfY29tcG9uZW50LCB2YWx1ZSkgPT4ge1xuXHRcdFx0aWYgKCFpc19ib3VuZF9vcl91bnNldChwcm9wcywga2V5KSAmJiBwYXJlbnQgJiYgdmFsdWUoKT8uW1NUQVRFX1NZTUJPTF0pIHtcblx0XHRcdFx0dy5vd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nKFxuXHRcdFx0XHRcdGNvbXBvbmVudFtGSUxFTkFNRV0sXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGNoaWxkX2NvbXBvbmVudFtGSUxFTkFNRV0sXG5cdFx0XHRcdFx0cGFyZW50W0ZJTEVOQU1FXVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcF9uYW1lXG4gKi9cbmZ1bmN0aW9uIGlzX2JvdW5kX29yX3Vuc2V0KHByb3BzLCBwcm9wX25hbWUpIHtcblx0Ly8gQ2FuIGJlIHRoZSBjYXNlIHdoZW4gc29tZW9uZSBkb2VzIGBtb3VudChDb21wb25lbnQsIHByb3BzKWAgd2l0aCBgbGV0IHByb3BzID0gJHN0YXRlKHsuLi59KWBcblx0Ly8gb3IgYGNyZWF0ZUNsYXNzQ29tcG9uZW50KENvbXBvbmVudCwgcHJvcHMpYFxuXHRjb25zdCBpc19lbnRyeV9wcm9wcyA9IFNUQVRFX1NZTUJPTCBpbiBwcm9wcyB8fCBMRUdBQ1lfUFJPUFMgaW4gcHJvcHM7XG5cdHJldHVybiAoXG5cdFx0ISFnZXRfZGVzY3JpcHRvcihwcm9wcywgcHJvcF9uYW1lKT8uc2V0IHx8XG5cdFx0KGlzX2VudHJ5X3Byb3BzICYmIHByb3BfbmFtZSBpbiBwcm9wcykgfHxcblx0XHQhKHByb3BfbmFtZSBpbiBwcm9wcylcblx0KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG4vKiogQHBhcmFtIHtGdW5jdGlvbiAmIHsgW0ZJTEVOQU1FXTogc3RyaW5nIH19IHRhcmdldCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX3RhcmdldCh0YXJnZXQpIHtcblx0aWYgKHRhcmdldCkge1xuXHRcdGUuY29tcG9uZW50X2FwaV9pbnZhbGlkX25ldyh0YXJnZXRbRklMRU5BTUVdID8/ICdhIGNvbXBvbmVudCcsIHRhcmdldC5uYW1lKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X2FwaSgpIHtcblx0Y29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uO1xuXG5cdC8qKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kICovXG5cdGZ1bmN0aW9uIGVycm9yKG1ldGhvZCkge1xuXHRcdGUuY29tcG9uZW50X2FwaV9jaGFuZ2VkKG1ldGhvZCwgY29tcG9uZW50W0ZJTEVOQU1FXSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdCRkZXN0cm95OiAoKSA9PiBlcnJvcignJGRlc3Ryb3koKScpLFxuXHRcdCRvbjogKCkgPT4gZXJyb3IoJyRvbiguLi4pJyksXG5cdFx0JHNldDogKCkgPT4gZXJyb3IoJyRzZXQoLi4uKScpXG5cdH07XG59XG4iLCAiaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBzbmFwc2hvdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jbG9uZS5qcyc7XG5pbXBvcnQgeyBlYWdlcl9lZmZlY3QsIHJlbmRlcl9lZmZlY3QsIHZhbGlkYXRlX2VmZmVjdCB9IGZyb20gJy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBnZXRfZXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvZGV2LmpzJztcblxuLyoqXG4gKiBAcGFyYW0geygpID0+IGFueVtdfSBnZXRfdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGluc3BlY3RvclxuICogQHBhcmFtIHtib29sZWFufSBzaG93X3N0YWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0KGdldF92YWx1ZSwgaW5zcGVjdG9yLCBzaG93X3N0YWNrID0gZmFsc2UpIHtcblx0dmFsaWRhdGVfZWZmZWN0KCckaW5zcGVjdCcpO1xuXG5cdGxldCBpbml0aWFsID0gdHJ1ZTtcblx0bGV0IGVycm9yID0gLyoqIEB0eXBlIHthbnl9ICovIChVTklOSVRJQUxJWkVEKTtcblxuXHQvLyBJbnNwZWN0IGVmZmVjdHMgcnVucyBzeW5jaHJvbm91c2x5IHNvIHRoYXQgd2UgY2FuIGNhcHR1cmUgdXNlZnVsXG5cdC8vIHN0YWNrIHRyYWNlcy4gQXMgYSBjb25zZXF1ZW5jZSwgcmVhZGluZyB0aGUgdmFsdWUgbWlnaHQgcmVzdWx0XG5cdC8vIGluIGFuIGVycm9yIChhbiBgJGluc3BlY3Qob2JqZWN0LnByb3BlcnR5KWAgd2lsbCBydW4gYmVmb3JlIHRoZVxuXHQvLyBgeyNpZiBvYmplY3R9Li4uey9pZn1gIHRoYXQgY29udGFpbnMgaXQpXG5cdGVhZ2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciB2YWx1ZSA9IGdldF92YWx1ZSgpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGVycm9yID0gZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc25hcCA9IHNuYXBzaG90KHZhbHVlLCB0cnVlLCB0cnVlKTtcblx0XHR1bnRyYWNrKCgpID0+IHtcblx0XHRcdGlmIChzaG93X3N0YWNrKSB7XG5cdFx0XHRcdGluc3BlY3RvciguLi5zbmFwKTtcblxuXHRcdFx0XHRpZiAoIWluaXRpYWwpIHtcblx0XHRcdFx0XHRjb25zdCBzdGFjayA9IGdldF9lcnJvcignJGluc3BlY3QoLi4uKScpO1xuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cblx0XHRcdFx0XHRpZiAoc3RhY2spIHtcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdFx0XHRjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCdzdGFjayB0cmFjZScpO1xuXHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHN0YWNrKTtcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdFx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnNwZWN0b3IoaW5pdGlhbCA/ICdpbml0JyA6ICd1cGRhdGUnLCAuLi5zbmFwKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGluaXRpYWwgPSBmYWxzZTtcblx0fSk7XG5cblx0Ly8gSWYgYW4gZXJyb3Igb2NjdXJzLCB3ZSBzdG9yZSBpdCAoYWxvbmcgd2l0aCBpdHMgc3RhY2sgdHJhY2UpLlxuXHQvLyBJZiB0aGUgcmVuZGVyIGVmZmVjdCBzdWJzZXF1ZW50bHkgcnVucywgd2UgbG9nIHRoZSBlcnJvcixcblx0Ly8gYnV0IGlmIGl0IGRvZXNuJ3QgcnVuIGl0J3MgYmVjYXVzZSB0aGUgYCRpbnNwZWN0YCB3YXNcblx0Ly8gZGVzdHJveWVkLCBtZWFuaW5nIHdlIGRvbid0IG5lZWQgdG8gYm90aGVyXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBjYWxsIGBnZXRfdmFsdWVgIHNvIHRoYXQgdGhpcyBydW5zIGFsb25nc2lkZSB0aGUgaW5zcGVjdCBlZmZlY3Rcblx0XHRcdGdldF92YWx1ZSgpO1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0Ly8gaWdub3JlXG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yICE9PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS5lcnJvcihlcnJvcik7XG5cdFx0XHRlcnJvciA9IFVOSU5JVElBTElaRUQ7XG5cdFx0fVxuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYXN5bmMuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGN1cnJlbnRfYmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZyxcblx0c2tpcF9ub2Rlc1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0X2JvdW5kYXJ5IH0gZnJvbSAnLi9ib3VuZGFyeS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZTx2b2lkPj59IGJsb2NrZXJzXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IFByb21pc2U8YW55Pj59IGV4cHJlc3Npb25zXG4gKiBAcGFyYW0geyhhbmNob3I6IFRlbXBsYXRlTm9kZSwgLi4uZGVyaXZlZHM6IFZhbHVlW10pID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3luYyhub2RlLCBibG9ja2VycyA9IFtdLCBleHByZXNzaW9ucyA9IFtdLCBmbikge1xuXHR2YXIgYm91bmRhcnkgPSBnZXRfYm91bmRhcnkoKTtcblx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXHR2YXIgYmxvY2tpbmcgPSAhYm91bmRhcnkuaXNfcGVuZGluZygpO1xuXG5cdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KDEpO1xuXHRiYXRjaC5pbmNyZW1lbnQoYmxvY2tpbmcpO1xuXG5cdHZhciB3YXNfaHlkcmF0aW5nID0gaHlkcmF0aW5nO1xuXG5cdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cblx0XHR2YXIgcHJldmlvdXNfaHlkcmF0ZV9ub2RlID0gaHlkcmF0ZV9ub2RlO1xuXHRcdHZhciBlbmQgPSBza2lwX25vZGVzKGZhbHNlKTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKGVuZCk7XG5cdH1cblxuXHRmbGF0dGVuKGJsb2NrZXJzLCBbXSwgZXhwcmVzc2lvbnMsICh2YWx1ZXMpID0+IHtcblx0XHRpZiAod2FzX2h5ZHJhdGluZykge1xuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHRcdHNldF9oeWRyYXRlX25vZGUocHJldmlvdXNfaHlkcmF0ZV9ub2RlKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gZ2V0IHZhbHVlcyBlYWdlcmx5IHRvIGF2b2lkIGNyZWF0aW5nIGJsb2NrcyBpZiB0aGV5IHJlamVjdFxuXHRcdFx0Zm9yIChjb25zdCBkIG9mIHZhbHVlcykgZ2V0KGQpO1xuXG5cdFx0XHRmbihub2RlLCAuLi52YWx1ZXMpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAod2FzX2h5ZHJhdGluZykge1xuXHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoLTEpO1xuXHRcdFx0YmF0Y2guZGVjcmVtZW50KGJsb2NraW5nKTtcblx0XHR9XG5cdH0pO1xufVxuIiwgImltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbi8qKlxuICogQHBhcmFtIHtOb2RlfSBhbmNob3JcbiAqIEBwYXJhbSB7Li4uKCgpPT5hbnkpW119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3NuaXBwZXRfYXJncyhhbmNob3IsIC4uLmFyZ3MpIHtcblx0aWYgKHR5cGVvZiBhbmNob3IgIT09ICdvYmplY3QnIHx8ICEoYW5jaG9yIGluc3RhbmNlb2YgTm9kZSkpIHtcblx0XHRlLmludmFsaWRfc25pcHBldF9hcmd1bWVudHMoKTtcblx0fVxuXG5cdGZvciAobGV0IGFyZyBvZiBhcmdzKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmcgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGUuaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50cygpO1xuXHRcdH1cblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgQmF0Y2gsIGN1cnJlbnRfYmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcbmltcG9ydCB7XG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdG1vdmVfZWZmZWN0LFxuXHRwYXVzZV9lZmZlY3QsXG5cdHJlc3VtZV9lZmZlY3Rcbn0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV90ZXh0LCBzaG91bGRfZGVmZXJfYXBwZW5kIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3sgZWZmZWN0OiBFZmZlY3QsIGZyYWdtZW50OiBEb2N1bWVudEZyYWdtZW50IH19IEJyYW5jaFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEtleVxuICovXG5leHBvcnQgY2xhc3MgQnJhbmNoTWFuYWdlciB7XG5cdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqL1xuXHRhbmNob3I7XG5cblx0LyoqIEB0eXBlIHtNYXA8QmF0Y2gsIEtleT59ICovXG5cdCNiYXRjaGVzID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBNYXAgb2Yga2V5cyB0byBlZmZlY3RzIHRoYXQgYXJlIGN1cnJlbnRseSByZW5kZXJlZCBpbiB0aGUgRE9NLlxuXHQgKiBUaGVzZSBlZmZlY3RzIGFyZSB2aXNpYmxlIGFuZCBhY3RpdmVseSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB0cmVlLlxuXHQgKiBFeGFtcGxlOlxuXHQgKiBgYGBcblx0ICogeyNpZiBjb25kaXRpb259XG5cdCAqIFx0Zm9vXG5cdCAqIHs6ZWxzZX1cblx0ICogXHRiYXJcblx0ICogey9pZn1cblx0ICogYGBgXG5cdCAqIENhbiByZXN1bHQgaW4gdGhlIGVudHJpZXMgYHRydWUtPkVmZmVjdGAgYW5kIGBmYWxzZS0+RWZmZWN0YFxuXHQgKiBAdHlwZSB7TWFwPEtleSwgRWZmZWN0Pn1cblx0ICovXG5cdCNvbnNjcmVlbiA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogU2ltaWxhciB0byAjb25zY3JlZW4gd2l0aCByZXNwZWN0IHRvIHRoZSBrZXlzLCBidXQgY29udGFpbnMgYnJhbmNoZXMgdGhhdCBhcmUgbm90IHlldFxuXHQgKiBpbiB0aGUgRE9NLCBiZWNhdXNlIHRoZWlyIGluc2VydGlvbiBpcyBkZWZlcnJlZC5cblx0ICogQHR5cGUge01hcDxLZXksIEJyYW5jaD59XG5cdCAqL1xuXHQjb2Zmc2NyZWVuID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBLZXlzIG9mIGVmZmVjdHMgdGhhdCBhcmUgY3VycmVudGx5IG91dHJvaW5nXG5cdCAqIEB0eXBlIHtTZXQ8S2V5Pn1cblx0ICovXG5cdCNvdXRyb2luZyA9IG5ldyBTZXQoKTtcblxuXHQvKipcblx0ICogV2hldGhlciB0byBwYXVzZSAoaS5lLiBvdXRybykgb24gY2hhbmdlLCBvciBkZXN0cm95IGltbWVkaWF0ZWx5LlxuXHQgKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgYDxzdmVsdGU6ZWxlbWVudD5gXG5cdCAqL1xuXHQjdHJhbnNpdGlvbiA9IHRydWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBhbmNob3Jcblx0ICogQHBhcmFtIHtib29sZWFufSB0cmFuc2l0aW9uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihhbmNob3IsIHRyYW5zaXRpb24gPSB0cnVlKSB7XG5cdFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cdFx0dGhpcy4jdHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cdH1cblxuXHQjY29tbWl0ID0gKCkgPT4ge1xuXHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblxuXHRcdC8vIGlmIHRoaXMgYmF0Y2ggd2FzIG1hZGUgb2Jzb2xldGUsIGJhaWxcblx0XHRpZiAoIXRoaXMuI2JhdGNoZXMuaGFzKGJhdGNoKSkgcmV0dXJuO1xuXG5cdFx0dmFyIGtleSA9IC8qKiBAdHlwZSB7S2V5fSAqLyAodGhpcy4jYmF0Y2hlcy5nZXQoYmF0Y2gpKTtcblxuXHRcdHZhciBvbnNjcmVlbiA9IHRoaXMuI29uc2NyZWVuLmdldChrZXkpO1xuXG5cdFx0aWYgKG9uc2NyZWVuKSB7XG5cdFx0XHQvLyBlZmZlY3QgaXMgYWxyZWFkeSBpbiB0aGUgRE9NIFx1MjAxNCBhYm9ydCBhbnkgY3VycmVudCBvdXRyb1xuXHRcdFx0cmVzdW1lX2VmZmVjdChvbnNjcmVlbik7XG5cdFx0XHR0aGlzLiNvdXRyb2luZy5kZWxldGUoa2V5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZWZmZWN0IGlzIGN1cnJlbnRseSBvZmZzY3JlZW4uIHB1dCBpdCBpbiB0aGUgRE9NXG5cdFx0XHR2YXIgb2Zmc2NyZWVuID0gdGhpcy4jb2Zmc2NyZWVuLmdldChrZXkpO1xuXG5cdFx0XHRpZiAob2Zmc2NyZWVuKSB7XG5cdFx0XHRcdHRoaXMuI29uc2NyZWVuLnNldChrZXksIG9mZnNjcmVlbi5lZmZlY3QpO1xuXHRcdFx0XHR0aGlzLiNvZmZzY3JlZW4uZGVsZXRlKGtleSk7XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIHRoZSBhbmNob3IuLi5cblx0XHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChvZmZzY3JlZW4uZnJhZ21lbnQubGFzdENoaWxkKS5yZW1vdmUoKTtcblxuXHRcdFx0XHQvLyAuLi5hbmQgYXBwZW5kIHRoZSBmcmFnbWVudFxuXHRcdFx0XHR0aGlzLmFuY2hvci5iZWZvcmUob2Zmc2NyZWVuLmZyYWdtZW50KTtcblx0XHRcdFx0b25zY3JlZW4gPSBvZmZzY3JlZW4uZWZmZWN0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgW2IsIGtdIG9mIHRoaXMuI2JhdGNoZXMpIHtcblx0XHRcdHRoaXMuI2JhdGNoZXMuZGVsZXRlKGIpO1xuXG5cdFx0XHRpZiAoYiA9PT0gYmF0Y2gpIHtcblx0XHRcdFx0Ly8ga2VlcCB2YWx1ZXMgZm9yIG5ld2VyIGJhdGNoZXNcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG9mZnNjcmVlbiA9IHRoaXMuI29mZnNjcmVlbi5nZXQoayk7XG5cblx0XHRcdGlmIChvZmZzY3JlZW4pIHtcblx0XHRcdFx0Ly8gZm9yIG9sZGVyIGJhdGNoZXMsIGRlc3Ryb3kgb2Zmc2NyZWVuIGVmZmVjdHNcblx0XHRcdFx0Ly8gYXMgdGhleSB3aWxsIG5ldmVyIGJlIGNvbW1pdHRlZFxuXHRcdFx0XHRkZXN0cm95X2VmZmVjdChvZmZzY3JlZW4uZWZmZWN0KTtcblx0XHRcdFx0dGhpcy4jb2Zmc2NyZWVuLmRlbGV0ZShrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBvdXRyby9kZXN0cm95IGFsbCBvbnNjcmVlbiBlZmZlY3RzLi4uXG5cdFx0Zm9yIChjb25zdCBbaywgZWZmZWN0XSBvZiB0aGlzLiNvbnNjcmVlbikge1xuXHRcdFx0Ly8gLi4uZXhjZXB0IHRoZSBvbmUgdGhhdCB3YXMganVzdCBjb21taXR0ZWRcblx0XHRcdC8vICAgIG9yIHRob3NlIHRoYXQgYXJlIGFscmVhZHkgb3V0cm9pbmcgKGVsc2UgdGhlIHRyYW5zaXRpb24gaXMgYWJvcnRlZCBhbmQgdGhlIGVmZmVjdCBkZXN0cm95ZWQgcmlnaHQgYXdheSlcblx0XHRcdGlmIChrID09PSBrZXkgfHwgdGhpcy4jb3V0cm9pbmcuaGFzKGspKSBjb250aW51ZTtcblxuXHRcdFx0Y29uc3Qgb25fZGVzdHJveSA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3Qga2V5cyA9IEFycmF5LmZyb20odGhpcy4jYmF0Y2hlcy52YWx1ZXMoKSk7XG5cblx0XHRcdFx0aWYgKGtleXMuaW5jbHVkZXMoaykpIHtcblx0XHRcdFx0XHQvLyBrZWVwIHRoZSBlZmZlY3Qgb2Zmc2NyZWVuLCBhcyBhbm90aGVyIGJhdGNoIHdpbGwgbmVlZCBpdFxuXHRcdFx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XHRtb3ZlX2VmZmVjdChlZmZlY3QsIGZyYWdtZW50KTtcblxuXHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZChjcmVhdGVfdGV4dCgpKTsgLy8gVE9ETyBjYW4gd2UgYXZvaWQgdGhpcz9cblxuXHRcdFx0XHRcdHRoaXMuI29mZnNjcmVlbi5zZXQoaywgeyBlZmZlY3QsIGZyYWdtZW50IH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLiNvdXRyb2luZy5kZWxldGUoayk7XG5cdFx0XHRcdHRoaXMuI29uc2NyZWVuLmRlbGV0ZShrKTtcblx0XHRcdH07XG5cblx0XHRcdGlmICh0aGlzLiN0cmFuc2l0aW9uIHx8ICFvbnNjcmVlbikge1xuXHRcdFx0XHR0aGlzLiNvdXRyb2luZy5hZGQoayk7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QsIG9uX2Rlc3Ryb3ksIGZhbHNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9uX2Rlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QmF0Y2h9IGJhdGNoXG5cdCAqL1xuXHQjZGlzY2FyZCA9IChiYXRjaCkgPT4ge1xuXHRcdHRoaXMuI2JhdGNoZXMuZGVsZXRlKGJhdGNoKTtcblxuXHRcdGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHRoaXMuI2JhdGNoZXMudmFsdWVzKCkpO1xuXG5cdFx0Zm9yIChjb25zdCBbaywgYnJhbmNoXSBvZiB0aGlzLiNvZmZzY3JlZW4pIHtcblx0XHRcdGlmICgha2V5cy5pbmNsdWRlcyhrKSkge1xuXHRcdFx0XHRkZXN0cm95X2VmZmVjdChicmFuY2guZWZmZWN0KTtcblx0XHRcdFx0dGhpcy4jb2Zmc2NyZWVuLmRlbGV0ZShrKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7YW55fSBrZXlcblx0ICogQHBhcmFtIHtudWxsIHwgKCh0YXJnZXQ6IFRlbXBsYXRlTm9kZSkgPT4gdm9pZCl9IGZuXG5cdCAqL1xuXHRlbnN1cmUoa2V5LCBmbikge1xuXHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblx0XHR2YXIgZGVmZXIgPSBzaG91bGRfZGVmZXJfYXBwZW5kKCk7XG5cblx0XHRpZiAoZm4gJiYgIXRoaXMuI29uc2NyZWVuLmhhcyhrZXkpICYmICF0aGlzLiNvZmZzY3JlZW4uaGFzKGtleSkpIHtcblx0XHRcdGlmIChkZWZlcikge1xuXHRcdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBjcmVhdGVfdGV4dCgpO1xuXG5cdFx0XHRcdGZyYWdtZW50LmFwcGVuZCh0YXJnZXQpO1xuXG5cdFx0XHRcdHRoaXMuI29mZnNjcmVlbi5zZXQoa2V5LCB7XG5cdFx0XHRcdFx0ZWZmZWN0OiBicmFuY2goKCkgPT4gZm4odGFyZ2V0KSksXG5cdFx0XHRcdFx0ZnJhZ21lbnRcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLiNvbnNjcmVlbi5zZXQoXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGJyYW5jaCgoKSA9PiBmbih0aGlzLmFuY2hvcikpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy4jYmF0Y2hlcy5zZXQoYmF0Y2gsIGtleSk7XG5cblx0XHRpZiAoZGVmZXIpIHtcblx0XHRcdGZvciAoY29uc3QgW2ssIGVmZmVjdF0gb2YgdGhpcy4jb25zY3JlZW4pIHtcblx0XHRcdFx0aWYgKGsgPT09IGtleSkge1xuXHRcdFx0XHRcdGJhdGNoLnNraXBwZWRfZWZmZWN0cy5kZWxldGUoZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRiYXRjaC5za2lwcGVkX2VmZmVjdHMuYWRkKGVmZmVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChjb25zdCBbaywgYnJhbmNoXSBvZiB0aGlzLiNvZmZzY3JlZW4pIHtcblx0XHRcdFx0aWYgKGsgPT09IGtleSkge1xuXHRcdFx0XHRcdGJhdGNoLnNraXBwZWRfZWZmZWN0cy5kZWxldGUoYnJhbmNoLmVmZmVjdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YmF0Y2guc2tpcHBlZF9lZmZlY3RzLmFkZChicmFuY2guZWZmZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRiYXRjaC5vbmNvbW1pdCh0aGlzLiNjb21taXQpO1xuXHRcdFx0YmF0Y2gub25kaXNjYXJkKHRoaXMuI2Rpc2NhcmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdHRoaXMuYW5jaG9yID0gaHlkcmF0ZV9ub2RlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLiNjb21taXQoKTtcblx0XHR9XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IFNvdXJjZSwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGlzX3Byb21pc2UgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgYmxvY2sgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaW50ZXJuYWxfc2V0LCBtdXRhYmxlX3NvdXJjZSwgc291cmNlIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0aW5nLFxuXHRza2lwX25vZGVzLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBIWURSQVRJT05fU1RBUlRfRUxTRSwgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBpc19ydW5lcyB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGZsdXNoU3luYywgaXNfZmx1c2hpbmdfc3luYyB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuaW1wb3J0IHsgQnJhbmNoTWFuYWdlciB9IGZyb20gJy4vYnJhbmNoZXMuanMnO1xuaW1wb3J0IHsgY2FwdHVyZSwgdW5zZXRfY29udGV4dCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYXN5bmMuanMnO1xuXG5jb25zdCBQRU5ESU5HID0gMDtcbmNvbnN0IFRIRU4gPSAxO1xuY29uc3QgQ0FUQ0ggPSAyO1xuXG4vKiogQHR5cGVkZWYge3R5cGVvZiBQRU5ESU5HIHwgdHlwZW9mIFRIRU4gfCB0eXBlb2YgQ0FUQ0h9IEF3YWl0U3RhdGUgKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KCgpID0+IGFueSl9IGdldF9pbnB1dFxuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSBwZW5kaW5nX2ZuXG4gKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogTm9kZSwgdmFsdWU6IFNvdXJjZTxWPikgPT4gdm9pZCl9IHRoZW5fZm5cbiAqIEBwYXJhbSB7bnVsbCB8ICgoYW5jaG9yOiBOb2RlLCBlcnJvcjogdW5rbm93bikgPT4gdm9pZCl9IGNhdGNoX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF3YWl0X2Jsb2NrKG5vZGUsIGdldF9pbnB1dCwgcGVuZGluZ19mbiwgdGhlbl9mbiwgY2F0Y2hfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIHJ1bmVzID0gaXNfcnVuZXMoKTtcblxuXHR2YXIgdiA9IC8qKiBAdHlwZSB7Vn0gKi8gKFVOSU5JVElBTElaRUQpO1xuXHR2YXIgdmFsdWUgPSBydW5lcyA/IHNvdXJjZSh2KSA6IG11dGFibGVfc291cmNlKHYsIGZhbHNlLCBmYWxzZSk7XG5cdHZhciBlcnJvciA9IHJ1bmVzID8gc291cmNlKHYpIDogbXV0YWJsZV9zb3VyY2UodiwgZmFsc2UsIGZhbHNlKTtcblxuXHR2YXIgYnJhbmNoZXMgPSBuZXcgQnJhbmNoTWFuYWdlcihub2RlKTtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0dmFyIGlucHV0ID0gZ2V0X2lucHV0KCk7XG5cdFx0dmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuXG5cdFx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhIGh5ZHJhdGlvbiBtaXNtYXRjaC4gTmVlZHMgdG8gYmUgYSBgbGV0YCBvciBlbHNlIGl0IGlzbid0IHRyZWVzaGFrZW4gb3V0ICovXG5cdFx0Ly8gQHRzLWlnbm9yZSBjb2VyY2luZyBgbm9kZWAgdG8gYSBgQ29tbWVudGAgY2F1c2VzIFR5cGVTY3JpcHQgYW5kIFByZXR0aWVyIHRvIGZpZ2h0XG5cdFx0bGV0IG1pc21hdGNoID0gaHlkcmF0aW5nICYmIGlzX3Byb21pc2UoaW5wdXQpID09PSAobm9kZS5kYXRhID09PSBIWURSQVRJT05fU1RBUlRfRUxTRSk7XG5cblx0XHRpZiAobWlzbWF0Y2gpIHtcblx0XHRcdC8vIEh5ZHJhdGlvbiBtaXNtYXRjaDogcmVtb3ZlIGV2ZXJ5dGhpbmcgaW5zaWRlIHRoZSBhbmNob3IgYW5kIHN0YXJ0IGZyZXNoXG5cdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKHNraXBfbm9kZXMoKSk7XG5cdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfcHJvbWlzZShpbnB1dCkpIHtcblx0XHRcdHZhciByZXN0b3JlID0gY2FwdHVyZSgpO1xuXHRcdFx0dmFyIHJlc29sdmVkID0gZmFsc2U7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuXHRcdFx0ICovXG5cdFx0XHRjb25zdCByZXNvbHZlID0gKGZuKSA9PiB7XG5cdFx0XHRcdGlmIChkZXN0cm95ZWQpIHJldHVybjtcblxuXHRcdFx0XHRyZXNvbHZlZCA9IHRydWU7XG5cdFx0XHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gcmVzdG9yZSB0aGUgcHJldmlvdXMgYmF0Y2ggaGVyZTsgeyNhd2FpdH0gYmxvY2tzIGRvbid0IGZvbGxvdyB0aGUgYXN5bmMgbG9naWNcblx0XHRcdFx0Ly8gd2UgaGF2ZSBlbHNld2hlcmUsIGluc3RlYWQgcGVuZGluZy9yZXNvbHZlL2ZhaWwgc3RhdGVzIGFyZSBlYWNoIHRoZWlyIG93biBiYXRjaCBzbyB0byBzcGVhay5cblx0XHRcdFx0cmVzdG9yZShmYWxzZSk7XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgYmF0Y2gsIHNpbmNlIHRoZSBicmFuY2ggbWFuYWdlciBleHBlY3RzIG9uZSB0byBleGlzdFxuXHRcdFx0XHRCYXRjaC5lbnN1cmUoKTtcblxuXHRcdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdFx0Ly8gYHJlc3RvcmUoKWAgY291bGQgc2V0IGBoeWRyYXRpbmdgIHRvIGB0cnVlYCwgd2hpY2ggd2UgdmVyeSBtdWNoXG5cdFx0XHRcdFx0Ly8gZG9uJ3Qgd2FudCBcdTIwMTQgd2Ugd2FudCB0byByZXN0b3JlIGV2ZXJ5dGhpbmcgX2V4Y2VwdF8gdGhpc1xuXHRcdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmbigpO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblxuXHRcdFx0XHRcdC8vIHdpdGhvdXQgdGhpcywgdGhlIERPTSBkb2VzIG5vdCB1cGRhdGUgdW50aWwgdHdvIHRpY2tzIGFmdGVyIHRoZSBwcm9taXNlXG5cdFx0XHRcdFx0Ly8gcmVzb2x2ZXMsIHdoaWNoIGlzIHVuZXhwZWN0ZWQgYmVoYXZpb3VyIChhbmQgc29tZXdoYXQgaXJrc29tZSB0byB0ZXN0KVxuXHRcdFx0XHRcdGlmICghaXNfZmx1c2hpbmdfc3luYykgZmx1c2hTeW5jKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGlucHV0LnRoZW4oXG5cdFx0XHRcdCh2KSA9PiB7XG5cdFx0XHRcdFx0cmVzb2x2ZSgoKSA9PiB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbF9zZXQodmFsdWUsIHYpO1xuXHRcdFx0XHRcdFx0YnJhbmNoZXMuZW5zdXJlKFRIRU4sIHRoZW5fZm4gJiYgKCh0YXJnZXQpID0+IHRoZW5fZm4odGFyZ2V0LCB2YWx1ZSkpKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0KGUpID0+IHtcblx0XHRcdFx0XHRyZXNvbHZlKCgpID0+IHtcblx0XHRcdFx0XHRcdGludGVybmFsX3NldChlcnJvciwgZSk7XG5cdFx0XHRcdFx0XHRicmFuY2hlcy5lbnN1cmUoVEhFTiwgY2F0Y2hfZm4gJiYgKCh0YXJnZXQpID0+IGNhdGNoX2ZuKHRhcmdldCwgZXJyb3IpKSk7XG5cblx0XHRcdFx0XHRcdGlmICghY2F0Y2hfZm4pIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgbm8gY2F0Y2ggYmxvY2sgZXhpc3RzXG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yLnY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0YnJhbmNoZXMuZW5zdXJlKFBFTkRJTkcsIHBlbmRpbmdfZm4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIG1pY3JvdGFzayBiZWZvcmUgY2hlY2tpbmcgaWYgd2Ugc2hvdWxkIHNob3cgdGhlIHBlbmRpbmcgc3RhdGUgYXNcblx0XHRcdFx0Ly8gdGhlIHByb21pc2UgbWlnaHQgaGF2ZSByZXNvbHZlZCBieSB0aGVuXG5cdFx0XHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0XHRcdGlmICghcmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHJlc29sdmUoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRicmFuY2hlcy5lbnN1cmUoUEVORElORywgcGVuZGluZ19mbik7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnRlcm5hbF9zZXQodmFsdWUsIGlucHV0KTtcblx0XHRcdGJyYW5jaGVzLmVuc3VyZShUSEVOLCB0aGVuX2ZuICYmICgodGFyZ2V0KSA9PiB0aGVuX2ZuKHRhcmdldCwgdmFsdWUpKSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1pc21hdGNoKSB7XG5cdFx0XHQvLyBjb250aW51ZSBpbiBoeWRyYXRpb24gbW9kZVxuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0ZGVzdHJveWVkID0gdHJ1ZTtcblx0XHR9O1xuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBFRkZFQ1RfVFJBTlNQQVJFTlQgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGluZyxcblx0cmVhZF9oeWRyYXRpb25faW5zdHJ1Y3Rpb24sXG5cdHNraXBfbm9kZXMsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGJsb2NrIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IEhZRFJBVElPTl9TVEFSVF9FTFNFIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEJyYW5jaE1hbmFnZXIgfSBmcm9tICcuL2JyYW5jaGVzLmpzJztcblxuLy8gVE9ETyByZWluc3RhdGUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzE1MjUwXG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KGJyYW5jaDogKGZuOiAoYW5jaG9yOiBOb2RlKSA9PiB2b2lkLCBmbGFnPzogYm9vbGVhbikgPT4gdm9pZCkgPT4gdm9pZH0gZm5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Vsc2VpZl0gVHJ1ZSBpZiB0aGlzIGlzIGFuIGB7OmVsc2UgaWYgLi4ufWAgYmxvY2sgcmF0aGVyIHRoYW4gYW4gYHsjaWYgLi4ufWAsIGFzIHRoYXQgYWZmZWN0cyB3aGljaCB0cmFuc2l0aW9ucyBhcmUgY29uc2lkZXJlZCAnbG9jYWwnXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlmX2Jsb2NrKG5vZGUsIGZuLCBlbHNlaWYgPSBmYWxzZSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYnJhbmNoZXMgPSBuZXcgQnJhbmNoTWFuYWdlcihub2RlKTtcblx0dmFyIGZsYWdzID0gZWxzZWlmID8gRUZGRUNUX1RSQU5TUEFSRU5UIDogMDtcblxuXHQvKipcblx0ICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb24sXG5cdCAqIEBwYXJhbSB7bnVsbCB8ICgoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gZm5cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZV9icmFuY2goY29uZGl0aW9uLCBmbikge1xuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGNvbnN0IGlzX2Vsc2UgPSByZWFkX2h5ZHJhdGlvbl9pbnN0cnVjdGlvbihub2RlKSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0U7XG5cblx0XHRcdGlmIChjb25kaXRpb24gPT09IGlzX2Vsc2UpIHtcblx0XHRcdFx0Ly8gSHlkcmF0aW9uIG1pc21hdGNoOiByZW1vdmUgZXZlcnl0aGluZyBpbnNpZGUgdGhlIGFuY2hvciBhbmQgc3RhcnQgZnJlc2guXG5cdFx0XHRcdC8vIFRoaXMgY291bGQgaGFwcGVuIHdpdGggYHsjaWYgYnJvd3Nlcn0uLi57L2lmfWAsIGZvciBleGFtcGxlXG5cdFx0XHRcdHZhciBhbmNob3IgPSBza2lwX25vZGVzKCk7XG5cblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShhbmNob3IpO1xuXHRcdFx0XHRicmFuY2hlcy5hbmNob3IgPSBhbmNob3I7XG5cblx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdGJyYW5jaGVzLmVuc3VyZShjb25kaXRpb24sIGZuKTtcblx0XHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YnJhbmNoZXMuZW5zdXJlKGNvbmRpdGlvbiwgZm4pO1xuXHR9XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdHZhciBoYXNfYnJhbmNoID0gZmFsc2U7XG5cblx0XHRmbigoZm4sIGZsYWcgPSB0cnVlKSA9PiB7XG5cdFx0XHRoYXNfYnJhbmNoID0gdHJ1ZTtcblx0XHRcdHVwZGF0ZV9icmFuY2goZmxhZywgZm4pO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCFoYXNfYnJhbmNoKSB7XG5cdFx0XHR1cGRhdGVfYnJhbmNoKGZhbHNlLCBudWxsKTtcblx0XHR9XG5cdH0sIGZsYWdzKTtcbn1cbiIsICIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBpc19ydW5lcyB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgYmxvY2sgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgQnJhbmNoTWFuYWdlciB9IGZyb20gJy4vYnJhbmNoZXMuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBWfSBnZXRfa2V5XG4gKiBAcGFyYW0geyhhbmNob3I6IE5vZGUpID0+IFRlbXBsYXRlTm9kZSB8IHZvaWR9IHJlbmRlcl9mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZXkobm9kZSwgZ2V0X2tleSwgcmVuZGVyX2ZuKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBicmFuY2hlcyA9IG5ldyBCcmFuY2hNYW5hZ2VyKG5vZGUpO1xuXG5cdHZhciBsZWdhY3kgPSAhaXNfcnVuZXMoKTtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0dmFyIGtleSA9IGdldF9rZXkoKTtcblxuXHRcdC8vIGtleSBibG9ja3MgaW4gU3ZlbHRlIDw1IGhhZCBzdHVwaWQgc2VtYW50aWNzXG5cdFx0aWYgKGxlZ2FjeSAmJiBrZXkgIT09IG51bGwgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGtleSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHt9KTtcblx0XHR9XG5cblx0XHRicmFuY2hlcy5lbnN1cmUoa2V5LCByZW5kZXJfZm4pO1xuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyByZW5kZXJfZWZmZWN0LCB0ZWFyZG93biB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudCB8IFNWR0dFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IFJlY29yZDxzdHJpbmcsIHN0cmluZz59IGdldF9zdHlsZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3NzX3Byb3BzKGVsZW1lbnQsIGdldF9zdHlsZXMpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQoZWxlbWVudCkpKTtcblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciBzdHlsZXMgPSBnZXRfc3R5bGVzKCk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBzdHlsZXNba2V5XTtcblxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEZJTEVOQU1FLCBIWURSQVRJT05fRVJST1IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcmVtb3ZlX2VmZmVjdF9kb20sIHRlbXBsYXRlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwgfSBmcm9tICcuLi9yZWNvbmNpbGVyLmpzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4uL3RlbXBsYXRlLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgaGFzaCwgc2FuaXRpemVfbG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkLCBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBDT01NRU5UX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHNlcnZlcl9oYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2hlY2tfaGFzaChlbGVtZW50LCBzZXJ2ZXJfaGFzaCwgdmFsdWUpIHtcblx0aWYgKCFzZXJ2ZXJfaGFzaCB8fCBzZXJ2ZXJfaGFzaCA9PT0gaGFzaChTdHJpbmcodmFsdWUgPz8gJycpKSkgcmV0dXJuO1xuXG5cdGxldCBsb2NhdGlvbjtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGxvYyA9IGVsZW1lbnQuX19zdmVsdGVfbWV0YT8ubG9jO1xuXHRpZiAobG9jKSB7XG5cdFx0bG9jYXRpb24gPSBgbmVhciAke2xvYy5maWxlfToke2xvYy5saW5lfToke2xvYy5jb2x1bW59YDtcblx0fSBlbHNlIGlmIChkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24/LltGSUxFTkFNRV0pIHtcblx0XHRsb2NhdGlvbiA9IGBpbiAke2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbltGSUxFTkFNRV19YDtcblx0fVxuXG5cdHcuaHlkcmF0aW9uX2h0bWxfY2hhbmdlZChzYW5pdGl6ZV9sb2NhdGlvbihsb2NhdGlvbikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCB8IFRleHQgfCBDb21tZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IHN0cmluZ30gZ2V0X3ZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdmddXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFttYXRobWxdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWwobm9kZSwgZ2V0X3ZhbHVlLCBzdmcgPSBmYWxzZSwgbWF0aG1sID0gZmFsc2UsIHNraXBfd2FybmluZyA9IGZhbHNlKSB7XG5cdHZhciBhbmNob3IgPSBub2RlO1xuXG5cdHZhciB2YWx1ZSA9ICcnO1xuXG5cdHRlbXBsYXRlX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0XHRpZiAodmFsdWUgPT09ICh2YWx1ZSA9IGdldF92YWx1ZSgpID8/ICcnKSkge1xuXHRcdFx0aWYgKGh5ZHJhdGluZykgaHlkcmF0ZV9uZXh0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGVmZmVjdC5ub2Rlc19zdGFydCAhPT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlX2VmZmVjdF9kb20oZWZmZWN0Lm5vZGVzX3N0YXJ0LCAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGVmZmVjdC5ub2Rlc19lbmQpKTtcblx0XHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9IGVmZmVjdC5ub2Rlc19lbmQgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA9PT0gJycpIHJldHVybjtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdC8vIFdlJ3JlIGRlbGliZXJhdGVseSBub3QgdHJ5aW5nIHRvIHJlcGFpciBtaXNtYXRjaGVzIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQsXG5cdFx0XHQvLyBhcyBpdCdzIGNvc3RseSBhbmQgZXJyb3ItcHJvbmUgKGFuZCBpdCdzIGFuIGVkZ2UgY2FzZSB0byBoYXZlIGEgbWlzbWF0Y2ggYW55d2F5KVxuXHRcdFx0dmFyIGhhc2ggPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChoeWRyYXRlX25vZGUpLmRhdGE7XG5cdFx0XHR2YXIgbmV4dCA9IGh5ZHJhdGVfbmV4dCgpO1xuXHRcdFx0dmFyIGxhc3QgPSBuZXh0O1xuXG5cdFx0XHR3aGlsZSAoXG5cdFx0XHRcdG5leHQgIT09IG51bGwgJiZcblx0XHRcdFx0KG5leHQubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSB8fCAvKiogQHR5cGUge0NvbW1lbnR9ICovIChuZXh0KS5kYXRhICE9PSAnJylcblx0XHRcdCkge1xuXHRcdFx0XHRsYXN0ID0gbmV4dDtcblx0XHRcdFx0bmV4dCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhuZXh0KSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXh0ID09PSBudWxsKSB7XG5cdFx0XHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKERFViAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0XHRcdGNoZWNrX2hhc2goLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobmV4dC5wYXJlbnROb2RlKSwgaGFzaCwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBsYXN0KTtcblx0XHRcdGFuY2hvciA9IHNldF9oeWRyYXRlX25vZGUobmV4dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGh0bWwgPSB2YWx1ZSArICcnO1xuXHRcdGlmIChzdmcpIGh0bWwgPSBgPHN2Zz4ke2h0bWx9PC9zdmc+YDtcblx0XHRlbHNlIGlmIChtYXRobWwpIGh0bWwgPSBgPG1hdGg+JHtodG1sfTwvbWF0aD5gO1xuXG5cdFx0Ly8gRG9uJ3QgdXNlIGNyZWF0ZV9mcmFnbWVudF93aXRoX3NjcmlwdF9mcm9tX2h0bWwgaGVyZSBiZWNhdXNlIHRoYXQgd291bGQgbWVhbiBzY3JpcHQgdGFncyBhcmUgZXhlY3V0ZWQuXG5cdFx0Ly8gQGh0bWwgaXMgYmFzaWNhbGx5IGAuaW5uZXJIVE1MID0gLi4uYCBhbmQgdGhhdCBkb2Vzbid0IGV4ZWN1dGUgc2NyaXB0cyBlaXRoZXIgZHVlIHRvIHNlY3VyaXR5IHJlYXNvbnMuXG5cdFx0LyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gKi9cblx0XHR2YXIgbm9kZSA9IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwoaHRtbCk7XG5cblx0XHRpZiAoc3ZnIHx8IG1hdGhtbCkge1xuXHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSk7XG5cdFx0fVxuXG5cdFx0YXNzaWduX25vZGVzKFxuXHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpLFxuXHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChub2RlLmxhc3RDaGlsZClcblx0XHQpO1xuXG5cdFx0aWYgKHN2ZyB8fCBtYXRobWwpIHtcblx0XHRcdHdoaWxlIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpIHtcblx0XHRcdFx0YW5jaG9yLmJlZm9yZSgvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5jaG9yLmJlZm9yZShub2RlKTtcblx0XHR9XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0NvbW1lbnR9IGFuY2hvclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gc2xvdF9wcm9wc1xuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IENvbW1lbnQpID0+IHZvaWQpfSBmYWxsYmFja19mblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xvdChhbmNob3IsICQkcHJvcHMsIG5hbWUsIHNsb3RfcHJvcHMsIGZhbGxiYWNrX2ZuKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBzbG90X2ZuID0gJCRwcm9wcy4kJHNsb3RzPy5bbmFtZV07XG5cdC8vIEludGVyb3A6IENhbiB1c2Ugc25pcHBldHMgdG8gZmlsbCBzbG90c1xuXHR2YXIgaXNfaW50ZXJvcCA9IGZhbHNlO1xuXHRpZiAoc2xvdF9mbiA9PT0gdHJ1ZSkge1xuXHRcdHNsb3RfZm4gPSAkJHByb3BzW25hbWUgPT09ICdkZWZhdWx0JyA/ICdjaGlsZHJlbicgOiBuYW1lXTtcblx0XHRpc19pbnRlcm9wID0gdHJ1ZTtcblx0fVxuXG5cdGlmIChzbG90X2ZuID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZmFsbGJhY2tfZm4gIT09IG51bGwpIHtcblx0XHRcdGZhbGxiYWNrX2ZuKGFuY2hvcik7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHNsb3RfZm4oYW5jaG9yLCBpc19pbnRlcm9wID8gKCkgPT4gc2xvdF9wcm9wcyA6IHNsb3RfcHJvcHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBwcm9wc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVfc2xvdHMocHJvcHMpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn0gKi9cblx0Y29uc3Qgc2FuaXRpemVkID0ge307XG5cdGlmIChwcm9wcy5jaGlsZHJlbikgc2FuaXRpemVkLmRlZmF1bHQgPSB0cnVlO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBwcm9wcy4kJHNsb3RzKSB7XG5cdFx0c2FuaXRpemVkW2tleV0gPSB0cnVlO1xuXHR9XG5cdHJldHVybiBzYW5pdGl6ZWQ7XG59XG4iLCAiaW1wb3J0IHsgaXNfdm9pZCB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcblxuZXhwb3J0IHsgaW52YWxpZF9kZWZhdWx0X3NuaXBwZXQgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IHRhZ19mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCh0YWdfZm4pIHtcblx0Y29uc3QgdGFnID0gdGFnX2ZuKCk7XG5cdGlmICh0YWcgJiYgaXNfdm9pZCh0YWcpKSB7XG5cdFx0dy5keW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50KHRhZyk7XG5cdH1cbn1cblxuLyoqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gdGFnX2ZuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZHluYW1pY19lbGVtZW50X3RhZyh0YWdfZm4pIHtcblx0Y29uc3QgdGFnID0gdGFnX2ZuKCk7XG5cdGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuXHRpZiAodGFnICYmICFpc19zdHJpbmcpIHtcblx0XHRlLnN2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZSgpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHN0b3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcblx0aWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdGUuc3RvcmVfaW52YWxpZF9zaGFwZShuYW1lKTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB1bmtub3dufSBUXG4gKiBAcGFyYW0ge1R9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50X3NuaXBwZXRfc3RyaW5naWZpY2F0aW9uKGZuKSB7XG5cdGZuLnRvU3RyaW5nID0gKCkgPT4ge1xuXHRcdGUuc25pcHBldF93aXRob3V0X3JlbmRlcl90YWcoKTtcblx0XHRyZXR1cm4gJyc7XG5cdH07XG5cdHJldHVybiBmbjtcbn1cbiIsICIvKiogQGltcG9ydCB7IFNuaXBwZXQgfSBmcm9tICdzdmVsdGUnICovXG4vKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEdldHRlcnMgfSBmcm9tICcjc2hhcmVkJyAqL1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5ULCBFTEVNRU5UX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBibG9jaywgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uXG59IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sIH0gZnJvbSAnLi4vcmVjb25jaWxlci5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uLy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkLCBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBwcmV2ZW50X3NuaXBwZXRfc3RyaW5naWZpY2F0aW9uIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3ZhbGlkYXRlLmpzJztcbmltcG9ydCB7IEJyYW5jaE1hbmFnZXIgfSBmcm9tICcuL2JyYW5jaGVzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgeyhub2RlOiBUZW1wbGF0ZU5vZGUsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBTbmlwcGV0Rm5cbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygpID0+IFNuaXBwZXRGbiB8IG51bGwgfCB1bmRlZmluZWR9IGdldF9zbmlwcGV0XG4gKiBAcGFyYW0geygoKSA9PiBhbnkpW119IGFyZ3NcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc25pcHBldChub2RlLCBnZXRfc25pcHBldCwgLi4uYXJncykge1xuXHR2YXIgYnJhbmNoZXMgPSBuZXcgQnJhbmNoTWFuYWdlcihub2RlKTtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0Y29uc3Qgc25pcHBldCA9IGdldF9zbmlwcGV0KCkgPz8gbnVsbDtcblxuXHRcdGlmIChERVYgJiYgc25pcHBldCA9PSBudWxsKSB7XG5cdFx0XHRlLmludmFsaWRfc25pcHBldCgpO1xuXHRcdH1cblxuXHRcdGJyYW5jaGVzLmVuc3VyZShzbmlwcGV0LCBzbmlwcGV0ICYmICgoYW5jaG9yKSA9PiBzbmlwcGV0KGFuY2hvciwgLi4uYXJncykpKTtcblx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcbn1cblxuLyoqXG4gKiBJbiBkZXZlbG9wbWVudCwgd3JhcCB0aGUgc25pcHBldCBmdW5jdGlvbiBzbyB0aGF0IGl0IHBhc3NlcyB2YWxpZGF0aW9uLCBhbmQgc28gdGhhdCB0aGVcbiAqIGNvcnJlY3QgY29tcG9uZW50IGNvbnRleHQgaXMgc2V0IGZvciBvd25lcnNoaXAgY2hlY2tzXG4gKiBAcGFyYW0ge2FueX0gY29tcG9uZW50XG4gKiBAcGFyYW0geyhub2RlOiBUZW1wbGF0ZU5vZGUsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcF9zbmlwcGV0KGNvbXBvbmVudCwgZm4pIHtcblx0Y29uc3Qgc25pcHBldCA9ICgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gbm9kZSwgLyoqIEB0eXBlIHthbnlbXX0gKi8gLi4uYXJncykgPT4ge1xuXHRcdHZhciBwcmV2aW91c19jb21wb25lbnRfZnVuY3Rpb24gPSBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb247XG5cdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihjb21wb25lbnQpO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBmbihub2RlLCAuLi5hcmdzKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihwcmV2aW91c19jb21wb25lbnRfZnVuY3Rpb24pO1xuXHRcdH1cblx0fTtcblxuXHRwcmV2ZW50X3NuaXBwZXRfc3RyaW5naWZpY2F0aW9uKHNuaXBwZXQpO1xuXG5cdHJldHVybiBzbmlwcGV0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNuaXBwZXQgcHJvZ3JhbW1hdGljYWxseVxuICogQHRlbXBsYXRlIHt1bmtub3duW119IFBhcmFtc1xuICogQHBhcmFtIHsoLi4ucGFyYW1zOiBHZXR0ZXJzPFBhcmFtcz4pID0+IHtcbiAqICAgcmVuZGVyOiAoKSA9PiBzdHJpbmdcbiAqICAgc2V0dXA/OiAoZWxlbWVudDogRWxlbWVudCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKVxuICogfX0gZm5cbiAqIEByZXR1cm5zIHtTbmlwcGV0PFBhcmFtcz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYXdTbmlwcGV0KGZuKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHR5cGVzIGFyZSBhIGxpZVxuXHRyZXR1cm4gKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyBhbmNob3IsIC8qKiBAdHlwZSB7R2V0dGVyczxQYXJhbXM+fSAqLyAuLi5wYXJhbXMpID0+IHtcblx0XHR2YXIgc25pcHBldCA9IGZuKC4uLnBhcmFtcyk7XG5cblx0XHQvKiogQHR5cGUge0VsZW1lbnR9ICovXG5cdFx0dmFyIGVsZW1lbnQ7XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRlbGVtZW50ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaHRtbCA9IHNuaXBwZXQucmVuZGVyKCkudHJpbSgpO1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChodG1sKTtcblx0XHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQoZnJhZ21lbnQpKTtcblxuXHRcdFx0aWYgKERFViAmJiAoZ2V0X25leHRfc2libGluZyhlbGVtZW50KSAhPT0gbnVsbCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUpKSB7XG5cdFx0XHRcdHcuaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0YW5jaG9yLmJlZm9yZShlbGVtZW50KTtcblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHQgPSBzbmlwcGV0LnNldHVwPy4oZWxlbWVudCk7XG5cdFx0YXNzaWduX25vZGVzKGVsZW1lbnQsIGVsZW1lbnQpO1xuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRlYXJkb3duKHJlc3VsdCk7XG5cdFx0fVxuXHR9O1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlLCBEb20gfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgYmxvY2sgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgQnJhbmNoTWFuYWdlciB9IGZyb20gJy4vYnJhbmNoZXMuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBQXG4gKiBAdGVtcGxhdGUgeyhwcm9wczogUCkgPT4gdm9pZH0gQ1xuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gQ30gZ2V0X2NvbXBvbmVudFxuICogQHBhcmFtIHsoYW5jaG9yOiBUZW1wbGF0ZU5vZGUsIGNvbXBvbmVudDogQykgPT4gRG9tIHwgdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudChub2RlLCBnZXRfY29tcG9uZW50LCByZW5kZXJfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGJyYW5jaGVzID0gbmV3IEJyYW5jaE1hbmFnZXIobm9kZSk7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdHZhciBjb21wb25lbnQgPSBnZXRfY29tcG9uZW50KCkgPz8gbnVsbDtcblx0XHRicmFuY2hlcy5lbnN1cmUoY29tcG9uZW50LCBjb21wb25lbnQgJiYgKCh0YXJnZXQpID0+IHJlbmRlcl9mbih0YXJnZXQsIGNvbXBvbmVudCkpKTtcblx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEZJTEVOQU1FLCBOQU1FU1BBQ0VfU1ZHIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV90ZXh0LCBnZXRfZmlyc3RfY2hpbGQgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGJsb2NrLCB0ZWFyZG93biB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzZXRfc2hvdWxkX2ludHJvIH0gZnJvbSAnLi4vLi4vcmVuZGVyLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfZWFjaF9pdGVtLCBzZXRfY3VycmVudF9lYWNoX2l0ZW0gfSBmcm9tICcuL2VhY2guanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGRldl9zdGFjayB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBFRkZFQ1RfVFJBTlNQQVJFTlQsIEVMRU1FTlRfTk9ERSB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4uL3RlbXBsYXRlLmpzJztcbmltcG9ydCB7IGlzX3Jhd190ZXh0X2VsZW1lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyBCcmFuY2hNYW5hZ2VyIH0gZnJvbSAnLi9icmFuY2hlcy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtDb21tZW50IHwgRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGdldF90YWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfc3ZnXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8ICgoZWxlbWVudDogRWxlbWVudCwgYW5jaG9yOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCl9IHJlbmRlcl9mbixcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgKCgpID0+IHN0cmluZyl9IGdldF9uYW1lc3BhY2VcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgW251bWJlciwgbnVtYmVyXX0gbG9jYXRpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudChub2RlLCBnZXRfdGFnLCBpc19zdmcsIHJlbmRlcl9mbiwgZ2V0X25hbWVzcGFjZSwgbG9jYXRpb24pIHtcblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGZpbGVuYW1lID0gREVWICYmIGxvY2F0aW9uICYmIGNvbXBvbmVudF9jb250ZXh0Py5mdW5jdGlvbltGSUxFTkFNRV07XG5cblx0LyoqIEB0eXBlIHtudWxsIHwgRWxlbWVudH0gKi9cblx0dmFyIGVsZW1lbnQgPSBudWxsO1xuXG5cdGlmIChoeWRyYXRpbmcgJiYgaHlkcmF0ZV9ub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcblx0XHRlbGVtZW50ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGh5ZHJhdGluZyA/IGh5ZHJhdGVfbm9kZSA6IG5vZGUpO1xuXG5cdC8qKlxuXHQgKiBUaGUga2V5ZWQgYHsjZWFjaCAuLi59YCBpdGVtIGJsb2NrLCBpZiBhbnksIHRoYXQgdGhpcyBlbGVtZW50IGlzIGluc2lkZS5cblx0ICogV2UgdHJhY2sgdGhpcyBzbyB3ZSBjYW4gc2V0IGl0IHdoZW4gY2hhbmdpbmcgdGhlIGVsZW1lbnQsIGFsbG93aW5nIGFueVxuXHQgKiBgYW5pbWF0ZTpgIGRpcmVjdGl2ZSB0byBiaW5kIGl0c2VsZiB0byB0aGUgY29ycmVjdCBibG9ja1xuXHQgKi9cblx0dmFyIGVhY2hfaXRlbV9ibG9jayA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXG5cdHZhciBicmFuY2hlcyA9IG5ldyBCcmFuY2hNYW5hZ2VyKGFuY2hvciwgZmFsc2UpO1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRjb25zdCBuZXh0X3RhZyA9IGdldF90YWcoKSB8fCBudWxsO1xuXHRcdHZhciBucyA9IGdldF9uYW1lc3BhY2UgPyBnZXRfbmFtZXNwYWNlKCkgOiBpc19zdmcgfHwgbmV4dF90YWcgPT09ICdzdmcnID8gTkFNRVNQQUNFX1NWRyA6IG51bGw7XG5cblx0XHRpZiAobmV4dF90YWcgPT09IG51bGwpIHtcblx0XHRcdGJyYW5jaGVzLmVuc3VyZShudWxsLCBudWxsKTtcblx0XHRcdHNldF9zaG91bGRfaW50cm8odHJ1ZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0YnJhbmNoZXMuZW5zdXJlKG5leHRfdGFnLCAoYW5jaG9yKSA9PiB7XG5cdFx0XHQvLyBTZWUgZXhwbGFuYXRpb24gb2YgYGVhY2hfaXRlbV9ibG9ja2AgYWJvdmVcblx0XHRcdHZhciBwcmV2aW91c19lYWNoX2l0ZW0gPSBjdXJyZW50X2VhY2hfaXRlbTtcblx0XHRcdHNldF9jdXJyZW50X2VhY2hfaXRlbShlYWNoX2l0ZW1fYmxvY2spO1xuXG5cdFx0XHRpZiAobmV4dF90YWcpIHtcblx0XHRcdFx0ZWxlbWVudCA9IGh5ZHJhdGluZ1xuXHRcdFx0XHRcdD8gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZWxlbWVudClcblx0XHRcdFx0XHQ6IG5zXG5cdFx0XHRcdFx0XHQ/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgbmV4dF90YWcpXG5cdFx0XHRcdFx0XHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dF90YWcpO1xuXG5cdFx0XHRcdGlmIChERVYgJiYgbG9jYXRpb24pIHtcblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdFx0XHRcdFx0cGFyZW50OiBkZXZfc3RhY2ssXG5cdFx0XHRcdFx0XHRsb2M6IHtcblx0XHRcdFx0XHRcdFx0ZmlsZTogZmlsZW5hbWUsXG5cdFx0XHRcdFx0XHRcdGxpbmU6IGxvY2F0aW9uWzBdLFxuXHRcdFx0XHRcdFx0XHRjb2x1bW46IGxvY2F0aW9uWzFdXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbl9ub2RlcyhlbGVtZW50LCBlbGVtZW50KTtcblxuXHRcdFx0XHRpZiAocmVuZGVyX2ZuKSB7XG5cdFx0XHRcdFx0aWYgKGh5ZHJhdGluZyAmJiBpc19yYXdfdGV4dF9lbGVtZW50KG5leHRfdGFnKSkge1xuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCBoeWRyYXRpb24gZ2xpdGNoZXNcblx0XHRcdFx0XHRcdGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBJZiBoeWRyYXRpbmcsIHVzZSB0aGUgZXhpc3Rpbmcgc3NyIGNvbW1lbnQgYXMgdGhlIGFuY2hvciBzbyB0aGF0IHRoZVxuXHRcdFx0XHRcdC8vIGlubmVyIG9wZW4gYW5kIGNsb3NlIG1ldGhvZHMgY2FuIHBpY2sgdXAgdGhlIGV4aXN0aW5nIG5vZGVzIGNvcnJlY3RseVxuXHRcdFx0XHRcdHZhciBjaGlsZF9hbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKFxuXHRcdFx0XHRcdFx0aHlkcmF0aW5nID8gZ2V0X2ZpcnN0X2NoaWxkKGVsZW1lbnQpIDogZWxlbWVudC5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2hpbGRfYW5jaG9yID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShjaGlsZF9hbmNob3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGBjaGlsZF9hbmNob3JgIGlzIHVuZGVmaW5lZCBpZiB0aGlzIGlzIGEgdm9pZCBlbGVtZW50LCBidXQgd2Ugc3RpbGxcblx0XHRcdFx0XHQvLyBuZWVkIHRvIGNhbGwgYHJlbmRlcl9mbmAgaW4gb3JkZXIgdG8gcnVuIGFjdGlvbnMgZXRjLiBJZiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdC8vIGNvbnRhaW5zIGNoaWxkcmVuLCBpdCdzIGEgdXNlciBlcnJvciAod2hpY2ggaXMgd2FybmVkIG9uIGVsc2V3aGVyZSlcblx0XHRcdFx0XHQvLyBhbmQgdGhlIERPTSB3aWxsIGJlIHNpbGVudGx5IGRpc2NhcmRlZFxuXHRcdFx0XHRcdHJlbmRlcl9mbihlbGVtZW50LCBjaGlsZF9hbmNob3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gd2UgZG8gdGhpcyBhZnRlciBjYWxsaW5nIGByZW5kZXJfZm5gIHNvIHRoYXQgY2hpbGQgZWZmZWN0cyBkb24ndCBvdmVycmlkZSBgbm9kZXMuZW5kYFxuXHRcdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLm5vZGVzX2VuZCA9IGVsZW1lbnQ7XG5cblx0XHRcdFx0YW5jaG9yLmJlZm9yZShlbGVtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0c2V0X2N1cnJlbnRfZWFjaF9pdGVtKHByZXZpb3VzX2VhY2hfaXRlbSk7XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShhbmNob3IpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gcmV2ZXJ0IHRvIHRoZSBkZWZhdWx0IHN0YXRlIGFmdGVyIHRoZSBlZmZlY3QgaGFzIGJlZW4gY3JlYXRlZFxuXHRcdHNldF9zaG91bGRfaW50cm8odHJ1ZSk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0aWYgKG5leHRfdGFnKSB7XG5cdFx0XHRcdC8vIGlmIHdlJ3JlIGluIHRoaXMgY2FsbGJhY2sgYmVjYXVzZSB3ZSdyZSByZS1ydW5uaW5nIHRoZSBlZmZlY3QsXG5cdFx0XHRcdC8vIGRpc2FibGUgaW50cm9zICh1bmxlc3Mgbm8gZWxlbWVudCBpcyBjdXJyZW50bHkgZGlzcGxheWVkKVxuXHRcdFx0XHRzZXRfc2hvdWxkX2ludHJvKGZhbHNlKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LCBFRkZFQ1RfVFJBTlNQQVJFTlQpO1xuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHRzZXRfc2hvdWxkX2ludHJvKHRydWUpO1xuXHR9KTtcblxuXHRpZiAod2FzX2h5ZHJhdGluZykge1xuXHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShhbmNob3IpO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUsIHNldF9oeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX3RleHQsIGdldF9maXJzdF9jaGlsZCwgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgYmxvY2sgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFLCBIRUFEX0VGRkVDVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlKSA9PiB2b2lkfSByZW5kZXJfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZChoYXNoLCByZW5kZXJfZm4pIHtcblx0Ly8gVGhlIGhlYWQgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciB0aGUgZmlyc3QgaHlkcmF0aW9uIHBhc3MgYW5kIHNzciBjb21tZW50IG5vZGVzIG1heSBzdGlsbCBiZSBwcmVzZW50LFxuXHQvLyB0aGVyZWZvcmUgd2UgbmVlZCB0byBza2lwIHRoYXQgd2hlbiB3ZSBkZXRlY3QgdGhhdCB3ZSdyZSBub3QgaW4gaHlkcmF0aW9uIG1vZGUuXG5cdGxldCBwcmV2aW91c19oeWRyYXRlX25vZGUgPSBudWxsO1xuXHRsZXQgd2FzX2h5ZHJhdGluZyA9IGh5ZHJhdGluZztcblxuXHQvKiogQHR5cGUge0NvbW1lbnQgfCBUZXh0fSAqL1xuXHR2YXIgYW5jaG9yO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRwcmV2aW91c19oeWRyYXRlX25vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0XHR2YXIgaGVhZF9hbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChkb2N1bWVudC5oZWFkKSk7XG5cblx0XHQvLyBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSBoZWFkIGJsb2NrcyBpbiBvdXIgYXBwLCBhbmQgdGhleSBjb3VsZCBoYXZlIGJlZW5cblx0XHQvLyByZW5kZXJlZCBpbiBhbiBhcmJpdHJhcnkgb3JkZXIgXHUyMDE0IGZpbmQgb25lIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBjb21wb25lbnRcblx0XHR3aGlsZSAoXG5cdFx0XHRoZWFkX2FuY2hvciAhPT0gbnVsbCAmJlxuXHRcdFx0KGhlYWRfYW5jaG9yLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgfHwgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaGVhZF9hbmNob3IpLmRhdGEgIT09IGhhc2gpXG5cdFx0KSB7XG5cdFx0XHRoZWFkX2FuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhoZWFkX2FuY2hvcikpO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGNhbid0IGZpbmQgYW4gb3BlbmluZyBoeWRyYXRpb24gbWFya2VyLCBza2lwIGh5ZHJhdGlvbiAodGhpcyBjYW4gaGFwcGVuXG5cdFx0Ly8gaWYgYSBmcmFtZXdvcmsgcmVuZGVyZWQgYm9keSBidXQgbm90IGhlYWQgY29udGVudClcblx0XHRpZiAoaGVhZF9hbmNob3IgPT09IG51bGwpIHtcblx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoaGVhZF9hbmNob3IpKTtcblx0XHRcdGhlYWRfYW5jaG9yLnJlbW92ZSgpOyAvLyBpbiBjYXNlIHRoaXMgY29tcG9uZW50IGlzIHJlcGVhdGVkXG5cblx0XHRcdHNldF9oeWRyYXRlX25vZGUoc3RhcnQpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0YW5jaG9yID0gZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0YmxvY2soKCkgPT4gcmVuZGVyX2ZuKGFuY2hvciksIEhFQURfRUZGRUNUKTtcblx0fSBmaW5hbGx5IHtcblx0XHRpZiAod2FzX2h5ZHJhdGluZykge1xuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChwcmV2aW91c19oeWRyYXRlX25vZGUpKTtcblx0XHR9XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IHJlZ2lzdGVyX3N0eWxlIH0gZnJvbSAnLi4vZGV2L2Nzcy5qcyc7XG5pbXBvcnQgeyBlZmZlY3QgfSBmcm9tICcuLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gYW5jaG9yXG4gKiBAcGFyYW0ge3sgaGFzaDogc3RyaW5nLCBjb2RlOiBzdHJpbmcgfX0gY3NzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfc3R5bGVzKGFuY2hvciwgY3NzKSB7XG5cdC8vIFVzZSBgcXVldWVfbWljcm9fdGFza2AgdG8gZW5zdXJlIGBhbmNob3JgIGlzIGluIHRoZSBET00sIG90aGVyd2lzZSBnZXRSb290Tm9kZSgpIHdpbGwgeWllbGQgd3JvbmcgcmVzdWx0c1xuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdHZhciByb290ID0gYW5jaG9yLmdldFJvb3ROb2RlKCk7XG5cblx0XHR2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdFxuXHRcdFx0PyAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KVxuXHRcdFx0OiAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAocm9vdCkuaGVhZCA/PyAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAocm9vdC5vd25lckRvY3VtZW50KS5oZWFkO1xuXG5cdFx0Ly8gQWx3YXlzIHF1ZXJ5aW5nIHRoZSBET00gaXMgcm91Z2hseSB0aGUgc2FtZSBwZXJmIGFzIGFkZGl0aW9uYWxseSBjaGVja2luZyBmb3IgcHJlc2VuY2UgaW4gYSBtYXAgZmlyc3QgYXNzdW1pbmdcblx0XHQvLyB0aGF0IHlvdSdsbCBnZXQgY2FjaGUgaGl0cyBoYWxmIG9mIHRoZSB0aW1lLCBzbyB3ZSBqdXN0IGFsd2F5cyBxdWVyeSB0aGUgZG9tIGZvciBzaW1wbGljaXR5IGFuZCBjb2RlIHNhdmluZ3MuXG5cdFx0aWYgKCF0YXJnZXQucXVlcnlTZWxlY3RvcignIycgKyBjc3MuaGFzaCkpIHtcblx0XHRcdGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0XHRcdHN0eWxlLmlkID0gY3NzLmhhc2g7XG5cdFx0XHRzdHlsZS50ZXh0Q29udGVudCA9IGNzcy5jb2RlO1xuXG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXG5cdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdHJlZ2lzdGVyX3N0eWxlKGNzcy5oYXNoLCBzdHlsZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEFjdGlvblBheWxvYWQgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgZWZmZWN0LCByZW5kZXJfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNhZmVfbm90X2VxdWFsIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgeyBkZWVwX3JlYWRfc3RhdGUsIHVudHJhY2sgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7KGRvbTogRWxlbWVudCwgdmFsdWU/OiBQKSA9PiBBY3Rpb25QYXlsb2FkPFA+fSBhY3Rpb25cbiAqIEBwYXJhbSB7KCkgPT4gUH0gW2dldF92YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uKGRvbSwgYWN0aW9uLCBnZXRfdmFsdWUpIHtcblx0ZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgcGF5bG9hZCA9IHVudHJhY2soKCkgPT4gYWN0aW9uKGRvbSwgZ2V0X3ZhbHVlPy4oKSkgfHwge30pO1xuXG5cdFx0aWYgKGdldF92YWx1ZSAmJiBwYXlsb2FkPy51cGRhdGUpIHtcblx0XHRcdHZhciBpbml0ZWQgPSBmYWxzZTtcblx0XHRcdC8qKiBAdHlwZSB7UH0gKi9cblx0XHRcdHZhciBwcmV2ID0gLyoqIEB0eXBlIHthbnl9ICovICh7fSk7IC8vIGluaXRpYWxpemUgd2l0aCBzb21ldGhpbmcgc28gaXQncyBuZXZlciBlcXVhbCBvbiBmaXJzdCBydW5cblxuXHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGdldF92YWx1ZSgpO1xuXG5cdFx0XHRcdC8vIEFjdGlvbidzIHVwZGF0ZSBtZXRob2QgaXMgY29hcnNlLWdyYWluZWQsIGkuZS4gd2hlbiBhbnl0aGluZyBpbiB0aGUgcGFzc2VkIHZhbHVlIGNoYW5nZXMsIHVwZGF0ZS5cblx0XHRcdFx0Ly8gVGhpcyB3b3JrcyBpbiBsZWdhY3kgbW9kZSBiZWNhdXNlIG9mIG11dGFibGVfc291cmNlIGJlaW5nIHVwZGF0ZWQgYXMgYSB3aG9sZSwgYnV0IHdoZW4gdXNpbmcgJHN0YXRlXG5cdFx0XHRcdC8vIHRvZ2V0aGVyIHdpdGggYWN0aW9ucyBhbmQgbXV0YXRpb24sIGl0IHdvdWxkbid0IG5vdGljZSB0aGUgY2hhbmdlIHdpdGhvdXQgYSBkZWVwIHJlYWQuXG5cdFx0XHRcdGRlZXBfcmVhZF9zdGF0ZSh2YWx1ZSk7XG5cblx0XHRcdFx0aWYgKGluaXRlZCAmJiBzYWZlX25vdF9lcXVhbChwcmV2LCB2YWx1ZSkpIHtcblx0XHRcdFx0XHRwcmV2ID0gdmFsdWU7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gKHBheWxvYWQudXBkYXRlKSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpbml0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChwYXlsb2FkPy5kZXN0cm95KSB7XG5cdFx0XHRyZXR1cm4gKCkgPT4gLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gKHBheWxvYWQuZGVzdHJveSkoKTtcblx0XHR9XG5cdH0pO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGJyYW5jaCwgZWZmZWN0LCBkZXN0cm95X2VmZmVjdCwgbWFuYWdlZCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5cbi8vIFRPRE8gaW4gNi4wIG9yIDcuMCwgd2hlbiB3ZSByZW1vdmUgbGVnYWN5IG1vZGUsIHdlIGNhbiBzaW1wbGlmeSB0aGlzIGJ5XG4vLyBnZXR0aW5nIHJpZCBvZiB0aGUgYmxvY2svYnJhbmNoIHN0dWZmIGFuZCBqdXN0IGxldHRpbmcgdGhlIGVmZmVjdCByaXAuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzE1OTYyXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IChub2RlOiBFbGVtZW50KSA9PiB2b2lkfSBnZXRfZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChub2RlLCBnZXRfZm4pIHtcblx0LyoqIEB0eXBlIHtmYWxzZSB8IHVuZGVmaW5lZCB8ICgobm9kZTogRWxlbWVudCkgPT4gdm9pZCl9ICovXG5cdHZhciBmbiA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdHZhciBlO1xuXG5cdG1hbmFnZWQoKCkgPT4ge1xuXHRcdGlmIChmbiAhPT0gKGZuID0gZ2V0X2ZuKCkpKSB7XG5cdFx0XHRpZiAoZSkge1xuXHRcdFx0XHRkZXN0cm95X2VmZmVjdChlKTtcblx0XHRcdFx0ZSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmbikge1xuXHRcdFx0XHRlID0gYnJhbmNoKCgpID0+IHtcblx0XHRcdFx0XHRlZmZlY3QoKCkgPT4gLyoqIEB0eXBlIHsobm9kZTogRWxlbWVudCkgPT4gdm9pZH0gKi8gKGZuKShub2RlKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG4iLCAiaW1wb3J0IHsgdG9fY2xhc3MgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBudW1iZXJ9IGlzX2h0bWxcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW3ByZXZfY2xhc3Nlc11cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW25leHRfY2xhc3Nlc11cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jbGFzcyhkb20sIGlzX2h0bWwsIHZhbHVlLCBoYXNoLCBwcmV2X2NsYXNzZXMsIG5leHRfY2xhc3Nlcykge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdHZhciBwcmV2ID0gZG9tLl9fY2xhc3NOYW1lO1xuXG5cdGlmIChcblx0XHRoeWRyYXRpbmcgfHxcblx0XHRwcmV2ICE9PSB2YWx1ZSB8fFxuXHRcdHByZXYgPT09IHVuZGVmaW5lZCAvLyBmb3IgZWRnZSBjYXNlIG9mIGBjbGFzcz17dW5kZWZpbmVkfWBcblx0KSB7XG5cdFx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoLCBuZXh0X2NsYXNzZXMpO1xuXG5cdFx0aWYgKCFoeWRyYXRpbmcgfHwgbmV4dF9jbGFzc19uYW1lICE9PSBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpKSB7XG5cdFx0XHQvLyBSZW1vdmluZyB0aGUgYXR0cmlidXRlIHdoZW4gdGhlIHZhbHVlIGlzIG9ubHkgYW4gZW1wdHkgc3RyaW5nIGNhdXNlc1xuXHRcdFx0Ly8gcGVyZm9ybWFuY2UgaXNzdWVzIHZzIHNpbXBseSBtYWtpbmcgdGhlIGNsYXNzTmFtZSBhbiBlbXB0eSBzdHJpbmcuIFNvXG5cdFx0XHQvLyB3ZSBzaG91bGQgb25seSByZW1vdmUgdGhlIGNsYXNzIGlmIHRoZSB2YWx1ZSBpcyBudWxsaXNoXG5cdFx0XHQvLyBhbmQgdGhlcmUgbm8gaGFzaC9kaXJlY3RpdmVzIDpcblx0XHRcdGlmIChuZXh0X2NsYXNzX25hbWUgPT0gbnVsbCkge1xuXHRcdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdFx0fSBlbHNlIGlmIChpc19odG1sKSB7XG5cdFx0XHRcdGRvbS5jbGFzc05hbWUgPSBuZXh0X2NsYXNzX25hbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRfY2xhc3NfbmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IHZhbHVlO1xuXHR9IGVsc2UgaWYgKG5leHRfY2xhc3NlcyAmJiBwcmV2X2NsYXNzZXMgIT09IG5leHRfY2xhc3Nlcykge1xuXHRcdGZvciAodmFyIGtleSBpbiBuZXh0X2NsYXNzZXMpIHtcblx0XHRcdHZhciBpc19wcmVzZW50ID0gISFuZXh0X2NsYXNzZXNba2V5XTtcblxuXHRcdFx0aWYgKHByZXZfY2xhc3NlcyA9PSBudWxsIHx8IGlzX3ByZXNlbnQgIT09ICEhcHJldl9jbGFzc2VzW2tleV0pIHtcblx0XHRcdFx0ZG9tLmNsYXNzTGlzdC50b2dnbGUoa2V5LCBpc19wcmVzZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV4dF9jbGFzc2VzO1xufVxuIiwgImltcG9ydCB7IHRvX3N0eWxlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2F0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IGRvbVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBwcmV2XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IG5leHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJpb3JpdHldXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZV9zdHlsZXMoZG9tLCBwcmV2ID0ge30sIG5leHQsIHByaW9yaXR5KSB7XG5cdGZvciAodmFyIGtleSBpbiBuZXh0KSB7XG5cdFx0dmFyIHZhbHVlID0gbmV4dFtrZXldO1xuXG5cdFx0aWYgKHByZXZba2V5XSAhPT0gdmFsdWUpIHtcblx0XHRcdGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuXHRcdFx0XHRkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBwcmlvcml0eSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBkb21cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55PiB8IFtSZWNvcmQ8c3RyaW5nLCBhbnk+LCBSZWNvcmQ8c3RyaW5nLCBhbnk+XX0gW3ByZXZfc3R5bGVzXVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgW1JlY29yZDxzdHJpbmcsIGFueT4sIFJlY29yZDxzdHJpbmcsIGFueT5dfSBbbmV4dF9zdHlsZXNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3R5bGUoZG9tLCB2YWx1ZSwgcHJldl9zdHlsZXMsIG5leHRfc3R5bGVzKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0dmFyIHByZXYgPSBkb20uX19zdHlsZTtcblxuXHRpZiAoaHlkcmF0aW5nIHx8IHByZXYgIT09IHZhbHVlKSB7XG5cdFx0dmFyIG5leHRfc3R5bGVfYXR0ciA9IHRvX3N0eWxlKHZhbHVlLCBuZXh0X3N0eWxlcyk7XG5cblx0XHRpZiAoIWh5ZHJhdGluZyB8fCBuZXh0X3N0eWxlX2F0dHIgIT09IGRvbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcblx0XHRcdGlmIChuZXh0X3N0eWxlX2F0dHIgPT0gbnVsbCkge1xuXHRcdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSBuZXh0X3N0eWxlX2F0dHI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGRvbS5fX3N0eWxlID0gdmFsdWU7XG5cdH0gZWxzZSBpZiAobmV4dF9zdHlsZXMpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShuZXh0X3N0eWxlcykpIHtcblx0XHRcdHVwZGF0ZV9zdHlsZXMoZG9tLCBwcmV2X3N0eWxlcz8uWzBdLCBuZXh0X3N0eWxlc1swXSk7XG5cdFx0XHR1cGRhdGVfc3R5bGVzKGRvbSwgcHJldl9zdHlsZXM/LlsxXSwgbmV4dF9zdHlsZXNbMV0sICdpbXBvcnRhbnQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dXBkYXRlX3N0eWxlcyhkb20sIHByZXZfc3R5bGVzLCBuZXh0X3N0eWxlcyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5leHRfc3R5bGVzO1xufVxuIiwgImltcG9ydCB7IGVmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudCB9IGZyb20gJy4vc2hhcmVkLmpzJztcbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vLi4vLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBCYXRjaCwgY3VycmVudF9iYXRjaCwgcHJldmlvdXNfYmF0Y2ggfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLyoqXG4gKiBTZWxlY3RzIHRoZSBjb3JyZWN0IG9wdGlvbihzKSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdClcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbW91bnRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcgPSBmYWxzZSkge1xuXHRpZiAoc2VsZWN0Lm11bHRpcGxlKSB7XG5cdFx0Ly8gSWYgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGtlZXAgdGhlIHNlbGVjdGlvbiBhcyBpc1xuXHRcdGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiBub3QgYW4gYXJyYXksIHdhcm4gYW5kIGtlZXAgdGhlIHNlbGVjdGlvbiBhcyBpc1xuXHRcdGlmICghaXNfYXJyYXkodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gdy5zZWxlY3RfbXVsdGlwbGVfaW52YWxpZF92YWx1ZSgpO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgdXBkYXRlIHRoZSBzZWxlY3Rpb25cblx0XHRmb3IgKHZhciBvcHRpb24gb2Ygc2VsZWN0Lm9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmluY2x1ZGVzKGdldF9vcHRpb25fdmFsdWUob3B0aW9uKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Zm9yIChvcHRpb24gb2Ygc2VsZWN0Lm9wdGlvbnMpIHtcblx0XHR2YXIgb3B0aW9uX3ZhbHVlID0gZ2V0X29wdGlvbl92YWx1ZShvcHRpb24pO1xuXHRcdGlmIChpcyhvcHRpb25fdmFsdWUsIHZhbHVlKSkge1xuXHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIW1vdW50aW5nIHx8IHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG5cdH1cbn1cblxuLyoqXG4gKiBTZWxlY3RzIHRoZSBjb3JyZWN0IG9wdGlvbihzKSBpZiBgdmFsdWVgIGlzIGdpdmVuLFxuICogYW5kIHRoZW4gc2V0cyB1cCBhIG11dGF0aW9uIG9ic2VydmVyIHRvIHN5bmMgdGhlXG4gKiBjdXJyZW50IHNlbGVjdGlvbiB0byB0aGUgZG9tIHdoZW4gaXQgY2hhbmdlcy4gU3VjaFxuICogY2hhbmdlcyBjb3VsZCBmb3IgZXhhbXBsZSBvY2N1ciB3aGVuIG9wdGlvbnMgYXJlXG4gKiBpbnNpZGUgYW4gYCNlYWNoYCBibG9jay5cbiAqIEBwYXJhbSB7SFRNTFNlbGVjdEVsZW1lbnR9IHNlbGVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9zZWxlY3Qoc2VsZWN0KSB7XG5cdHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0c2VsZWN0X29wdGlvbihzZWxlY3QsIHNlbGVjdC5fX3ZhbHVlKTtcblx0XHQvLyBEZWxpYmVyYXRlbHkgZG9uJ3QgdXBkYXRlIHRoZSBwb3RlbnRpYWwgYmluZGluZyB2YWx1ZSxcblx0XHQvLyB0aGUgbW9kZWwgc2hvdWxkIGJlIHByZXNlcnZlZCB1bmxlc3MgZXhwbGljaXRseSBjaGFuZ2VkXG5cdH0pO1xuXG5cdG9ic2VydmVyLm9ic2VydmUoc2VsZWN0LCB7XG5cdFx0Ly8gTGlzdGVuIHRvIG9wdGlvbiBlbGVtZW50IGNoYW5nZXNcblx0XHRjaGlsZExpc3Q6IHRydWUsXG5cdFx0c3VidHJlZTogdHJ1ZSwgLy8gYmVjYXVzZSBvZiA8b3B0Z3JvdXA+XG5cdFx0Ly8gTGlzdGVuIHRvIG9wdGlvbiBlbGVtZW50IHZhbHVlIGF0dHJpYnV0ZSBjaGFuZ2VzXG5cdFx0Ly8gKGRvZXNuJ3QgZ2V0IG5vdGlmaWVkIG9mIHNlbGVjdCB2YWx1ZSBjaGFuZ2VzLFxuXHRcdC8vIGJlY2F1c2UgdGhhdCBwcm9wZXJ0eSBpcyBub3QgcmVmbGVjdGVkIGFzIGFuIGF0dHJpYnV0ZSlcblx0XHRhdHRyaWJ1dGVzOiB0cnVlLFxuXHRcdGF0dHJpYnV0ZUZpbHRlcjogWyd2YWx1ZSddXG5cdH0pO1xuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHRvYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNlbGVjdEVsZW1lbnR9IHNlbGVjdFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9zZWxlY3RfdmFsdWUoc2VsZWN0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgYmF0Y2hlcyA9IG5ldyBXZWFrU2V0KCk7XG5cdHZhciBtb3VudGluZyA9IHRydWU7XG5cblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChzZWxlY3QsICdjaGFuZ2UnLCAoaXNfcmVzZXQpID0+IHtcblx0XHR2YXIgcXVlcnkgPSBpc19yZXNldCA/ICdbc2VsZWN0ZWRdJyA6ICc6Y2hlY2tlZCc7XG5cdFx0LyoqIEB0eXBlIHt1bmtub3dufSAqL1xuXHRcdHZhciB2YWx1ZTtcblxuXHRcdGlmIChzZWxlY3QubXVsdGlwbGUpIHtcblx0XHRcdHZhbHVlID0gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLCBnZXRfb3B0aW9uX3ZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyoqIEB0eXBlIHtIVE1MT3B0aW9uRWxlbWVudCB8IG51bGx9ICovXG5cdFx0XHR2YXIgc2VsZWN0ZWRfb3B0aW9uID1cblx0XHRcdFx0c2VsZWN0LnF1ZXJ5U2VsZWN0b3IocXVlcnkpID8/XG5cdFx0XHRcdC8vIHdpbGwgZmFsbCBiYWNrIHRvIGZpcnN0IG5vbi1kaXNhYmxlZCBvcHRpb24gaWYgbm8gb3B0aW9uIGlzIHNlbGVjdGVkXG5cdFx0XHRcdHNlbGVjdC5xdWVyeVNlbGVjdG9yKCdvcHRpb246bm90KFtkaXNhYmxlZF0pJyk7XG5cdFx0XHR2YWx1ZSA9IHNlbGVjdGVkX29wdGlvbiAmJiBnZXRfb3B0aW9uX3ZhbHVlKHNlbGVjdGVkX29wdGlvbik7XG5cdFx0fVxuXG5cdFx0c2V0KHZhbHVlKTtcblxuXHRcdGlmIChjdXJyZW50X2JhdGNoICE9PSBudWxsKSB7XG5cdFx0XHRiYXRjaGVzLmFkZChjdXJyZW50X2JhdGNoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIE5lZWRzIHRvIGJlIGFuIGVmZmVjdCwgbm90IGEgcmVuZGVyX2VmZmVjdCwgc28gdGhhdCBpbiBjYXNlIG9mIGVhY2ggbG9vcHMgdGhlIGxvZ2ljIHJ1bnMgYWZ0ZXIgdGhlIGVhY2ggYmxvY2sgaGFzIHVwZGF0ZWRcblx0ZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblxuXHRcdGlmIChzZWxlY3QgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcblx0XHRcdC8vIHdlIG5lZWQgYm90aCwgYmVjYXVzZSBpbiBub24tYXN5bmMgbW9kZSwgcmVuZGVyIGVmZmVjdHMgcnVuIGJlZm9yZSBwcmV2aW91c19iYXRjaCBpcyBzZXRcblx0XHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChwcmV2aW91c19iYXRjaCA/PyBjdXJyZW50X2JhdGNoKTtcblxuXHRcdFx0Ly8gRG9uJ3QgdXBkYXRlIHRoZSA8c2VsZWN0PiBpZiBpdCBpcyBmb2N1c2VkLiBXZSBjYW4gZ2V0IGhlcmUgaWYsIGZvciBleGFtcGxlLFxuXHRcdFx0Ly8gYW4gdXBkYXRlIGlzIGRlZmVycmVkIGJlY2F1c2Ugb2YgYXN5bmMgd29yayBkZXBlbmRpbmcgb24gdGhlIHNlbGVjdDpcblx0XHRcdC8vXG5cdFx0XHQvLyA8c2VsZWN0IGJpbmQ6dmFsdWU9e3NlbGVjdGVkfT4uLi48L3NlbGVjdD5cblx0XHRcdC8vIDxwPnthd2FpdCBmaW5kKHNlbGVjdGVkKX08L3A+XG5cdFx0XHRpZiAoYmF0Y2hlcy5oYXMoYmF0Y2gpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nKTtcblxuXHRcdC8vIE1vdW50aW5nIGFuZCB2YWx1ZSB1bmRlZmluZWQgLT4gdGFrZSBzZWxlY3Rpb24gZnJvbSBkb21cblx0XHRpZiAobW91bnRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0LyoqIEB0eXBlIHtIVE1MT3B0aW9uRWxlbWVudCB8IG51bGx9ICovXG5cdFx0XHR2YXIgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG5cdFx0XHRpZiAoc2VsZWN0ZWRfb3B0aW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X29wdGlvbl92YWx1ZShzZWxlY3RlZF9vcHRpb24pO1xuXHRcdFx0XHRzZXQodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRzZWxlY3QuX192YWx1ZSA9IHZhbHVlO1xuXHRcdG1vdW50aW5nID0gZmFsc2U7XG5cdH0pO1xuXG5cdGluaXRfc2VsZWN0KHNlbGVjdCk7XG59XG5cbi8qKiBAcGFyYW0ge0hUTUxPcHRpb25FbGVtZW50fSBvcHRpb24gKi9cbmZ1bmN0aW9uIGdldF9vcHRpb25fdmFsdWUob3B0aW9uKSB7XG5cdC8vIF9fdmFsdWUgb25seSBleGlzdHMgaWYgdGhlIDxvcHRpb24+IGhhcyBhIHZhbHVlIGF0dHJpYnV0ZVxuXHRpZiAoJ19fdmFsdWUnIGluIG9wdGlvbikge1xuXHRcdHJldHVybiBvcHRpb24uX192YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gb3B0aW9uLnZhbHVlO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFZmZlY3QgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBoeWRyYXRpbmcsIHNldF9oeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3JzLCBnZXRfcHJvdG90eXBlX29mIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ldmVudCwgZGVsZWdhdGUgfSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgeyBhZGRfZm9ybV9yZXNldF9saXN0ZW5lciwgYXV0b2ZvY3VzIH0gZnJvbSAnLi9taXNjLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgTE9BRElOR19BVFRSX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IGlzX2NhcHR1cmVfZXZlbnQsIGNhbl9kZWxlZ2F0ZV9ldmVudCwgbm9ybWFsaXplX2F0dHJpYnV0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0Z2V0LFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGF0dGFjaCB9IGZyb20gJy4vYXR0YWNobWVudHMuanMnO1xuaW1wb3J0IHsgY2xzeCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9hdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IHNldF9jbGFzcyB9IGZyb20gJy4vY2xhc3MuanMnO1xuaW1wb3J0IHsgc2V0X3N0eWxlIH0gZnJvbSAnLi9zdHlsZS5qcyc7XG5pbXBvcnQgeyBBVFRBQ0hNRU5UX0tFWSwgTkFNRVNQQUNFX0hUTUwsIFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYnJhbmNoLCBkZXN0cm95X2VmZmVjdCwgZWZmZWN0LCBtYW5hZ2VkIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGluaXRfc2VsZWN0LCBzZWxlY3Rfb3B0aW9uIH0gZnJvbSAnLi9iaW5kaW5ncy9zZWxlY3QuanMnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYXN5bmMuanMnO1xuXG5leHBvcnQgY29uc3QgQ0xBU1MgPSBTeW1ib2woJ2NsYXNzJyk7XG5leHBvcnQgY29uc3QgU1RZTEUgPSBTeW1ib2woJ3N0eWxlJyk7XG5cbmNvbnN0IElTX0NVU1RPTV9FTEVNRU5UID0gU3ltYm9sKCdpcyBjdXN0b20gZWxlbWVudCcpO1xuY29uc3QgSVNfSFRNTCA9IFN5bWJvbCgnaXMgaHRtbCcpO1xuXG4vKipcbiAqIFRoZSB2YWx1ZS9jaGVja2VkIGF0dHJpYnV0ZSBpbiB0aGUgdGVtcGxhdGUgYWN0dWFsbHkgY29ycmVzcG9uZHMgdG8gdGhlIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSwgc28gd2UgbmVlZFxuICogdG8gcmVtb3ZlIGl0IHVwb24gaHlkcmF0aW9uIHRvIGF2b2lkIGEgYnVnIHdoZW4gc29tZW9uZSByZXNldHMgdGhlIGZvcm0gdmFsdWUuXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9pbnB1dF9kZWZhdWx0cyhpbnB1dCkge1xuXHRpZiAoIWh5ZHJhdGluZykgcmV0dXJuO1xuXG5cdHZhciBhbHJlYWR5X3JlbW92ZWQgPSBmYWxzZTtcblxuXHQvLyBXZSB0cnkgYW5kIHJlbW92ZSB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGxhdGVyLCByYXRoZXIgdGhhbiBzeW5jIGR1cmluZyBoeWRyYXRpb24uXG5cdC8vIERvaW5nIGl0IHN5bmMgZHVyaW5nIGh5ZHJhdGlvbiBoYXMgYSBuZWdhdGl2ZSBpbXBhY3Qgb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWZlcnJpbmcgdGhlXG5cdC8vIHdvcmsgaW4gYW4gaWRsZSB0YXNrIGFsbGV2aWF0ZXMgdGhpcyBncmVhdGx5LiBJZiBhIGZvcm0gcmVzZXQgZXZlbnQgY29tZXMgaW4gYmVmb3JlXG5cdC8vIHRoZSBpZGxlIGNhbGxiYWNrLCB0aGVuIHdlIGVuc3VyZSB0aGUgaW5wdXQgZGVmYXVsdHMgYXJlIGNsZWFyZWQganVzdCBiZWZvcmUuXG5cdHZhciByZW1vdmVfZGVmYXVsdHMgPSAoKSA9PiB7XG5cdFx0aWYgKGFscmVhZHlfcmVtb3ZlZCkgcmV0dXJuO1xuXHRcdGFscmVhZHlfcmVtb3ZlZCA9IHRydWU7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGF0dHJpYnV0ZXMgYnV0IHByZXNlcnZlIHRoZSB2YWx1ZXNcblx0XHRpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZTtcblx0XHRcdHNldF9hdHRyaWJ1dGUoaW5wdXQsICd2YWx1ZScsIG51bGwpO1xuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCdjaGVja2VkJykpIHtcblx0XHRcdHZhciBjaGVja2VkID0gaW5wdXQuY2hlY2tlZDtcblx0XHRcdHNldF9hdHRyaWJ1dGUoaW5wdXQsICdjaGVja2VkJywgbnVsbCk7XG5cdFx0XHRpbnB1dC5jaGVja2VkID0gY2hlY2tlZDtcblx0XHR9XG5cdH07XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRpbnB1dC5fX29uX3IgPSByZW1vdmVfZGVmYXVsdHM7XG5cdHF1ZXVlX21pY3JvX3Rhc2socmVtb3ZlX2RlZmF1bHRzKTtcblx0YWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3ZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG5cdHZhciBhdHRyaWJ1dGVzID0gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMudmFsdWUgPT09XG5cdFx0XHQoYXR0cmlidXRlcy52YWx1ZSA9XG5cdFx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdFx0dmFsdWUgPz8gdW5kZWZpbmVkKSB8fFxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHQvLyBgcHJvZ3Jlc3NgIGVsZW1lbnRzIGFsd2F5cyBuZWVkIHRoZWlyIHZhbHVlIHNldCB3aGVuIGl0J3MgYDBgXG5cdFx0KGVsZW1lbnQudmFsdWUgPT09IHZhbHVlICYmICh2YWx1ZSAhPT0gMCB8fCBlbGVtZW50Lm5vZGVOYW1lICE9PSAnUFJPR1JFU1MnKSlcblx0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50LnZhbHVlID0gdmFsdWUgPz8gJyc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jaGVja2VkKGVsZW1lbnQsIGNoZWNrZWQpIHtcblx0dmFyIGF0dHJpYnV0ZXMgPSBnZXRfYXR0cmlidXRlcyhlbGVtZW50KTtcblxuXHRpZiAoXG5cdFx0YXR0cmlidXRlcy5jaGVja2VkID09PVxuXHRcdChhdHRyaWJ1dGVzLmNoZWNrZWQgPVxuXHRcdFx0Ly8gdHJlYXQgbnVsbCBhbmQgdW5kZWZpbmVkIHRoZSBzYW1lIGZvciB0aGUgaW5pdGlhbCB2YWx1ZVxuXHRcdFx0Y2hlY2tlZCA/PyB1bmRlZmluZWQpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudC5jaGVja2VkID0gY2hlY2tlZDtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSBvbiBhbiBgb3B0aW9uYCBlbGVtZW50LlxuICogTm90IHNldCB0aHJvdWdoIHRoZSBwcm9wZXJ0eSBiZWNhdXNlIHRoYXQgZG9lc24ndCByZWZsZWN0IHRvIHRoZSBET00sXG4gKiB3aGljaCBtZWFucyBpdCB3b3VsZG4ndCBiZSB0YWtlbiBpbnRvIGFjY291bnQgd2hlbiBhIGZvcm0gaXMgcmVzZXQuXG4gKiBAcGFyYW0ge0hUTUxPcHRpb25FbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc2VsZWN0ZWQoZWxlbWVudCwgc2VsZWN0ZWQpIHtcblx0aWYgKHNlbGVjdGVkKSB7XG5cdFx0Ly8gVGhlIHNlbGVjdGVkIG9wdGlvbiBjb3VsZCd2ZSBjaGFuZ2VkIHZpYSB1c2VyIHNlbGVjdGlvbiwgYW5kXG5cdFx0Ly8gc2V0dGluZyB0aGUgdmFsdWUgd2l0aG91dCB0aGlzIGNoZWNrIHdvdWxkIHNldCBpdCBiYWNrLlxuXHRcdGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICcnKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkZWZhdWx0IGNoZWNrZWQgcHJvcGVydHkgd2l0aG91dCBpbmZsdWVuY2luZyB0aGUgY3VycmVudCBjaGVja2VkIHByb3BlcnR5LlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZWZhdWx0X2NoZWNrZWQoZWxlbWVudCwgY2hlY2tlZCkge1xuXHRjb25zdCBleGlzdGluZ192YWx1ZSA9IGVsZW1lbnQuY2hlY2tlZDtcblx0ZWxlbWVudC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XG5cdGVsZW1lbnQuY2hlY2tlZCA9IGV4aXN0aW5nX3ZhbHVlO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGRlZmF1bHQgdmFsdWUgcHJvcGVydHkgd2l0aG91dCBpbmZsdWVuY2luZyB0aGUgY3VycmVudCB2YWx1ZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RlZmF1bHRfdmFsdWUoZWxlbWVudCwgdmFsdWUpIHtcblx0Y29uc3QgZXhpc3RpbmdfdmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuXHRlbGVtZW50LmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuXHRlbGVtZW50LnZhbHVlID0gZXhpc3RpbmdfdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUsIHNraXBfd2FybmluZykge1xuXHR2YXIgYXR0cmlidXRlcyA9IGdldF9hdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXG5cdFx0aWYgKFxuXHRcdFx0YXR0cmlidXRlID09PSAnc3JjJyB8fFxuXHRcdFx0YXR0cmlidXRlID09PSAnc3Jjc2V0JyB8fFxuXHRcdFx0KGF0dHJpYnV0ZSA9PT0gJ2hyZWYnICYmIGVsZW1lbnQubm9kZU5hbWUgPT09ICdMSU5LJylcblx0XHQpIHtcblx0XHRcdGlmICghc2tpcF93YXJuaW5nKSB7XG5cdFx0XHRcdGNoZWNrX3NyY19pbl9kZXZfaHlkcmF0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUgPz8gJycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSByZXNldCB0aGVzZSBhdHRyaWJ1dGVzLCB0aGV5IHdvdWxkIHJlc3VsdCBpbiBhbm90aGVyIG5ldHdvcmsgcmVxdWVzdCwgd2hpY2ggd2Ugd2FudCB0byBhdm9pZC5cblx0XHRcdC8vIFdlIGFzc3VtZSB0aGV5IGFyZSB0aGUgc2FtZSBiZXR3ZWVuIGNsaWVudCBhbmQgc2VydmVyIGFzIGNoZWNraW5nIGlmIHRoZXkgYXJlIGVxdWFsIGlzIGV4cGVuc2l2ZVxuXHRcdFx0Ly8gKHdlIGNhbid0IGp1c3QgY29tcGFyZSB0aGUgc3RyaW5ncyBhcyB0aGV5IGNhbiBiZSBkaWZmZXJlbnQgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlciBidXQgcmVzdWx0IGluIHRoZVxuXHRcdFx0Ly8gc2FtZSB1cmwsIHNvIHdlIHdvdWxkIG5lZWQgdG8gY3JlYXRlIGhpZGRlbiBhbmNob3IgZWxlbWVudHMgdG8gY29tcGFyZSB0aGVtKVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdGlmIChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPT09IChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZSkpIHJldHVybjtcblxuXHRpZiAoYXR0cmlidXRlID09PSAnbG9hZGluZycpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudFtMT0FESU5HX0FUVFJfU1lNQk9MXSA9IHZhbHVlO1xuXHR9XG5cblx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgZ2V0X3NldHRlcnMoZWxlbWVudCkuaW5jbHVkZXMoYXR0cmlidXRlKSkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRlbGVtZW50W2F0dHJpYnV0ZV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF94bGlua19hdHRyaWJ1dGUoZG9tLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdGRvbS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG5cdC8vIFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgc2V0dGluZyBjdXN0b20gZWxlbWVudCBwcm9wcywgd2hpY2ggY2FuXG5cdC8vIGludm9rZSBsaWZlY3ljbGUgbWV0aG9kcyBvbiBvdGhlciBjdXN0b20gZWxlbWVudHMsIGRvZXMgbm90IGFsc29cblx0Ly8gYXNzb2NpYXRlIHRob3NlIGxpZmVjeWNsZSBtZXRob2RzIHdpdGggdGhlIGN1cnJlbnQgYWN0aXZlIHJlYWN0aW9uXG5cdC8vIG9yIGVmZmVjdFxuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdC8vIElmIHdlJ3JlIGh5ZHJhdGluZyBidXQgdGhlIGN1c3RvbSBlbGVtZW50IGlzIGZyb20gU3ZlbHRlLCBhbmQgaXQgYWxyZWFkeSBzY2FmZm9sZGVkLFxuXHQvLyB0aGVuIGl0IG1pZ2h0IHJ1biBibG9jayBsb2dpYyBpbiBoeWRyYXRpb24gbW9kZSwgd2hpY2ggd2UgaGF2ZSB0byBwcmV2ZW50LlxuXHRsZXQgd2FzX2h5ZHJhdGluZyA9IGh5ZHJhdGluZztcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHR9XG5cblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cblx0dHJ5IHtcblx0XHRpZiAoXG5cdFx0XHQvLyBgc3R5bGVgIHNob3VsZCB1c2UgYHNldF9hdHRyaWJ1dGVgIHJhdGhlciB0aGFuIHRoZSBzZXR0ZXJcblx0XHRcdHByb3AgIT09ICdzdHlsZScgJiZcblx0XHRcdC8vIERvbid0IGNvbXB1dGUgc2V0dGVycyBmb3IgY3VzdG9tIGVsZW1lbnRzIHdoaWxlIHRoZXkgYXJlbid0IHJlZ2lzdGVyZWQgeWV0LFxuXHRcdFx0Ly8gYmVjYXVzZSBkdXJpbmcgdGhlaXIgdXBncmFkZS9pbnN0YW50aWF0aW9uIHRoZXkgbWlnaHQgYWRkIG1vcmUgc2V0dGVycy5cblx0XHRcdC8vIEluc3RlYWQsIGZhbGwgYmFjayB0byBhIHNpbXBsZSBcImFuIG9iamVjdCwgdGhlbiBzZXQgYXMgcHJvcGVydHlcIiBoZXVyaXN0aWMuXG5cdFx0XHQoc2V0dGVyc19jYWNoZS5oYXMobm9kZS5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgbm9kZS5ub2RlTmFtZSkgfHxcblx0XHRcdC8vIGN1c3RvbUVsZW1lbnRzIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIGJyb3dzZXIgZXh0ZW5zaW9uIGNvbnRleHRzXG5cdFx0XHQhY3VzdG9tRWxlbWVudHMgfHxcblx0XHRcdGN1c3RvbUVsZW1lbnRzLmdldChub2RlLmdldEF0dHJpYnV0ZSgnaXMnKSB8fCBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0PyBnZXRfc2V0dGVycyhub2RlKS5pbmNsdWRlcyhwcm9wKVxuXHRcdFx0XHQ6IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpXG5cdFx0KSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRub2RlW3Byb3BdID0gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFdlIGRpZCBnZXR0ZXJzIGV0YyBjaGVja3MgYWxyZWFkeSwgc3RyaW5naWZ5IGJlZm9yZSBwYXNzaW5nIHRvIHNldF9hdHRyaWJ1dGVcblx0XHRcdC8vIHRvIGVuc3VyZSBpdCBkb2Vzbid0IGludm9rZSB0aGUgc2FtZSBsb2dpYyBhZ2FpbiwgYW5kIHBvdGVudGlhbGx5IHBvcHVsYXRpbmdcblx0XHRcdC8vIHRoZSBzZXR0ZXJzIGNhY2hlIHRvbyBlYXJseS5cblx0XHRcdHNldF9hdHRyaWJ1dGUobm9kZSwgcHJvcCwgdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogU3RyaW5nKHZhbHVlKSk7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogU3ByZWFkcyBhdHRyaWJ1dGVzIG9udG8gYSBET00gZWxlbWVudCwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgY3VycmVudGx5IHNldCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IGVsZW1lbnRcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55PiB8IHVuZGVmaW5lZH0gcHJldlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCBhbnk+fSBuZXh0IE5ldyBhdHRyaWJ1dGVzIC0gdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoaXMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2Nzc19oYXNoXVxuICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkX3JlbW92ZV9kZWZhdWx0c11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fVxuICovXG5mdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhcblx0ZWxlbWVudCxcblx0cHJldixcblx0bmV4dCxcblx0Y3NzX2hhc2gsXG5cdHNob3VsZF9yZW1vdmVfZGVmYXVsdHMgPSBmYWxzZSxcblx0c2tpcF93YXJuaW5nID0gZmFsc2Vcbikge1xuXHRpZiAoaHlkcmF0aW5nICYmIHNob3VsZF9yZW1vdmVfZGVmYXVsdHMgJiYgZWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnKSB7XG5cdFx0dmFyIGlucHV0ID0gLyoqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50fSAqLyAoZWxlbWVudCk7XG5cdFx0dmFyIGF0dHJpYnV0ZSA9IGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcgPyAnZGVmYXVsdENoZWNrZWQnIDogJ2RlZmF1bHRWYWx1ZSc7XG5cblx0XHRpZiAoIShhdHRyaWJ1dGUgaW4gbmV4dCkpIHtcblx0XHRcdHJlbW92ZV9pbnB1dF9kZWZhdWx0cyhpbnB1dCk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGF0dHJpYnV0ZXMgPSBnZXRfYXR0cmlidXRlcyhlbGVtZW50KTtcblxuXHR2YXIgaXNfY3VzdG9tX2VsZW1lbnQgPSBhdHRyaWJ1dGVzW0lTX0NVU1RPTV9FTEVNRU5UXTtcblx0dmFyIHByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlID0gIWF0dHJpYnV0ZXNbSVNfSFRNTF07XG5cblx0Ly8gSWYgd2UncmUgaHlkcmF0aW5nIGJ1dCB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgZnJvbSBTdmVsdGUsIGFuZCBpdCBhbHJlYWR5IHNjYWZmb2xkZWQsXG5cdC8vIHRoZW4gaXQgbWlnaHQgcnVuIGJsb2NrIGxvZ2ljIGluIGh5ZHJhdGlvbiBtb2RlLCB3aGljaCB3ZSBoYXZlIHRvIHByZXZlbnQuXG5cdGxldCBpc19oeWRyYXRpbmdfY3VzdG9tX2VsZW1lbnQgPSBoeWRyYXRpbmcgJiYgaXNfY3VzdG9tX2VsZW1lbnQ7XG5cdGlmIChpc19oeWRyYXRpbmdfY3VzdG9tX2VsZW1lbnQpIHtcblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0fVxuXG5cdHZhciBjdXJyZW50ID0gcHJldiB8fCB7fTtcblx0dmFyIGlzX29wdGlvbl9lbGVtZW50ID0gZWxlbWVudC50YWdOYW1lID09PSAnT1BUSU9OJztcblxuXHRmb3IgKHZhciBrZXkgaW4gcHJldikge1xuXHRcdGlmICghKGtleSBpbiBuZXh0KSkge1xuXHRcdFx0bmV4dFtrZXldID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZiAobmV4dC5jbGFzcykge1xuXHRcdG5leHQuY2xhc3MgPSBjbHN4KG5leHQuY2xhc3MpO1xuXHR9IGVsc2UgaWYgKGNzc19oYXNoIHx8IG5leHRbQ0xBU1NdKSB7XG5cdFx0bmV4dC5jbGFzcyA9IG51bGw7IC8qIGZvcmNlIGNhbGwgdG8gc2V0X2NsYXNzKCkgKi9cblx0fVxuXG5cdGlmIChuZXh0W1NUWUxFXSkge1xuXHRcdG5leHQuc3R5bGUgPz89IG51bGw7IC8qIGZvcmNlIGNhbGwgdG8gc2V0X3N0eWxlKCkgKi9cblx0fVxuXG5cdHZhciBzZXR0ZXJzID0gZ2V0X3NldHRlcnMoZWxlbWVudCk7XG5cblx0Ly8gc2luY2Uga2V5IGlzIGNhcHR1cmVkIHdlIHVzZSBjb25zdFxuXHRmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG5cdFx0Ly8gbGV0IGluc3RlYWQgb2YgdmFyIGJlY2F1c2UgcmVmZXJlbmNlZCBpbiBhIGNsb3N1cmVcblx0XHRsZXQgdmFsdWUgPSBuZXh0W2tleV07XG5cblx0XHQvLyBVcCBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byBkbyB0aGlzIGZvciB0aGUgaW5pdGlhbCB2YWx1ZSwgdG9vLCBldmVuIGlmIGl0J3MgdW5kZWZpbmVkLFxuXHRcdC8vIGFuZCB0aGlzIHdvdWxkbid0IGJlIHJlYWNoZWQgaW4gY2FzZSBvZiB1bmRlZmluZWQgYmVjYXVzZSBvZiB0aGUgZXF1YWxpdHkgY2hlY2sgYmVsb3dcblx0XHRpZiAoaXNfb3B0aW9uX2VsZW1lbnQgJiYga2V5ID09PSAndmFsdWUnICYmIHZhbHVlID09IG51bGwpIHtcblx0XHRcdC8vIFRoZSA8b3B0aW9uPiBlbGVtZW50IGlzIGEgc3BlY2lhbCBjYXNlIGJlY2F1c2UgcmVtb3ZpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSBtZWFuc1xuXHRcdFx0Ly8gdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBvcHRpb24gZWxlbWVudCwgYW5kIHNldHRpbmcgdGhlIHZhbHVlXG5cdFx0XHQvLyB0byBudWxsIG9yIHVuZGVmaW5lZCBtZWFucyB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSBzdHJpbmcgXCJudWxsXCIgb3IgXCJ1bmRlZmluZWRcIi5cblx0XHRcdC8vIFRvIGFsaWduIHdpdGggaG93IHdlIGhhbmRsZSB0aGlzIGNhc2UgaW4gbm9uLXNwcmVhZC1zY2VuYXJpb3MsIHRoaXMgbG9naWMgaXMgbmVlZGVkLlxuXHRcdFx0Ly8gVGhlcmUncyBhIHN1cGVyLWVkZ2UtY2FzZSBidWcgaGVyZSB0aGF0IGlzIGxlZnQgaW4gaW4gZmF2b3Igb2Ygc21hbGxlciBjb2RlIHNpemU6XG5cdFx0XHQvLyBCZWNhdXNlIG9mIHRoZSBcInNldCBtaXNzaW5nIHByb3BzIHRvIG51bGxcIiBsb2dpYyBhYm92ZSwgd2UgY2FuJ3QgZGlmZmVyZW50aWF0ZVxuXHRcdFx0Ly8gYmV0d2VlbiBhIG1pc3NpbmcgdmFsdWUgYW5kIGFuIGV4cGxpY2l0bHkgc2V0IHZhbHVlIG9mIG51bGwgb3IgdW5kZWZpbmVkLiBUaGF0IG1lYW5zXG5cdFx0XHQvLyB0aGF0IG9uY2Ugc2V0LCB0aGUgdmFsdWUgYXR0cmlidXRlIG9mIGFuIDxvcHRpb24+IGVsZW1lbnQgY2FuJ3QgYmUgcmVtb3ZlZC4gVGhpcyBpc1xuXHRcdFx0Ly8gYSB2ZXJ5IHJhcmUgZWRnZSBjYXNlLCBhbmQgcmVtb3ZpbmcgdGhlIGF0dHJpYnV0ZSBhbHRvZ2V0aGVyIGlzbid0IHBvc3NpYmxlIGVpdGhlclxuXHRcdFx0Ly8gZm9yIHRoZSA8b3B0aW9uIHZhbHVlPXt1bmRlZmluZWR9PiBjYXNlLCBzbyB3ZSdyZSBub3QgbG9zaW5nIGFueSBmdW5jdGlvbmFsaXR5IGhlcmUuXG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRlbGVtZW50LnZhbHVlID0gZWxlbWVudC5fX3ZhbHVlID0gJyc7XG5cdFx0XHRjdXJyZW50W2tleV0gPSB2YWx1ZTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChrZXkgPT09ICdjbGFzcycpIHtcblx0XHRcdHZhciBpc19odG1sID0gZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblx0XHRcdHNldF9jbGFzcyhlbGVtZW50LCBpc19odG1sLCB2YWx1ZSwgY3NzX2hhc2gsIHByZXY/LltDTEFTU10sIG5leHRbQ0xBU1NdKTtcblx0XHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y3VycmVudFtDTEFTU10gPSBuZXh0W0NMQVNTXTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChrZXkgPT09ICdzdHlsZScpIHtcblx0XHRcdHNldF9zdHlsZShlbGVtZW50LCB2YWx1ZSwgcHJldj8uW1NUWUxFXSwgbmV4dFtTVFlMRV0pO1xuXHRcdFx0Y3VycmVudFtrZXldID0gdmFsdWU7XG5cdFx0XHRjdXJyZW50W1NUWUxFXSA9IG5leHRbU1RZTEVdO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFyIHByZXZfdmFsdWUgPSBjdXJyZW50W2tleV07XG5cblx0XHQvLyBTa2lwIGlmIHZhbHVlIGlzIHVuY2hhbmdlZCwgdW5sZXNzIGl0J3MgYHVuZGVmaW5lZGAgYW5kIHRoZSBlbGVtZW50IHN0aWxsIGhhcyB0aGUgYXR0cmlidXRlXG5cdFx0aWYgKHZhbHVlID09PSBwcmV2X3ZhbHVlICYmICEodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShrZXkpKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y3VycmVudFtrZXldID0gdmFsdWU7XG5cblx0XHR2YXIgcHJlZml4ID0ga2V5WzBdICsga2V5WzFdOyAvLyB0aGlzIGlzIGZhc3RlciB0aGFuIGtleS5zbGljZSgwLCAyKVxuXHRcdGlmIChwcmVmaXggPT09ICckJCcpIGNvbnRpbnVlO1xuXG5cdFx0aWYgKHByZWZpeCA9PT0gJ29uJykge1xuXHRcdFx0LyoqIEB0eXBlIHt7IGNhcHR1cmU/OiB0cnVlIH19ICovXG5cdFx0XHRjb25zdCBvcHRzID0ge307XG5cdFx0XHRjb25zdCBldmVudF9oYW5kbGVfa2V5ID0gJyQkJyArIGtleTtcblx0XHRcdGxldCBldmVudF9uYW1lID0ga2V5LnNsaWNlKDIpO1xuXHRcdFx0dmFyIGRlbGVnYXRlZCA9IGNhbl9kZWxlZ2F0ZV9ldmVudChldmVudF9uYW1lKTtcblxuXHRcdFx0aWYgKGlzX2NhcHR1cmVfZXZlbnQoZXZlbnRfbmFtZSkpIHtcblx0XHRcdFx0ZXZlbnRfbmFtZSA9IGV2ZW50X25hbWUuc2xpY2UoMCwgLTcpO1xuXHRcdFx0XHRvcHRzLmNhcHR1cmUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRlbGVnYXRlZCAmJiBwcmV2X3ZhbHVlKSB7XG5cdFx0XHRcdC8vIExpc3RlbmluZyB0byBzYW1lIGV2ZW50IGJ1dCBkaWZmZXJlbnQgaGFuZGxlciAtPiBvdXIgaGFuZGxlIGZ1bmN0aW9uIGJlbG93IHRha2VzIGNhcmUgb2YgdGhpc1xuXHRcdFx0XHQvLyBJZiB3ZSB3ZXJlIHRvIHJlbW92ZSBhbmQgYWRkIGxpc3RlbmVycyBpbiB0aGlzIGNhc2UsIGl0IGNvdWxkIGhhcHBlbiB0aGF0IHRoZSBldmVudCBpcyBcInN3YWxsb3dlZFwiXG5cdFx0XHRcdC8vICh0aGUgYnJvd3NlciBzZWVtcyB0byBub3Qga25vdyB5ZXQgdGhhdCBhIG5ldyBvbmUgZXhpc3RzIG5vdykgYW5kIGRvZXNuJ3QgcmVhY2ggdGhlIGhhbmRsZXJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMTE5MDNcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBjdXJyZW50W2V2ZW50X2hhbmRsZV9rZXldLCBvcHRzKTtcblx0XHRcdFx0Y3VycmVudFtldmVudF9oYW5kbGVfa2V5XSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICghZGVsZWdhdGVkKSB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogQHRoaXMge2FueX1cblx0XHRcdFx0XHQgKiBAcGFyYW0ge0V2ZW50fSBldnRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRmdW5jdGlvbiBoYW5kbGUoZXZ0KSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50W2tleV0uY2FsbCh0aGlzLCBldnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1cnJlbnRbZXZlbnRfaGFuZGxlX2tleV0gPSBjcmVhdGVfZXZlbnQoZXZlbnRfbmFtZSwgZWxlbWVudCwgaGFuZGxlLCBvcHRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0ZWxlbWVudFtgX18ke2V2ZW50X25hbWV9YF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRkZWxlZ2F0ZShbZXZlbnRfbmFtZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGVsZW1lbnRbYF9fJHtldmVudF9uYW1lfWBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG5cdFx0XHQvLyBhdm9pZCB1c2luZyB0aGUgc2V0dGVyXG5cdFx0XHRzZXRfYXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnYXV0b2ZvY3VzJykge1xuXHRcdFx0YXV0b2ZvY3VzKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChlbGVtZW50KSwgQm9vbGVhbih2YWx1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoIWlzX2N1c3RvbV9lbGVtZW50ICYmIChrZXkgPT09ICdfX3ZhbHVlJyB8fCAoa2V5ID09PSAndmFsdWUnICYmIHZhbHVlICE9IG51bGwpKSkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSdyZSBub3QgcnVubmluZyB0aGlzIGZvciBjdXN0b20gZWxlbWVudHMgYmVjYXVzZSBfX3ZhbHVlIGlzIGFjdHVhbGx5XG5cdFx0XHQvLyBob3cgTGl0IHN0b3JlcyB0aGUgY3VycmVudCB2YWx1ZSBvbiB0aGUgZWxlbWVudCwgYW5kIG1lc3Npbmcgd2l0aCB0aGF0IHdvdWxkIGJyZWFrIHRoaW5ncy5cblx0XHRcdGVsZW1lbnQudmFsdWUgPSBlbGVtZW50Ll9fdmFsdWUgPSB2YWx1ZTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3NlbGVjdGVkJyAmJiBpc19vcHRpb25fZWxlbWVudCkge1xuXHRcdFx0c2V0X3NlbGVjdGVkKC8qKiBAdHlwZSB7SFRNTE9wdGlvbkVsZW1lbnR9ICovIChlbGVtZW50KSwgdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbmFtZSA9IGtleTtcblx0XHRcdGlmICghcHJlc2VydmVfYXR0cmlidXRlX2Nhc2UpIHtcblx0XHRcdFx0bmFtZSA9IG5vcm1hbGl6ZV9hdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpc19kZWZhdWx0ID0gbmFtZSA9PT0gJ2RlZmF1bHRWYWx1ZScgfHwgbmFtZSA9PT0gJ2RlZmF1bHRDaGVja2VkJztcblxuXHRcdFx0aWYgKHZhbHVlID09IG51bGwgJiYgIWlzX2N1c3RvbV9lbGVtZW50ICYmICFpc19kZWZhdWx0KSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXNba2V5XSA9IG51bGw7XG5cblx0XHRcdFx0aWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ2NoZWNrZWQnKSB7XG5cdFx0XHRcdFx0Ly8gcmVtb3ZpbmcgdmFsdWUvY2hlY2tlZCBhbHNvIHJlbW92ZXMgZGVmYXVsdFZhbHVlL2RlZmF1bHRDaGVja2VkIFx1MjAxNCBwcmVzZXJ2ZVxuXHRcdFx0XHRcdGxldCBpbnB1dCA9IC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi8gKGVsZW1lbnQpO1xuXHRcdFx0XHRcdGNvbnN0IHVzZV9kZWZhdWx0ID0gcHJldiA9PT0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGlmIChuYW1lID09PSAndmFsdWUnKSB7XG5cdFx0XHRcdFx0XHRsZXQgcHJldmlvdXMgPSBpbnB1dC5kZWZhdWx0VmFsdWU7XG5cdFx0XHRcdFx0XHRpbnB1dC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdFx0XHRpbnB1dC5kZWZhdWx0VmFsdWUgPSBwcmV2aW91cztcblx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdGlucHV0LnZhbHVlID0gaW5wdXQuX192YWx1ZSA9IHVzZV9kZWZhdWx0ID8gcHJldmlvdXMgOiBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsZXQgcHJldmlvdXMgPSBpbnB1dC5kZWZhdWx0Q2hlY2tlZDtcblx0XHRcdFx0XHRcdGlucHV0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHRcdFx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0XHRpbnB1dC5jaGVja2VkID0gdXNlX2RlZmF1bHQgPyBwcmV2aW91cyA6IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRpc19kZWZhdWx0IHx8XG5cdFx0XHRcdChzZXR0ZXJzLmluY2x1ZGVzKG5hbWUpICYmIChpc19jdXN0b21fZWxlbWVudCB8fCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSlcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGVsZW1lbnRbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0Ly8gcmVtb3ZlIGl0IGZyb20gYXR0cmlidXRlcydzIGNhY2hlXG5cdFx0XHRcdGlmIChuYW1lIGluIGF0dHJpYnV0ZXMpIGF0dHJpYnV0ZXNbbmFtZV0gPSBVTklOSVRJQUxJWkVEO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0c2V0X2F0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSwgc2tpcF93YXJuaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaXNfaHlkcmF0aW5nX2N1c3RvbV9lbGVtZW50KSB7XG5cdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0fVxuXG5cdHJldHVybiBjdXJyZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gZWxlbWVudFxuICogQHBhcmFtIHsoLi4uZXhwcmVzc2lvbnM6IGFueSkgPT4gUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55Pn0gZm5cbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gYW55Pn0gc3luY1xuICogQHBhcmFtIHtBcnJheTwoKSA9PiBQcm9taXNlPGFueT4+fSBhc3luY1xuICogQHBhcmFtIHtBcnJheTxQcm9taXNlPHZvaWQ+Pn0gYmxvY2tlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY3NzX2hhc2hdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG91bGRfcmVtb3ZlX2RlZmF1bHRzXVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlX2VmZmVjdChcblx0ZWxlbWVudCxcblx0Zm4sXG5cdHN5bmMgPSBbXSxcblx0YXN5bmMgPSBbXSxcblx0YmxvY2tlcnMgPSBbXSxcblx0Y3NzX2hhc2gsXG5cdHNob3VsZF9yZW1vdmVfZGVmYXVsdHMgPSBmYWxzZSxcblx0c2tpcF93YXJuaW5nID0gZmFsc2Vcbikge1xuXHRmbGF0dGVuKGJsb2NrZXJzLCBzeW5jLCBhc3luYywgKHZhbHVlcykgPT4ge1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55PiB8IHVuZGVmaW5lZH0gKi9cblx0XHR2YXIgcHJldiA9IHVuZGVmaW5lZDtcblxuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN5bWJvbCwgRWZmZWN0Pn0gKi9cblx0XHR2YXIgZWZmZWN0cyA9IHt9O1xuXG5cdFx0dmFyIGlzX3NlbGVjdCA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdTRUxFQ1QnO1xuXHRcdHZhciBpbml0ZWQgPSBmYWxzZTtcblxuXHRcdG1hbmFnZWQoKCkgPT4ge1xuXHRcdFx0dmFyIG5leHQgPSBmbiguLi52YWx1ZXMubWFwKGdldCkpO1xuXHRcdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCBhbnk+fSAqL1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBzZXRfYXR0cmlidXRlcyhcblx0XHRcdFx0ZWxlbWVudCxcblx0XHRcdFx0cHJldixcblx0XHRcdFx0bmV4dCxcblx0XHRcdFx0Y3NzX2hhc2gsXG5cdFx0XHRcdHNob3VsZF9yZW1vdmVfZGVmYXVsdHMsXG5cdFx0XHRcdHNraXBfd2FybmluZ1xuXHRcdFx0KTtcblxuXHRcdFx0aWYgKGluaXRlZCAmJiBpc19zZWxlY3QgJiYgJ3ZhbHVlJyBpbiBuZXh0KSB7XG5cdFx0XHRcdHNlbGVjdF9vcHRpb24oLyoqIEB0eXBlIHtIVE1MU2VsZWN0RWxlbWVudH0gKi8gKGVsZW1lbnQpLCBuZXh0LnZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgc3ltYm9sIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZWZmZWN0cykpIHtcblx0XHRcdFx0aWYgKCFuZXh0W3N5bWJvbF0pIGRlc3Ryb3lfZWZmZWN0KGVmZmVjdHNbc3ltYm9sXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IHN5bWJvbCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG5leHQpKSB7XG5cdFx0XHRcdHZhciBuID0gbmV4dFtzeW1ib2xdO1xuXG5cdFx0XHRcdGlmIChzeW1ib2wuZGVzY3JpcHRpb24gPT09IEFUVEFDSE1FTlRfS0VZICYmICghcHJldiB8fCBuICE9PSBwcmV2W3N5bWJvbF0pKSB7XG5cdFx0XHRcdFx0aWYgKGVmZmVjdHNbc3ltYm9sXSkgZGVzdHJveV9lZmZlY3QoZWZmZWN0c1tzeW1ib2xdKTtcblx0XHRcdFx0XHRlZmZlY3RzW3N5bWJvbF0gPSBicmFuY2goKCkgPT4gYXR0YWNoKGVsZW1lbnQsICgpID0+IG4pKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRbc3ltYm9sXSA9IG47XG5cdFx0XHR9XG5cblx0XHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdH0pO1xuXG5cdFx0aWYgKGlzX3NlbGVjdCkge1xuXHRcdFx0dmFyIHNlbGVjdCA9IC8qKiBAdHlwZSB7SFRNTFNlbGVjdEVsZW1lbnR9ICovIChlbGVtZW50KTtcblxuXHRcdFx0ZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0c2VsZWN0X29wdGlvbihzZWxlY3QsIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55Pn0gKi8gKHByZXYpLnZhbHVlLCB0cnVlKTtcblx0XHRcdFx0aW5pdF9zZWxlY3Qoc2VsZWN0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGluaXRlZCA9IHRydWU7XG5cdH0pO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCkge1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPn0gKiovIChcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX2F0dHJpYnV0ZXMgPz89IHtcblx0XHRcdFtJU19DVVNUT01fRUxFTUVOVF06IGVsZW1lbnQubm9kZU5hbWUuaW5jbHVkZXMoJy0nKSxcblx0XHRcdFtJU19IVE1MXTogZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRV9IVE1MXG5cdFx0fVxuXHQpO1xufVxuXG4vKiogQHR5cGUge01hcDxzdHJpbmcsIHN0cmluZ1tdPn0gKi9cbnZhciBzZXR0ZXJzX2NhY2hlID0gbmV3IE1hcCgpO1xuXG4vKiogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICovXG5mdW5jdGlvbiBnZXRfc2V0dGVycyhlbGVtZW50KSB7XG5cdHZhciBjYWNoZV9rZXkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaXMnKSB8fCBlbGVtZW50Lm5vZGVOYW1lO1xuXHR2YXIgc2V0dGVycyA9IHNldHRlcnNfY2FjaGUuZ2V0KGNhY2hlX2tleSk7XG5cdGlmIChzZXR0ZXJzKSByZXR1cm4gc2V0dGVycztcblx0c2V0dGVyc19jYWNoZS5zZXQoY2FjaGVfa2V5LCAoc2V0dGVycyA9IFtdKSk7XG5cblx0dmFyIGRlc2NyaXB0b3JzO1xuXHR2YXIgcHJvdG8gPSBlbGVtZW50OyAvLyBJbiB0aGUgY2FzZSBvZiBjdXN0b20gZWxlbWVudHMgdGhlcmUgbWlnaHQgYmUgc2V0dGVycyBvbiB0aGUgaW5zdGFuY2Vcblx0dmFyIGVsZW1lbnRfcHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcblxuXHQvLyBTdG9wIGF0IEVsZW1lbnQsIGZyb20gdGhlcmUgb24gdGhlcmUncyBvbmx5IHVubmVjZXNzYXJ5IHNldHRlcnMgd2UncmUgbm90IGludGVyZXN0ZWQgaW5cblx0Ly8gRG8gbm90IHVzZSBjb250cnVjdG9yLm5hbWUgaGVyZSBhcyB0aGF0J3MgdW5yZWxpYWJsZSBpbiBzb21lIGJyb3dzZXIgZW52aXJvbm1lbnRzXG5cdHdoaWxlIChlbGVtZW50X3Byb3RvICE9PSBwcm90bykge1xuXHRcdGRlc2NyaXB0b3JzID0gZ2V0X2Rlc2NyaXB0b3JzKHByb3RvKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBkZXNjcmlwdG9ycykge1xuXHRcdFx0aWYgKGRlc2NyaXB0b3JzW2tleV0uc2V0KSB7XG5cdFx0XHRcdHNldHRlcnMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0X3Byb3RvdHlwZV9vZihwcm90byk7XG5cdH1cblxuXHRyZXR1cm4gc2V0dGVycztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrX3NyY19pbl9kZXZfaHlkcmF0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0aWYgKCFERVYpIHJldHVybjtcblx0aWYgKGF0dHJpYnV0ZSA9PT0gJ3NyY3NldCcgJiYgc3Jjc2V0X3VybF9lcXVhbChlbGVtZW50LCB2YWx1ZSkpIHJldHVybjtcblx0aWYgKHNyY191cmxfZXF1YWwoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSA/PyAnJywgdmFsdWUpKSByZXR1cm47XG5cblx0dy5oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWQoXG5cdFx0YXR0cmlidXRlLFxuXHRcdGVsZW1lbnQub3V0ZXJIVE1MLnJlcGxhY2UoZWxlbWVudC5pbm5lckhUTUwsIGVsZW1lbnQuaW5uZXJIVE1MICYmICcuLi4nKSxcblx0XHRTdHJpbmcodmFsdWUpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRfc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG5cdGlmIChlbGVtZW50X3NyYyA9PT0gdXJsKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIG5ldyBVUkwoZWxlbWVudF9zcmMsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWYgPT09IG5ldyBVUkwodXJsLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmO1xufVxuXG4vKiogQHBhcmFtIHtzdHJpbmd9IHNyY3NldCAqL1xuZnVuY3Rpb24gc3BsaXRfc3Jjc2V0KHNyY3NldCkge1xuXHRyZXR1cm4gc3Jjc2V0LnNwbGl0KCcsJykubWFwKChzcmMpID0+IHNyYy50cmltKCkuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNvdXJjZUVsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3Jjc2V0X3VybF9lcXVhbChlbGVtZW50LCBzcmNzZXQpIHtcblx0dmFyIGVsZW1lbnRfdXJscyA9IHNwbGl0X3NyY3NldChlbGVtZW50LnNyY3NldCk7XG5cdHZhciB1cmxzID0gc3BsaXRfc3Jjc2V0KHNyY3NldCk7XG5cblx0cmV0dXJuIChcblx0XHR1cmxzLmxlbmd0aCA9PT0gZWxlbWVudF91cmxzLmxlbmd0aCAmJlxuXHRcdHVybHMuZXZlcnkoXG5cdFx0XHQoW3VybCwgd2lkdGhdLCBpKSA9PlxuXHRcdFx0XHR3aWR0aCA9PT0gZWxlbWVudF91cmxzW2ldWzFdICYmXG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBib3RoIHdheXMgYmVjYXVzZSBWaXRlIHdpbGwgY3JlYXRlIGFuIGEgZnVsbCBVUkwgd2l0aFxuXHRcdFx0XHQvLyBgbmV3IFVSTChhc3NldCwgaW1wb3J0Lm1ldGEudXJsKS5ocmVmYCBmb3IgdGhlIGNsaWVudCB3aGVuIGBiYXNlOiAnLi8nYCwgYW5kIHRoZVxuXHRcdFx0XHQvLyByZWxhdGl2ZSBVUkxzIGluc2lkZSBzcmNzZXQgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IHJlc29sdmVkIHRvIGFic29sdXRlIFVSTHMgYnlcblx0XHRcdFx0Ly8gYnJvd3NlcnMgKGluIGNvbnRyYXN0IHRvIGltZy5zcmMpLiBUaGlzIG1lYW5zIGJvdGggU1NSIGFuZCBET00gY29kZSBjb3VsZFxuXHRcdFx0XHQvLyBjb250YWluIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTHMuXG5cdFx0XHRcdChzcmNfdXJsX2VxdWFsKGVsZW1lbnRfdXJsc1tpXVswXSwgdXJsKSB8fCBzcmNfdXJsX2VxdWFsKHVybCwgZWxlbWVudF91cmxzW2ldWzBdKSlcblx0XHQpXG5cdCk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBSYWYgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbmltcG9ydCB7IEJST1dTRVIgfSBmcm9tICdlc20tZW52JztcblxuY29uc3Qgbm93ID0gQlJPV1NFUiA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogKCkgPT4gRGF0ZS5ub3coKTtcblxuLyoqIEB0eXBlIHtSYWZ9ICovXG5leHBvcnQgY29uc3QgcmFmID0ge1xuXHQvLyBkb24ndCBhY2Nlc3MgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGVhZ2VybHkgb3V0c2lkZSBtZXRob2Rcblx0Ly8gdGhpcyBhbGxvd3MgYmFzaWMgdGVzdGluZyBvZiB1c2VyIGNvZGUgd2l0aG91dCBKU0RPTVxuXHQvLyBidW5kZXIgd2lsbCBldmFsIGFuZCByZW1vdmUgdGVybmFyeSB3aGVuIHRoZSB1c2VyJ3MgYXBwIGlzIGJ1aWx0XG5cdHRpY2s6IC8qKiBAcGFyYW0ge2FueX0gXyAqLyAoXykgPT4gKEJST1dTRVIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBub29wKShfKSxcblx0bm93OiAoKSA9PiBub3coKSxcblx0dGFza3M6IG5ldyBTZXQoKVxufTtcbiIsICIvKiogQGltcG9ydCB7IFRhc2tDYWxsYmFjaywgVGFzaywgVGFza0VudHJ5IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJhZiB9IGZyb20gJy4vdGltaW5nLmpzJztcblxuLy8gVE9ETyBtb3ZlIHRoaXMgaW50byB0aW1pbmcuanMgd2hlcmUgaXQgcHJvYmFibHkgYmVsb25nc1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBydW5fdGFza3MoKSB7XG5cdC8vIHVzZSBgcmFmLm5vdygpYCBpbnN0ZWFkIG9mIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjayBhcmd1bWVudCwgYmVjYXVzZVxuXHQvLyBvdGhlcndpc2UgdGhpbmdzIGNhbiBnZXQgd29ua3kgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzE0NTQxXG5cdGNvbnN0IG5vdyA9IHJhZi5ub3coKTtcblxuXHRyYWYudGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuXHRcdGlmICghdGFzay5jKG5vdykpIHtcblx0XHRcdHJhZi50YXNrcy5kZWxldGUodGFzayk7XG5cdFx0XHR0YXNrLmYoKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChyYWYudGFza3Muc2l6ZSAhPT0gMCkge1xuXHRcdHJhZi50aWNrKHJ1bl90YXNrcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICogQHBhcmFtIHtUYXNrQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7VGFza31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcblx0LyoqIEB0eXBlIHtUYXNrRW50cnl9ICovXG5cdGxldCB0YXNrO1xuXG5cdGlmIChyYWYudGFza3Muc2l6ZSA9PT0gMCkge1xuXHRcdHJhZi50aWNrKHJ1bl90YXNrcyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHByb21pc2U6IG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiB7XG5cdFx0XHRyYWYudGFza3MuYWRkKCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KSk7XG5cdFx0fSksXG5cdFx0YWJvcnQoKSB7XG5cdFx0XHRyYWYudGFza3MuZGVsZXRlKHRhc2spO1xuXHRcdH1cblx0fTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEFuaW1hdGVGbiwgQW5pbWF0aW9uLCBBbmltYXRpb25Db25maWcsIEVhY2hJdGVtLCBFZmZlY3QsIFRyYW5zaXRpb25GbiwgVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgbm9vcCwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QsIHVudHJhY2sgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGxvb3AgfSBmcm9tICcuLi8uLi9sb29wLmpzJztcbmltcG9ydCB7IHNob3VsZF9pbnRybyB9IGZyb20gJy4uLy4uL3JlbmRlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2VhY2hfaXRlbSB9IGZyb20gJy4uL2Jsb2Nrcy9lYWNoLmpzJztcbmltcG9ydCB7IFRSQU5TSVRJT05fR0xPQkFMLCBUUkFOU0lUSU9OX0lOLCBUUkFOU0lUSU9OX09VVCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBCTE9DS19FRkZFQ1QsIEVGRkVDVF9SQU4sIEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vYmluZGluZ3Mvc2hhcmVkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7J2ludHJvc3RhcnQnIHwgJ2ludHJvZW5kJyB8ICdvdXRyb3N0YXJ0JyB8ICdvdXRyb2VuZCd9IHR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaF9ldmVudChlbGVtZW50LCB0eXBlKSB7XG5cdHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0ZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCh0eXBlKSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJvcGVydHkgdG8gdGhlIGNhbWVsLWNhc2UgZm9ybWF0IGV4cGVjdGVkIGJ5IEVsZW1lbnQuYW5pbWF0ZSgpLCBLZXlmcmFtZUVmZmVjdCgpLCBhbmQgS2V5ZnJhbWVFZmZlY3Quc2V0S2V5ZnJhbWVzKCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNzc19wcm9wZXJ0eV90b19jYW1lbGNhc2Uoc3R5bGUpIHtcblx0Ly8gaW4gY29tcGxpYW5jZSB3aXRoIHNwZWNcblx0aWYgKHN0eWxlID09PSAnZmxvYXQnKSByZXR1cm4gJ2Nzc0Zsb2F0Jztcblx0aWYgKHN0eWxlID09PSAnb2Zmc2V0JykgcmV0dXJuICdjc3NPZmZzZXQnO1xuXG5cdC8vIGRvIG5vdCByZW5hbWUgY3VzdG9tIEBwcm9wZXJ0aWVzXG5cdGlmIChzdHlsZS5zdGFydHNXaXRoKCctLScpKSByZXR1cm4gc3R5bGU7XG5cblx0Y29uc3QgcGFydHMgPSBzdHlsZS5zcGxpdCgnLScpO1xuXHRpZiAocGFydHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydHNbMF07XG5cdHJldHVybiAoXG5cdFx0cGFydHNbMF0gK1xuXHRcdHBhcnRzXG5cdFx0XHQuc2xpY2UoMSlcblx0XHRcdC5tYXAoLyoqIEBwYXJhbSB7YW55fSB3b3JkICovICh3b3JkKSA9PiB3b3JkWzBdLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKVxuXHRcdFx0LmpvaW4oJycpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1xuICogQHJldHVybnMge0tleWZyYW1lfVxuICovXG5mdW5jdGlvbiBjc3NfdG9fa2V5ZnJhbWUoY3NzKSB7XG5cdC8qKiBAdHlwZSB7S2V5ZnJhbWV9ICovXG5cdGNvbnN0IGtleWZyYW1lID0ge307XG5cdGNvbnN0IHBhcnRzID0gY3NzLnNwbGl0KCc7Jyk7XG5cdGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuXHRcdGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdID0gcGFydC5zcGxpdCgnOicpO1xuXHRcdGlmICghcHJvcGVydHkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG5cblx0XHRjb25zdCBmb3JtYXR0ZWRfcHJvcGVydHkgPSBjc3NfcHJvcGVydHlfdG9fY2FtZWxjYXNlKHByb3BlcnR5LnRyaW0oKSk7XG5cdFx0a2V5ZnJhbWVbZm9ybWF0dGVkX3Byb3BlcnR5XSA9IHZhbHVlLnRyaW0oKTtcblx0fVxuXHRyZXR1cm4ga2V5ZnJhbWU7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdCAqL1xuY29uc3QgbGluZWFyID0gKHQpID0+IHQ7XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBrZXllZCBgeyNlYWNoIC4uLn1gIGJsb2NrcyAoYXMgYCQuYW5pbWF0aW9uKC4uLilgKS4gVGhpcyBjcmVhdGVzIGFuIGFuaW1hdGlvbiBtYW5hZ2VyXG4gKiBhbmQgYXR0YWNoZXMgaXQgdG8gdGhlIGJsb2NrLCBzbyB0aGF0IG1vdmVzIGNhbiBiZSBhbmltYXRlZCBmb2xsb3dpbmcgcmVjb25jaWxpYXRpb24uXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IEFuaW1hdGVGbjxQIHwgdW5kZWZpbmVkPn0gZ2V0X2ZuXG4gKiBAcGFyYW0geygoKSA9PiBQKSB8IG51bGx9IGdldF9wYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuaW1hdGlvbihlbGVtZW50LCBnZXRfZm4sIGdldF9wYXJhbXMpIHtcblx0dmFyIGl0ZW0gPSAvKiogQHR5cGUge0VhY2hJdGVtfSAqLyAoY3VycmVudF9lYWNoX2l0ZW0pO1xuXG5cdC8qKiBAdHlwZSB7RE9NUmVjdH0gKi9cblx0dmFyIGZyb207XG5cblx0LyoqIEB0eXBlIHtET01SZWN0fSAqL1xuXHR2YXIgdG87XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBhbmltYXRpb247XG5cblx0LyoqIEB0eXBlIHtudWxsIHwgeyBwb3NpdGlvbjogc3RyaW5nLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZywgdHJhbnNmb3JtOiBzdHJpbmcgfX0gKi9cblx0dmFyIG9yaWdpbmFsX3N0eWxlcyA9IG51bGw7XG5cblx0aXRlbS5hID8/PSB7XG5cdFx0ZWxlbWVudCxcblx0XHRtZWFzdXJlKCkge1xuXHRcdFx0ZnJvbSA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9LFxuXHRcdGFwcGx5KCkge1xuXHRcdFx0YW5pbWF0aW9uPy5hYm9ydCgpO1xuXG5cdFx0XHR0byA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRmcm9tLmxlZnQgIT09IHRvLmxlZnQgfHxcblx0XHRcdFx0ZnJvbS5yaWdodCAhPT0gdG8ucmlnaHQgfHxcblx0XHRcdFx0ZnJvbS50b3AgIT09IHRvLnRvcCB8fFxuXHRcdFx0XHRmcm9tLmJvdHRvbSAhPT0gdG8uYm90dG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3Qgb3B0aW9ucyA9IGdldF9mbigpKHRoaXMuZWxlbWVudCwgeyBmcm9tLCB0byB9LCBnZXRfcGFyYW1zPy4oKSk7XG5cblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0ZSh0aGlzLmVsZW1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCwgMSwgKCkgPT4ge1xuXHRcdFx0XHRcdGFuaW1hdGlvbj8uYWJvcnQoKTtcblx0XHRcdFx0XHRhbmltYXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zml4KCkge1xuXHRcdFx0Ly8gSWYgYW4gYW5pbWF0aW9uIGlzIGFscmVhZHkgcnVubmluZywgdHJhbnNmb3JtaW5nIHRoZSBlbGVtZW50IGlzIGxpa2VseSB0byBmYWlsLFxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgc3R5bGVzIGFwcGxpZWQgYnkgdGhlIGFuaW1hdGlvbiB0YWtlIHByZWNlZGVuY2UuIEluIHRoZSBjYXNlIG9mIGNyb3NzZmFkZSxcblx0XHRcdC8vIHRoYXQgbWVhbnMgdGhlIGB0cmFuc2xhdGUoLi4uKWAgb2YgdGhlIGNyb3NzZmFkZSB0cmFuc2l0aW9uIG92ZXJydWxlcyB0aGUgYHRyYW5zbGF0ZSguLi4pYFxuXHRcdFx0Ly8gd2Ugd291bGQgYXBwbHkgYmVsb3csIGxlYWRpbmcgdG8gdGhlIGVsZW1lbnQganVtcGluZyBzb21ld2hlcmUgdG8gdGhlIHRvcCBsZWZ0LlxuXHRcdFx0aWYgKGVsZW1lbnQuZ2V0QW5pbWF0aW9ucygpLmxlbmd0aCkgcmV0dXJuO1xuXG5cdFx0XHQvLyBJdCdzIGltcG9ydGFudCB0byBkZXN0cnVjdHVyZSB0aGVzZSB0byBnZXQgZml4ZWQgdmFsdWVzIC0gdGhlIG9iamVjdCBpdHNlbGYgaGFzIGdldHRlcnMsXG5cdFx0XHQvLyBhbmQgY2hhbmdpbmcgdGhlIHN0eWxlIHRvICdhYnNvbHV0ZScgY2FuIGZvciBleGFtcGxlIGluZmx1ZW5jZSB0aGUgd2lkdGguXG5cdFx0XHR2YXIgeyBwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSAqLyAoZWxlbWVudCkuc3R5bGU7XG5cblx0XHRcdFx0b3JpZ2luYWxfc3R5bGVzID0ge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBzdHlsZS5wb3NpdGlvbixcblx0XHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG5cdFx0XHRcdFx0dHJhbnNmb3JtOiBzdHlsZS50cmFuc2Zvcm1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0dmFyIHRvID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0XHRpZiAoZnJvbS5sZWZ0ICE9PSB0by5sZWZ0IHx8IGZyb20udG9wICE9PSB0by50b3ApIHtcblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2Zyb20ubGVmdCAtIHRvLmxlZnR9cHgsICR7ZnJvbS50b3AgLSB0by50b3B9cHgpYDtcblx0XHRcdFx0XHRzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPyBgJHtzdHlsZS50cmFuc2Zvcm19ICR7dHJhbnNmb3JtfWAgOiB0cmFuc2Zvcm07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHVuZml4KCkge1xuXHRcdFx0aWYgKG9yaWdpbmFsX3N0eWxlcykge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlO1xuXG5cdFx0XHRcdHN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxfc3R5bGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IG9yaWdpbmFsX3N0eWxlcy53aWR0aDtcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxfc3R5bGVzLmhlaWdodDtcblx0XHRcdFx0c3R5bGUudHJhbnNmb3JtID0gb3JpZ2luYWxfc3R5bGVzLnRyYW5zZm9ybTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gaW4gdGhlIGNhc2Ugb2YgYSBgPHN2ZWx0ZTplbGVtZW50PmAsIGl0J3MgcG9zc2libGUgZm9yIGAkLmFuaW1hdGlvbiguLi4pYCB0byBiZSBjYWxsZWRcblx0Ly8gd2hlbiBhbiBhbmltYXRpb24gbWFuYWdlciBhbHJlYWR5IGV4aXN0cywgaWYgdGhlIHRhZyBjaGFuZ2VzLiBpbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG9cblx0Ly8gc3dhcCBvdXQgdGhlIGVsZW1lbnQgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgbWFuYWdlciwgaW4gY2FzZSBpdCBoYXBwZW5lZCBhdCB0aGUgc2FtZVxuXHQvLyBtb21lbnQgYXMgYSByZWNvbmNpbGlhdGlvblxuXHRpdGVtLmEuZWxlbWVudCA9IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBibG9jayBlZmZlY3RzIGFzIGAkLnRyYW5zaXRpb24oLi4uKWAuIFRoaXMgY3JlYXRlcyBhIHRyYW5zaXRpb24gbWFuYWdlciBhbmRcbiAqIGF0dGFjaGVzIGl0IHRvIHRoZSBjdXJyZW50IGVmZmVjdCBcdTIwMTQgbGF0ZXIsIGluc2lkZSBgcGF1c2VfZWZmZWN0YCBhbmQgYHJlc3VtZV9lZmZlY3RgLCB3ZVxuICogdXNlIHRoaXMgdG8gY3JlYXRlIGBpbnRyb2AgYW5kIGBvdXRyb2AgdHJhbnNpdGlvbnMuXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IFRyYW5zaXRpb25GbjxQIHwgdW5kZWZpbmVkPn0gZ2V0X2ZuXG4gKiBAcGFyYW0geygoKSA9PiBQKSB8IG51bGx9IGdldF9wYXJhbXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbihmbGFncywgZWxlbWVudCwgZ2V0X2ZuLCBnZXRfcGFyYW1zKSB7XG5cdHZhciBpc19pbnRybyA9IChmbGFncyAmIFRSQU5TSVRJT05fSU4pICE9PSAwO1xuXHR2YXIgaXNfb3V0cm8gPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX09VVCkgIT09IDA7XG5cdHZhciBpc19ib3RoID0gaXNfaW50cm8gJiYgaXNfb3V0cm87XG5cdHZhciBpc19nbG9iYWwgPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX0dMT0JBTCkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHsnaW4nIHwgJ291dCcgfCAnYm90aCd9ICovXG5cdHZhciBkaXJlY3Rpb24gPSBpc19ib3RoID8gJ2JvdGgnIDogaXNfaW50cm8gPyAnaW4nIDogJ291dCc7XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb25Db25maWcgfCAoKG9wdHM6IHsgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfSkgPT4gQW5pbWF0aW9uQ29uZmlnKSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGN1cnJlbnRfb3B0aW9ucztcblxuXHR2YXIgaW5lcnQgPSBlbGVtZW50LmluZXJ0O1xuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBvdmVyZmxvdyBzdHlsZSwgc3Rhc2hlZCBzbyB3ZSBjYW4gcmV2ZXJ0IGNoYW5nZXMgZHVyaW5nIHRoZSB0cmFuc2l0aW9uXG5cdCAqIHRoYXQgYXJlIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSA8MTggYnVnXG5cdCAqIFRPRE8gNi4wIHJlbW92ZSB0aGlzLCBpZiBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgaGF2ZSBkaWVkIG91dCBlbm91Z2hcblx0ICovXG5cdHZhciBvdmVyZmxvdyA9IGVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBpbnRybztcblxuXHQvKiogQHR5cGUge0FuaW1hdGlvbiB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIG91dHJvO1xuXG5cdGZ1bmN0aW9uIGdldF9vcHRpb25zKCkge1xuXHRcdHJldHVybiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0Ly8gSWYgYSB0cmFuc2l0aW9uIGlzIHN0aWxsIG9uZ29pbmcsIHdlIHVzZSB0aGUgZXhpc3Rpbmcgb3B0aW9ucyByYXRoZXIgdGhhbiBnZW5lcmF0aW5nXG5cdFx0XHQvLyBuZXcgb25lcy4gVGhpcyBlbnN1cmVzIHRoYXQgcmV2ZXJzaWJsZSB0cmFuc2l0aW9ucyByZXZlcnNlIHNtb290aGx5LCByYXRoZXIgdGhhblxuXHRcdFx0Ly8ganVtcGluZyB0byBhIG5ldyBzcG90IGJlY2F1c2UgKGZvciBleGFtcGxlKSBhIGRpZmZlcmVudCBgZHVyYXRpb25gIHdhcyB1c2VkXG5cdFx0XHRyZXR1cm4gKGN1cnJlbnRfb3B0aW9ucyA/Pz0gZ2V0X2ZuKCkoZWxlbWVudCwgZ2V0X3BhcmFtcz8uKCkgPz8gLyoqIEB0eXBlIHtQfSAqLyAoe30pLCB7XG5cdFx0XHRcdGRpcmVjdGlvblxuXHRcdFx0fSkpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcn0gKi9cblx0dmFyIHRyYW5zaXRpb24gPSB7XG5cdFx0aXNfZ2xvYmFsLFxuXHRcdGluKCkge1xuXHRcdFx0ZWxlbWVudC5pbmVydCA9IGluZXJ0O1xuXG5cdFx0XHRpZiAoIWlzX2ludHJvKSB7XG5cdFx0XHRcdG91dHJvPy5hYm9ydCgpO1xuXHRcdFx0XHRvdXRybz8ucmVzZXQ/LigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNfb3V0cm8pIHtcblx0XHRcdFx0Ly8gaWYgd2UgaW50cm8gdGhlbiBvdXRybyB0aGVuIGludHJvIGFnYWluLCB3ZSB3YW50IHRvIGFib3J0IHRoZSBmaXJzdCBpbnRybyxcblx0XHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiaWRpcmVjdGlvbmFsIHRyYW5zaXRpb25cblx0XHRcdFx0aW50cm8/LmFib3J0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdpbnRyb3N0YXJ0Jyk7XG5cblx0XHRcdGludHJvID0gYW5pbWF0ZShlbGVtZW50LCBnZXRfb3B0aW9ucygpLCBvdXRybywgMSwgKCkgPT4ge1xuXHRcdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnaW50cm9lbmQnKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgd2UgY2FuY2VsIHRoZSBhbmltYXRpb24gdG8gcHJldmVudCBsZWFraW5nXG5cdFx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0XHRpbnRybyA9IGN1cnJlbnRfb3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG91dChmbikge1xuXHRcdFx0aWYgKCFpc19vdXRybykge1xuXHRcdFx0XHRmbj8uKCk7XG5cdFx0XHRcdGN1cnJlbnRfb3B0aW9ucyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtZW50LmluZXJ0ID0gdHJ1ZTtcblxuXHRcdFx0ZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgJ291dHJvc3RhcnQnKTtcblxuXHRcdFx0b3V0cm8gPSBhbmltYXRlKGVsZW1lbnQsIGdldF9vcHRpb25zKCksIGludHJvLCAwLCAoKSA9PiB7XG5cdFx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdvdXRyb2VuZCcpO1xuXHRcdFx0XHRmbj8uKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdHN0b3A6ICgpID0+IHtcblx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0b3V0cm8/LmFib3J0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBlID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHQoZS50cmFuc2l0aW9ucyA/Pz0gW10pLnB1c2godHJhbnNpdGlvbik7XG5cblx0Ly8gaWYgdGhpcyBpcyBhIGxvY2FsIHRyYW5zaXRpb24sIHdlIG9ubHkgd2FudCB0byBydW4gaXQgaWYgdGhlIHBhcmVudCAoYnJhbmNoKSBlZmZlY3Qnc1xuXHQvLyBwYXJlbnQgKGJsb2NrKSBlZmZlY3QgaXMgd2hlcmUgdGhlIHN0YXRlIGNoYW5nZSBoYXBwZW5lZC4gd2UgY2FuIGRldGVybWluZSB0aGF0IGJ5XG5cdC8vIGxvb2tpbmcgYXQgd2hldGhlciB0aGUgYmxvY2sgZWZmZWN0IGlzIGN1cnJlbnRseSBpbml0aWFsaXppbmdcblx0aWYgKGlzX2ludHJvICYmIHNob3VsZF9pbnRybykge1xuXHRcdHZhciBydW4gPSBpc19nbG9iYWw7XG5cblx0XHRpZiAoIXJ1bikge1xuXHRcdFx0dmFyIGJsb2NrID0gLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqLyAoZS5wYXJlbnQpO1xuXG5cdFx0XHQvLyBza2lwIG92ZXIgdHJhbnNwYXJlbnQgYmxvY2tzIChlLmcuIHNuaXBwZXRzLCBlbHNlLWlmIGJsb2Nrcylcblx0XHRcdHdoaWxlIChibG9jayAmJiAoYmxvY2suZiAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDApIHtcblx0XHRcdFx0d2hpbGUgKChibG9jayA9IGJsb2NrLnBhcmVudCkpIHtcblx0XHRcdFx0XHRpZiAoKGJsb2NrLmYgJiBCTE9DS19FRkZFQ1QpICE9PSAwKSBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRydW4gPSAhYmxvY2sgfHwgKGJsb2NrLmYgJiBFRkZFQ1RfUkFOKSAhPT0gMDtcblx0XHR9XG5cblx0XHRpZiAocnVuKSB7XG5cdFx0XHRlZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHR1bnRyYWNrKCgpID0+IHRyYW5zaXRpb24uaW4oKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBbmltYXRlcyBhbiBlbGVtZW50LCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtBbmltYXRpb25Db25maWcgfCAoKG9wdHM6IHsgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfSkgPT4gQW5pbWF0aW9uQ29uZmlnKX0gb3B0aW9uc1xuICogQHBhcmFtIHtBbmltYXRpb24gfCB1bmRlZmluZWR9IGNvdW50ZXJwYXJ0IFRoZSBjb3JyZXNwb25kaW5nIGludHJvL291dHJvIHRvIHRoaXMgb3V0cm8vaW50cm9cbiAqIEBwYXJhbSB7bnVtYmVyfSB0MiBUaGUgdGFyZ2V0IGB0YCB2YWx1ZSBcdTIwMTQgYDFgIGZvciBpbnRybywgYDBgIGZvciBvdXRyb1xuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IG9uX2ZpbmlzaCBDYWxsZWQgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRpbmcgdGhlIGFuaW1hdGlvblxuICogQHJldHVybnMge0FuaW1hdGlvbn1cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZShlbGVtZW50LCBvcHRpb25zLCBjb3VudGVycGFydCwgdDIsIG9uX2ZpbmlzaCkge1xuXHR2YXIgaXNfaW50cm8gPSB0MiA9PT0gMTtcblxuXHRpZiAoaXNfZnVuY3Rpb24ob3B0aW9ucykpIHtcblx0XHQvLyBJbiB0aGUgY2FzZSBvZiBhIGRlZmVycmVkIHRyYW5zaXRpb24gKHN1Y2ggYXMgYGNyb3NzZmFkZWApLCBgb3B0aW9uYCB3aWxsIGJlXG5cdFx0Ly8gYSBmdW5jdGlvbiByYXRoZXIgdGhhbiBhbiBgQW5pbWF0aW9uQ29uZmlnYC4gV2UgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb25cblx0XHQvLyBvbmNlIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZC4uLlxuXHRcdC8qKiBAdHlwZSB7QW5pbWF0aW9ufSAqL1xuXHRcdHZhciBhO1xuXHRcdHZhciBhYm9ydGVkID0gZmFsc2U7XG5cblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGlmIChhYm9ydGVkKSByZXR1cm47XG5cdFx0XHR2YXIgbyA9IG9wdGlvbnMoeyBkaXJlY3Rpb246IGlzX2ludHJvID8gJ2luJyA6ICdvdXQnIH0pO1xuXHRcdFx0YSA9IGFuaW1hdGUoZWxlbWVudCwgbywgY291bnRlcnBhcnQsIHQyLCBvbl9maW5pc2gpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gLi4uYnV0IHdlIHdhbnQgdG8gZG8gc28gd2l0aG91dCB1c2luZyBgYXN5bmNgL2Bhd2FpdGAgZXZlcnl3aGVyZSwgc29cblx0XHQvLyB3ZSByZXR1cm4gYSBmYWNhZGUgdGhhdCBhbGxvd3MgZXZlcnl0aGluZyB0byByZW1haW4gc3luY2hyb25vdXNcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWJvcnQ6ICgpID0+IHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWU7XG5cdFx0XHRcdGE/LmFib3J0KCk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVhY3RpdmF0ZTogKCkgPT4gYS5kZWFjdGl2YXRlKCksXG5cdFx0XHRyZXNldDogKCkgPT4gYS5yZXNldCgpLFxuXHRcdFx0dDogKCkgPT4gYS50KClcblx0XHR9O1xuXHR9XG5cblx0Y291bnRlcnBhcnQ/LmRlYWN0aXZhdGUoKTtcblxuXHRpZiAoIW9wdGlvbnM/LmR1cmF0aW9uKSB7XG5cdFx0b25fZmluaXNoKCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWJvcnQ6IG5vb3AsXG5cdFx0XHRkZWFjdGl2YXRlOiBub29wLFxuXHRcdFx0cmVzZXQ6IG5vb3AsXG5cdFx0XHR0OiAoKSA9PiB0MlxuXHRcdH07XG5cdH1cblxuXHRjb25zdCB7IGRlbGF5ID0gMCwgY3NzLCB0aWNrLCBlYXNpbmcgPSBsaW5lYXIgfSA9IG9wdGlvbnM7XG5cblx0dmFyIGtleWZyYW1lcyA9IFtdO1xuXG5cdGlmIChpc19pbnRybyAmJiBjb3VudGVycGFydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHRpY2spIHtcblx0XHRcdHRpY2soMCwgMSk7IC8vIFRPRE8gcHV0IGluIG5lc3RlZCBlZmZlY3QsIHRvIGF2b2lkIGludGVybGVhdmVkIHJlYWRzL3dyaXRlcz9cblx0XHR9XG5cblx0XHRpZiAoY3NzKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gY3NzX3RvX2tleWZyYW1lKGNzcygwLCAxKSk7XG5cdFx0XHRrZXlmcmFtZXMucHVzaChzdHlsZXMsIHN0eWxlcyk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGdldF90ID0gKCkgPT4gMSAtIHQyO1xuXG5cdC8vIGNyZWF0ZSBhIGR1bW15IGFuaW1hdGlvbiB0aGF0IGxhc3RzIGFzIGxvbmcgYXMgdGhlIGRlbGF5IChidXQgd2l0aCB3aGF0ZXZlciBkZXZ0b29sc1xuXHQvLyBtdWx0aXBsaWVyIGlzIGluIGVmZmVjdCkuIGluIHRoZSBjb21tb24gY2FzZSB0aGF0IGl0IGlzIGAwYCwgd2Uga2VlcCBpdCBhbnl3YXkgc28gdGhhdFxuXHQvLyB0aGUgQ1NTIGtleWZyYW1lcyBhcmVuJ3QgY3JlYXRlZCB1bnRpbCB0aGUgRE9NIGlzIHVwZGF0ZWRcblx0Ly9cblx0Ly8gZmlsbCBmb3J3YXJkcyB0byBwcmV2ZW50IHRoZSBlbGVtZW50IGZyb20gcmVuZGVyaW5nIHdpdGhvdXQgc3R5bGVzIGFwcGxpZWRcblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzE0NzMyXG5cdHZhciBhbmltYXRpb24gPSBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVzLCB7IGR1cmF0aW9uOiBkZWxheSwgZmlsbDogJ2ZvcndhcmRzJyB9KTtcblxuXHRhbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB7XG5cdFx0Ly8gcmVtb3ZlIGR1bW15IGFuaW1hdGlvbiBmcm9tIHRoZSBzdGFjayB0byBwcmV2ZW50IGNvbmZsaWN0IHdpdGggbWFpbiBhbmltYXRpb25cblx0XHRhbmltYXRpb24uY2FuY2VsKCk7XG5cblx0XHQvLyBmb3IgYmlkaXJlY3Rpb25hbCB0cmFuc2l0aW9ucywgd2Ugc3RhcnQgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbixcblx0XHQvLyByYXRoZXIgdGhhbiBkb2luZyBhIGZ1bGwgaW50cm8vb3V0cm9cblx0XHR2YXIgdDEgPSBjb3VudGVycGFydD8udCgpID8/IDEgLSB0Mjtcblx0XHRjb3VudGVycGFydD8uYWJvcnQoKTtcblxuXHRcdHZhciBkZWx0YSA9IHQyIC0gdDE7XG5cdFx0dmFyIGR1cmF0aW9uID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChvcHRpb25zLmR1cmF0aW9uKSAqIE1hdGguYWJzKGRlbHRhKTtcblx0XHR2YXIga2V5ZnJhbWVzID0gW107XG5cblx0XHRpZiAoZHVyYXRpb24gPiAwKSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBDU1MgaW5jbHVkZXMgYG92ZXJmbG93OiBoaWRkZW5gLCBpbiB3aGljaCBjYXNlIHdlIG5lZWQgdG9cblx0XHRcdCAqIGFkZCBpdCBhcyBhbiBpbmxpbmUgc3R5bGUgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgPDE4IGJ1Z1xuXHRcdFx0ICogVE9ETyA2LjAgcmVtb3ZlIHRoaXMsIGlmIHBvc3NpYmxlXG5cdFx0XHQgKi9cblx0XHRcdHZhciBuZWVkc19vdmVyZmxvd19oaWRkZW4gPSBmYWxzZTtcblxuXHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHR2YXIgbiA9IE1hdGguY2VpbChkdXJhdGlvbiAvICgxMDAwIC8gNjApKTsgLy8gYG5gIG11c3QgYmUgYW4gaW50ZWdlciwgb3Igd2UgcmlzayBtaXNzaW5nIHRoZSBgdDJgIHZhbHVlXG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSB0MSArIGRlbHRhICogZWFzaW5nKGkgLyBuKTtcblx0XHRcdFx0XHR2YXIgc3R5bGVzID0gY3NzX3RvX2tleWZyYW1lKGNzcyh0LCAxIC0gdCkpO1xuXHRcdFx0XHRcdGtleWZyYW1lcy5wdXNoKHN0eWxlcyk7XG5cblx0XHRcdFx0XHRuZWVkc19vdmVyZmxvd19oaWRkZW4gfHw9IHN0eWxlcy5vdmVyZmxvdyA9PT0gJ2hpZGRlbic7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5lZWRzX292ZXJmbG93X2hpZGRlbikge1xuXHRcdFx0XHQvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZWxlbWVudCkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblx0XHRcdH1cblxuXHRcdFx0Z2V0X3QgPSAoKSA9PiB7XG5cdFx0XHRcdHZhciB0aW1lID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChcblx0XHRcdFx0XHQvKiogQHR5cGUge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSAqLyAoYW5pbWF0aW9uKS5jdXJyZW50VGltZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHJldHVybiB0MSArIGRlbHRhICogZWFzaW5nKHRpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodGljaykge1xuXHRcdFx0XHRsb29wKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gJ3J1bm5pbmcnKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0XHR2YXIgdCA9IGdldF90KCk7XG5cdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YW5pbWF0aW9uID0gZWxlbWVudC5hbmltYXRlKGtleWZyYW1lcywgeyBkdXJhdGlvbiwgZmlsbDogJ2ZvcndhcmRzJyB9KTtcblxuXHRcdGFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHtcblx0XHRcdGdldF90ID0gKCkgPT4gdDI7XG5cdFx0XHR0aWNrPy4odDIsIDEgLSB0Mik7XG5cdFx0XHRvbl9maW5pc2goKTtcblx0XHR9O1xuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0YWJvcnQ6ICgpID0+IHtcblx0XHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdFx0YW5pbWF0aW9uLmNhbmNlbCgpO1xuXHRcdFx0XHQvLyBUaGlzIHByZXZlbnRzIG1lbW9yeSBsZWFrcyBpbiBDaHJvbWl1bVxuXHRcdFx0XHRhbmltYXRpb24uZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0Ly8gVGhpcyBwcmV2ZW50cyBvbmZpbmlzaCB0byBiZSBsYXVuY2hlZCBhZnRlciBjYW5jZWwoKSxcblx0XHRcdFx0Ly8gd2hpY2ggY2FuIGhhcHBlbiBpbiBzb21lIHJhcmUgY2FzZXNcblx0XHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzEzNjgxXG5cdFx0XHRcdGFuaW1hdGlvbi5vbmZpbmlzaCA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZWFjdGl2YXRlOiAoKSA9PiB7XG5cdFx0XHRvbl9maW5pc2ggPSBub29wO1xuXHRcdH0sXG5cdFx0cmVzZXQ6ICgpID0+IHtcblx0XHRcdGlmICh0MiA9PT0gMCkge1xuXHRcdFx0XHR0aWNrPy4oMSwgMCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0OiAoKSA9PiBnZXRfdCgpXG5cdH07XG59XG4iLCAiaW1wb3J0IHsgbGlzdGVuIH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KGFjdGl2ZUVsZW1lbnQ6IEVsZW1lbnQgfCBudWxsKSA9PiB2b2lkfSB1cGRhdGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9hY3RpdmVfZWxlbWVudCh1cGRhdGUpIHtcblx0bGlzdGVuKGRvY3VtZW50LCBbJ2ZvY3VzaW4nLCAnZm9jdXNvdXQnXSwgKGV2ZW50KSA9PiB7XG5cdFx0aWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdmb2N1c291dCcgJiYgLyoqIEB0eXBlIHtGb2N1c0V2ZW50fSAqLyAoZXZlbnQpLnJlbGF0ZWRUYXJnZXQpIHtcblx0XHRcdC8vIFRoZSB0ZXN0cyBzdGlsbCBwYXNzIGlmIHdlIHJlbW92ZSB0aGlzLCBiZWNhdXNlIG9mIEpTRE9NIGxpbWl0YXRpb25zLCBidXQgaXQgaXMgbmVjZXNzYXJ5XG5cdFx0XHQvLyB0byBhdm9pZCB0ZW1wb3JhcmlseSByZXNldHRpbmcgdG8gYGRvY3VtZW50LmJvZHlgXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dXBkYXRlKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEJhdGNoIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudCB9IGZyb20gJy4vc2hhcmVkLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vLi4vLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uLy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IHRpY2ssIHVudHJhY2sgfSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGlzX3J1bmVzIH0gZnJvbSAnLi4vLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2JhdGNoLCBwcmV2aW91c19iYXRjaCB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfdmFsdWUoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBiYXRjaGVzID0gbmV3IFdlYWtTZXQoKTtcblxuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGlucHV0LCAnaW5wdXQnLCBhc3luYyAoaXNfcmVzZXQpID0+IHtcblx0XHRpZiAoREVWICYmIGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWUoKTtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge2FueX0gKi9cblx0XHR2YXIgdmFsdWUgPSBpc19yZXNldCA/IGlucHV0LmRlZmF1bHRWYWx1ZSA6IGlucHV0LnZhbHVlO1xuXHRcdHZhbHVlID0gaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgPyB0b19udW1iZXIodmFsdWUpIDogdmFsdWU7XG5cdFx0c2V0KHZhbHVlKTtcblxuXHRcdGlmIChjdXJyZW50X2JhdGNoICE9PSBudWxsKSB7XG5cdFx0XHRiYXRjaGVzLmFkZChjdXJyZW50X2JhdGNoKTtcblx0XHR9XG5cblx0XHQvLyBCZWNhdXNlIGB7I2VhY2ggLi4ufWAgYmxvY2tzIHdvcmsgYnkgdXBkYXRpbmcgc291cmNlcyBpbnNpZGUgdGhlIGZsdXNoLFxuXHRcdC8vIHdlIG5lZWQgdG8gd2FpdCBhIHRpY2sgYmVmb3JlIGNoZWNraW5nIHRvIHNlZSBpZiB3ZSBzaG91bGQgZm9yY2libHlcblx0XHQvLyB1cGRhdGUgdGhlIGlucHV0IGFuZCByZXNldCB0aGUgc2VsZWN0aW9uIHN0YXRlXG5cdFx0YXdhaXQgdGljaygpO1xuXG5cdFx0Ly8gUmVzcGVjdCBhbnkgdmFsaWRhdGlvbiBpbiBhY2Nlc3NvcnNcblx0XHRpZiAodmFsdWUgIT09ICh2YWx1ZSA9IGdldCgpKSkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG5cdFx0XHR2YXIgZW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGlucHV0LnZhbHVlLmxlbmd0aDtcblxuXHRcdFx0Ly8gdGhlIHZhbHVlIGlzIGNvZXJjZWQgb24gYXNzaWdubWVudFxuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZSA/PyAnJztcblxuXHRcdFx0Ly8gUmVzdG9yZSBzZWxlY3Rpb25cblx0XHRcdGlmIChlbmQgIT09IG51bGwpIHtcblx0XHRcdFx0dmFyIG5ld19sZW5ndGggPSBpbnB1dC52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdC8vIElmIGN1cnNvciB3YXMgYXQgZW5kIGFuZCBuZXcgaW5wdXQgaXMgbG9uZ2VyLCBtb3ZlIGN1cnNvciB0byBuZXcgZW5kXG5cdFx0XHRcdGlmIChzdGFydCA9PT0gZW5kICYmIGVuZCA9PT0gbGVuZ3RoICYmIG5ld19sZW5ndGggPiBsZW5ndGgpIHtcblx0XHRcdFx0XHRpbnB1dC5zZWxlY3Rpb25TdGFydCA9IG5ld19sZW5ndGg7XG5cdFx0XHRcdFx0aW5wdXQuc2VsZWN0aW9uRW5kID0gbmV3X2xlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRcdGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgbmV3X2xlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHQoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRWYWx1ZSAhPT0gaW5wdXQudmFsdWUpIHx8XG5cdFx0Ly8gSWYgZGVmYXVsdFZhbHVlIGlzIHNldCwgdGhlbiB2YWx1ZSA9PSBkZWZhdWx0VmFsdWVcblx0XHQvLyBUT0RPIFN2ZWx0ZSA2OiByZW1vdmUgaW5wdXQudmFsdWUgY2hlY2sgYW5kIHNldCB0byBlbXB0eSBzdHJpbmc/XG5cdFx0KHVudHJhY2soZ2V0KSA9PSBudWxsICYmIGlucHV0LnZhbHVlKVxuXHQpIHtcblx0XHRzZXQoaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgPyB0b19udW1iZXIoaW5wdXQudmFsdWUpIDogaW5wdXQudmFsdWUpO1xuXG5cdFx0aWYgKGN1cnJlbnRfYmF0Y2ggIT09IG51bGwpIHtcblx0XHRcdGJhdGNoZXMuYWRkKGN1cnJlbnRfYmF0Y2gpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChERVYgJiYgaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuXHRcdFx0Ly8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJvZCB0b28/XG5cdFx0XHRlLmJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSgpO1xuXHRcdH1cblxuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXG5cdFx0aWYgKGlucHV0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG5cdFx0XHQvLyB3ZSBuZWVkIGJvdGgsIGJlY2F1c2UgaW4gbm9uLWFzeW5jIG1vZGUsIHJlbmRlciBlZmZlY3RzIHJ1biBiZWZvcmUgcHJldmlvdXNfYmF0Y2ggaXMgc2V0XG5cdFx0XHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAocHJldmlvdXNfYmF0Y2ggPz8gY3VycmVudF9iYXRjaCk7XG5cblx0XHRcdC8vIE5ldmVyIHJld3JpdGUgdGhlIGNvbnRlbnRzIG9mIGEgZm9jdXNlZCBpbnB1dC4gV2UgY2FuIGdldCBoZXJlIGlmLCBmb3IgZXhhbXBsZSxcblx0XHRcdC8vIGFuIHVwZGF0ZSBpcyBkZWZlcnJlZCBiZWNhdXNlIG9mIGFzeW5jIHdvcmsgZGVwZW5kaW5nIG9uIHRoZSBpbnB1dDpcblx0XHRcdC8vXG5cdFx0XHQvLyA8aW5wdXQgYmluZDp2YWx1ZT17cXVlcnl9PlxuXHRcdFx0Ly8gPHA+e2F3YWl0IGZpbmQocXVlcnkpfTwvcD5cblx0XHRcdGlmIChiYXRjaGVzLmhhcyhiYXRjaCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSAmJiB2YWx1ZSA9PT0gdG9fbnVtYmVyKGlucHV0LnZhbHVlKSkge1xuXHRcdFx0Ly8gaGFuZGxlcyAwIHZzIDAwIGNhc2UgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy85OTU5KVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC50eXBlID09PSAnZGF0ZScgJiYgIXZhbHVlICYmICFpbnB1dC52YWx1ZSkge1xuXHRcdFx0Ly8gSGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIHRlbXBvcmFyaWx5IGludmFsaWQgZGF0ZSBpcyBzZXQgKHdoaWxlIHR5cGluZywgZm9yIGV4YW1wbGUgd2l0aCBhIGxlYWRpbmcgMCBmb3IgdGhlIGRheSlcblx0XHRcdC8vIGFuZCBwcmV2ZW50cyB0aGlzIHN0YXRlIGZyb20gY2xlYXJpbmcgdGhlIG90aGVyIHBhcnRzIG9mIHRoZSBkYXRlIGlucHV0IChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvNzg5Nylcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBzZXQgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBpZiBpdCdzIHRoZSBzYW1lIHRvIGFsbG93XG5cdFx0Ly8gbWlubGVuZ3RoIHRvIHdvcmsgcHJvcGVybHlcblx0XHRpZiAodmFsdWUgIT09IGlucHV0LnZhbHVlKSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSB2YWx1ZSBpcyBjb2VyY2VkIG9uIGFzc2lnbm1lbnRcblx0XHRcdGlucHV0LnZhbHVlID0gdmFsdWUgPz8gJyc7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqIEB0eXBlIHtTZXQ8SFRNTElucHV0RWxlbWVudFtdPn0gKi9cbmNvbnN0IHBlbmRpbmcgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50W119IGlucHV0c1xuICogQHBhcmFtIHtudWxsIHwgW251bWJlcl19IGdyb3VwX2luZGV4XG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2dyb3VwKGlucHV0cywgZ3JvdXBfaW5kZXgsIGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgaXNfY2hlY2tib3ggPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2NoZWNrYm94Jztcblx0dmFyIGJpbmRpbmdfZ3JvdXAgPSBpbnB1dHM7XG5cblx0Ly8gbmVlZHMgdG8gYmUgbGV0IG9yIHJlbGF0ZWQgY29kZSBpc24ndCB0cmVlc2hha2VuIG91dCBpZiBpdCdzIGFsd2F5cyBmYWxzZVxuXHRsZXQgaHlkcmF0aW9uX21pc21hdGNoID0gZmFsc2U7XG5cblx0aWYgKGdyb3VwX2luZGV4ICE9PSBudWxsKSB7XG5cdFx0Zm9yICh2YXIgaW5kZXggb2YgZ3JvdXBfaW5kZXgpIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGJpbmRpbmdfZ3JvdXAgPSBiaW5kaW5nX2dyb3VwW2luZGV4XSA/Pz0gW107XG5cdFx0fVxuXHR9XG5cblx0YmluZGluZ19ncm91cC5wdXNoKGlucHV0KTtcblxuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KFxuXHRcdGlucHV0LFxuXHRcdCdjaGFuZ2UnLFxuXHRcdCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhciB2YWx1ZSA9IGlucHV0Ll9fdmFsdWU7XG5cblx0XHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGJpbmRpbmdfZ3JvdXAsIHZhbHVlLCBpbnB1dC5jaGVja2VkKTtcblx0XHRcdH1cblxuXHRcdFx0c2V0KHZhbHVlKTtcblx0XHR9LFxuXHRcdC8vIFRPRE8gYmV0dGVyIGRlZmF1bHQgdmFsdWUgaGFuZGxpbmdcblx0XHQoKSA9PiBzZXQoaXNfY2hlY2tib3ggPyBbXSA6IG51bGwpXG5cdCk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsIHRoZW4gdXNlIHRoZSB1cGRhdGUgdmFsdWVcblx0XHQvLyBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdGlmIChoeWRyYXRpbmcgJiYgaW5wdXQuZGVmYXVsdENoZWNrZWQgIT09IGlucHV0LmNoZWNrZWQpIHtcblx0XHRcdGh5ZHJhdGlvbl9taXNtYXRjaCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGlzX2NoZWNrYm94KSB7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IFtdO1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0aW5wdXQuY2hlY2tlZCA9IHZhbHVlLmluY2x1ZGVzKGlucHV0Ll9fdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRpbnB1dC5jaGVja2VkID0gaXMoaW5wdXQuX192YWx1ZSwgdmFsdWUpO1xuXHRcdH1cblx0fSk7XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdHZhciBpbmRleCA9IGJpbmRpbmdfZ3JvdXAuaW5kZXhPZihpbnB1dCk7XG5cblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRiaW5kaW5nX2dyb3VwLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoIXBlbmRpbmcuaGFzKGJpbmRpbmdfZ3JvdXApKSB7XG5cdFx0cGVuZGluZy5hZGQoYmluZGluZ19ncm91cCk7XG5cblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdC8vIG5lY2Vzc2FyeSB0byBtYWludGFpbiBiaW5kaW5nIGdyb3VwIG9yZGVyIGluIGFsbCBpbnNlcnRpb24gc2NlbmFyaW9zXG5cdFx0XHRiaW5kaW5nX2dyb3VwLnNvcnQoKGEsIGIpID0+IChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpID09PSA0ID8gLTEgOiAxKSk7XG5cdFx0XHRwZW5kaW5nLmRlbGV0ZShiaW5kaW5nX2dyb3VwKTtcblx0XHR9KTtcblx0fVxuXG5cdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpb25fbWlzbWF0Y2gpIHtcblx0XHRcdHZhciB2YWx1ZTtcblxuXHRcdFx0aWYgKGlzX2NoZWNrYm94KSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoYmluZGluZ19ncm91cCwgdmFsdWUsIGlucHV0LmNoZWNrZWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGh5ZHJhdGlvbl9pbnB1dCA9IGJpbmRpbmdfZ3JvdXAuZmluZCgoaW5wdXQpID0+IGlucHV0LmNoZWNrZWQpO1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdHZhbHVlID0gaHlkcmF0aW9uX2lucHV0Py5fX3ZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXQodmFsdWUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9jaGVja2VkKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGlucHV0LCAnY2hhbmdlJywgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gaXNfcmVzZXQgPyBpbnB1dC5kZWZhdWx0Q2hlY2tlZCA6IGlucHV0LmNoZWNrZWQ7XG5cdFx0c2V0KHZhbHVlKTtcblx0fSk7XG5cblx0aWYgKFxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCxcblx0XHQvLyB0aGVuIHVzZSB0aGUgdXBkYXRlIHZhbHVlIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0KGh5ZHJhdGluZyAmJiBpbnB1dC5kZWZhdWx0Q2hlY2tlZCAhPT0gaW5wdXQuY2hlY2tlZCkgfHxcblx0XHQvLyBJZiBkZWZhdWx0Q2hlY2tlZCBpcyBzZXQsIHRoZW4gY2hlY2tlZCA9PSBkZWZhdWx0Q2hlY2tlZFxuXHRcdHVudHJhY2soZ2V0KSA9PSBudWxsXG5cdCkge1xuXHRcdHNldChpbnB1dC5jaGVja2VkKTtcblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXHRcdGlucHV0LmNoZWNrZWQgPSBCb29sZWFuKHZhbHVlKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7QXJyYXk8SFRNTElucHV0RWxlbWVudD59IGdyb3VwXG4gKiBAcGFyYW0ge1Z9IF9fdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZFxuICogQHJldHVybnMge1ZbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcblx0LyoqIEB0eXBlIHtTZXQ8Vj59ICovXG5cdHZhciB2YWx1ZSA9IG5ldyBTZXQoKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGdyb3VwW2ldLmNoZWNrZWQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWNoZWNrZWQpIHtcblx0XHR2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSB7XG5cdHZhciB0eXBlID0gaW5wdXQudHlwZTtcblx0cmV0dXJuIHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdyYW5nZSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IEZpbGVMaXN0IHwgbnVsbH0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogRmlsZUxpc3QgfCBudWxsKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZmlsZXMoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoaW5wdXQsICdjaGFuZ2UnLCAoKSA9PiB7XG5cdFx0c2V0KGlucHV0LmZpbGVzKTtcblx0fSk7XG5cblx0aWYgKFxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCxcblx0XHQvLyB0aGVuIHVzZSB0aGUgdXBkYXRlZCB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdGh5ZHJhdGluZyAmJlxuXHRcdGlucHV0LmZpbGVzXG5cdCkge1xuXHRcdHNldChpbnB1dC5maWxlcyk7XG5cdH1cblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRpbnB1dC5maWxlcyA9IGdldCgpO1xuXHR9KTtcbn1cbiIsICJpbXBvcnQgeyByZW5kZXJfZWZmZWN0LCBlZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3RlbiB9IGZyb20gJy4vc2hhcmVkLmpzJztcblxuLyoqIEBwYXJhbSB7VGltZVJhbmdlc30gcmFuZ2VzICovXG5mdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcblx0dmFyIGFycmF5ID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuXHR9XG5cblx0cmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geygpID0+IG51bWJlciB8IHVuZGVmaW5lZH0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9jdXJyZW50X3RpbWUobWVkaWEsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHR2YXIgcmFmX2lkO1xuXHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0dmFyIHZhbHVlO1xuXG5cdC8vIElkZWFsbHksIGxpc3RlbmluZyB0byB0aW1ldXBkYXRlIHdvdWxkIGJlIGVub3VnaCwgYnV0IGl0IGZpcmVzIHRvbyBpbmZyZXF1ZW50bHkgZm9yIHRoZSBjdXJyZW50VGltZVxuXHQvLyBiaW5kaW5nLCB3aGljaCBpcyB3aHkgd2UgdXNlIGEgcmFmIGxvb3AsIHRvby4gV2UgYWRkaXRpb25hbGx5IHN0aWxsIGxpc3RlbiB0byB0aW1ldXBkYXRlIGJlY2F1c2Vcblx0Ly8gdGhlIHVzZXIgY291bGQgYmUgc2NydWJiaW5nIHRocm91Z2ggdGhlIHZpZGVvIHVzaW5nIHRoZSBuYXRpdmUgY29udHJvbHMgd2hlbiB0aGUgbWVkaWEgaXMgcGF1c2VkLlxuXHR2YXIgY2FsbGJhY2sgPSAoKSA9PiB7XG5cdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmX2lkKTtcblxuXHRcdGlmICghbWVkaWEucGF1c2VkKSB7XG5cdFx0XHRyYWZfaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuXHRcdH1cblxuXHRcdHZhciBuZXh0X3ZhbHVlID0gbWVkaWEuY3VycmVudFRpbWU7XG5cdFx0aWYgKHZhbHVlICE9PSBuZXh0X3ZhbHVlKSB7XG5cdFx0XHRzZXQoKHZhbHVlID0gbmV4dF92YWx1ZSkpO1xuXHRcdH1cblx0fTtcblxuXHRyYWZfaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuXHRtZWRpYS5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgY2FsbGJhY2spO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciBuZXh0X3ZhbHVlID0gTnVtYmVyKGdldCgpKTtcblxuXHRcdGlmICh2YWx1ZSAhPT0gbmV4dF92YWx1ZSAmJiAhaXNOYU4oLyoqIEB0eXBlIHthbnl9ICovIChuZXh0X3ZhbHVlKSkpIHtcblx0XHRcdG1lZGlhLmN1cnJlbnRUaW1lID0gdmFsdWUgPSBuZXh0X3ZhbHVlO1xuXHRcdH1cblx0fSk7XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZl9pZCk7XG5cdFx0bWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIGNhbGxiYWNrKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KGFycmF5OiBBcnJheTx7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyIH0+KSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfYnVmZmVyZWQobWVkaWEsIHNldCkge1xuXHQvKiogQHR5cGUge3sgc3RhcnQ6IG51bWJlcjsgZW5kOiBudW1iZXI7IH1bXX0gKi9cblx0dmFyIGN1cnJlbnQ7XG5cblx0Ly8gYGJ1ZmZlcmVkYCBjYW4gdXBkYXRlIHdpdGhvdXQgZW1pdHRpbmcgYW55IGV2ZW50LCBzbyB3ZSBjaGVjayBpdCBvbiB2YXJpb3VzIGV2ZW50cy5cblx0Ly8gQnkgc3BlY3MsIGBidWZmZXJlZGAgYWx3YXlzIHJldHVybnMgYSBuZXcgb2JqZWN0LCBzbyB3ZSBoYXZlIHRvIGNvbXBhcmUgZGVlcGx5LlxuXHRsaXN0ZW4obWVkaWEsIFsnbG9hZGVkbWV0YWRhdGEnLCAncHJvZ3Jlc3MnLCAndGltZXVwZGF0ZScsICdzZWVraW5nJ10sICgpID0+IHtcblx0XHR2YXIgcmFuZ2VzID0gbWVkaWEuYnVmZmVyZWQ7XG5cblx0XHRpZiAoXG5cdFx0XHQhY3VycmVudCB8fFxuXHRcdFx0Y3VycmVudC5sZW5ndGggIT09IHJhbmdlcy5sZW5ndGggfHxcblx0XHRcdGN1cnJlbnQuc29tZSgocmFuZ2UsIGkpID0+IHJhbmdlcy5zdGFydChpKSAhPT0gcmFuZ2Uuc3RhcnQgfHwgcmFuZ2VzLmVuZChpKSAhPT0gcmFuZ2UuZW5kKVxuXHRcdCkge1xuXHRcdFx0Y3VycmVudCA9IHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcyk7XG5cdFx0XHRzZXQoY3VycmVudCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoYXJyYXk6IEFycmF5PHsgc3RhcnQ6IG51bWJlcjsgZW5kOiBudW1iZXIgfT4pID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9zZWVrYWJsZShtZWRpYSwgc2V0KSB7XG5cdGxpc3RlbihtZWRpYSwgWydsb2FkZWRtZXRhZGF0YSddLCAoKSA9PiBzZXQodGltZV9yYW5nZXNfdG9fYXJyYXkobWVkaWEuc2Vla2FibGUpKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KGFycmF5OiBBcnJheTx7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyIH0+KSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcGxheWVkKG1lZGlhLCBzZXQpIHtcblx0bGlzdGVuKG1lZGlhLCBbJ3RpbWV1cGRhdGUnXSwgKCkgPT4gc2V0KHRpbWVfcmFuZ2VzX3RvX2FycmF5KG1lZGlhLnBsYXllZCkpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoc2Vla2luZzogYm9vbGVhbikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3NlZWtpbmcobWVkaWEsIHNldCkge1xuXHRsaXN0ZW4obWVkaWEsIFsnc2Vla2luZycsICdzZWVrZWQnXSwgKCkgPT4gc2V0KG1lZGlhLnNlZWtpbmcpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoc2Vla2luZzogYm9vbGVhbikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2VuZGVkKG1lZGlhLCBzZXQpIHtcblx0bGlzdGVuKG1lZGlhLCBbJ3RpbWV1cGRhdGUnLCAnZW5kZWQnXSwgKCkgPT4gc2V0KG1lZGlhLmVuZGVkKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KHJlYWR5X3N0YXRlOiBudW1iZXIpID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9yZWFkeV9zdGF0ZShtZWRpYSwgc2V0KSB7XG5cdGxpc3Rlbihcblx0XHRtZWRpYSxcblx0XHRbJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRlZGRhdGEnLCAnY2FucGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdwbGF5aW5nJywgJ3dhaXRpbmcnLCAnZW1wdGllZCddLFxuXHRcdCgpID0+IHNldChtZWRpYS5yZWFkeVN0YXRlKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geygpID0+IG51bWJlciB8IHVuZGVmaW5lZH0gZ2V0XG4gKiBAcGFyYW0geyhwbGF5YmFja19yYXRlOiBudW1iZXIpID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9wbGF5YmFja19yYXRlKG1lZGlhLCBnZXQsIHNldCA9IGdldCkge1xuXHQvLyBOZWVkcyB0byBoYXBwZW4gYWZ0ZXIgZWxlbWVudCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBkb20gKHdoaWNoIGlzIGd1YXJhbnRlZWQgYnkgdXNpbmcgZWZmZWN0KSxcblx0Ly8gZWxzZSBwbGF5YmFjayB3aWxsIGJlIHNldCBiYWNrIHRvIDEgYnkgdGhlIGJyb3dzZXJcblx0ZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBOdW1iZXIoZ2V0KCkpO1xuXG5cdFx0aWYgKHZhbHVlICE9PSBtZWRpYS5wbGF5YmFja1JhdGUgJiYgIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0bWVkaWEucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBTdGFydCBsaXN0ZW5pbmcgdG8gcmF0ZWNoYW5nZSBldmVudHMgYWZ0ZXIgdGhlIGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50byB0aGUgZG9tLFxuXHQvLyBlbHNlIHBsYXliYWNrIHdpbGwgYmUgc2V0IHRvIDEgYnkgdGhlIGJyb3dzZXJcblx0ZWZmZWN0KCgpID0+IHtcblx0XHRsaXN0ZW4obWVkaWEsIFsncmF0ZWNoYW5nZSddLCAoKSA9PiB7XG5cdFx0XHRzZXQobWVkaWEucGxheWJhY2tSYXRlKTtcblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KCkgPT4gYm9vbGVhbiB8IHVuZGVmaW5lZH0gZ2V0XG4gKiBAcGFyYW0geyhwYXVzZWQ6IGJvb2xlYW4pID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9wYXVzZWQobWVkaWEsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBwYXVzZWQgPSBnZXQoKTtcblxuXHR2YXIgdXBkYXRlID0gKCkgPT4ge1xuXHRcdGlmIChwYXVzZWQgIT09IG1lZGlhLnBhdXNlZCkge1xuXHRcdFx0c2V0KChwYXVzZWQgPSBtZWRpYS5wYXVzZWQpKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gSWYgc29tZW9uZSBzd2l0Y2hlcyB0aGUgc3JjIHdoaWxlIG1lZGlhIGlzIHBsYXlpbmcsIHRoZSBwbGF5ZXIgd2lsbCBwYXVzZS5cblx0Ly8gTGlzdGVuIHRvIHRoZSBjYW5wbGF5IGV2ZW50IHRvIGdldCBub3RpZmllZCBvZiB0aGlzIHNpdHVhdGlvbi5cblx0bGlzdGVuKG1lZGlhLCBbJ3BsYXknLCAncGF1c2UnLCAnY2FucGxheSddLCB1cGRhdGUsIHBhdXNlZCA9PSBudWxsKTtcblxuXHQvLyBOZWVkcyB0byBiZSBhbiBlZmZlY3QgdG8gZW5zdXJlIG1lZGlhIGVsZW1lbnQgaXMgbW91bnRlZDogZWxzZSwgaWYgcGF1c2VkIGlzIGBmYWxzZWAgKGkuZS4gc2hvdWxkIHBsYXkgcmlnaHQgYXdheSlcblx0Ly8gYSBcIlRoZSBwbGF5KCkgcmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBuZXcgbG9hZCByZXF1ZXN0XCIgZXJyb3Igd291bGQgYmUgdGhyb3duIGJlY2F1c2UgdGhlIHJlc291cmNlIGlzbid0IGxvYWRlZCB5ZXQuXG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKChwYXVzZWQgPSAhIWdldCgpKSAhPT0gbWVkaWEucGF1c2VkKSB7XG5cdFx0XHRpZiAocGF1c2VkKSB7XG5cdFx0XHRcdG1lZGlhLnBhdXNlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZWRpYS5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuXHRcdFx0XHRcdHNldCgocGF1c2VkID0gdHJ1ZSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geygpID0+IG51bWJlciB8IHVuZGVmaW5lZH0gZ2V0XG4gKiBAcGFyYW0geyh2b2x1bWU6IG51bWJlcikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3ZvbHVtZShtZWRpYSwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIGNhbGxiYWNrID0gKCkgPT4ge1xuXHRcdHNldChtZWRpYS52b2x1bWUpO1xuXHR9O1xuXG5cdGlmIChnZXQoKSA9PSBudWxsKSB7XG5cdFx0Y2FsbGJhY2soKTtcblx0fVxuXG5cdGxpc3RlbihtZWRpYSwgWyd2b2x1bWVjaGFuZ2UnXSwgY2FsbGJhY2ssIGZhbHNlKTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBOdW1iZXIoZ2V0KCkpO1xuXG5cdFx0aWYgKHZhbHVlICE9PSBtZWRpYS52b2x1bWUgJiYgIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0bWVkaWEudm9sdW1lID0gdmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoKSA9PiBib29sZWFuIHwgdW5kZWZpbmVkfSBnZXRcbiAqIEBwYXJhbSB7KG11dGVkOiBib29sZWFuKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfbXV0ZWQobWVkaWEsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBjYWxsYmFjayA9ICgpID0+IHtcblx0XHRzZXQobWVkaWEubXV0ZWQpO1xuXHR9O1xuXG5cdGlmIChnZXQoKSA9PSBudWxsKSB7XG5cdFx0Y2FsbGJhY2soKTtcblx0fVxuXG5cdGxpc3RlbihtZWRpYSwgWyd2b2x1bWVjaGFuZ2UnXSwgY2FsbGJhY2ssIGZhbHNlKTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSAhIWdldCgpO1xuXG5cdFx0aWYgKG1lZGlhLm11dGVkICE9PSB2YWx1ZSkgbWVkaWEubXV0ZWQgPSB2YWx1ZTtcblx0fSk7XG59XG4iLCAiaW1wb3J0IHsgbGlzdGVuIH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KG9ubGluZTogYm9vbGVhbikgPT4gdm9pZH0gdXBkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfb25saW5lKHVwZGF0ZSkge1xuXHRsaXN0ZW4od2luZG93LCBbJ29ubGluZScsICdvZmZsaW5lJ10sICgpID0+IHtcblx0XHR1cGRhdGUobmF2aWdhdG9yLm9uTGluZSk7XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBNYWtlcyBhbiBgZXhwb3J0YGVkIChub24tcHJvcCkgdmFyaWFibGUgYXZhaWxhYmxlIG9uIHRoZSBgJCRwcm9wc2Agb2JqZWN0XG4gKiBzbyB0aGF0IGNvbnN1bWVycyBjYW4gZG8gYGJpbmQ6eGAgb24gdGhlIGNvbXBvbmVudC5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9wcm9wKHByb3BzLCBwcm9wLCB2YWx1ZSkge1xuXHR2YXIgZGVzYyA9IGdldF9kZXNjcmlwdG9yKHByb3BzLCBwcm9wKTtcblxuXHRpZiAoZGVzYyAmJiBkZXNjLnNldCkge1xuXHRcdHByb3BzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0cHJvcHNbcHJvcF0gPSBudWxsO1xuXHRcdH0pO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgZWZmZWN0LCB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5cbi8qKlxuICogUmVzaXplIG9ic2VydmVyIHNpbmdsZXRvbi5cbiAqIE9uZSBsaXN0ZW5lciBwZXIgZWxlbWVudCBvbmx5IVxuICogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9nL2JsaW5rLWRldi9jL3o2aWVuT05VYjVBL20vRjUtVmNVWnRCQUFKXG4gKi9cbmNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcblx0LyoqICovXG5cdCNsaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdC8qKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXIgfCB1bmRlZmluZWR9ICovXG5cdCNvYnNlcnZlcjtcblxuXHQvKiogQHR5cGUge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gKi9cblx0I29wdGlvbnM7XG5cblx0LyoqIEBzdGF0aWMgKi9cblx0c3RhdGljIGVudHJpZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdC8qKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gb3B0aW9ucyAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0dGhpcy4jb3B0aW9ucyA9IG9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7KGVudHJ5OiBSZXNpemVPYnNlcnZlckVudHJ5KSA9PiBhbnl9IGxpc3RlbmVyXG5cdCAqL1xuXHRvYnNlcnZlKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuI2xpc3RlbmVycy5nZXQoZWxlbWVudCkgfHwgbmV3IFNldCgpO1xuXHRcdGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuXG5cdFx0dGhpcy4jbGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcnMpO1xuXHRcdHRoaXMuI2dldE9ic2VydmVyKCkub2JzZXJ2ZShlbGVtZW50LCB0aGlzLiNvcHRpb25zKTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy4jbGlzdGVuZXJzLmdldChlbGVtZW50KTtcblx0XHRcdGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuXG5cdFx0XHRpZiAobGlzdGVuZXJzLnNpemUgPT09IDApIHtcblx0XHRcdFx0dGhpcy4jbGlzdGVuZXJzLmRlbGV0ZShlbGVtZW50KTtcblx0XHRcdFx0LyoqIEB0eXBlIHtSZXNpemVPYnNlcnZlcn0gKi8gKHRoaXMuI29ic2VydmVyKS51bm9ic2VydmUoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdCNnZXRPYnNlcnZlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy4jb2JzZXJ2ZXIgPz9cblx0XHRcdCh0aGlzLiNvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcblx0XHRcdFx0LyoqIEBwYXJhbSB7YW55fSBlbnRyaWVzICovIChlbnRyaWVzKSA9PiB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgZW50cnkgb2YgZW50cmllcykge1xuXHRcdFx0XHRcdFx0UmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcy5zZXQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCkgfHwgW10pIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIoZW50cnkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KSlcblx0XHQpO1xuXHR9XG59XG5cbnZhciByZXNpemVfb2JzZXJ2ZXJfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnY29udGVudC1ib3gnXG59KTtcblxudmFyIHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2JvcmRlci1ib3gnXG59KTtcblxudmFyIHJlc2l6ZV9vYnNlcnZlcl9kZXZpY2VfcGl4ZWxfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94J1xufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geydjb250ZW50UmVjdCcgfCAnY29udGVudEJveFNpemUnIHwgJ2JvcmRlckJveFNpemUnIHwgJ2RldmljZVBpeGVsQ29udGVudEJveFNpemUnfSB0eXBlXG4gKiBAcGFyYW0geyhlbnRyeToga2V5b2YgUmVzaXplT2JzZXJ2ZXJFbnRyeSkgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3Jlc2l6ZV9vYnNlcnZlcihlbGVtZW50LCB0eXBlLCBzZXQpIHtcblx0dmFyIG9ic2VydmVyID1cblx0XHR0eXBlID09PSAnY29udGVudFJlY3QnIHx8IHR5cGUgPT09ICdjb250ZW50Qm94U2l6ZSdcblx0XHRcdD8gcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94XG5cdFx0XHQ6IHR5cGUgPT09ICdib3JkZXJCb3hTaXplJ1xuXHRcdFx0XHQ/IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94XG5cdFx0XHRcdDogcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveDtcblxuXHR2YXIgdW5zdWIgPSBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIC8qKiBAcGFyYW0ge2FueX0gZW50cnkgKi8gKGVudHJ5KSA9PiBzZXQoZW50cnlbdHlwZV0pKTtcblx0dGVhcmRvd24odW5zdWIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7J2NsaWVudFdpZHRoJyB8ICdjbGllbnRIZWlnaHQnIHwgJ29mZnNldFdpZHRoJyB8ICdvZmZzZXRIZWlnaHQnfSB0eXBlXG4gKiBAcGFyYW0geyhzaXplOiBudW1iZXIpID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9lbGVtZW50X3NpemUoZWxlbWVudCwgdHlwZSwgc2V0KSB7XG5cdHZhciB1bnN1YiA9IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94Lm9ic2VydmUoZWxlbWVudCwgKCkgPT4gc2V0KGVsZW1lbnRbdHlwZV0pKTtcblxuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdC8vIFRoZSB1cGRhdGUgY291bGQgY29udGFpbiByZWFkcyB3aGljaCBzaG91bGQgYmUgaWdub3JlZFxuXHRcdHVudHJhY2soKCkgPT4gc2V0KGVsZW1lbnRbdHlwZV0pKTtcblx0XHRyZXR1cm4gdW5zdWI7XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IFNUQVRFX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGVmZmVjdCwgcmVuZGVyX2VmZmVjdCB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vLi4vdGFzay5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGJvdW5kX3ZhbHVlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRfb3JfY29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNfYm91bmRfdGhpcyhib3VuZF92YWx1ZSwgZWxlbWVudF9vcl9jb21wb25lbnQpIHtcblx0cmV0dXJuIChcblx0XHRib3VuZF92YWx1ZSA9PT0gZWxlbWVudF9vcl9jb21wb25lbnQgfHwgYm91bmRfdmFsdWU/LltTVEFURV9TWU1CT0xdID09PSBlbGVtZW50X29yX2NvbXBvbmVudFxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBlbGVtZW50X29yX2NvbXBvbmVudFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24sIC4uLnBhcnRzOiB1bmtub3duW10pID0+IHZvaWR9IHVwZGF0ZVxuICogQHBhcmFtIHsoLi4ucGFydHM6IHVua25vd25bXSkgPT4gdW5rbm93bn0gZ2V0X3ZhbHVlXG4gKiBAcGFyYW0geygpID0+IHVua25vd25bXX0gW2dldF9wYXJ0c10gU2V0IGlmIHRoZSB0aGlzIGJpbmRpbmcgaXMgdXNlZCBpbnNpZGUgYW4gZWFjaCBibG9jayxcbiAqIFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJucyBhbGwgdGhlIHBhcnRzIG9mIHRoZSBlYWNoIGJsb2NrIGNvbnRleHQgdGhhdCBhcmUgdXNlZCBpbiB0aGUgZXhwcmVzc2lvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3RoaXMoZWxlbWVudF9vcl9jb21wb25lbnQgPSB7fSwgdXBkYXRlLCBnZXRfdmFsdWUsIGdldF9wYXJ0cykge1xuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdC8qKiBAdHlwZSB7dW5rbm93bltdfSAqL1xuXHRcdHZhciBvbGRfcGFydHM7XG5cblx0XHQvKiogQHR5cGUge3Vua25vd25bXX0gKi9cblx0XHR2YXIgcGFydHM7XG5cblx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9sZF9wYXJ0cyA9IHBhcnRzO1xuXHRcdFx0Ly8gV2Ugb25seSB0cmFjayBjaGFuZ2VzIHRvIHRoZSBwYXJ0cywgbm90IHRoZSB2YWx1ZSBpdHNlbGYgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVydW5zLlxuXHRcdFx0cGFydHMgPSBnZXRfcGFydHM/LigpIHx8IFtdO1xuXG5cdFx0XHR1bnRyYWNrKCgpID0+IHtcblx0XHRcdFx0aWYgKGVsZW1lbnRfb3JfY29tcG9uZW50ICE9PSBnZXRfdmFsdWUoLi4ucGFydHMpKSB7XG5cdFx0XHRcdFx0dXBkYXRlKGVsZW1lbnRfb3JfY29tcG9uZW50LCAuLi5wYXJ0cyk7XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBlZmZlY3QgcmVydW4gKGNhdXNlOiBlYWNoIGJsb2NrIGNvbnRleHQgY2hhbmdlcyksIHRoZW4gbnVsbGlmeSB0aGUgYmluZGluZyBhdFxuXHRcdFx0XHRcdC8vIHRoZSBwcmV2aW91cyBwb3NpdGlvbiBpZiBpdCBpc24ndCBhbHJlYWR5IHRha2VuIG92ZXIgYnkgYSBkaWZmZXJlbnQgZWZmZWN0LlxuXHRcdFx0XHRcdGlmIChvbGRfcGFydHMgJiYgaXNfYm91bmRfdGhpcyhnZXRfdmFsdWUoLi4ub2xkX3BhcnRzKSwgZWxlbWVudF9vcl9jb21wb25lbnQpKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUobnVsbCwgLi4ub2xkX3BhcnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdC8vIFdlIGNhbm5vdCB1c2UgZWZmZWN0cyBpbiB0aGUgdGVhcmRvd24gcGhhc2UsIHdlIHdlIHVzZSBhIG1pY3JvdGFzayBpbnN0ZWFkLlxuXHRcdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRcdGlmIChwYXJ0cyAmJiBpc19ib3VuZF90aGlzKGdldF92YWx1ZSguLi5wYXJ0cyksIGVsZW1lbnRfb3JfY29tcG9uZW50KSkge1xuXHRcdFx0XHRcdHVwZGF0ZShudWxsLCAuLi5wYXJ0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiBlbGVtZW50X29yX2NvbXBvbmVudDtcbn1cbiIsICJpbXBvcnQgeyByZW5kZXJfZWZmZWN0LCB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBsaXN0ZW4gfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsnaW5uZXJIVE1MJyB8ICd0ZXh0Q29udGVudCcgfCAnaW5uZXJUZXh0J30gcHJvcGVydHlcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfY29udGVudF9lZGl0YWJsZShwcm9wZXJ0eSwgZWxlbWVudCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0c2V0KGVsZW1lbnRbcHJvcGVydHldKTtcblx0fSk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHRpZiAoZWxlbWVudFtwcm9wZXJ0eV0gIT09IHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdHZhciBub25fbnVsbF92YWx1ZSA9IGVsZW1lbnRbcHJvcGVydHldO1xuXHRcdFx0XHRzZXQobm9uX251bGxfdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W3Byb3BlcnR5XSA9IHZhbHVlICsgJyc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gW2dldF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9wcm9wZXJ0eShwcm9wZXJ0eSwgZXZlbnRfbmFtZSwgZWxlbWVudCwgc2V0LCBnZXQpIHtcblx0dmFyIGhhbmRsZXIgPSAoKSA9PiB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHNldChlbGVtZW50W3Byb3BlcnR5XSk7XG5cdH07XG5cblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZXIpO1xuXG5cdGlmIChnZXQpIHtcblx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGVsZW1lbnRbcHJvcGVydHldID0gZ2V0KCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0aGFuZGxlcigpO1xuXHR9XG5cblx0Ly8gQHRzLWlnbm9yZVxuXHRpZiAoZWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbGVtZW50ID09PSB3aW5kb3cgfHwgZWxlbWVudCA9PT0gZG9jdW1lbnQpIHtcblx0XHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlcik7XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZm9jdXNlZChlbGVtZW50LCBzZXQpIHtcblx0bGlzdGVuKGVsZW1lbnQsIFsnZm9jdXMnLCAnYmx1ciddLCAoKSA9PiB7XG5cdFx0c2V0KGVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuXHR9KTtcbn1cbiIsICJpbXBvcnQgeyBlZmZlY3QsIHJlbmRlcl9lZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbiwgd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0IH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSB0eXBlXG4gKiBAcGFyYW0geygpID0+IG51bWJlcn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogbnVtYmVyKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF93aW5kb3dfc2Nyb2xsKHR5cGUsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBpc19zY3JvbGxpbmdfeCA9IHR5cGUgPT09ICd4JztcblxuXHR2YXIgdGFyZ2V0X2hhbmRsZXIgPSAoKSA9PlxuXHRcdHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0XHRzY3JvbGxpbmcgPSB0cnVlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQoY2xlYXIsIDEwMCk7IC8vIFRPRE8gdXNlIHNjcm9sbGVuZCBldmVudCBpZiBzdXBwb3J0ZWQgKG9yIHdoZW4gc3VwcG9ydGVkIGV2ZXJ5d2hlcmU/KVxuXG5cdFx0XHRzZXQod2luZG93W2lzX3Njcm9sbGluZ194ID8gJ3Njcm9sbFgnIDogJ3Njcm9sbFknXSk7XG5cdFx0fSk7XG5cblx0YWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGFyZ2V0X2hhbmRsZXIsIHtcblx0XHRwYXNzaXZlOiB0cnVlXG5cdH0pO1xuXG5cdHZhciBzY3JvbGxpbmcgPSBmYWxzZTtcblxuXHQvKiogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+fSAqL1xuXHR2YXIgdGltZW91dDtcblx0dmFyIGNsZWFyID0gKCkgPT4ge1xuXHRcdHNjcm9sbGluZyA9IGZhbHNlO1xuXHR9O1xuXHR2YXIgZmlyc3QgPSB0cnVlO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciBsYXRlc3RfdmFsdWUgPSBnZXQoKTtcblx0XHQvLyBEb24ndCBzY3JvbGwgdG8gdGhlIGluaXRpYWwgdmFsdWUgZm9yIGFjY2Vzc2liaWxpdHkgcmVhc29uc1xuXHRcdGlmIChmaXJzdCkge1xuXHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKCFzY3JvbGxpbmcgJiYgbGF0ZXN0X3ZhbHVlICE9IG51bGwpIHtcblx0XHRcdHNjcm9sbGluZyA9IHRydWU7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHRpZiAoaXNfc2Nyb2xsaW5nX3gpIHtcblx0XHRcdFx0c2Nyb2xsVG8obGF0ZXN0X3ZhbHVlLCB3aW5kb3cuc2Nyb2xsWSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzY3JvbGxUbyh3aW5kb3cuc2Nyb2xsWCwgbGF0ZXN0X3ZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFyLCAxMDApO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gQnJvd3NlcnMgZG9uJ3QgZmlyZSB0aGUgc2Nyb2xsIGV2ZW50IGZvciB0aGUgaW5pdGlhbCBzY3JvbGwgcG9zaXRpb24gd2hlbiBzY3JvbGwgc3R5bGUgaXNuJ3Qgc2V0IHRvIHNtb290aFxuXHRlZmZlY3QodGFyZ2V0X2hhbmRsZXIpO1xuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHRyZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0YXJnZXRfaGFuZGxlcik7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7J2lubmVyV2lkdGgnIHwgJ2lubmVySGVpZ2h0JyB8ICdvdXRlcldpZHRoJyB8ICdvdXRlckhlaWdodCd9IHR5cGVcbiAqIEBwYXJhbSB7KHNpemU6IG51bWJlcikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3dpbmRvd19zaXplKHR5cGUsIHNldCkge1xuXHRsaXN0ZW4od2luZG93LCBbJ3Jlc2l6ZSddLCAoKSA9PiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4gc2V0KHdpbmRvd1t0eXBlXSkpKTtcbn1cbiIsICJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHVzZXJfcHJlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBvbiB9IGZyb20gJy4uL2VsZW1lbnRzL2V2ZW50cy5qcyc7XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGB0cnVzdGVkYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0aWYgKGV2ZW50LmlzVHJ1c3RlZCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Zm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHNlbGZgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxmKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Zm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHN0b3BQcm9wYWdhdGlvbmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBvbmNlYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25jZShmbikge1xuXHR2YXIgcmFuID0gZmFsc2U7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHJhbikgcmV0dXJuO1xuXHRcdHJhbiA9IHRydWU7XG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBwcmV2ZW50RGVmYXVsdGAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgcGFzc2l2ZWAgZXZlbnQgbW9kaWZpZXIsIGltcGxlbWVudGVkIGFzIGFuIGFjdGlvblxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7W2V2ZW50OiBzdHJpbmcsIGhhbmRsZXI6ICgpID0+IEV2ZW50TGlzdGVuZXJdfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXNzaXZlKG5vZGUsIFtldmVudCwgaGFuZGxlcl0pIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRyZXR1cm4gb24obm9kZSwgZXZlbnQsIGhhbmRsZXIoKSA/PyBub29wLCB7XG5cdFx0XHRwYXNzaXZlOiB0cnVlXG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgbm9ucGFzc2l2ZWAgZXZlbnQgbW9kaWZpZXIsIGltcGxlbWVudGVkIGFzIGFuIGFjdGlvblxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7W2V2ZW50OiBzdHJpbmcsIGhhbmRsZXI6ICgpID0+IEV2ZW50TGlzdGVuZXJdfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25wYXNzaXZlKG5vZGUsIFtldmVudCwgaGFuZGxlcl0pIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRyZXR1cm4gb24obm9kZSwgZXZlbnQsIGhhbmRsZXIoKSA/PyBub29wLCB7XG5cdFx0XHRwYXNzaXZlOiBmYWxzZVxuXHRcdH0pO1xuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHRMZWdhY3kgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgcnVuLCBydW5fYWxsIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBkZXJpdmVkIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyc7XG5pbXBvcnQgeyB1c2VyX3ByZV9lZmZlY3QsIHVzZXJfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGRlZXBfcmVhZF9zdGF0ZSwgZ2V0LCB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5cbi8qKlxuICogTGVnYWN5LW1vZGUgb25seTogQ2FsbCBgb25Nb3VudGAgY2FsbGJhY2tzIGFuZCBzZXQgdXAgYGJlZm9yZVVwZGF0ZWAvYGFmdGVyVXBkYXRlYCBlZmZlY3RzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW11dGFibGVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KGltbXV0YWJsZSA9IGZhbHNlKSB7XG5cdGNvbnN0IGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cblx0Y29uc3QgY2FsbGJhY2tzID0gY29udGV4dC5sLnU7XG5cdGlmICghY2FsbGJhY2tzKSByZXR1cm47XG5cblx0bGV0IHByb3BzID0gKCkgPT4gZGVlcF9yZWFkX3N0YXRlKGNvbnRleHQucyk7XG5cblx0aWYgKGltbXV0YWJsZSkge1xuXHRcdGxldCB2ZXJzaW9uID0gMDtcblx0XHRsZXQgcHJldiA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi8gKHt9KTtcblxuXHRcdC8vIEluIGxlZ2FjeSBpbW11dGFibGUgbW9kZSwgYmVmb3JlL2FmdGVyVXBkYXRlIG9ubHkgZmlyZSBpZiB0aGUgb2JqZWN0IGlkZW50aXR5IG9mIGEgcHJvcCBjaGFuZ2VzXG5cdFx0Y29uc3QgZCA9IGRlcml2ZWQoKCkgPT4ge1xuXHRcdFx0bGV0IGNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHByb3BzID0gY29udGV4dC5zO1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcblx0XHRcdFx0aWYgKHByb3BzW2tleV0gIT09IHByZXZba2V5XSkge1xuXHRcdFx0XHRcdHByZXZba2V5XSA9IHByb3BzW2tleV07XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjaGFuZ2VkKSB2ZXJzaW9uKys7XG5cdFx0XHRyZXR1cm4gdmVyc2lvbjtcblx0XHR9KTtcblxuXHRcdHByb3BzID0gKCkgPT4gZ2V0KGQpO1xuXHR9XG5cblx0Ly8gYmVmb3JlVXBkYXRlXG5cdGlmIChjYWxsYmFja3MuYi5sZW5ndGgpIHtcblx0XHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0b2JzZXJ2ZV9hbGwoY29udGV4dCwgcHJvcHMpO1xuXHRcdFx0cnVuX2FsbChjYWxsYmFja3MuYik7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBvbk1vdW50IChtdXN0IHJ1biBiZWZvcmUgYWZ0ZXJVcGRhdGUpXG5cdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRjb25zdCBmbnMgPSB1bnRyYWNrKCgpID0+IGNhbGxiYWNrcy5tLm1hcChydW4pKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Zm9yIChjb25zdCBmbiBvZiBmbnMpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGZuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHQvLyBhZnRlclVwZGF0ZVxuXHRpZiAoY2FsbGJhY2tzLmEubGVuZ3RoKSB7XG5cdFx0dXNlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0b2JzZXJ2ZV9hbGwoY29udGV4dCwgcHJvcHMpO1xuXHRcdFx0cnVuX2FsbChjYWxsYmFja3MuYSk7XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBJbnZva2UgdGhlIGdldHRlciBvZiBhbGwgc2lnbmFscyBhc3NvY2lhdGVkIHdpdGggYSBjb21wb25lbnRcbiAqIHNvIHRoZXkgY2FuIGJlIHJlZ2lzdGVyZWQgdG8gdGhlIGVmZmVjdCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbi5cbiAqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gY29udGV4dFxuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKSB7XG5cdGlmIChjb250ZXh0Lmwucykge1xuXHRcdGZvciAoY29uc3Qgc2lnbmFsIG9mIGNvbnRleHQubC5zKSBnZXQoc2lnbmFsKTtcblx0fVxuXG5cdHByb3BzKCk7XG59XG4iLCAiaW1wb3J0IHsgc2V0LCBzb3VyY2UgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8qKlxuICogVW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBpbXBvcnRzIG1heSBiZSByZWFjdGl2ZSBpbiBsZWdhY3kgbW9kZS4gSW4gdGhhdCBjYXNlLFxuICogdGhleSBzaG91bGQgYmUgdXNpbmcgYHJlYWN0aXZlX2ltcG9ydGAgYXMgcGFydCBvZiB0aGUgdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhY3RpdmVfaW1wb3J0KGZuKSB7XG5cdHZhciBzID0gc291cmNlKDApO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHNldChzLCBnZXQocykgKyAxKTtcblx0XHRcdHJldHVybiBhcmd1bWVudHNbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldChzKTtcblx0XHRcdHJldHVybiBmbigpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAdGhpcyB7YW55fVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gJCRwcm9wc1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlX2V2ZW50KCQkcHJvcHMsIGV2ZW50KSB7XG5cdHZhciBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uW10gfCBGdW5jdGlvbj59ICovICgkJHByb3BzLiQkZXZlbnRzKT8uW1xuXHRcdGV2ZW50LnR5cGVcblx0XTtcblxuXHR2YXIgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogZXZlbnRzID09IG51bGwgPyBbXSA6IFtldmVudHNdO1xuXG5cdGZvciAodmFyIGZuIG9mIGNhbGxiYWNrcykge1xuXHRcdC8vIFByZXNlcnZlIFwidGhpc1wiIGNvbnRleHRcblx0XHRmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fVxufVxuXG4vKipcbiAqIFVzZWQgdG8gc2ltdWxhdGUgYCRvbmAgb24gYSBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbiBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGkgPT09IDRgXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59ICQkcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudF9jYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xlZ2FjeV9ldmVudF9saXN0ZW5lcigkJHByb3BzLCBldmVudF9uYW1lLCBldmVudF9jYWxsYmFjaykge1xuXHQkJHByb3BzLiQkZXZlbnRzIHx8PSB7fTtcblx0JCRwcm9wcy4kJGV2ZW50c1tldmVudF9uYW1lXSB8fD0gW107XG5cdCQkcHJvcHMuJCRldmVudHNbZXZlbnRfbmFtZV0ucHVzaChldmVudF9jYWxsYmFjayk7XG59XG5cbi8qKlxuICogVXNlZCB0byBzaW11bGF0ZSBgJHNldGAgb24gYSBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbiBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGkgPT09IDRgLlxuICogTmVlZHMgY29tcG9uZW50IGFjY2Vzc29ycyBzbyB0aGF0IGl0IGNhbiBjYWxsIHRoZSBzZXR0ZXIgb2YgdGhlIHByb3AuIFRoZXJlZm9yZSBkb2Vzbid0XG4gKiB3b3JrIGZvciB1cGRhdGluZyBwcm9wcyBpbiBgJCRwcm9wc2Agb3IgYCQkcmVzdFByb3BzYC5cbiAqIEB0aGlzIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJG5ld19wcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2xlZ2FjeV9wcm9wcygkJG5ld19wcm9wcykge1xuXHRmb3IgKHZhciBrZXkgaW4gJCRuZXdfcHJvcHMpIHtcblx0XHRpZiAoa2V5IGluIHRoaXMpIHtcblx0XHRcdHRoaXNba2V5XSA9ICQkbmV3X3Byb3BzW2tleV07XG5cdFx0fVxuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBSZWFkYWJsZSwgU3RhcnRTdG9wTm90aWZpZXIsIFN1YnNjcmliZXIsIFVuc3Vic2NyaWJlciwgVXBkYXRlciwgV3JpdGFibGUgfSBmcm9tICcuLi9wdWJsaWMuanMnICovXG4vKiogQGltcG9ydCB7IFN0b3JlcywgU3RvcmVzVmFsdWVzLCBTdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGUgfSBmcm9tICcuLi9wcml2YXRlLmpzJyAqL1xuaW1wb3J0IHsgbm9vcCwgcnVuX2FsbCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBzYWZlX25vdF9lcXVhbCB9IGZyb20gJy4uLy4uL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IHN1YnNjcmliZV90b19zdG9yZSB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPGFueT4gfCBhbnk+fVxuICovXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBSZWFkYWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlXG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtXcml0YWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRhYmxlKHZhbHVlLCBzdGFydCA9IG5vb3ApIHtcblx0LyoqIEB0eXBlIHtVbnN1YnNjcmliZXIgfCBudWxsfSAqL1xuXHRsZXQgc3RvcCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtTZXQ8U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+Pn0gKi9cblx0Y29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VH0gbmV3X3ZhbHVlXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuXHRcdGlmIChzYWZlX25vdF9lcXVhbCh2YWx1ZSwgbmV3X3ZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0XHRpZiAoc3RvcCkge1xuXHRcdFx0XHQvLyBzdG9yZSBpcyByZWFkeVxuXHRcdFx0XHRjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic2NyaWJlciBvZiBzdWJzY3JpYmVycykge1xuXHRcdFx0XHRcdHN1YnNjcmliZXJbMV0oKTtcblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLnB1c2goc3Vic2NyaWJlciwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5fcXVldWUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGRhdGVyPFQ+fSBmblxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuXHRcdHNldChmbigvKiogQHR5cGUge1R9ICovICh2YWx1ZSkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N1YnNjcmliZXI8VD59IHJ1blxuXHQgKiBAcGFyYW0geygpID0+IHZvaWR9IFtpbnZhbGlkYXRlXVxuXHQgKiBAcmV0dXJucyB7VW5zdWJzY3JpYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcblx0XHQvKiogQHR5cGUge1N1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPn0gKi9cblx0XHRjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07XG5cdFx0c3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpO1xuXHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG5cdFx0XHRzdG9wID0gc3RhcnQoc2V0LCB1cGRhdGUpIHx8IG5vb3A7XG5cdFx0fVxuXHRcdHJ1bigvKiogQHR5cGUge1R9ICovICh2YWx1ZSkpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cdFx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCAmJiBzdG9wKSB7XG5cdFx0XHRcdHN0b3AoKTtcblx0XHRcdFx0c3RvcCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG59XG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBAdGVtcGxhdGUge1N0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogU3RvcmVzVmFsdWVzPFM+LCBzZXQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgdXBkYXRlOiAoZm46IFVwZGF0ZXI8VD4pID0+IHZvaWQpID0+IFVuc3Vic2NyaWJlciB8IHZvaWR9IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFN0b3Jlc1ZhbHVlczxTPikgPT4gVH0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbi8qKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcblx0Y29uc3Qgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoc3RvcmVzKTtcblx0LyoqIEB0eXBlIHtBcnJheTxSZWFkYWJsZTxhbnk+Pn0gKi9cblx0Y29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlID8gW3N0b3Jlc10gOiBzdG9yZXM7XG5cdGlmICghc3RvcmVzX2FycmF5LmV2ZXJ5KEJvb2xlYW4pKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdkZXJpdmVkKCkgZXhwZWN0cyBzdG9yZXMgYXMgaW5wdXQsIGdvdCBhIGZhbHN5IHZhbHVlJyk7XG5cdH1cblx0Y29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG5cdHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCAoc2V0LCB1cGRhdGUpID0+IHtcblx0XHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7VFtdfSAqL1xuXHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXHRcdGxldCBwZW5kaW5nID0gMDtcblx0XHRsZXQgY2xlYW51cCA9IG5vb3A7XG5cdFx0Y29uc3Qgc3luYyA9ICgpID0+IHtcblx0XHRcdGlmIChwZW5kaW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0LCB1cGRhdGUpO1xuXHRcdFx0aWYgKGF1dG8pIHtcblx0XHRcdFx0c2V0KHJlc3VsdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbGVhbnVwID0gdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJyA/IHJlc3VsdCA6IG5vb3A7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcCgoc3RvcmUsIGkpID0+XG5cdFx0XHRzdWJzY3JpYmVfdG9fc3RvcmUoXG5cdFx0XHRcdHN0b3JlLFxuXHRcdFx0XHQodmFsdWUpID0+IHtcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRwZW5kaW5nICY9IH4oMSA8PCBpKTtcblx0XHRcdFx0XHRpZiAoc3RhcnRlZCkge1xuXHRcdFx0XHRcdFx0c3luYygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRcdHBlbmRpbmcgfD0gMSA8PCBpO1xuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0KTtcblx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRzeW5jKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Ly8gV2UgbmVlZCB0byBzZXQgdGhpcyB0byBmYWxzZSBiZWNhdXNlIGNhbGxiYWNrcyBjYW4gc3RpbGwgaGFwcGVuIGRlc3BpdGUgaGF2aW5nIHVuc3Vic2NyaWJlZDpcblx0XHRcdC8vIENhbGxiYWNrcyBtaWdodCBhbHJlYWR5IGJlIHBsYWNlZCBpbiB0aGUgcXVldWUgd2hpY2ggZG9lc24ndCBrbm93IGl0IHNob3VsZCBubyBsb25nZXJcblx0XHRcdC8vIGludm9rZSB0aGlzIGRlcml2ZWQgc3RvcmUuXG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzdG9yZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUgZGVyaXZlZCBmcm9tIHRoZSBvbGQgb25lIHRoYXQgaXMgcmVhZGFibGUuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UmVhZGFibGU8VD59IHN0b3JlICAtIHN0b3JlIHRvIG1ha2UgcmVhZG9ubHlcbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRvbmx5KHN0b3JlKSB7XG5cdHJldHVybiB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGkgc3VzcGVjdCB0aGUgYmluZCBpcyB1bm5lY2Vzc2FyeVxuXHRcdHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLmJpbmQoc3RvcmUpXG5cdH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZyb20gYSBzdG9yZSBieSBzdWJzY3JpYmluZyBhbmQgaW1tZWRpYXRlbHkgdW5zdWJzY3JpYmluZy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIHZhbHVlO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgU3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgU3RvcmUgfSBmcm9tICcjc2hhcmVkJyAqL1xuaW1wb3J0IHsgc3Vic2NyaWJlX3RvX3N0b3JlIH0gZnJvbSAnLi4vLi4vLi4vc3RvcmUvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0IGFzIGdldF9zdG9yZSB9IGZyb20gJy4uLy4uLy4uL3N0b3JlL3NoYXJlZC9pbmRleC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHksIG5vb3AgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4vZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBtdXRhYmxlX3NvdXJjZSwgc2V0IH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wIGN1cnJlbnRseSBiZWluZyByZWFkIGlzIGEgc3RvcmUgYmluZGluZywgYXMgaW5cbiAqIGA8Q2hpbGQgYmluZDp4PXskeX0gLz5gLiBJZiBpdCBpcywgd2UgdHJlYXQgdGhlIHByb3AgYXMgbXV0YWJsZSBldmVuIGluXG4gKiBydW5lcyBtb2RlLCBhbmQgc2tpcCBgYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgIHZhbGlkYXRpb25cbiAqL1xubGV0IGlzX3N0b3JlX2JpbmRpbmcgPSBmYWxzZTtcblxubGV0IElTX1VOTU9VTlRFRCA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBzdG9yZS4gSWYgdGhlIHN0b3JlIGlzbid0IHN1YnNjcmliZWQgdG8geWV0LCBpdCB3aWxsIGNyZWF0ZSBhIHByb3h5XG4gKiBzaWduYWwgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgd2hlbiB0aGUgc3RvcmUgaXMuIFRoZSBzdG9yZSByZWZlcmVuY2VzIGNvbnRhaW5lciBpcyBuZWVkZWQgdG9cbiAqIHRyYWNrIHJlYXNzaWdubWVudHMgdG8gc3RvcmVzIGFuZCB0byB0cmFjayB0aGUgY29ycmVjdCBjb21wb25lbnQgY29udGV4dC5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1N0b3JlPFY+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2dldChzdG9yZSwgc3RvcmVfbmFtZSwgc3RvcmVzKSB7XG5cdGNvbnN0IGVudHJ5ID0gKHN0b3Jlc1tzdG9yZV9uYW1lXSA/Pz0ge1xuXHRcdHN0b3JlOiBudWxsLFxuXHRcdHNvdXJjZTogbXV0YWJsZV9zb3VyY2UodW5kZWZpbmVkKSxcblx0XHR1bnN1YnNjcmliZTogbm9vcFxuXHR9KTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZW50cnkuc291cmNlLmxhYmVsID0gc3RvcmVfbmFtZTtcblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgdGhhdCBzZXR1cCB0aGlzIGlzIGFscmVhZHkgdW5tb3VudGVkIHdlIGRvbid0IHdhbnQgdG8gcmVnaXN0ZXIgYSBzdWJzY3JpcHRpb25cblx0aWYgKGVudHJ5LnN0b3JlICE9PSBzdG9yZSAmJiAhKElTX1VOTU9VTlRFRCBpbiBzdG9yZXMpKSB7XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUoKTtcblx0XHRlbnRyeS5zdG9yZSA9IHN0b3JlID8/IG51bGw7XG5cblx0XHRpZiAoc3RvcmUgPT0gbnVsbCkge1xuXHRcdFx0ZW50cnkuc291cmNlLnYgPSB1bmRlZmluZWQ7IC8vIHNlZSBzeW5jaHJvbm91cyBjYWxsYmFjayBjb21tZW50IGJlbG93XG5cdFx0XHRlbnRyeS51bnN1YnNjcmliZSA9IG5vb3A7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBpc19zeW5jaHJvbm91c19jYWxsYmFjayA9IHRydWU7XG5cblx0XHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gc3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCAodikgPT4ge1xuXHRcdFx0XHRpZiAoaXNfc3luY2hyb25vdXNfY2FsbGJhY2spIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgZmlyc3QgdXBkYXRlcyB0byB0aGUgc3RvcmUgdmFsdWUgKHBvc3NpYmx5IG11bHRpcGxlIG9mIHRoZW0pIGFyZSBzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0Ly8gaW5zaWRlIGEgZGVyaXZlZCwgd2Ugd2lsbCBoaXQgdGhlIGBzdGF0ZV91bnNhZmVfbXV0YXRpb25gIGVycm9yIGlmIHdlIGBzZXRgIHRoZSB2YWx1ZVxuXHRcdFx0XHRcdGVudHJ5LnNvdXJjZS52ID0gdjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXQoZW50cnkuc291cmNlLCB2KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlzX3N5bmNocm9ub3VzX2NhbGxiYWNrID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gaWYgdGhlIGNvbXBvbmVudCB0aGF0IHNldHVwIHRoaXMgc3RvcmVzIGlzIGFscmVhZHkgdW5tb3VudGVkIHRoZSBzb3VyY2Ugd2lsbCBiZSBvdXQgb2Ygc3luY1xuXHQvLyBzbyB3ZSBqdXN0IHVzZSB0aGUgYGdldGAgZm9yIHRoZSBzdG9yZXMsIGxlc3MgcGVyZm9ybWFudCBidXQgaXQgYXZvaWRzIHRvIGNyZWF0ZSBhIG1lbW9yeSBsZWFrXG5cdC8vIGFuZCBpdCB3aWxsIGtlZXAgdGhlIHZhbHVlIGNvbnNpc3RlbnRcblx0aWYgKHN0b3JlICYmIElTX1VOTU9VTlRFRCBpbiBzdG9yZXMpIHtcblx0XHRyZXR1cm4gZ2V0X3N0b3JlKHN0b3JlKTtcblx0fVxuXG5cdHJldHVybiBnZXQoZW50cnkuc291cmNlKTtcbn1cblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgaWYgaXQncyBub3QgdGhlIHNhbWUgYXMgdGhlIG9uZSBpbiB0aGUgc3RvcmUgcmVmZXJlbmNlcyBjb250YWluZXIuXG4gKiBXZSBuZWVkIHRoaXMgaW4gYWRkaXRpb24gdG8gYHN0b3JlX2dldGAgYmVjYXVzZSBzb21lb25lIGNvdWxkIHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBidXRcbiAqIHRoZW4gbmV2ZXIgc3Vic2NyaWJlIHRvIHRoZSBuZXcgb25lIChpZiBhbnkpLCBjYXVzaW5nIHRoZSBzdWJzY3JpcHRpb24gdG8gc3RheSBvcGVuIHdyb25nZnVsbHkuXG4gKiBAcGFyYW0ge1N0b3JlPGFueT4gfCBudWxsIHwgdW5kZWZpbmVkfSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX3Vuc3ViKHN0b3JlLCBzdG9yZV9uYW1lLCBzdG9yZXMpIHtcblx0LyoqIEB0eXBlIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJbJyddIHwgdW5kZWZpbmVkfSAqL1xuXHRsZXQgZW50cnkgPSBzdG9yZXNbc3RvcmVfbmFtZV07XG5cblx0aWYgKGVudHJ5ICYmIGVudHJ5LnN0b3JlICE9PSBzdG9yZSkge1xuXHRcdC8vIERvbid0IHJlc2V0IHN0b3JlIHlldCwgc28gdGhhdCBzdG9yZV9nZXQgYWJvdmUgY2FuIHJlc3Vic2NyaWJlIHRvIG5ldyBzdG9yZSBpZiBuZWNlc3Nhcnlcblx0XHRlbnRyeS51bnN1YnNjcmliZSgpO1xuXHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gbm9vcDtcblx0fVxuXG5cdHJldHVybiBzdG9yZTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBuZXcgdmFsdWUgb2YgYSBzdG9yZSBhbmQgcmV0dXJucyB0aGF0IHZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U3RvcmU8Vj59IHN0b3JlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX3NldChzdG9yZSwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlX3N0b3JlKHN0b3Jlcywgc3RvcmVfbmFtZSkge1xuXHR2YXIgZW50cnkgPSBzdG9yZXNbc3RvcmVfbmFtZV07XG5cdGlmIChlbnRyeS5zdG9yZSAhPT0gbnVsbCkge1xuXHRcdHN0b3JlX3NldChlbnRyeS5zdG9yZSwgZW50cnkuc291cmNlLnYpO1xuXHR9XG59XG5cbi8qKlxuICogVW5zdWJzY3JpYmVzIGZyb20gYWxsIGF1dG8tc3Vic2NyaWJlZCBzdG9yZXMgb24gZGVzdHJveVxuICogQHJldHVybnMge1tTdG9yZVJlZmVyZW5jZXNDb250YWluZXIsICgpPT52b2lkXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwX3N0b3JlcygpIHtcblx0LyoqIEB0eXBlIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9ICovXG5cdGNvbnN0IHN0b3JlcyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0Zm9yICh2YXIgc3RvcmVfbmFtZSBpbiBzdG9yZXMpIHtcblx0XHRcdFx0Y29uc3QgcmVmID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXHRcdFx0XHRyZWYudW5zdWJzY3JpYmUoKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZV9wcm9wZXJ0eShzdG9yZXMsIElTX1VOTU9VTlRFRCwge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IHRydWVcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIFtzdG9yZXMsIGNsZWFudXBdO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzdG9yZSB3aXRoIGEgbmV3IHZhbHVlLlxuICogQHBhcmFtIHtTdG9yZTxWPn0gc3RvcmUgIHRoZSBzdG9yZSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBleHByZXNzaW9uICB0aGUgZXhwcmVzc2lvbiB0aGF0IG11dGF0ZXMgdGhlIHN0b3JlXG4gKiBAcGFyYW0ge1Z9IG5ld192YWx1ZSAgdGhlIG5ldyBzdG9yZSB2YWx1ZVxuICogQHRlbXBsYXRlIFZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX211dGF0ZShzdG9yZSwgZXhwcmVzc2lvbiwgbmV3X3ZhbHVlKSB7XG5cdHN0b3JlLnNldChuZXdfdmFsdWUpO1xuXHRyZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlPG51bWJlcj59IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RvcmVfdmFsdWVcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc3RvcmUoc3RvcmUsIHN0b3JlX3ZhbHVlLCBkID0gMSkge1xuXHRzdG9yZS5zZXQoc3RvcmVfdmFsdWUgKyBkKTtcblx0cmV0dXJuIHN0b3JlX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RvcmU8bnVtYmVyPn0gc3RvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdG9yZV92YWx1ZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmVfc3RvcmUoc3RvcmUsIHN0b3JlX3ZhbHVlLCBkID0gMSkge1xuXHRjb25zdCB2YWx1ZSA9IHN0b3JlX3ZhbHVlICsgZDtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUgcHJvcCBnZXR0ZXJzIHRvIGNvbW11bmljYXRlIHRoYXQgdGhlIHByb3AgaXMgYSBzdG9yZSBiaW5kaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrX3N0b3JlX2JpbmRpbmcoKSB7XG5cdGlzX3N0b3JlX2JpbmRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB0dXBsZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGBmbigpYCByZWFkcyBhIHByb3AgdGhhdCBpcyBhIHN0b3JlIGJpbmRpbmcuXG4gKiBVc2VkIHRvIHByZXZlbnQgYGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCB2YWxpZGF0aW9uIGZhbHNlIHBvc2l0aXZlcyBhbmRcbiAqIGVuc3VyZSB0aGF0IHRoZXNlIHByb3BzIGFyZSB0cmVhdGVkIGFzIG11dGFibGUgZXZlbiBpbiBydW5lcyBtb2RlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1tULCBib29sZWFuXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVfc3RvcmVfYmluZGluZyhmbikge1xuXHR2YXIgcHJldmlvdXNfaXNfc3RvcmVfYmluZGluZyA9IGlzX3N0b3JlX2JpbmRpbmc7XG5cblx0dHJ5IHtcblx0XHRpc19zdG9yZV9iaW5kaW5nID0gZmFsc2U7XG5cdFx0cmV0dXJuIFtmbigpLCBpc19zdG9yZV9iaW5kaW5nXTtcblx0fSBmaW5hbGx5IHtcblx0XHRpc19zdG9yZV9iaW5kaW5nID0gcHJldmlvdXNfaXNfc3RvcmVfYmluZGluZztcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBTb3VyY2UgfSBmcm9tICcuL3R5cGVzLmpzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRQUk9QU19JU19CSU5EQUJMRSxcblx0UFJPUFNfSVNfSU1NVVRBQkxFLFxuXHRQUk9QU19JU19MQVpZX0lOSVRJQUwsXG5cdFBST1BTX0lTX1JVTkVTLFxuXHRQUk9QU19JU19VUERBVEVEXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvciwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgc2V0LCBzb3VyY2UsIHVwZGF0ZSB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgeyBkZXJpdmVkLCBkZXJpdmVkX3NhZmVfZXF1YWwgfSBmcm9tICcuL2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGdldCxcblx0aXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHR1bnRyYWNrXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgREVTVFJPWUVELCBMRUdBQ1lfUFJPUFMsIFNUQVRFX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHByb3h5IH0gZnJvbSAnLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgY2FwdHVyZV9zdG9yZV9iaW5kaW5nIH0gZnJvbSAnLi9zdG9yZS5qcyc7XG5pbXBvcnQgeyBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KCh2YWx1ZT86IG51bWJlcikgPT4gbnVtYmVyKX0gZm5cbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJvcChmbiwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBmbigpO1xuXHRmbih2YWx1ZSArIGQpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKHZhbHVlPzogbnVtYmVyKSA9PiBudW1iZXIpfSBmblxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmVfcHJvcChmbiwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBmbigpICsgZDtcblx0Zm4odmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIHJlc3QgcHJvcHMgKGkuZS4gYGNvbnN0IHsgeCwgLi4ucmVzdCB9ID0gJHByb3BzKClgKS5cbiAqIElzIHBhc3NlZCB0aGUgZnVsbCBgJCRwcm9wc2Agb2JqZWN0IGFuZCBleGNsdWRlcyB0aGUgbmFtZWQgcHJvcHMuXG4gKiBAdHlwZSB7UHJveHlIYW5kbGVyPHsgcHJvcHM6IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+LCBleGNsdWRlOiBBcnJheTxzdHJpbmcgfCBzeW1ib2w+LCBuYW1lPzogc3RyaW5nIH0+fX1cbiAqL1xuY29uc3QgcmVzdF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdHJldHVybiB0YXJnZXQucHJvcHNba2V5XTtcblx0fSxcblx0c2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0Ly8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJvZCB0b28/XG5cdFx0XHRlLnByb3BzX3Jlc3RfcmVhZG9ubHkoYCR7dGFyZ2V0Lm5hbWV9LiR7U3RyaW5nKGtleSl9YCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGlmIChrZXkgaW4gdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB0YXJnZXQucHJvcHNba2V5XVxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cdGhhcyh0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIGtleSBpbiB0YXJnZXQucHJvcHM7XG5cdH0sXG5cdG93bktleXModGFyZ2V0KSB7XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQucHJvcHMpLmZpbHRlcigoa2V5KSA9PiAhdGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSk7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGV4Y2x1ZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gcmVzdF9wcm9wcyhwcm9wcywgZXhjbHVkZSwgbmFtZSkge1xuXHRyZXR1cm4gbmV3IFByb3h5KFxuXHRcdERFViA/IHsgcHJvcHMsIGV4Y2x1ZGUsIG5hbWUsIG90aGVyOiB7fSwgdG9fcHJveHk6IFtdIH0gOiB7IHByb3BzLCBleGNsdWRlIH0sXG5cdFx0cmVzdF9wcm9wc19oYW5kbGVyXG5cdCk7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIGxlZ2FjeSAkJHJlc3RQcm9wcyBhbmQgJCRwcm9wc1xuICogQHR5cGUge1Byb3h5SGFuZGxlcjx7IHByb3BzOiBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPiwgZXhjbHVkZTogQXJyYXk8c3RyaW5nIHwgc3ltYm9sPiwgc3BlY2lhbDogUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgKHY/OiB1bmtub3duKSA9PiB1bmtub3duPiwgdmVyc2lvbjogU291cmNlPG51bWJlcj4sIHBhcmVudF9lZmZlY3Q6IEVmZmVjdCB9Pn19XG4gKi9cbmNvbnN0IGxlZ2FjeV9yZXN0X3Byb3BzX2hhbmRsZXIgPSB7XG5cdGdldCh0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm47XG5cdFx0Z2V0KHRhcmdldC52ZXJzaW9uKTtcblx0XHRyZXR1cm4ga2V5IGluIHRhcmdldC5zcGVjaWFsID8gdGFyZ2V0LnNwZWNpYWxba2V5XSgpIDogdGFyZ2V0LnByb3BzW2tleV07XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcblx0XHRpZiAoIShrZXkgaW4gdGFyZ2V0LnNwZWNpYWwpKSB7XG5cdFx0XHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QodGFyZ2V0LnBhcmVudF9lZmZlY3QpO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBwcm9wcyB0aGF0IGNhbiB0ZW1wb3JhcmlseSBnZXQgb3V0IG9mIHN5bmMgd2l0aCB0aGUgcGFyZW50XG5cdFx0XHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgKHY/OiB1bmtub3duKSA9PiB1bmtub3duPn0gKi9cblx0XHRcdFx0dGFyZ2V0LnNwZWNpYWxba2V5XSA9IHByb3AoXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Z2V0IFtrZXldKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnByb3BzW2tleV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiogQHR5cGUge3N0cmluZ30gKi8gKGtleSksXG5cdFx0XHRcdFx0UFJPUFNfSVNfVVBEQVRFRFxuXHRcdFx0XHQpO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0YXJnZXQuc3BlY2lhbFtrZXldKHZhbHVlKTtcblx0XHR1cGRhdGUodGFyZ2V0LnZlcnNpb24pOyAvLyAkJHByb3BzIGlzIGNvYXJzZS1ncmFpbmVkOiB3aGVuICQkcHJvcHMueCBpcyB1cGRhdGVkLCB1c2FnZXMgb2YgJCRwcm9wcy55IGV0YyBhcmUgYWxzbyByZXJ1blxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGlmIChrZXkgaW4gdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB0YXJnZXQucHJvcHNba2V5XVxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG5cdFx0Ly8gU3ZlbHRlIDQgYWxsb3dlZCBmb3IgZGVsZXRpb25zIG9uICQkcmVzdFByb3BzXG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybiB0cnVlO1xuXHRcdHRhcmdldC5leGNsdWRlLnB1c2goa2V5KTtcblx0XHR1cGRhdGUodGFyZ2V0LnZlcnNpb24pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnByb3BzO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnByb3BzKS5maWx0ZXIoKGtleSkgPT4gIXRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcmVzdF9wcm9wcyhwcm9wcywgZXhjbHVkZSkge1xuXHRyZXR1cm4gbmV3IFByb3h5KFxuXHRcdHtcblx0XHRcdHByb3BzLFxuXHRcdFx0ZXhjbHVkZSxcblx0XHRcdHNwZWNpYWw6IHt9LFxuXHRcdFx0dmVyc2lvbjogc291cmNlKDApLFxuXHRcdFx0Ly8gVE9ETyB0aGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0byB0cmFjayBjb21wb25lbnRcblx0XHRcdC8vIGRlc3RydWN0aW9uIGluc2lkZSBgcHJvcGAsIGJlY2F1c2Ugb2YgYGJpbmQ6dGhpc2AsIGJ1dCBpdFxuXHRcdFx0Ly8gc2VlbXMgbGlrZWx5IHRoYXQgd2UgY2FuIHNpbXBsaWZ5IGBiaW5kOnRoaXNgIGluc3RlYWRcblx0XHRcdHBhcmVudF9lZmZlY3Q6IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdClcblx0XHR9LFxuXHRcdGxlZ2FjeV9yZXN0X3Byb3BzX2hhbmRsZXJcblx0KTtcbn1cblxuLyoqXG4gKiBUaGUgcHJveHkgaGFuZGxlciBmb3Igc3ByZWFkIHByb3BzLiBIYW5kbGVzIHRoZSBpbmNvbWluZyBhcnJheSBvZiBwcm9wc1xuICogdGhhdCBsb29rcyBsaWtlIGAoKSA9PiB7IGR5bmFtaWM6IHByb3BzIH0sIHsgc3RhdGljOiBwcm9wIH0sIC4uYCBhbmQgd3JhcHNcbiAqIHRoZW0gc28gdGhhdCB0aGUgd2hvbGUgdGhpbmcgaXMgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQgYXMgdGhlIGAkJHByb3BzYCBhcmd1bWVudC5cbiAqIEB0eXBlIHtQcm94eUhhbmRsZXI8eyBwcm9wczogQXJyYXk8UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4gfCAoKCkgPT4gUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4pPiB9Pn19XG4gKi9cbmNvbnN0IHNwcmVhZF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRsZXQgaSA9IHRhcmdldC5wcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bGV0IHAgPSB0YXJnZXQucHJvcHNbaV07XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAodHlwZW9mIHAgPT09ICdvYmplY3QnICYmIHAgIT09IG51bGwgJiYga2V5IGluIHApIHJldHVybiBwW2tleV07XG5cdFx0fVxuXHR9LFxuXHRzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG5cdFx0bGV0IGkgPSB0YXJnZXQucHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGxldCBwID0gdGFyZ2V0LnByb3BzW2ldO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0Y29uc3QgZGVzYyA9IGdldF9kZXNjcmlwdG9yKHAsIGtleSk7XG5cdFx0XHRpZiAoZGVzYyAmJiBkZXNjLnNldCkge1xuXHRcdFx0XHRkZXNjLnNldCh2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuXHRcdGxldCBpID0gdGFyZ2V0LnByb3BzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRsZXQgcCA9IHRhcmdldC5wcm9wc1tpXTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGlmICh0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgcCAhPT0gbnVsbCAmJiBrZXkgaW4gcCkge1xuXHRcdFx0XHRjb25zdCBkZXNjcmlwdG9yID0gZ2V0X2Rlc2NyaXB0b3IocCwga2V5KTtcblx0XHRcdFx0aWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0Ly8gUHJldmVudCBhIFwiTm9uLWNvbmZpZ3VyYWJpbGl0eSBSZXBvcnQgRXJyb3JcIjogVGhlIHRhcmdldCBpcyBhbiBhcnJheSwgaXQgZG9lc1xuXHRcdFx0XHRcdC8vIG5vdCBhY3R1YWxseSBjb250YWluIHRoaXMgcHJvcGVydHkuIElmIGl0IGlzIG5vdyBkZXNjcmliZWQgYXMgbm9uLWNvbmZpZ3VyYWJsZSxcblx0XHRcdFx0XHQvLyB0aGUgcHJveHkgdGhyb3dzIGEgdmFsaWRhdGlvbiBlcnJvci4gU2V0dGluZyBpdCB0byB0cnVlIGF2b2lkcyB0aGF0LlxuXHRcdFx0XHRcdGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGVzY3JpcHRvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhcyh0YXJnZXQsIGtleSkge1xuXHRcdC8vIFRvIHByZXZlbnQgYSBmYWxzZSBwb3NpdGl2ZSBgaXNfZW50cnlfcHJvcHNgIGluIHRoZSBgcHJvcGAgZnVuY3Rpb25cblx0XHRpZiAoa2V5ID09PSBTVEFURV9TWU1CT0wgfHwga2V5ID09PSBMRUdBQ1lfUFJPUFMpIHJldHVybiBmYWxzZTtcblxuXHRcdGZvciAobGV0IHAgb2YgdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAocCAhPSBudWxsICYmIGtleSBpbiBwKSByZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdG93bktleXModGFyZ2V0KSB7XG5cdFx0LyoqIEB0eXBlIHtBcnJheTxzdHJpbmcgfCBzeW1ib2w+fSAqL1xuXHRcdGNvbnN0IGtleXMgPSBbXTtcblxuXHRcdGZvciAobGV0IHAgb2YgdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAoIXApIGNvbnRpbnVlO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBwKSB7XG5cdFx0XHRcdGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSBrZXlzLnB1c2goa2V5KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwKSkge1xuXHRcdFx0XHRpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkga2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGtleXM7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8ICgoKSA9PiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik+fSBwcm9wc1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwcmVhZF9wcm9wcyguLi5wcm9wcykge1xuXHRyZXR1cm4gbmV3IFByb3h5KHsgcHJvcHMgfSwgc3ByZWFkX3Byb3BzX2hhbmRsZXIpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHN5bmNocm9uaXppbmcgYSBwb3NzaWJseSBib3VuZCBwcm9wIHdpdGggdGhlIGlubmVyIGNvbXBvbmVudCBzdGF0ZS5cbiAqIEl0IGlzIHVzZWQgd2hlbmV2ZXIgdGhlIGNvbXBpbGVyIHNlZXMgdGhhdCB0aGUgY29tcG9uZW50IHdyaXRlcyB0byB0aGUgcHJvcCwgb3Igd2hlbiBpdCBoYXMgYSBkZWZhdWx0IHByb3BfdmFsdWUuXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHtWIHwgKCgpID0+IFYpfSBbZmFsbGJhY2tdXG4gKiBAcmV0dXJucyB7KCgpID0+IFYgfCAoKGFyZzogVikgPT4gVikgfCAoKGFyZzogViwgbXV0YXRpb246IGJvb2xlYW4pID0+IFYpKX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3AocHJvcHMsIGtleSwgZmxhZ3MsIGZhbGxiYWNrKSB7XG5cdHZhciBydW5lcyA9ICFsZWdhY3lfbW9kZV9mbGFnIHx8IChmbGFncyAmIFBST1BTX0lTX1JVTkVTKSAhPT0gMDtcblx0dmFyIGJpbmRhYmxlID0gKGZsYWdzICYgUFJPUFNfSVNfQklOREFCTEUpICE9PSAwO1xuXHR2YXIgbGF6eSA9IChmbGFncyAmIFBST1BTX0lTX0xBWllfSU5JVElBTCkgIT09IDA7XG5cblx0dmFyIGZhbGxiYWNrX3ZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spO1xuXHR2YXIgZmFsbGJhY2tfZGlydHkgPSB0cnVlO1xuXG5cdHZhciBnZXRfZmFsbGJhY2sgPSAoKSA9PiB7XG5cdFx0aWYgKGZhbGxiYWNrX2RpcnR5KSB7XG5cdFx0XHRmYWxsYmFja19kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRmYWxsYmFja192YWx1ZSA9IGxhenlcblx0XHRcdFx0PyB1bnRyYWNrKC8qKiBAdHlwZSB7KCkgPT4gVn0gKi8gKGZhbGxiYWNrKSlcblx0XHRcdFx0OiAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjayk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbGxiYWNrX3ZhbHVlO1xuXHR9O1xuXG5cdC8qKiBAdHlwZSB7KCh2OiBWKSA9PiB2b2lkKSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIHNldHRlcjtcblxuXHRpZiAoYmluZGFibGUpIHtcblx0XHQvLyBDYW4gYmUgdGhlIGNhc2Ugd2hlbiBzb21lb25lIGRvZXMgYG1vdW50KENvbXBvbmVudCwgcHJvcHMpYCB3aXRoIGBsZXQgcHJvcHMgPSAkc3RhdGUoey4uLn0pYFxuXHRcdC8vIG9yIGBjcmVhdGVDbGFzc0NvbXBvbmVudChDb21wb25lbnQsIHByb3BzKWBcblx0XHR2YXIgaXNfZW50cnlfcHJvcHMgPSBTVEFURV9TWU1CT0wgaW4gcHJvcHMgfHwgTEVHQUNZX1BST1BTIGluIHByb3BzO1xuXG5cdFx0c2V0dGVyID1cblx0XHRcdGdldF9kZXNjcmlwdG9yKHByb3BzLCBrZXkpPy5zZXQgPz9cblx0XHRcdChpc19lbnRyeV9wcm9wcyAmJiBrZXkgaW4gcHJvcHMgPyAodikgPT4gKHByb3BzW2tleV0gPSB2KSA6IHVuZGVmaW5lZCk7XG5cdH1cblxuXHR2YXIgaW5pdGlhbF92YWx1ZTtcblx0dmFyIGlzX3N0b3JlX3N1YiA9IGZhbHNlO1xuXG5cdGlmIChiaW5kYWJsZSkge1xuXHRcdFtpbml0aWFsX3ZhbHVlLCBpc19zdG9yZV9zdWJdID0gY2FwdHVyZV9zdG9yZV9iaW5kaW5nKCgpID0+IC8qKiBAdHlwZSB7Vn0gKi8gKHByb3BzW2tleV0pKTtcblx0fSBlbHNlIHtcblx0XHRpbml0aWFsX3ZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSk7XG5cdH1cblxuXHRpZiAoaW5pdGlhbF92YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRpbml0aWFsX3ZhbHVlID0gZ2V0X2ZhbGxiYWNrKCk7XG5cblx0XHRpZiAoc2V0dGVyKSB7XG5cdFx0XHRpZiAocnVuZXMpIGUucHJvcHNfaW52YWxpZF92YWx1ZShrZXkpO1xuXHRcdFx0c2V0dGVyKGluaXRpYWxfdmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBAdHlwZSB7KCkgPT4gVn0gKi9cblx0dmFyIGdldHRlcjtcblxuXHRpZiAocnVuZXMpIHtcblx0XHRnZXR0ZXIgPSAoKSA9PiB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0X2ZhbGxiYWNrKCk7XG5cdFx0XHRmYWxsYmFja19kaXJ0eSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRnZXR0ZXIgPSAoKSA9PiB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKTtcblxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gaW4gbGVnYWN5IG1vZGUsIHdlIGRvbid0IHJldmVydCB0byB0aGUgZmFsbGJhY2sgdmFsdWVcblx0XHRcdFx0Ly8gaWYgdGhlIHByb3AgZ29lcyBmcm9tIGRlZmluZWQgdG8gdW5kZWZpbmVkLiBUaGUgZWFzaWVzdFxuXHRcdFx0XHQvLyB3YXkgdG8gbW9kZWwgdGhpcyBpcyB0byBtYWtlIHRoZSBmYWxsYmFjayB1bmRlZmluZWRcblx0XHRcdFx0Ly8gYXMgc29vbiBhcyB0aGUgcHJvcCBoYXMgYSB2YWx1ZVxuXHRcdFx0XHRmYWxsYmFja192YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZmFsbGJhY2tfdmFsdWUgOiB2YWx1ZTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gcHJvcCBpcyBuZXZlciB3cml0dGVuIHRvIFx1MjAxNCB3ZSBvbmx5IG5lZWQgYSBnZXR0ZXJcblx0aWYgKHJ1bmVzICYmIChmbGFncyAmIFBST1BTX0lTX1VQREFURUQpID09PSAwKSB7XG5cdFx0cmV0dXJuIGdldHRlcjtcblx0fVxuXG5cdC8vIHByb3AgaXMgd3JpdHRlbiB0bywgYnV0IHRoZSBwYXJlbnQgY29tcG9uZW50IGhhZCBgYmluZDpmb29gIHdoaWNoXG5cdC8vIG1lYW5zIHdlIGNhbiBqdXN0IGNhbGwgYCQkcHJvcHMuZm9vID0gdmFsdWVgIGRpcmVjdGx5XG5cdGlmIChzZXR0ZXIpIHtcblx0XHR2YXIgbGVnYWN5X3BhcmVudCA9IHByb3BzLiQkbGVnYWN5O1xuXHRcdHJldHVybiAvKiogQHR5cGUgeygpID0+IFZ9ICovIChcblx0XHRcdGZ1bmN0aW9uICgvKiogQHR5cGUge1Z9ICovIHZhbHVlLCAvKiogQHR5cGUge2Jvb2xlYW59ICovIG11dGF0aW9uKSB7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gbm90aWZ5IGlmIHRoZSB2YWx1ZSB3YXMgbXV0YXRlZCBhbmQgdGhlIHBhcmVudCBpcyBpbiBydW5lcyBtb2RlLlxuXHRcdFx0XHRcdC8vIEluIHRoYXQgY2FzZSB0aGUgc3RhdGUgcHJveHkgKGlmIGl0IGV4aXN0cykgc2hvdWxkIHRha2UgY2FyZSBvZiB0aGUgbm90aWZpY2F0aW9uLlxuXHRcdFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgaXMgbm90IGluIHJ1bmVzIG1vZGUsIHdlIG5lZWQgdG8gbm90aWZ5IG9uIG11dGF0aW9uLCB0b28sIHRoYXQgdGhlIHByb3Bcblx0XHRcdFx0XHQvLyBoYXMgY2hhbmdlZCBiZWNhdXNlIHRoZSBwYXJlbnQgd2lsbCBub3QgYmUgYWJsZSB0byBkZXRlY3QgdGhlIGNoYW5nZSBvdGhlcndpc2UuXG5cdFx0XHRcdFx0aWYgKCFydW5lcyB8fCAhbXV0YXRpb24gfHwgbGVnYWN5X3BhcmVudCB8fCBpc19zdG9yZV9zdWIpIHtcblx0XHRcdFx0XHRcdC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChzZXR0ZXIpKG11dGF0aW9uID8gZ2V0dGVyKCkgOiB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGdldHRlcigpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxuXHQvLyBFaXRoZXIgcHJvcCBpcyB3cml0dGVuIHRvLCBidXQgdGhlcmUncyBubyBiaW5kaW5nLCB3aGljaCBtZWFucyB3ZVxuXHQvLyBjcmVhdGUgYSBkZXJpdmVkIHRoYXQgd2UgY2FuIHdyaXRlIHRvIGxvY2FsbHkuXG5cdC8vIE9yIHdlIGFyZSBpbiBsZWdhY3kgbW9kZSB3aGVyZSB3ZSBhbHdheXMgY3JlYXRlIGEgZGVyaXZlZCB0byByZXBsaWNhdGUgdGhhdFxuXHQvLyBTdmVsdGUgNCBkaWQgbm90IHRyaWdnZXIgdXBkYXRlcyB3aGVuIGEgcHJpbWl0aXZlIHZhbHVlIHdhcyB1cGRhdGVkIHRvIHRoZSBzYW1lIHZhbHVlLlxuXHR2YXIgb3ZlcnJpZGRlbiA9IGZhbHNlO1xuXG5cdHZhciBkID0gKChmbGFncyAmIFBST1BTX0lTX0lNTVVUQUJMRSkgIT09IDAgPyBkZXJpdmVkIDogZGVyaXZlZF9zYWZlX2VxdWFsKSgoKSA9PiB7XG5cdFx0b3ZlcnJpZGRlbiA9IGZhbHNlO1xuXHRcdHJldHVybiBnZXR0ZXIoKTtcblx0fSk7XG5cblx0aWYgKERFVikge1xuXHRcdGQubGFiZWwgPSBrZXk7XG5cdH1cblxuXHQvLyBDYXB0dXJlIHRoZSBpbml0aWFsIHZhbHVlIGlmIGl0J3MgYmluZGFibGVcblx0aWYgKGJpbmRhYmxlKSBnZXQoZCk7XG5cblx0dmFyIHBhcmVudF9lZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdHJldHVybiAvKiogQHR5cGUgeygpID0+IFZ9ICovIChcblx0XHRmdW5jdGlvbiAoLyoqIEB0eXBlIHthbnl9ICovIHZhbHVlLCAvKiogQHR5cGUge2Jvb2xlYW59ICovIG11dGF0aW9uKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgbmV3X3ZhbHVlID0gbXV0YXRpb24gPyBnZXQoZCkgOiBydW5lcyAmJiBiaW5kYWJsZSA/IHByb3h5KHZhbHVlKSA6IHZhbHVlO1xuXG5cdFx0XHRcdHNldChkLCBuZXdfdmFsdWUpO1xuXHRcdFx0XHRvdmVycmlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoZmFsbGJhY2tfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGZhbGxiYWNrX3ZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UgXHUyMDE0IGF2b2lkIHJlY2FsY3VsYXRpbmcgdGhlIGRlcml2ZWQgaWYgd2UncmUgaW4gYVxuXHRcdFx0Ly8gdGVhcmRvd24gZnVuY3Rpb24gYW5kIHRoZSBwcm9wIHdhcyBvdmVycmlkZGVuIGxvY2FsbHksIG9yIHRoZVxuXHRcdFx0Ly8gY29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCAodGhpcyBsYXR0ZXIgcGFydCBpcyBuZWNlc3Nhcnlcblx0XHRcdC8vIGJlY2F1c2UgYGJpbmQ6dGhpc2AgY2FuIHJlYWQgcHJvcHMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXNcblx0XHRcdC8vIGJlZW4gZGVzdHJveWVkLiBUT0RPIHNpbXBsaWZ5IGBiaW5kOnRoaXNgXG5cdFx0XHRpZiAoKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0ICYmIG92ZXJyaWRkZW4pIHx8IChwYXJlbnRfZWZmZWN0LmYgJiBERVNUUk9ZRUQpICE9PSAwKSB7XG5cdFx0XHRcdHJldHVybiBkLnY7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZXQoZCk7XG5cdFx0fVxuXHQpO1xufVxuIiwgImltcG9ydCB7IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBpc19hcnJheSB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgY2FwdHVyZV9zdG9yZV9iaW5kaW5nIH0gZnJvbSAnLi9yZWFjdGl2aXR5L3N0b3JlLmpzJztcbmltcG9ydCB7IHJ1bl9hZnRlcl9ibG9ja2VycyB9IGZyb20gJy4vcmVhY3Rpdml0eS9hc3luYy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7KGl0ZW06IGFueSwgaW5kZXg6IG51bWJlcikgPT4gc3RyaW5nfSBrZXlfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGNvbGxlY3Rpb24sIGtleV9mbikge1xuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuXHRcdGNvbnN0IG1heWJlX2FycmF5ID0gY29sbGVjdGlvbigpO1xuXHRcdGNvbnN0IGFycmF5ID0gaXNfYXJyYXkobWF5YmVfYXJyYXkpXG5cdFx0XHQ/IG1heWJlX2FycmF5XG5cdFx0XHQ6IG1heWJlX2FycmF5ID09IG51bGxcblx0XHRcdFx0PyBbXVxuXHRcdFx0XHQ6IEFycmF5LmZyb20obWF5YmVfYXJyYXkpO1xuXHRcdGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBrZXkgPSBrZXlfZm4oYXJyYXlbaV0sIGkpO1xuXHRcdFx0aWYgKGtleXMuaGFzKGtleSkpIHtcblx0XHRcdFx0Y29uc3QgYSA9IFN0cmluZyhrZXlzLmdldChrZXkpKTtcblx0XHRcdFx0Y29uc3QgYiA9IFN0cmluZyhpKTtcblxuXHRcdFx0XHQvKiogQHR5cGUge3N0cmluZyB8IG51bGx9ICovXG5cdFx0XHRcdGxldCBrID0gU3RyaW5nKGtleSk7XG5cdFx0XHRcdGlmIChrLnN0YXJ0c1dpdGgoJ1tvYmplY3QgJykpIGsgPSBudWxsO1xuXG5cdFx0XHRcdGUuZWFjaF9rZXlfZHVwbGljYXRlKGEsIGIsIGspO1xuXHRcdFx0fVxuXHRcdFx0a2V5cy5zZXQoa2V5LCBpKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5kaW5nXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U8dm9pZD4+fSBibG9ja2Vyc1xuICogQHBhcmFtIHsoKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+fSBnZXRfb2JqZWN0XG4gKiBAcGFyYW0geygpID0+IHN0cmluZ30gZ2V0X3Byb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0gbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfYmluZGluZyhiaW5kaW5nLCBibG9ja2VycywgZ2V0X29iamVjdCwgZ2V0X3Byb3BlcnR5LCBsaW5lLCBjb2x1bW4pIHtcblx0cnVuX2FmdGVyX2Jsb2NrZXJzKGJsb2NrZXJzLCAoKSA9PiB7XG5cdFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xuXG5cdFx0dmFyIGZpbGVuYW1lID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uPy5bRklMRU5BTUVdO1xuXG5cdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRpZiAod2FybmVkKSByZXR1cm47XG5cblx0XHRcdHZhciBbb2JqZWN0LCBpc19zdG9yZV9zdWJdID0gY2FwdHVyZV9zdG9yZV9iaW5kaW5nKGdldF9vYmplY3QpO1xuXG5cdFx0XHRpZiAoaXNfc3RvcmVfc3ViKSByZXR1cm47XG5cblx0XHRcdHZhciBwcm9wZXJ0eSA9IGdldF9wcm9wZXJ0eSgpO1xuXG5cdFx0XHR2YXIgcmFuID0gZmFsc2U7XG5cblx0XHRcdC8vIGJ5IG1ha2luZyB0aGUgKHBvc3NpYmx5IGZhbHNlLCBidXQgaXQgd291bGQgYmUgYW4gZXh0cmVtZSBlZGdlIGNhc2UpIGFzc3VtcHRpb25cblx0XHRcdC8vIHRoYXQgYSBnZXR0ZXIgaGFzIGEgY29ycmVzcG9uZGluZyBzZXR0ZXIsIHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBwcm9wZXJ0eSBpc1xuXHRcdFx0Ly8gcmVhY3RpdmUgYnkgc2VlaW5nIGlmIHRoaXMgZWZmZWN0IGhhcyBkZXBlbmRlbmNpZXNcblx0XHRcdHZhciBlZmZlY3QgPSByZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0aWYgKHJhbikgcmV0dXJuO1xuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdG9iamVjdFtwcm9wZXJ0eV07XG5cdFx0XHR9KTtcblxuXHRcdFx0cmFuID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGVmZmVjdC5kZXBzID09PSBudWxsKSB7XG5cdFx0XHRcdHZhciBsb2NhdGlvbiA9IGAke2ZpbGVuYW1lfToke2xpbmV9OiR7Y29sdW1ufWA7XG5cdFx0XHRcdHcuYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmUoYmluZGluZywgbG9jYXRpb24pO1xuXG5cdFx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zLCBDb21wb25lbnRUeXBlLCBTdmVsdGVDb21wb25lbnQsIENvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZScgKi9cbmltcG9ydCB7IERJUlRZLCBMRUdBQ1lfUFJPUFMsIE1BWUJFX0RJUlRZIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyB1c2VyX3ByZV9lZmZlY3QgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IG11dGFibGVfc291cmNlLCBzZXQgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGUsIG1vdW50LCB1bm1vdW50IH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlbmRlci5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBnZXQsIHNldF9zaWduYWxfc3RhdHVzIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBpc19hcnJheSB9IGZyb20gJy4uL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9lcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBGSUxFTkFNRSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCwgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L2NvbnRleHQuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnIH0gZnJvbSAnLi4vaW50ZXJuYWwvZmxhZ3MvaW5kZXguanMnO1xuXG4vKipcbiAqIFRha2VzIHRoZSBzYW1lIG9wdGlvbnMgYXMgYSBTdmVsdGUgNCBjb21wb25lbnQgYW5kIHRoZSBjb21wb25lbnQgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBTdmVsdGUgNCBjb21wYXRpYmxlIGNvbXBvbmVudC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhpcyBvbmx5IGFzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uIHRvIG1pZ3JhdGUgeW91ciBpbXBlcmF0aXZlIGNvbXBvbmVudCBjb2RlIHRvIFN2ZWx0ZSA1LlxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFdmVudHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gU2xvdHNcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnN0cnVjdG9yT3B0aW9uczxQcm9wcz4gJiB7XG4gKiBcdGNvbXBvbmVudDogQ29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHMsIEV2ZW50cywgU2xvdHM+PiB8IENvbXBvbmVudDxQcm9wcz47XG4gKiB9fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7U3ZlbHRlQ29tcG9uZW50PFByb3BzLCBFdmVudHMsIFNsb3RzPiAmIEV4cG9ydHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGFzc0NvbXBvbmVudChvcHRpb25zKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgJCRwcm9wX2RlZiBldGMgYXJlIG5vdCBhY3R1YWxseSBkZWZpbmVkXG5cdHJldHVybiBuZXcgU3ZlbHRlNENvbXBvbmVudChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgY29tcG9uZW50IGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgU3ZlbHRlIDQgY29tcGF0aWJsZSBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoaXMgb25seSBhcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiB0byBtaWdyYXRlIHlvdXIgaW1wZXJhdGl2ZSBjb21wb25lbnQgY29kZSB0byBTdmVsdGUgNS5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV4cG9ydHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXZlbnRzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFNsb3RzXG4gKlxuICogQHBhcmFtIHtTdmVsdGVDb21wb25lbnQ8UHJvcHMsIEV2ZW50cywgU2xvdHM+IHwgQ29tcG9uZW50PFByb3BzPn0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7Q29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHMsIEV2ZW50cywgU2xvdHM+ICYgRXhwb3J0cz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yICQkcHJvcF9kZWYgZXRjIGFyZSBub3QgYWN0dWFsbHkgZGVmaW5lZFxuXHRyZXR1cm4gY2xhc3MgZXh0ZW5kcyBTdmVsdGU0Q29tcG9uZW50IHtcblx0XHQvKiogQHBhcmFtIHthbnl9IG9wdGlvbnMgKi9cblx0XHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0XHRzdXBlcih7XG5cdFx0XHRcdGNvbXBvbmVudCxcblx0XHRcdFx0Li4ub3B0aW9uc1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdXNpbmcgdGhlIGNvbXBvbmVudCBhcyBib3RoIGEgY2xhc3MgYW5kIGZ1bmN0aW9uIGR1cmluZyB0aGUgdHJhbnNpdGlvbiBwZXJpb2RcbiAqIEB0eXBlZGVmICB7e25ldyAobzogQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zKTogU3ZlbHRlQ29tcG9uZW50OyguLi5hcmdzOiBQYXJhbWV0ZXJzPENvbXBvbmVudDxSZWNvcmQ8c3RyaW5nLCBhbnk+Pj4pOiBSZXR1cm5UeXBlPENvbXBvbmVudDxSZWNvcmQ8c3RyaW5nLCBhbnk+LCBSZWNvcmQ8c3RyaW5nLCBhbnk+Pj47fX0gTGVnYWN5Q29tcG9uZW50VHlwZVxuICovXG5cbmNsYXNzIFN2ZWx0ZTRDb21wb25lbnQge1xuXHQvKiogQHR5cGUge2FueX0gKi9cblx0I2V2ZW50cztcblxuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG5cdCNpbnN0YW5jZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtDb21wb25lbnRDb25zdHJ1Y3Rvck9wdGlvbnMgJiB7XG5cdCAqICBjb21wb25lbnQ6IGFueTtcblx0ICogfX0gb3B0aW9uc1xuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHZhciBzb3VyY2VzID0gbmV3IE1hcCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmcgfCBzeW1ib2x9IGtleVxuXHRcdCAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcblx0XHQgKi9cblx0XHR2YXIgYWRkX3NvdXJjZSA9IChrZXksIHZhbHVlKSA9PiB7XG5cdFx0XHR2YXIgcyA9IG11dGFibGVfc291cmNlKHZhbHVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0c291cmNlcy5zZXQoa2V5LCBzKTtcblx0XHRcdHJldHVybiBzO1xuXHRcdH07XG5cblx0XHQvLyBSZXBsaWNhdGUgY29hcnNlLWdyYWluZWQgcHJvcHMgdGhyb3VnaCBhIHByb3h5IHRoYXQgaGFzIGEgdmVyc2lvbiBzb3VyY2UgZm9yXG5cdFx0Ly8gZWFjaCBwcm9wZXJ0eSwgd2hpY2ggaXMgaW5jcmVtZW50ZWQgb24gdXBkYXRlcyB0byB0aGUgcHJvcGVydHkgaXRzZWxmLiBEbyBub3Rcblx0XHQvLyB1c2Ugb3VyICRzdGF0ZSBwcm94eSBiZWNhdXNlIHRoYXQgb25lIGhhcyBmaW5lLWdyYWluZWQgcmVhY3Rpdml0eS5cblx0XHRjb25zdCBwcm9wcyA9IG5ldyBQcm94eShcblx0XHRcdHsgLi4uKG9wdGlvbnMucHJvcHMgfHwge30pLCAkJGV2ZW50czoge30gfSxcblx0XHRcdHtcblx0XHRcdFx0Z2V0KHRhcmdldCwgcHJvcCkge1xuXHRcdFx0XHRcdHJldHVybiBnZXQoc291cmNlcy5nZXQocHJvcCkgPz8gYWRkX3NvdXJjZShwcm9wLCBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApKSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGhhcyh0YXJnZXQsIHByb3ApIHtcblx0XHRcdFx0XHQvLyBOZWNlc3NhcnkgdG8gbm90IHRocm93IFwiaW52YWxpZCBiaW5kaW5nXCIgdmFsaWRhdGlvbiBlcnJvcnMgb24gdGhlIGNvbXBvbmVudCBzaWRlXG5cdFx0XHRcdFx0aWYgKHByb3AgPT09IExFR0FDWV9QUk9QUykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRnZXQoc291cmNlcy5nZXQocHJvcCkgPz8gYWRkX3NvdXJjZShwcm9wLCBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApKSk7XG5cdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG5cdFx0XHRcdFx0c2V0KHNvdXJjZXMuZ2V0KHByb3ApID8/IGFkZF9zb3VyY2UocHJvcCwgdmFsdWUpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdHRoaXMuI2luc3RhbmNlID0gKG9wdGlvbnMuaHlkcmF0ZSA/IGh5ZHJhdGUgOiBtb3VudCkob3B0aW9ucy5jb21wb25lbnQsIHtcblx0XHRcdHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG5cdFx0XHRhbmNob3I6IG9wdGlvbnMuYW5jaG9yLFxuXHRcdFx0cHJvcHMsXG5cdFx0XHRjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG5cdFx0XHRpbnRybzogb3B0aW9ucy5pbnRybyA/PyBmYWxzZSxcblx0XHRcdHJlY292ZXI6IG9wdGlvbnMucmVjb3ZlclxuXHRcdH0pO1xuXG5cdFx0Ly8gV2UgZG9uJ3QgZmx1c2hTeW5jIGZvciBjdXN0b20gZWxlbWVudCB3cmFwcGVycyBvciBpZiB0aGUgdXNlciBkb2Vzbid0IHdhbnQgaXQsXG5cdFx0Ly8gb3IgaWYgd2UncmUgaW4gYXN5bmMgbW9kZSBzaW5jZSBgZmx1c2hTeW5jKClgIHdpbGwgZmFpbFxuXHRcdGlmICghYXN5bmNfbW9kZV9mbGFnICYmICghb3B0aW9ucz8ucHJvcHM/LiQkaG9zdCB8fCBvcHRpb25zLnN5bmMgPT09IGZhbHNlKSkge1xuXHRcdFx0Zmx1c2hTeW5jKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4jZXZlbnRzID0gcHJvcHMuJCRldmVudHM7XG5cblx0XHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLiNpbnN0YW5jZSkpIHtcblx0XHRcdGlmIChrZXkgPT09ICckc2V0JyB8fCBrZXkgPT09ICckZGVzdHJveScgfHwga2V5ID09PSAnJG9uJykgY29udGludWU7XG5cdFx0XHRkZWZpbmVfcHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGdldCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy4jaW5zdGFuY2Vba2V5XTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqIEBwYXJhbSB7YW55fSB2YWx1ZSAqL1xuXHRcdFx0XHRzZXQodmFsdWUpIHtcblx0XHRcdFx0XHR0aGlzLiNpbnN0YW5jZVtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuI2luc3RhbmNlLiRzZXQgPSAvKiogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBuZXh0ICovIChuZXh0KSA9PiB7XG5cdFx0XHRPYmplY3QuYXNzaWduKHByb3BzLCBuZXh0KTtcblx0XHR9O1xuXG5cdFx0dGhpcy4jaW5zdGFuY2UuJGRlc3Ryb3kgPSAoKSA9PiB7XG5cdFx0XHR1bm1vdW50KHRoaXMuI2luc3RhbmNlKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gcHJvcHMgKi9cblx0JHNldChwcm9wcykge1xuXHRcdHRoaXMuI2luc3RhbmNlLiRzZXQocHJvcHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gYW55fSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7YW55fVxuXHQgKi9cblx0JG9uKGV2ZW50LCBjYWxsYmFjaykge1xuXHRcdHRoaXMuI2V2ZW50c1tldmVudF0gPSB0aGlzLiNldmVudHNbZXZlbnRdIHx8IFtdO1xuXG5cdFx0LyoqIEBwYXJhbSB7YW55W119IGFyZ3MgKi9cblx0XHRjb25zdCBjYiA9ICguLi5hcmdzKSA9PiBjYWxsYmFjay5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuXHRcdHRoaXMuI2V2ZW50c1tldmVudF0ucHVzaChjYik7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuI2V2ZW50c1tldmVudF0gPSB0aGlzLiNldmVudHNbZXZlbnRdLmZpbHRlcigvKiogQHBhcmFtIHthbnl9IGZuICovIChmbikgPT4gZm4gIT09IGNiKTtcblx0XHR9O1xuXHR9XG5cblx0JGRlc3Ryb3koKSB7XG5cdFx0dGhpcy4jaW5zdGFuY2UuJGRlc3Ryb3koKTtcblx0fVxufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uY2UgaW1tZWRpYXRlbHkgb24gdGhlIHNlcnZlciwgYW5kIHdvcmtzIGxpa2UgYCRlZmZlY3QucHJlYCBvbiB0aGUgY2xpZW50LlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGlzIG9ubHkgYXMgYSB0ZW1wb3Jhcnkgc29sdXRpb24gdG8gbWlncmF0ZSB5b3VyIGNvbXBvbmVudCBjb2RlIHRvIFN2ZWx0ZSA1LlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRmbigpO1xuXHRcdHZhciBlZmZlY3QgPSAvKiogQHR5cGUge2ltcG9ydCgnI2NsaWVudCcpLkVmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXHRcdC8vIElmIHRoZSBlZmZlY3QgaXMgaW1tZWRpYXRlbHkgbWFkZSBkaXJ0eSBhZ2FpbiwgbWFyayBpdCBhcyBtYXliZSBkaXJ0eSB0byBlbXVsYXRlIGxlZ2FjeSBiZWhhdmlvdXJcblx0XHRpZiAoKGVmZmVjdC5mICYgRElSVFkpICE9PSAwKSB7XG5cdFx0XHRsZXQgZmlsZW5hbWUgPSBcImEgZmlsZSAod2UgY2FuJ3Qga25vdyB3aGljaCBvbmUpXCI7XG5cdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0ZmlsZW5hbWUgPSBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24/LltGSUxFTkFNRV0gPz8gZmlsZW5hbWU7XG5cdFx0XHR9XG5cdFx0XHR3LmxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2soZmlsZW5hbWUpO1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBNQVlCRV9ESVJUWSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBtaW1pYyB0aGUgbXVsdGlwbGUgbGlzdGVuZXJzIGF2YWlsYWJsZSBpbiBzdmVsdGUgNFxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcltdfSBoYW5kbGVyc1xuICogQHJldHVybnMge0V2ZW50TGlzdGVuZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVycyguLi5oYW5kbGVycykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Y29uc3QgeyBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gfSA9IGV2ZW50O1xuXHRcdGxldCBzdG9wcGVkID0gZmFsc2U7XG5cblx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG5cdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbi5jYWxsKGV2ZW50KTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgZXJyb3JzID0gW107XG5cblx0XHRmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgYHRoaXNgIGlzIG5vdCB0eXBlZFxuXHRcdFx0XHRoYW5kbGVyPy5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3JzLnB1c2goZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdG9wcGVkKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobGV0IGVycm9yIG9mIGVycm9ycykge1xuXHRcdFx0cXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBjcmVhdGUgYSBgYnViYmxlYCBmdW5jdGlvbiB0aGF0IG1pbWljIHRoZSBiZWhhdmlvciBvZiBgb246Y2xpY2tgIHdpdGhvdXQgaGFuZGxlciBhdmFpbGFibGUgaW4gc3ZlbHRlIDQuXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhpcyBvbmx5IGFzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uIHRvIG1pZ3JhdGUgeW91ciBhdXRvbWF0aWNhbGx5IGRlbGVnYXRlZCBldmVudHMgaW4gU3ZlbHRlIDUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCdWJibGVyKCkge1xuXHRjb25zdCBhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0aWYgKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdjcmVhdGVCdWJibGVyJyk7XG5cdH1cblxuXHRyZXR1cm4gKC8qKkB0eXBlIHtzdHJpbmd9Ki8gdHlwZSkgPT4gKC8qKkB0eXBlIHtFdmVudH0qLyBldmVudCkgPT4ge1xuXHRcdGNvbnN0IGV2ZW50cyA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb24gfCBGdW5jdGlvbltdPn0gKi8gKFxuXHRcdFx0YWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LnMuJCRldmVudHNcblx0XHQpPy5bLyoqIEB0eXBlIHthbnl9ICovICh0eXBlKV07XG5cblx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRjb25zdCBjYWxsYmFja3MgPSBpc19hcnJheShldmVudHMpID8gZXZlbnRzLnNsaWNlKCkgOiBbZXZlbnRzXTtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGZuLmNhbGwoYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LngsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5cbmV4cG9ydCB7XG5cdG9uY2UsXG5cdHByZXZlbnREZWZhdWx0LFxuXHRzZWxmLFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sXG5cdHN0b3BQcm9wYWdhdGlvbixcblx0dHJ1c3RlZCxcblx0cGFzc2l2ZSxcblx0bm9ucGFzc2l2ZVxufSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvZG9tL2xlZ2FjeS9ldmVudC1tb2RpZmllcnMuanMnO1xuIiwgImltcG9ydCB7IGNyZWF0ZUNsYXNzQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vbGVnYWN5L2xlZ2FjeS1jbGllbnQuanMnO1xuaW1wb3J0IHsgZWZmZWN0X3Jvb3QsIHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgYXBwZW5kIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBnZXRfZGVzY3JpcHRvciwgb2JqZWN0X2tleXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJ1dGVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWZsZWN0XVxuICogQHByb3BlcnR5IHsnU3RyaW5nJ3wnQm9vbGVhbid8J051bWJlcid8J0FycmF5J3wnT2JqZWN0J30gW3R5cGVdXG4gKi9cblxuLyoqIEB0eXBlIHthbnl9ICovXG5sZXQgU3ZlbHRlRWxlbWVudDtcblxuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cdFx0LyoqIFRoZSBTdmVsdGUgY29tcG9uZW50IGNvbnN0cnVjdG9yICovXG5cdFx0JCRjdG9yO1xuXHRcdC8qKiBTbG90cyAqL1xuXHRcdCQkcztcblx0XHQvKiogQHR5cGUge2FueX0gVGhlIFN2ZWx0ZSBjb21wb25lbnQgaW5zdGFuY2UgKi9cblx0XHQkJGM7XG5cdFx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZSBjdXN0b20gZWxlbWVudCBpcyBjb25uZWN0ZWQgKi9cblx0XHQkJGNuID0gZmFsc2U7XG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBDb21wb25lbnQgcHJvcHMgZGF0YSAqL1xuXHRcdCQkZCA9IHt9O1xuXHRcdC8qKiBgdHJ1ZWAgaWYgY3VycmVudGx5IGluIHRoZSBwcm9jZXNzIG9mIHJlZmxlY3RpbmcgY29tcG9uZW50IHByb3BzIGJhY2sgdG8gYXR0cmlidXRlcyAqL1xuXHRcdCQkciA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gUHJvcHMgZGVmaW5pdGlvbiAobmFtZSwgcmVmbGVjdGVkLCB0eXBlIGV0YykgKi9cblx0XHQkJHBfZCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdFtdPn0gRXZlbnQgbGlzdGVuZXJzICovXG5cdFx0JCRsID0ge307XG5cdFx0LyoqIEB0eXBlIHtNYXA8RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCwgRnVuY3Rpb24+fSBFdmVudCBsaXN0ZW5lciB1bnN1YnNjcmliZSBmdW5jdGlvbnMgKi9cblx0XHQkJGxfdSA9IG5ldyBNYXAoKTtcblx0XHQvKiogQHR5cGUge2FueX0gVGhlIG1hbmFnZWQgcmVuZGVyIGVmZmVjdCBmb3IgcmVmbGVjdGluZyBhdHRyaWJ1dGVzICovXG5cdFx0JCRtZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7Kn0gJCRjb21wb25lbnRDdG9yXG5cdFx0ICogQHBhcmFtIHsqfSAkJHNsb3RzXG5cdFx0ICogQHBhcmFtIHsqfSB1c2Vfc2hhZG93X2RvbVxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yKCQkY29tcG9uZW50Q3RvciwgJCRzbG90cywgdXNlX3NoYWRvd19kb20pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLiQkY3RvciA9ICQkY29tcG9uZW50Q3Rvcjtcblx0XHRcdHRoaXMuJCRzID0gJCRzbG90cztcblx0XHRcdGlmICh1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHRcdCAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdH0gbGlzdGVuZXJcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG5cdFx0ICovXG5cdFx0YWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0Ly8gV2UgY2FuJ3QgZGV0ZXJtaW5lIHVwZnJvbnQgaWYgdGhlIGV2ZW50IGlzIGEgY3VzdG9tIGV2ZW50IG9yIG5vdCwgc28gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gbGlzdGVuIHRvIGJvdGguIElmIHNvbWVvbmUgdXNlcyBhIGN1c3RvbSBldmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgYSByZWd1bGFyXG5cdFx0XHQvLyBicm93c2VyIGV2ZW50LCB0aGlzIGZpcmVzIHR3aWNlIC0gd2UgY2FuJ3QgYXZvaWQgdGhhdC5cblx0XHRcdHRoaXMuJCRsW3R5cGVdID0gdGhpcy4kJGxbdHlwZV0gfHwgW107XG5cdFx0XHR0aGlzLiQkbFt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdGlmICh0aGlzLiQkYykge1xuXHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRjLiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHR9XG5cdFx0XHRzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHRcdCAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdH0gbGlzdGVuZXJcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG5cdFx0ICovXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0c3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkbF91LmdldChsaXN0ZW5lcik7XG5cdFx0XHRcdGlmICh1bnN1Yikge1xuXHRcdFx0XHRcdHVuc3ViKCk7XG5cdFx0XHRcdFx0dGhpcy4kJGxfdS5kZWxldGUobGlzdGVuZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSB0cnVlO1xuXHRcdFx0aWYgKCF0aGlzLiQkYykge1xuXHRcdFx0XHQvLyBXZSB3YWl0IG9uZSB0aWNrIHRvIGxldCBwb3NzaWJsZSBjaGlsZCBzbG90IGVsZW1lbnRzIGJlIGNyZWF0ZWQvbW91bnRlZFxuXHRcdFx0XHRhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24gfHwgdGhpcy4kJGMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5cdFx0XHRcdGZ1bmN0aW9uIGNyZWF0ZV9zbG90KG5hbWUpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGFuY2hvclxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdHJldHVybiAoYW5jaG9yKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBzbG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2xvdCcpO1xuXHRcdFx0XHRcdFx0aWYgKG5hbWUgIT09ICdkZWZhdWx0Jykgc2xvdC5uYW1lID0gbmFtZTtcblxuXHRcdFx0XHRcdFx0YXBwZW5kKGFuY2hvciwgc2xvdCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG5cdFx0XHRcdGNvbnN0ICQkc2xvdHMgPSB7fTtcblx0XHRcdFx0Y29uc3QgZXhpc3Rpbmdfc2xvdHMgPSBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKHRoaXMpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy4kJHMpIHtcblx0XHRcdFx0XHRpZiAobmFtZSBpbiBleGlzdGluZ19zbG90cykge1xuXHRcdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdkZWZhdWx0JyAmJiAhdGhpcy4kJGQuY2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy4kJGQuY2hpbGRyZW4gPSBjcmVhdGVfc2xvdChuYW1lKTtcblx0XHRcdFx0XHRcdFx0JCRzbG90cy5kZWZhdWx0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdCQkc2xvdHNbbmFtZV0gPSBjcmVhdGVfc2xvdChuYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgdGhpcy5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcy4kJGRhdGEgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMuYXR0cmlidXRlc1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSB0aGlzLiQkZ19wKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0XHRpZiAoIShuYW1lIGluIHRoaXMuJCRkKSkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRbbmFtZV0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUobmFtZSwgYXR0cmlidXRlLnZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFBvcnQgb3ZlciBwcm9wcyB0aGF0IHdlcmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgYmVmb3JlIGNlIHdhcyBpbml0aWFsaXplZFxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkcF9kKSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRcdGlmICghKGtleSBpbiB0aGlzLiQkZCkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0gPSB0aGlzW2tleV07IC8vIGRvbid0IHRyYW5zZm9ybSwgdGhlc2Ugd2VyZSBzZXQgdGhyb3VnaCBKYXZhU2NyaXB0XG5cdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpc1trZXldOyAvLyByZW1vdmUgdGhlIHByb3BlcnR5IHRoYXQgc2hhZG93cyB0aGUgZ2V0dGVyL3NldHRlclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkYyA9IGNyZWF0ZUNsYXNzQ29tcG9uZW50KHtcblx0XHRcdFx0XHRjb21wb25lbnQ6IHRoaXMuJCRjdG9yLFxuXHRcdFx0XHRcdHRhcmdldDogdGhpcy5zaGFkb3dSb290IHx8IHRoaXMsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdC4uLnRoaXMuJCRkLFxuXHRcdFx0XHRcdFx0JCRzbG90cyxcblx0XHRcdFx0XHRcdCQkaG9zdDogdGhpc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gUmVmbGVjdCBjb21wb25lbnQgcHJvcHMgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHR0aGlzLiQkbWUgPSBlZmZlY3Rfcm9vdCgoKSA9PiB7XG5cdFx0XHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkciA9IHRydWU7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBvYmplY3Rfa2V5cyh0aGlzLiQkYykpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLiQkcF9kW2tleV0/LnJlZmxlY3QpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldID0gdGhpcy4kJGNba2V5XTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlX3ZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKFxuXHRcdFx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuJCRwX2QsXG5cdFx0XHRcdFx0XHRcdFx0J3RvQXR0cmlidXRlJ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0cmlidXRlX3ZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlIHx8IGtleSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUodGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSB8fCBrZXksIGF0dHJpYnV0ZV92YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuJCRyID0gZmFsc2U7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLiQkbCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4kJGxbdHlwZV0pIHtcblx0XHRcdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRsID0ge307XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0aGlzIHdoZW4gd29ya2luZyB3aXRoaW4gU3ZlbHRlIGNvZGUsIGJ1dCBmb3IgY29tcGF0aWJpbGl0eSBvZiBwZW9wbGUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIFN2ZWx0ZVxuXHRcdC8vIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgdGhyb3VnaCBzZXRBdHRyaWJ1dGUgZXRjLCB0aGlzIGlzIGhlbHBmdWxcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IF9vbGRWYWx1ZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuZXdWYWx1ZVxuXHRcdCAqL1xuXHRcdGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy4kJHIpIHJldHVybjtcblx0XHRcdGF0dHIgPSB0aGlzLiQkZ19wKGF0dHIpO1xuXHRcdFx0dGhpcy4kJGRbYXR0cl0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoYXR0ciwgbmV3VmFsdWUsIHRoaXMuJCRwX2QsICd0b1Byb3AnKTtcblx0XHRcdHRoaXMuJCRjPy4kc2V0KHsgW2F0dHJdOiB0aGlzLiQkZFthdHRyXSB9KTtcblx0XHR9XG5cblx0XHRkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuJCRjbiA9IGZhbHNlO1xuXHRcdFx0Ly8gSW4gYSBtaWNyb3Rhc2ssIGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhIG1vdmUgd2l0aGluIHRoZSBET01cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjbiAmJiB0aGlzLiQkYykge1xuXHRcdFx0XHRcdHRoaXMuJCRjLiRkZXN0cm95KCk7XG5cdFx0XHRcdFx0dGhpcy4kJG1lKCk7XG5cdFx0XHRcdFx0dGhpcy4kJGMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVfbmFtZVxuXHRcdCAqL1xuXHRcdCQkZ19wKGF0dHJpYnV0ZV9uYW1lKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRvYmplY3Rfa2V5cyh0aGlzLiQkcF9kKS5maW5kKFxuXHRcdFx0XHRcdChrZXkpID0+XG5cdFx0XHRcdFx0XHR0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlID09PSBhdHRyaWJ1dGVfbmFtZSB8fFxuXHRcdFx0XHRcdFx0KCF0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBhdHRyaWJ1dGVfbmFtZSlcblx0XHRcdFx0KSB8fCBhdHRyaWJ1dGVfbmFtZVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uXG4gKiBAcGFyYW0geyd0b0F0dHJpYnV0ZScgfCAndG9Qcm9wJ30gW3RyYW5zZm9ybV1cbiAqL1xuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uLCB0cmFuc2Zvcm0pIHtcblx0Y29uc3QgdHlwZSA9IHByb3BzX2RlZmluaXRpb25bcHJvcF0/LnR5cGU7XG5cdHZhbHVlID0gdHlwZSA9PT0gJ0Jvb2xlYW4nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nID8gdmFsdWUgIT0gbnVsbCA6IHZhbHVlO1xuXHRpZiAoIXRyYW5zZm9ybSB8fCAhcHJvcHNfZGVmaW5pdGlvbltwcm9wXSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSBlbHNlIGlmICh0cmFuc2Zvcm0gPT09ICd0b0F0dHJpYnV0ZScpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnJyA6IG51bGw7XG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlOyAvLyBjb252ZXJzaW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZVxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICE9IG51bGwgPyArdmFsdWUgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHRydWU+fSAqL1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0ZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcblx0XHRyZXN1bHRbLyoqIEB0eXBlIHtFbGVtZW50fSBub2RlICovIChub2RlKS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBUdXJuIGEgU3ZlbHRlIGNvbXBvbmVudCBpbnRvIGEgY3VzdG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2FueX0gQ29tcG9uZW50ICBBIFN2ZWx0ZSBjb21wb25lbnQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvbiAgVGhlIHByb3BzIHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHNsb3RzICBUaGUgc2xvdHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleHBvcnRzICBFeHBsaWNpdGx5IGV4cG9ydGVkIHZhbHVlcywgb3RoZXIgdGhhbiBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSB1c2Vfc2hhZG93X2RvbSAgV2hldGhlciB0byB1c2Ugc2hhZG93IERPTVxuICogQHBhcmFtIHsoY2U6IG5ldyAoKSA9PiBIVE1MRWxlbWVudCkgPT4gbmV3ICgpID0+IEhUTUxFbGVtZW50fSBbZXh0ZW5kXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9lbGVtZW50KFxuXHRDb21wb25lbnQsXG5cdHByb3BzX2RlZmluaXRpb24sXG5cdHNsb3RzLFxuXHRleHBvcnRzLFxuXHR1c2Vfc2hhZG93X2RvbSxcblx0ZXh0ZW5kXG4pIHtcblx0bGV0IENsYXNzID0gY2xhc3MgZXh0ZW5kcyBTdmVsdGVFbGVtZW50IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKENvbXBvbmVudCwgc2xvdHMsIHVzZV9zaGFkb3dfZG9tKTtcblx0XHRcdHRoaXMuJCRwX2QgPSBwcm9wc19kZWZpbml0aW9uO1xuXHRcdH1cblx0XHRzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcblx0XHRcdHJldHVybiBvYmplY3Rfa2V5cyhwcm9wc19kZWZpbml0aW9uKS5tYXAoKGtleSkgPT5cblx0XHRcdFx0KHByb3BzX2RlZmluaXRpb25ba2V5XS5hdHRyaWJ1dGUgfHwga2V5KS50b0xvd2VyQ2FzZSgpXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcblx0b2JqZWN0X2tleXMocHJvcHNfZGVmaW5pdGlvbikuZm9yRWFjaCgocHJvcCkgPT4ge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIHByb3AsIHtcblx0XHRcdGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRjICYmIHByb3AgaW4gdGhpcy4kJGMgPyB0aGlzLiQkY1twcm9wXSA6IHRoaXMuJCRkW3Byb3BdO1xuXHRcdFx0fSxcblx0XHRcdHNldCh2YWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbik7XG5cdFx0XHRcdHRoaXMuJCRkW3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdHZhciBjb21wb25lbnQgPSB0aGlzLiQkYztcblxuXHRcdFx0XHRpZiAoY29tcG9uZW50KSB7XG5cdFx0XHRcdFx0Ly8gLy8gSWYgdGhlIGluc3RhbmNlIGhhcyBhbiBhY2Nlc3NvciwgdXNlIHRoYXQgaW5zdGVhZFxuXHRcdFx0XHRcdHZhciBzZXR0ZXIgPSBnZXRfZGVzY3JpcHRvcihjb21wb25lbnQsIHByb3ApPy5nZXQ7XG5cblx0XHRcdFx0XHRpZiAoc2V0dGVyKSB7XG5cdFx0XHRcdFx0XHRjb21wb25lbnRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50LiRzZXQoeyBbcHJvcF06IHZhbHVlIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0ZXhwb3J0cy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkYz8uW3Byb3BlcnR5XTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGlmIChleHRlbmQpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIC0gYXNzaWduaW5nIGhlcmUgaXMgZmluZVxuXHRcdENsYXNzID0gZXh0ZW5kKENsYXNzKTtcblx0fVxuXHRDb21wb25lbnQuZWxlbWVudCA9IC8qKiBAdHlwZSB7YW55fSAqLyBDbGFzcztcblx0cmV0dXJuIENsYXNzO1xufVxuIiwgImltcG9ydCB7IFNUQVRFX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHNuYXBzaG90IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Nsb25lLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSAgey4uLmFueX0gb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gbG9nX2lmX2NvbnRhaW5zX3N0YXRlKG1ldGhvZCwgLi4ub2JqZWN0cykge1xuXHR1bnRyYWNrKCgpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IGhhc19zdGF0ZSA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgdHJhbnNmb3JtZWQgPSBbXTtcblxuXHRcdFx0Zm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuXHRcdFx0XHRpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIFNUQVRFX1NZTUJPTCBpbiBvYmopIHtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZC5wdXNoKHNuYXBzaG90KG9iaiwgdHJ1ZSkpO1xuXHRcdFx0XHRcdGhhc19zdGF0ZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtZWQucHVzaChvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXNfc3RhdGUpIHtcblx0XHRcdFx0dy5jb25zb2xlX2xvZ19zdGF0ZShtZXRob2QpO1xuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdGNvbnNvbGUubG9nKCclY1tzbmFwc2hvdF0nLCAnY29sb3I6IGdyZXknLCAuLi50cmFuc2Zvcm1lZCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCB7fVxuXHR9KTtcblxuXHRyZXR1cm4gb2JqZWN0cztcbn1cbiIsICJleHBvcnQgeyBjcmVhdGVBdHRhY2htZW50S2V5IGFzIGF0dGFjaG1lbnQgfSBmcm9tICcuLi8uLi9hdHRhY2htZW50cy9pbmRleC5qcyc7XG5leHBvcnQgeyBGSUxFTkFNRSwgSE1SLCBOQU1FU1BBQ0VfU1ZHIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmV4cG9ydCB7IHB1c2gsIHBvcCwgYWRkX3N2ZWx0ZV9tZXRhIH0gZnJvbSAnLi9jb250ZXh0LmpzJztcbmV4cG9ydCB7IGFzc2lnbiwgYXNzaWduX2FuZCwgYXNzaWduX29yLCBhc3NpZ25fbnVsbGlzaCB9IGZyb20gJy4vZGV2L2Fzc2lnbi5qcyc7XG5leHBvcnQgeyBjbGVhbnVwX3N0eWxlcyB9IGZyb20gJy4vZGV2L2Nzcy5qcyc7XG5leHBvcnQgeyBhZGRfbG9jYXRpb25zIH0gZnJvbSAnLi9kZXYvZWxlbWVudHMuanMnO1xuZXhwb3J0IHsgaG1yIH0gZnJvbSAnLi9kZXYvaG1yLmpzJztcbmV4cG9ydCB7IGNyZWF0ZV9vd25lcnNoaXBfdmFsaWRhdG9yIH0gZnJvbSAnLi9kZXYvb3duZXJzaGlwLmpzJztcbmV4cG9ydCB7IGNoZWNrX3RhcmdldCwgbGVnYWN5X2FwaSB9IGZyb20gJy4vZGV2L2xlZ2FjeS5qcyc7XG5leHBvcnQgeyB0cmFjZSwgdGFnLCB0YWdfcHJveHkgfSBmcm9tICcuL2Rldi90cmFjaW5nLmpzJztcbmV4cG9ydCB7IGluc3BlY3QgfSBmcm9tICcuL2Rldi9pbnNwZWN0LmpzJztcbmV4cG9ydCB7IGFzeW5jIH0gZnJvbSAnLi9kb20vYmxvY2tzL2FzeW5jLmpzJztcbmV4cG9ydCB7IHZhbGlkYXRlX3NuaXBwZXRfYXJncyB9IGZyb20gJy4vZGV2L3ZhbGlkYXRpb24uanMnO1xuZXhwb3J0IHsgYXdhaXRfYmxvY2sgYXMgYXdhaXQgfSBmcm9tICcuL2RvbS9ibG9ja3MvYXdhaXQuanMnO1xuZXhwb3J0IHsgaWZfYmxvY2sgYXMgaWYgfSBmcm9tICcuL2RvbS9ibG9ja3MvaWYuanMnO1xuZXhwb3J0IHsga2V5IH0gZnJvbSAnLi9kb20vYmxvY2tzL2tleS5qcyc7XG5leHBvcnQgeyBjc3NfcHJvcHMgfSBmcm9tICcuL2RvbS9ibG9ja3MvY3NzLXByb3BzLmpzJztcbmV4cG9ydCB7IGluZGV4LCBlYWNoIH0gZnJvbSAnLi9kb20vYmxvY2tzL2VhY2guanMnO1xuZXhwb3J0IHsgaHRtbCB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9odG1sLmpzJztcbmV4cG9ydCB7IHNhbml0aXplX3Nsb3RzLCBzbG90IH0gZnJvbSAnLi9kb20vYmxvY2tzL3Nsb3QuanMnO1xuZXhwb3J0IHsgc25pcHBldCwgd3JhcF9zbmlwcGV0IH0gZnJvbSAnLi9kb20vYmxvY2tzL3NuaXBwZXQuanMnO1xuZXhwb3J0IHsgY29tcG9uZW50IH0gZnJvbSAnLi9kb20vYmxvY2tzL3N2ZWx0ZS1jb21wb25lbnQuanMnO1xuZXhwb3J0IHsgZWxlbWVudCB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9zdmVsdGUtZWxlbWVudC5qcyc7XG5leHBvcnQgeyBoZWFkIH0gZnJvbSAnLi9kb20vYmxvY2tzL3N2ZWx0ZS1oZWFkLmpzJztcbmV4cG9ydCB7IGFwcGVuZF9zdHlsZXMgfSBmcm9tICcuL2RvbS9jc3MuanMnO1xuZXhwb3J0IHsgYWN0aW9uIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvYWN0aW9ucy5qcyc7XG5leHBvcnQgeyBhdHRhY2ggfSBmcm9tICcuL2RvbS9lbGVtZW50cy9hdHRhY2htZW50cy5qcyc7XG5leHBvcnQge1xuXHRyZW1vdmVfaW5wdXRfZGVmYXVsdHMsXG5cdHNldF9hdHRyaWJ1dGUsXG5cdGF0dHJpYnV0ZV9lZmZlY3QsXG5cdHNldF9jdXN0b21fZWxlbWVudF9kYXRhLFxuXHRzZXRfeGxpbmtfYXR0cmlidXRlLFxuXHRzZXRfdmFsdWUsXG5cdHNldF9jaGVja2VkLFxuXHRzZXRfc2VsZWN0ZWQsXG5cdHNldF9kZWZhdWx0X2NoZWNrZWQsXG5cdHNldF9kZWZhdWx0X3ZhbHVlLFxuXHRDTEFTUyxcblx0U1RZTEVcbn0gZnJvbSAnLi9kb20vZWxlbWVudHMvYXR0cmlidXRlcy5qcyc7XG5leHBvcnQgeyBzZXRfY2xhc3MgfSBmcm9tICcuL2RvbS9lbGVtZW50cy9jbGFzcy5qcyc7XG5leHBvcnQgeyBhcHBseSwgZXZlbnQsIGRlbGVnYXRlLCByZXBsYXlfZXZlbnRzIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvZXZlbnRzLmpzJztcbmV4cG9ydCB7IGF1dG9mb2N1cywgcmVtb3ZlX3RleHRhcmVhX2NoaWxkIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvbWlzYy5qcyc7XG5leHBvcnQgeyBzZXRfc3R5bGUgfSBmcm9tICcuL2RvbS9lbGVtZW50cy9zdHlsZS5qcyc7XG5leHBvcnQgeyBhbmltYXRpb24sIHRyYW5zaXRpb24gfSBmcm9tICcuL2RvbS9lbGVtZW50cy90cmFuc2l0aW9ucy5qcyc7XG5leHBvcnQgeyBiaW5kX2FjdGl2ZV9lbGVtZW50IH0gZnJvbSAnLi9kb20vZWxlbWVudHMvYmluZGluZ3MvZG9jdW1lbnQuanMnO1xuZXhwb3J0IHsgYmluZF9jaGVja2VkLCBiaW5kX2ZpbGVzLCBiaW5kX2dyb3VwLCBiaW5kX3ZhbHVlIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvYmluZGluZ3MvaW5wdXQuanMnO1xuZXhwb3J0IHtcblx0YmluZF9idWZmZXJlZCxcblx0YmluZF9jdXJyZW50X3RpbWUsXG5cdGJpbmRfZW5kZWQsXG5cdGJpbmRfbXV0ZWQsXG5cdGJpbmRfcGF1c2VkLFxuXHRiaW5kX3BsYXliYWNrX3JhdGUsXG5cdGJpbmRfcGxheWVkLFxuXHRiaW5kX3JlYWR5X3N0YXRlLFxuXHRiaW5kX3NlZWthYmxlLFxuXHRiaW5kX3NlZWtpbmcsXG5cdGJpbmRfdm9sdW1lXG59IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL21lZGlhLmpzJztcbmV4cG9ydCB7IGJpbmRfb25saW5lIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvYmluZGluZ3MvbmF2aWdhdG9yLmpzJztcbmV4cG9ydCB7IGJpbmRfcHJvcCB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3Byb3BzLmpzJztcbmV4cG9ydCB7IGJpbmRfc2VsZWN0X3ZhbHVlLCBpbml0X3NlbGVjdCwgc2VsZWN0X29wdGlvbiB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NlbGVjdC5qcyc7XG5leHBvcnQgeyBiaW5kX2VsZW1lbnRfc2l6ZSwgYmluZF9yZXNpemVfb2JzZXJ2ZXIgfSBmcm9tICcuL2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaXplLmpzJztcbmV4cG9ydCB7IGJpbmRfdGhpcyB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3RoaXMuanMnO1xuZXhwb3J0IHtcblx0YmluZF9jb250ZW50X2VkaXRhYmxlLFxuXHRiaW5kX3Byb3BlcnR5LFxuXHRiaW5kX2ZvY3VzZWRcbn0gZnJvbSAnLi9kb20vZWxlbWVudHMvYmluZGluZ3MvdW5pdmVyc2FsLmpzJztcbmV4cG9ydCB7IGJpbmRfd2luZG93X3Njcm9sbCwgYmluZF93aW5kb3dfc2l6ZSB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3dpbmRvdy5qcyc7XG5leHBvcnQgeyBoeWRyYXRlX3RlbXBsYXRlLCBuZXh0LCByZXNldCB9IGZyb20gJy4vZG9tL2h5ZHJhdGlvbi5qcyc7XG5leHBvcnQge1xuXHRvbmNlLFxuXHRwcmV2ZW50RGVmYXVsdCxcblx0c2VsZixcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLFxuXHRzdG9wUHJvcGFnYXRpb24sXG5cdHRydXN0ZWRcbn0gZnJvbSAnLi9kb20vbGVnYWN5L2V2ZW50LW1vZGlmaWVycy5qcyc7XG5leHBvcnQgeyBpbml0IH0gZnJvbSAnLi9kb20vbGVnYWN5L2xpZmVjeWNsZS5qcyc7XG5leHBvcnQge1xuXHRhZGRfbGVnYWN5X2V2ZW50X2xpc3RlbmVyLFxuXHRidWJibGVfZXZlbnQsXG5cdHJlYWN0aXZlX2ltcG9ydCxcblx0dXBkYXRlX2xlZ2FjeV9wcm9wc1xufSBmcm9tICcuL2RvbS9sZWdhY3kvbWlzYy5qcyc7XG5leHBvcnQge1xuXHRhcHBlbmQsXG5cdGNvbW1lbnQsXG5cdGZyb21faHRtbCxcblx0ZnJvbV9tYXRobWwsXG5cdGZyb21fc3ZnLFxuXHRmcm9tX3RyZWUsXG5cdHRleHQsXG5cdHByb3BzX2lkLFxuXHR3aXRoX3NjcmlwdFxufSBmcm9tICcuL2RvbS90ZW1wbGF0ZS5qcyc7XG5leHBvcnQge1xuXHRhc3luY19ib2R5LFxuXHRmb3JfYXdhaXRfdHJhY2tfcmVhY3Rpdml0eV9sb3NzLFxuXHRydW4sXG5cdHNhdmUsXG5cdHRyYWNrX3JlYWN0aXZpdHlfbG9zcyxcblx0cnVuX2FmdGVyX2Jsb2NrZXJzXG59IGZyb20gJy4vcmVhY3Rpdml0eS9hc3luYy5qcyc7XG5leHBvcnQgeyBlYWdlciwgZmx1c2hTeW5jIGFzIGZsdXNoIH0gZnJvbSAnLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcbmV4cG9ydCB7XG5cdGFzeW5jX2Rlcml2ZWQsXG5cdHVzZXJfZGVyaXZlZCBhcyBkZXJpdmVkLFxuXHRkZXJpdmVkX3NhZmVfZXF1YWxcbn0gZnJvbSAnLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcbmV4cG9ydCB7XG5cdGFib3J0ZWQsXG5cdGVmZmVjdF90cmFja2luZyxcblx0ZWZmZWN0X3Jvb3QsXG5cdGxlZ2FjeV9wcmVfZWZmZWN0LFxuXHRsZWdhY3lfcHJlX2VmZmVjdF9yZXNldCxcblx0cmVuZGVyX2VmZmVjdCxcblx0dGVtcGxhdGVfZWZmZWN0LFxuXHRkZWZlcnJlZF90ZW1wbGF0ZV9lZmZlY3QsXG5cdGVmZmVjdCxcblx0dXNlcl9lZmZlY3QsXG5cdHVzZXJfcHJlX2VmZmVjdFxufSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5leHBvcnQgeyBtdXRhYmxlX3NvdXJjZSwgbXV0YXRlLCBzZXQsIHN0YXRlLCB1cGRhdGUsIHVwZGF0ZV9wcmUgfSBmcm9tICcuL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5leHBvcnQge1xuXHRwcm9wLFxuXHRyZXN0X3Byb3BzLFxuXHRsZWdhY3lfcmVzdF9wcm9wcyxcblx0c3ByZWFkX3Byb3BzLFxuXHR1cGRhdGVfcHJlX3Byb3AsXG5cdHVwZGF0ZV9wcm9wXG59IGZyb20gJy4vcmVhY3Rpdml0eS9wcm9wcy5qcyc7XG5leHBvcnQge1xuXHRpbnZhbGlkYXRlX3N0b3JlLFxuXHRzdG9yZV9tdXRhdGUsXG5cdHNldHVwX3N0b3Jlcyxcblx0c3RvcmVfZ2V0LFxuXHRzdG9yZV9zZXQsXG5cdHN0b3JlX3Vuc3ViLFxuXHR1cGRhdGVfcHJlX3N0b3JlLFxuXHR1cGRhdGVfc3RvcmUsXG5cdG1hcmtfc3RvcmVfYmluZGluZ1xufSBmcm9tICcuL3JlYWN0aXZpdHkvc3RvcmUuanMnO1xuZXhwb3J0IHsgYm91bmRhcnksIHBlbmRpbmcgfSBmcm9tICcuL2RvbS9ibG9ja3MvYm91bmRhcnkuanMnO1xuZXhwb3J0IHsgaW52YWxpZGF0ZV9pbm5lcl9zaWduYWxzIH0gZnJvbSAnLi9sZWdhY3kuanMnO1xuZXhwb3J0IHsgc2V0X3RleHQgfSBmcm9tICcuL3JlbmRlci5qcyc7XG5leHBvcnQge1xuXHRnZXQsXG5cdHNhZmVfZ2V0LFxuXHR0aWNrLFxuXHR1bnRyYWNrLFxuXHRleGNsdWRlX2Zyb21fb2JqZWN0LFxuXHRkZWVwX3JlYWQsXG5cdGRlZXBfcmVhZF9zdGF0ZSxcblx0YWN0aXZlX2VmZmVjdFxufSBmcm9tICcuL3J1bnRpbWUuanMnO1xuZXhwb3J0IHsgdmFsaWRhdGVfYmluZGluZywgdmFsaWRhdGVfZWFjaF9rZXlzIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyByYWYgfSBmcm9tICcuL3RpbWluZy5qcyc7XG5leHBvcnQgeyBwcm94eSB9IGZyb20gJy4vcHJveHkuanMnO1xuZXhwb3J0IHsgY3JlYXRlX2N1c3RvbV9lbGVtZW50IH0gZnJvbSAnLi9kb20vZWxlbWVudHMvY3VzdG9tLWVsZW1lbnQuanMnO1xuZXhwb3J0IHtcblx0Y2hpbGQsXG5cdGZpcnN0X2NoaWxkLFxuXHRzaWJsaW5nLFxuXHQkd2luZG93IGFzIHdpbmRvdyxcblx0JGRvY3VtZW50IGFzIGRvY3VtZW50XG59IGZyb20gJy4vZG9tL29wZXJhdGlvbnMuanMnO1xuZXhwb3J0IHsgYXR0ciwgY2xzeCB9IGZyb20gJy4uL3NoYXJlZC9hdHRyaWJ1dGVzLmpzJztcbmV4cG9ydCB7IHNuYXBzaG90IH0gZnJvbSAnLi4vc2hhcmVkL2Nsb25lLmpzJztcbmV4cG9ydCB7IG5vb3AsIGZhbGxiYWNrLCB0b19hcnJheSB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5leHBvcnQge1xuXHRpbnZhbGlkX2RlZmF1bHRfc25pcHBldCxcblx0dmFsaWRhdGVfZHluYW1pY19lbGVtZW50X3RhZyxcblx0dmFsaWRhdGVfc3RvcmUsXG5cdHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50LFxuXHRwcmV2ZW50X3NuaXBwZXRfc3RyaW5naWZpY2F0aW9uXG59IGZyb20gJy4uL3NoYXJlZC92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBzdHJpY3RfZXF1YWxzLCBlcXVhbHMgfSBmcm9tICcuL2Rldi9lcXVhbGl0eS5qcyc7XG5leHBvcnQgeyBsb2dfaWZfY29udGFpbnNfc3RhdGUgfSBmcm9tICcuL2Rldi9jb25zb2xlLWxvZy5qcyc7XG5leHBvcnQgeyBpbnZva2VfZXJyb3JfYm91bmRhcnkgfSBmcm9tICcuL2Vycm9yLWhhbmRsaW5nLmpzJztcbiIsICJpbXBvcnQgeyBhc3luY19tb2RlX2ZsYWcgfSBmcm9tICcuLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuL2RvbS9oeWRyYXRpb24uanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0YWJsZShrZXksIGZuKSB7XG5cdGlmICghYXN5bmNfbW9kZV9mbGFnKSB7XG5cdFx0ZS5leHBlcmltZW50YWxfYXN5bmNfcmVxdWlyZWQoJ2h5ZHJhdGFibGUnKTtcblx0fVxuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRjb25zdCBzdG9yZSA9IHdpbmRvdy5fX3N2ZWx0ZT8uaDtcblxuXHRcdGlmIChzdG9yZT8uaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiAvKiogQHR5cGUge1R9ICovIChzdG9yZS5nZXQoa2V5KSk7XG5cdFx0fVxuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0ZS5oeWRyYXRhYmxlX21pc3NpbmdfYnV0X3JlcXVpcmVkKGtleSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHcuaHlkcmF0YWJsZV9taXNzaW5nX2J1dF9leHBlY3RlZChrZXkpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmbigpO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgQ29tcG9uZW50Q29udGV4dExlZ2FjeSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vaW5kZXguanMnICovXG4vKiogQGltcG9ydCB7IE5vdEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnRlcm5hbC90eXBlcy5qcycgKi9cbmltcG9ydCB7IGFjdGl2ZV9yZWFjdGlvbiwgdW50cmFjayB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyB1c2VyX2VmZmVjdCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcgfSBmcm9tICcuL2ludGVybmFsL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuaWYgKERFVikge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcblx0ICovXG5cdGZ1bmN0aW9uIHRocm93X3J1bmVfZXJyb3IocnVuZSkge1xuXHRcdGlmICghKHJ1bmUgaW4gZ2xvYmFsVGhpcykpIHtcblx0XHRcdC8vIFRPRE8gaWYgcGVvcGxlIHN0YXJ0IGFkanVzdGluZyB0aGUgXCJ0aGlzIGNhbiBjb250YWluIHJ1bmVzXCIgY29uZmlnIHRocm91Z2ggdi1wLXMgbW9yZSwgYWRqdXN0IHRoaXMgbWVzc2FnZVxuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0XHRsZXQgdmFsdWU7IC8vIGxldCdzIGhvcGUgbm9vbmUgbW9kaWZpZXMgdGhpcyBnbG9iYWwsIGJ1dCBiZWx0cyBhbmQgYnJhY2VzXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgcnVuZSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnZXR0ZXItcmV0dXJuXG5cdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZS5ydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6ICh2KSA9PiB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR0aHJvd19ydW5lX2Vycm9yKCckc3RhdGUnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGVmZmVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckZGVyaXZlZCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckaW5zcGVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckcHJvcHMnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGJpbmRhYmxlJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBbYEFib3J0U2lnbmFsYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsKSB0aGF0IGFib3J0cyB3aGVuIHRoZSBjdXJyZW50IFtkZXJpdmVkXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGRlcml2ZWQpIG9yIFtlZmZlY3RdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0KSByZS1ydW5zIG9yIGlzIGRlc3Ryb3llZC5cbiAqXG4gKiBNdXN0IGJlIGNhbGxlZCB3aGlsZSBhIGRlcml2ZWQgb3IgZWZmZWN0IGlzIHJ1bm5pbmcuXG4gKlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0PlxuICogXHRpbXBvcnQgeyBnZXRBYm9ydFNpZ25hbCB9IGZyb20gJ3N2ZWx0ZSc7XG4gKlxuICogXHRsZXQgeyBpZCB9ID0gJHByb3BzKCk7XG4gKlxuICogXHRhc3luYyBmdW5jdGlvbiBnZXREYXRhKGlkKSB7XG4gKiBcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2l0ZW1zLyR7aWR9YCwge1xuICogXHRcdFx0c2lnbmFsOiBnZXRBYm9ydFNpZ25hbCgpXG4gKiBcdFx0fSk7XG4gKlxuICogXHRcdHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gKiBcdH1cbiAqXG4gKiBcdGNvbnN0IGRhdGEgPSAkZGVyaXZlZChhd2FpdCBnZXREYXRhKGlkKSk7XG4gKiA8L3NjcmlwdD5cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWJvcnRTaWduYWwoKSB7XG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gPT09IG51bGwpIHtcblx0XHRlLmdldF9hYm9ydF9zaWduYWxfb3V0c2lkZV9yZWFjdGlvbigpO1xuXHR9XG5cblx0cmV0dXJuIChhY3RpdmVfcmVhY3Rpb24uYWMgPz89IG5ldyBBYm9ydENvbnRyb2xsZXIoKSkuc2lnbmFsO1xufVxuXG4vKipcbiAqIGBvbk1vdW50YCwgbGlrZSBbYCRlZmZlY3RgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCksIHNjaGVkdWxlcyBhIGZ1bmN0aW9uIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogVW5saWtlIGAkZWZmZWN0YCwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIG9ubHkgcnVucyBvbmNlLlxuICpcbiAqIEl0IG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUgY29tcG9uZW50J3MgaW5pdGlhbGlzYXRpb24gKGJ1dCBkb2Vzbid0IG5lZWQgdG8gbGl2ZSBfaW5zaWRlXyB0aGUgY29tcG9uZW50O1xuICogaXQgY2FuIGJlIGNhbGxlZCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSkuIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgX3N5bmNocm9ub3VzbHlfIGZyb20gYG9uTW91bnRgLFxuICogaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBgb25Nb3VudGAgZnVuY3Rpb25zIGRvIG5vdCBydW4gZHVyaW5nIFtzZXJ2ZXItc2lkZSByZW5kZXJpbmddKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUtc2VydmVyI3JlbmRlcikuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gTm90RnVuY3Rpb248VD4gfCBQcm9taXNlPE5vdEZ1bmN0aW9uPFQ+PiB8ICgoKSA9PiBhbnkpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1vdW50KGZuKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdvbk1vdW50Jyk7XG5cdH1cblxuXHRpZiAobGVnYWN5X21vZGVfZmxhZyAmJiBjb21wb25lbnRfY29udGV4dC5sICE9PSBudWxsKSB7XG5cdFx0aW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbXBvbmVudF9jb250ZXh0KS5tLnB1c2goZm4pO1xuXHR9IGVsc2Uge1xuXHRcdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdGNvbnN0IGNsZWFudXAgPSB1bnRyYWNrKGZuKTtcblx0XHRcdGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIC8qKiBAdHlwZSB7KCkgPT4gdm9pZH0gKi8gKGNsZWFudXApO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ29uRGVzdHJveScpO1xuXHR9XG5cblx0b25Nb3VudCgoKSA9PiAoKSA9PiB1bnRyYWNrKGZuKSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPWFueV1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge2FueX1wYXJhbXNfMFxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL2xlZ2FjeS1vbiNDb21wb25lbnQtZXZlbnRzKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIFRoZSBldmVudCBkaXNwYXRjaGVyIGNhbiBiZSB0eXBlZCB0byBuYXJyb3cgdGhlIGFsbG93ZWQgZXZlbnQgbmFtZXMgYW5kIHRoZSB0eXBlIG9mIHRoZSBgZGV0YWlsYCBhcmd1bWVudDpcbiAqIGBgYHRzXG4gKiBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcjx7XG4gKiAgbG9hZGVkOiBudWxsOyAvLyBkb2VzIG5vdCB0YWtlIGEgZGV0YWlsIGFyZ3VtZW50XG4gKiAgY2hhbmdlOiBzdHJpbmc7IC8vIHRha2VzIGEgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nLCB3aGljaCBpcyByZXF1aXJlZFxuICogIG9wdGlvbmFsOiBudW1iZXIgfCBudWxsOyAvLyB0YWtlcyBhbiBvcHRpb25hbCBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBudW1iZXJcbiAqIH0+KCk7XG4gKiBgYGBcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgY2FsbGJhY2sgcHJvcHMgYW5kL29yIHRoZSBgJGhvc3QoKWAgcnVuZSBpbnN0ZWFkIFx1MjAxNCBzZWUgW21pZ3JhdGlvbiBndWlkZV0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3Y1LW1pZ3JhdGlvbi1ndWlkZSNFdmVudC1jaGFuZ2VzLUNvbXBvbmVudC1ldmVudHMpXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudE1hcCA9IGFueV1cbiAqIEByZXR1cm5zIHtFdmVudERpc3BhdGNoZXI8RXZlbnRNYXA+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRjb25zdCBhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0aWYgKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdjcmVhdGVFdmVudERpc3BhdGNoZXInKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gW2RldGFpbF1cblx0ICogQHBhcmFtIFtvcHRpb25zXVxuXHQgKi9cblx0cmV0dXJuICh0eXBlLCBkZXRhaWwsIG9wdGlvbnMpID0+IHtcblx0XHRjb25zdCBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uIHwgRnVuY3Rpb25bXT59ICovIChcblx0XHRcdGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC5zLiQkZXZlbnRzXG5cdFx0KT8uWy8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSldO1xuXG5cdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogW2V2ZW50c107XG5cdFx0XHQvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG5cdFx0XHQvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG5cdFx0XHRjb25zdCBldmVudCA9IGNyZWF0ZV9jdXN0b21fZXZlbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgZGV0YWlsLCBvcHRpb25zKTtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGZuLmNhbGwoYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LngsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLy8gVE9ETyBtYXJrIGJlZm9yZVVwZGF0ZSBhbmQgYWZ0ZXJVcGRhdGUgYXMgZGVwcmVjYXRlZCBpbiBTdmVsdGUgNlxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0LnByZWAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2AkZWZmZWN0LnByZWBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0IyRlZmZlY3QucHJlKSBpbnN0ZWFkXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnYmVmb3JlVXBkYXRlJyk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX2xlZ2FjeV9vbmx5KCdiZWZvcmVVcGRhdGUnKTtcblx0fVxuXG5cdGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb21wb25lbnRfY29udGV4dCkuYi5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0YCBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBbYCRlZmZlY3RgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCkgaW5zdGVhZFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnYWZ0ZXJVcGRhdGUnKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRfY29udGV4dC5sID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfbGVnYWN5X29ubHkoJ2FmdGVyVXBkYXRlJyk7XG5cdH1cblxuXHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLmEucHVzaChmbik7XG59XG5cbi8qKlxuICogTGVnYWN5LW1vZGU6IEluaXQgY2FsbGJhY2tzIG9iamVjdCBmb3Igb25Nb3VudC9iZWZvcmVVcGRhdGUvYWZ0ZXJVcGRhdGVcbiAqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29udGV4dCkge1xuXHR2YXIgbCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbnRleHQpLmw7XG5cdHJldHVybiAobC51ID8/PSB7IGE6IFtdLCBiOiBbXSwgbTogW10gfSk7XG59XG5cbmV4cG9ydCB7IGZsdXNoU3luYywgZm9yayB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuZXhwb3J0IHtcblx0Y3JlYXRlQ29udGV4dCxcblx0Z2V0Q29udGV4dCxcblx0Z2V0QWxsQ29udGV4dHMsXG5cdGhhc0NvbnRleHQsXG5cdHNldENvbnRleHRcbn0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyc7XG5leHBvcnQgeyBoeWRyYXRhYmxlIH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvaHlkcmF0YWJsZS5qcyc7XG5leHBvcnQgeyBoeWRyYXRlLCBtb3VudCwgdW5tb3VudCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3JlbmRlci5qcyc7XG5leHBvcnQgeyB0aWNrLCB1bnRyYWNrLCBzZXR0bGVkIH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5leHBvcnQgeyBjcmVhdGVSYXdTbmlwcGV0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbmlwcGV0LmpzJztcbiIsICIvKiogQGltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnLi9wdWJsaWMnICovXG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vaW5kZXgtY2xpZW50LmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7KHZhbHVlOiBUKSA9PiB2b2lkfSBydW5cbiAqIEBwYXJhbSB7KHZhbHVlOiBUKSA9PiB2b2lkfSBbaW52YWxpZGF0ZV1cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCBydW4sIGludmFsaWRhdGUpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0cnVuKHVuZGVmaW5lZCk7XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0aWYgKGludmFsaWRhdGUpIGludmFsaWRhdGUodW5kZWZpbmVkKTtcblxuXHRcdHJldHVybiBub29wO1xuXHR9XG5cblx0Ly8gU3ZlbHRlIHN0b3JlIHRha2VzIGEgcHJpdmF0ZSBzZWNvbmQgYXJndW1lbnRcblx0Ly8gU3RhcnRTdG9wTm90aWZpZXIgY291bGQgbXV0YXRlIHN0YXRlLCBhbmQgd2Ugd2FudCB0byBzaWxlbmNlIHRoZSBjb3JyZXNwb25kaW5nIHZhbGlkYXRpb24gZXJyb3Jcblx0Y29uc3QgdW5zdWIgPSB1bnRyYWNrKCgpID0+XG5cdFx0c3RvcmUuc3Vic2NyaWJlKFxuXHRcdFx0cnVuLFxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0aW52YWxpZGF0ZVxuXHRcdClcblx0KTtcblxuXHQvLyBBbHNvIHN1cHBvcnQgUnhKU1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gZml4IHRoaXMgaW4gdGhlIHR5cGVzP1xuXHRyZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG4iLCAiaW1wb3J0IHsgSFlEUkFUSU9OX0VORCwgSFlEUkFUSU9OX1NUQVJULCBIWURSQVRJT05fU1RBUlRfRUxTRSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBCTE9DS19PUEVOID0gYDwhLS0ke0hZRFJBVElPTl9TVEFSVH0tLT5gO1xuZXhwb3J0IGNvbnN0IEJMT0NLX09QRU5fRUxTRSA9IGA8IS0tJHtIWURSQVRJT05fU1RBUlRfRUxTRX0tLT5gO1xuZXhwb3J0IGNvbnN0IEJMT0NLX0NMT1NFID0gYDwhLS0ke0hZRFJBVElPTl9FTkR9LS0+YDtcbmV4cG9ydCBjb25zdCBFTVBUWV9DT01NRU5UID0gYDwhLS0tLT5gO1xuIiwgImltcG9ydCB7IFNUQUxFX1JFQUNUSU9OIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuXG4vKiogQHR5cGUge0Fib3J0Q29udHJvbGxlciB8IG51bGx9ICovXG5sZXQgY29udHJvbGxlciA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydCgpIHtcblx0Y29udHJvbGxlcj8uYWJvcnQoU1RBTEVfUkVBQ1RJT04pO1xuXHRjb250cm9sbGVyID0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFib3J0U2lnbmFsKCkge1xuXHRyZXR1cm4gKGNvbnRyb2xsZXIgPz89IG5ldyBBYm9ydENvbnRyb2xsZXIoKSkuc2lnbmFsO1xufVxuIiwgIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuZXhwb3J0ICogIGZyb20gJy4uL3NoYXJlZC9lcnJvcnMuanMnO1xuXG4vKipcbiAqIFRoZSBub2RlIEFQSSBgQXN5bmNMb2NhbFN0b3JhZ2VgIGlzIG5vdCBhdmFpbGFibGUsIGJ1dCBpcyByZXF1aXJlZCB0byB1c2UgYXN5bmMgc2VydmVyIHJlbmRlcmluZy5cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jX2xvY2FsX3N0b3JhZ2VfdW5hdmFpbGFibGUoKSB7XG5cdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBhc3luY19sb2NhbF9zdG9yYWdlX3VuYXZhaWxhYmxlXFxuVGhlIG5vZGUgQVBJIFxcYEFzeW5jTG9jYWxTdG9yYWdlXFxgIGlzIG5vdCBhdmFpbGFibGUsIGJ1dCBpcyByZXF1aXJlZCB0byB1c2UgYXN5bmMgc2VydmVyIHJlbmRlcmluZy5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hc3luY19sb2NhbF9zdG9yYWdlX3VuYXZhaWxhYmxlYCk7XG5cblx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdHRocm93IGVycm9yO1xufVxuXG4vKipcbiAqIEVuY291bnRlcmVkIGFzeW5jaHJvbm91cyB3b3JrIHdoaWxlIHJlbmRlcmluZyBzeW5jaHJvbm91c2x5LlxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRfaW52YWxpZCgpIHtcblx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGF3YWl0X2ludmFsaWRcXG5FbmNvdW50ZXJlZCBhc3luY2hyb25vdXMgd29yayB3aGlsZSByZW5kZXJpbmcgc3luY2hyb25vdXNseS5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hd2FpdF9pbnZhbGlkYCk7XG5cblx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdHRocm93IGVycm9yO1xufVxuXG4vKipcbiAqIFRoZSBgaHRtbGAgcHJvcGVydHkgb2Ygc2VydmVyIHJlbmRlciByZXN1bHRzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBgYm9keWAgaW5zdGVhZC5cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWxfZGVwcmVjYXRlZCgpIHtcblx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGh0bWxfZGVwcmVjYXRlZFxcblRoZSBcXGBodG1sXFxgIHByb3BlcnR5IG9mIHNlcnZlciByZW5kZXIgcmVzdWx0cyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgXFxgYm9keVxcYCBpbnN0ZWFkLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h0bWxfZGVwcmVjYXRlZGApO1xuXG5cdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHR0aHJvdyBlcnJvcjtcbn1cblxuLyoqXG4gKiBBdHRlbXB0ZWQgdG8gc2V0IGBoeWRyYXRhYmxlYCB3aXRoIGtleSBgJWtleSVgIHR3aWNlIHdpdGggZGlmZmVyZW50IHZhbHVlcy5cbiAqIFxuICogJXN0YWNrJVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHN0YWNrXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRhYmxlX2Nsb2JiZXJpbmcoa2V5LCBzdGFjaykge1xuXHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaHlkcmF0YWJsZV9jbG9iYmVyaW5nXFxuQXR0ZW1wdGVkIHRvIHNldCBcXGBoeWRyYXRhYmxlXFxgIHdpdGgga2V5IFxcYCR7a2V5fVxcYCB0d2ljZSB3aXRoIGRpZmZlcmVudCB2YWx1ZXMuXG5cbiR7c3RhY2t9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0YWJsZV9jbG9iYmVyaW5nYCk7XG5cblx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdHRocm93IGVycm9yO1xufVxuXG4vKipcbiAqIEZhaWxlZCB0byBzZXJpYWxpemUgYGh5ZHJhdGFibGVgIGRhdGEgZm9yIGtleSBgJWtleSVgLlxuICogXG4gKiBgaHlkcmF0YWJsZWAgY2FuIHNlcmlhbGl6ZSBhbnl0aGluZyBbYHVuZXZhbGAgZnJvbSBgZGV2YWx1ZWBdKGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvdW5ldmFsKSBjYW4sIHBsdXMgUHJvbWlzZXMuXG4gKiBcbiAqIENhdXNlOlxuICogJXN0YWNrJVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHN0YWNrXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRhYmxlX3NlcmlhbGl6YXRpb25fZmFpbGVkKGtleSwgc3RhY2spIHtcblx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGh5ZHJhdGFibGVfc2VyaWFsaXphdGlvbl9mYWlsZWRcXG5GYWlsZWQgdG8gc2VyaWFsaXplIFxcYGh5ZHJhdGFibGVcXGAgZGF0YSBmb3Iga2V5IFxcYCR7a2V5fVxcYC5cblxuXFxgaHlkcmF0YWJsZVxcYCBjYW4gc2VyaWFsaXplIGFueXRoaW5nIFtcXGB1bmV2YWxcXGAgZnJvbSBcXGBkZXZhbHVlXFxgXShodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL3VuZXZhbCkgY2FuLCBwbHVzIFByb21pc2VzLlxuXG5DYXVzZTpcbiR7c3RhY2t9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0YWJsZV9zZXJpYWxpemF0aW9uX2ZhaWxlZGApO1xuXG5cdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHR0aHJvdyBlcnJvcjtcbn1cblxuLyoqXG4gKiBgJW5hbWUlKC4uLilgIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHNlcnZlclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9mdW5jdGlvbl91bmF2YWlsYWJsZShuYW1lKSB7XG5cdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBsaWZlY3ljbGVfZnVuY3Rpb25fdW5hdmFpbGFibGVcXG5cXGAke25hbWV9KC4uLilcXGAgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2Z1bmN0aW9uX3VuYXZhaWxhYmxlYCk7XG5cblx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdHRocm93IGVycm9yO1xufVxuXG4vKipcbiAqIENvdWxkIG5vdCByZXNvbHZlIGByZW5kZXJgIGNvbnRleHQuXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJ2ZXJfY29udGV4dF9yZXF1aXJlZCgpIHtcblx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHNlcnZlcl9jb250ZXh0X3JlcXVpcmVkXFxuQ291bGQgbm90IHJlc29sdmUgXFxgcmVuZGVyXFxgIGNvbnRleHQuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc2VydmVyX2NvbnRleHRfcmVxdWlyZWRgKTtcblxuXHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0dGhyb3cgZXJyb3I7XG59IiwgIi8qKiBAaW1wb3J0IHsgU1NSQ29udGV4dCB9IGZyb20gJyNzZXJ2ZXInICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuXG4vKiogQHR5cGUge1NTUkNvbnRleHQgfCBudWxsfSAqL1xuZXhwb3J0IHZhciBzc3JfY29udGV4dCA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge1NTUkNvbnRleHQgfCBudWxsfSB2ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3Nzcl9jb250ZXh0KHYpIHtcblx0c3NyX2NvbnRleHQgPSB2O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcmV0dXJucyB7WygpID0+IFQsIChjb250ZXh0OiBUKSA9PiBUXX1cbiAqIEBzaW5jZSA1LjQwLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoKSB7XG5cdGNvbnN0IGtleSA9IHt9O1xuXHRyZXR1cm4gWygpID0+IGdldENvbnRleHQoa2V5KSwgKGNvbnRleHQpID0+IHNldENvbnRleHQoa2V5LCBjb250ZXh0KV07XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnZ2V0Q29udGV4dCcpO1xuXHRjb25zdCByZXN1bHQgPSAvKiogQHR5cGUge1R9ICovIChjb250ZXh0X21hcC5nZXQoa2V5KSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHBhcmFtIHtUfSBjb250ZXh0XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG5cdGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdzZXRDb250ZXh0Jykuc2V0KGtleSwgY29udGV4dCk7XG5cdHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0cmV0dXJuIGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdoYXNDb250ZXh0JykuaGFzKGtleSk7XG59XG5cbi8qKiBAcmV0dXJucyB7TWFwPGFueSwgYW55Pn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcblx0cmV0dXJuIGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRBbGxDb250ZXh0cycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+fVxuICovXG5mdW5jdGlvbiBnZXRfb3JfaW5pdF9jb250ZXh0X21hcChuYW1lKSB7XG5cdGlmIChzc3JfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KG5hbWUpO1xuXHR9XG5cblx0cmV0dXJuIChzc3JfY29udGV4dC5jID8/PSBuZXcgTWFwKGdldF9wYXJlbnRfY29udGV4dChzc3JfY29udGV4dCkgfHwgdW5kZWZpbmVkKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaChmbikge1xuXHRzc3JfY29udGV4dCA9IHsgcDogc3NyX2NvbnRleHQsIGM6IG51bGwsIHI6IG51bGwgfTtcblxuXHRpZiAoREVWKSB7XG5cdFx0c3NyX2NvbnRleHQuZnVuY3Rpb24gPSBmbjtcblx0XHRzc3JfY29udGV4dC5lbGVtZW50ID0gc3NyX2NvbnRleHQucD8uZWxlbWVudDtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wKCkge1xuXHRzc3JfY29udGV4dCA9IC8qKiBAdHlwZSB7U1NSQ29udGV4dH0gKi8gKHNzcl9jb250ZXh0KS5wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U1NSQ29udGV4dH0gc3NyX2NvbnRleHRcbiAqIEByZXR1cm5zIHtNYXA8dW5rbm93biwgdW5rbm93bj4gfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRfcGFyZW50X2NvbnRleHQoc3NyX2NvbnRleHQpIHtcblx0bGV0IHBhcmVudCA9IHNzcl9jb250ZXh0LnA7XG5cblx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IGNvbnRleHRfbWFwID0gcGFyZW50LmM7XG5cdFx0aWYgKGNvbnRleHRfbWFwICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dF9tYXA7XG5cdFx0fVxuXHRcdHBhcmVudCA9IHBhcmVudC5wO1xuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogV3JhcHMgYW4gYGF3YWl0YCBleHByZXNzaW9uIGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgY29tcG9uZW50IGNvbnRleHQgdGhhdCB3YXNcbiAqIGFjdGl2ZSBiZWZvcmUgdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVkIGNhbiBiZSByZWFwcGxpZWQgYWZ0ZXJ3YXJkcyBcdTIwMTRcbiAqIGBhd2FpdCBhICsgYigpYCBiZWNvbWVzIGAoYXdhaXQgJC5zYXZlKGEpKSgpICsgYigpYCwgbWVhbmluZyBgYigpYCB3aWxsIGhhdmUgYWNjZXNzXG4gKiB0byB0aGUgY29udGV4dCBvZiBpdHMgY29tcG9uZW50LlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UHJvbWlzZTxUPn0gcHJvbWlzZVxuICogQHJldHVybnMge1Byb21pc2U8KCkgPT4gVD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlKHByb21pc2UpIHtcblx0dmFyIHByZXZpb3VzX2NvbnRleHQgPSBzc3JfY29udGV4dDtcblx0dmFyIHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdHNzcl9jb250ZXh0ID0gcHJldmlvdXNfY29udGV4dDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG59XG4iLCAiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxudmFyIGJvbGQgPSAnZm9udC13ZWlnaHQ6IGJvbGQnO1xudmFyIG5vcm1hbCA9ICdmb250LXdlaWdodDogbm9ybWFsJztcblxuLyoqXG4gKiBBIGBoeWRyYXRhYmxlYCB2YWx1ZSB3aXRoIGtleSBgJWtleSVgIHdhcyBjcmVhdGVkLCBidXQgYXQgbGVhc3QgcGFydCBvZiBpdCB3YXMgbm90IHVzZWQgZHVyaW5nIHRoZSByZW5kZXIuXG4gKiBcbiAqIFRoZSBgaHlkcmF0YWJsZWAgd2FzIGluaXRpYWxpemVkIGluOlxuICogJXN0YWNrJVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHN0YWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnJlc29sdmVkX2h5ZHJhdGFibGUoa2V5LCBzdGFjaykge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YCVjW3N2ZWx0ZV0gdW5yZXNvbHZlZF9oeWRyYXRhYmxlXFxuJWNBIFxcYGh5ZHJhdGFibGVcXGAgdmFsdWUgd2l0aCBrZXkgXFxgJHtrZXl9XFxgIHdhcyBjcmVhdGVkLCBidXQgYXQgbGVhc3QgcGFydCBvZiBpdCB3YXMgbm90IHVzZWQgZHVyaW5nIHRoZSByZW5kZXIuXG5cblRoZSBcXGBoeWRyYXRhYmxlXFxgIHdhcyBpbml0aWFsaXplZCBpbjpcbiR7c3RhY2t9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvdW5yZXNvbHZlZF9oeWRyYXRhYmxlYCxcblx0XHRcdGJvbGQsXG5cdFx0XHRub3JtYWxcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvdW5yZXNvbHZlZF9oeWRyYXRhYmxlYCk7XG5cdH1cbn0iLCAiLy8gQHRzLWlnbm9yZSAtLSB3ZSBkb24ndCBpbmNsdWRlIG5vZGUgdHlwZXMgaW4gdGhlIHByb2R1Y3Rpb24gYnVpbGRcbi8qKiBAaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tICdub2RlOmFzeW5jX2hvb2tzJyAqL1xuLyoqIEBpbXBvcnQgeyBSZW5kZXJDb250ZXh0IH0gZnJvbSAnI3NlcnZlcicgKi9cblxuaW1wb3J0IHsgZGVmZXJyZWQgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5cbi8qKiBAdHlwZSB7UHJvbWlzZTx2b2lkPiB8IG51bGx9ICovXG5sZXQgY3VycmVudF9yZW5kZXIgPSBudWxsO1xuXG4vKiogQHR5cGUge1JlbmRlckNvbnRleHQgfCBudWxsfSAqL1xubGV0IGNvbnRleHQgPSBudWxsO1xuXG4vKiogQHJldHVybnMge1JlbmRlckNvbnRleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3JlbmRlcl9jb250ZXh0KCkge1xuXHRjb25zdCBzdG9yZSA9IGNvbnRleHQgPz8gYWxzPy5nZXRTdG9yZSgpO1xuXG5cdGlmICghc3RvcmUpIHtcblx0XHRlLnNlcnZlcl9jb250ZXh0X3JlcXVpcmVkKCk7XG5cdH1cblxuXHRyZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gUHJvbWlzZTxUPn0gZm5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aF9yZW5kZXJfY29udGV4dChmbikge1xuXHRjb250ZXh0ID0ge1xuXHRcdGh5ZHJhdGFibGU6IHtcblx0XHRcdGxvb2t1cDogbmV3IE1hcCgpLFxuXHRcdFx0Y29tcGFyaXNvbnM6IFtdLFxuXHRcdFx0dW5yZXNvbHZlZF9wcm9taXNlczogbmV3IE1hcCgpXG5cdFx0fVxuXHR9O1xuXG5cdGlmIChpbl93ZWJjb250YWluZXIoKSkge1xuXHRcdGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gZGVmZXJyZWQoKTtcblx0XHRjb25zdCBwcmV2aW91c19yZW5kZXIgPSBjdXJyZW50X3JlbmRlcjtcblx0XHRjdXJyZW50X3JlbmRlciA9IHByb21pc2U7XG5cdFx0YXdhaXQgcHJldmlvdXNfcmVuZGVyO1xuXHRcdHJldHVybiBmbigpLmZpbmFsbHkocmVzb2x2ZSk7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmIChhbHMgPT09IG51bGwpIHtcblx0XHRcdGUuYXN5bmNfbG9jYWxfc3RvcmFnZV91bmF2YWlsYWJsZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gYWxzLnJ1bihjb250ZXh0LCBmbik7XG5cdH0gZmluYWxseSB7XG5cdFx0Y29udGV4dCA9IG51bGw7XG5cdH1cbn1cblxuLyoqIEB0eXBlIHtBc3luY0xvY2FsU3RvcmFnZTxSZW5kZXJDb250ZXh0IHwgbnVsbD4gfCBudWxsfSAqL1xubGV0IGFscyA9IG51bGw7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0X3JlbmRlcl9jb250ZXh0KCkge1xuXHRpZiAoYWxzICE9PSBudWxsKSByZXR1cm47XG5cdHRyeSB7XG5cdFx0Ly8gQHRzLWlnbm9yZSAtLSB3ZSBkb24ndCBpbmNsdWRlIG5vZGUgdHlwZXMgaW4gdGhlIHByb2R1Y3Rpb24gYnVpbGRcblx0XHRjb25zdCB7IEFzeW5jTG9jYWxTdG9yYWdlIH0gPSBhd2FpdCBpbXBvcnQoJ25vZGU6YXN5bmNfaG9va3MnKTtcblx0XHRhbHMgPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2UoKTtcblx0fSBjYXRjaCB7fVxufVxuXG4vLyB0aGlzIGhhcyB0byBiZSBhIGZ1bmN0aW9uIGJlY2F1c2Ugcm9sbHVwIHdvbid0IHRyZWVzaGFrZSBpdCBpZiBpdCdzIGEgY29uc3RhbnRcbmZ1bmN0aW9uIGluX3dlYmNvbnRhaW5lcigpIHtcblx0Ly8gQHRzLWlnbm9yZSAtLSB0aGlzIHdpbGwgZmFpbCB3aGVuIHdlIHJ1biB0eXBlY2hlY2sgYmVjYXVzZSB3ZSBleGNsdWRlIG5vZGUgdHlwZXNcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG4vcHJlZmVyLWdsb2JhbC9wcm9jZXNzXG5cdHJldHVybiAhIWdsb2JhbFRoaXMucHJvY2Vzcz8udmVyc2lvbnM/LndlYmNvbnRhaW5lcjtcbn1cbiIsICIvKiogQGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZScgKi9cbi8qKiBAaW1wb3J0IHsgSHlkcmF0YWJsZUNvbnRleHQsIFJlbmRlck91dHB1dCwgU1NSQ29udGV4dCwgU3luY1JlbmRlck91dHB1dCB9IGZyb20gJy4vdHlwZXMuanMnICovXG4vKiogQGltcG9ydCB7IE1heWJlUHJvbWlzZSB9IGZyb20gJyNzaGFyZWQnICovXG5pbXBvcnQgeyBhc3luY19tb2RlX2ZsYWcgfSBmcm9tICcuLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBhYm9ydCB9IGZyb20gJy4vYWJvcnQtc2lnbmFsLmpzJztcbmltcG9ydCB7IHBvcCwgcHVzaCwgc2V0X3Nzcl9jb250ZXh0LCBzc3JfY29udGV4dCwgc2F2ZSB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBCTE9DS19DTE9TRSwgQkxPQ0tfT1BFTiB9IGZyb20gJy4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGF0dHJpYnV0ZXMgfSBmcm9tICcuL2luZGV4LmpzJztcbmltcG9ydCB7IGdldF9yZW5kZXJfY29udGV4dCwgd2l0aF9yZW5kZXJfY29udGV4dCwgaW5pdF9yZW5kZXJfY29udGV4dCB9IGZyb20gJy4vcmVuZGVyLWNvbnRleHQuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbi8qKiBAdHlwZWRlZiB7J2hlYWQnIHwgJ2JvZHknfSBSZW5kZXJlclR5cGUgKi9cbi8qKiBAdHlwZWRlZiB7eyBba2V5IGluIFJlbmRlcmVyVHlwZV06IHN0cmluZyB9fSBBY2N1bXVsYXRlZENvbnRlbnQgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7c3RyaW5nIHwgUmVuZGVyZXJ9IFJlbmRlcmVySXRlbVxuICovXG5cbi8qKlxuICogUmVuZGVyZXJzIGFyZSBiYXNpY2FsbHkgYSB0cmVlIG9mIGBzdHJpbmcgfCBSZW5kZXJlcmBzLCB3aGVyZSBlYWNoIGBSZW5kZXJlcmAgaW4gdGhlIHRyZWUgcmVwcmVzZW50c1xuICogd29yayB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgY29tcGxldGVkLiBBIHJlbmRlcmVyIGNhbiBiZSB7QGxpbmsgY29sbGVjdH1lZCB0byBhZ2dyZWdhdGUgdGhlXG4gKiBjb250ZW50IGZyb20gaXRzZWxmIGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuLCBidXQgdGhpcyB3aWxsIHRocm93IGlmIGFueSBvZiB0aGUgY2hpbGRyZW4gYXJlXG4gKiBwZXJmb3JtaW5nIGFzeW5jaHJvbm91cyB3b3JrLiBUbyBhc3luY2hyb25vdXNseSBjb2xsZWN0IGEgcmVuZGVyZXIsIGp1c3QgYGF3YWl0YCBpdC5cbiAqXG4gKiBUaGUgYHN0cmluZ2AgdmFsdWVzIHdpdGhpbiBhIHJlbmRlcmVyIGFyZSBhbHdheXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB7QGxpbmsgdHlwZX0gb2YgdGhhdCByZW5kZXJlci4gVG8gc3dpdGNoIHR5cGVzLFxuICogY2FsbCB7QGxpbmsgY2hpbGR9IHdpdGggYSBkaWZmZXJlbnQgYHR5cGVgIGFyZ3VtZW50LlxuICovXG5leHBvcnQgY2xhc3MgUmVuZGVyZXIge1xuXHQvKipcblx0ICogVGhlIGNvbnRlbnRzIG9mIHRoZSByZW5kZXJlci5cblx0ICogQHR5cGUge1JlbmRlcmVySXRlbVtdfVxuXHQgKi9cblx0I291dCA9IFtdO1xuXG5cdC8qKlxuXHQgKiBBbnkgYG9uRGVzdHJveWAgY2FsbGJhY2tzIHJlZ2lzdGVyZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiB0aGlzIHJlbmRlcmVyLlxuXHQgKiBAdHlwZSB7KCgpID0+IHZvaWQpW10gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHQjb25fZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogV2hldGhlciB0aGlzIHJlbmRlcmVyIGlzIGEgY29tcG9uZW50IGJvZHkuXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKi9cblx0I2lzX2NvbXBvbmVudF9ib2R5ID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSB0eXBlIG9mIHN0cmluZyBjb250ZW50IHRoYXQgdGhpcyByZW5kZXJlciBpcyBhY2N1bXVsYXRpbmcuXG5cdCAqIEB0eXBlIHtSZW5kZXJlclR5cGV9XG5cdCAqL1xuXHR0eXBlO1xuXG5cdC8qKiBAdHlwZSB7UmVuZGVyZXIgfCB1bmRlZmluZWR9ICovXG5cdCNwYXJlbnQ7XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91cyB3b3JrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlbmRlcmVyXG5cdCAqIEB0eXBlIHtQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0cHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogU3RhdGUgd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb250ZW50IHRyZWUgYXMgYSB3aG9sZS5cblx0ICogSXQgd2lsbCBiZSByZS1leHBvc2VkLCB1bmNvcGllZCwgb24gYWxsIGNoaWxkcmVuLlxuXHQgKiBAdHlwZSB7U1NSU3RhdGV9XG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0Z2xvYmFsO1xuXG5cdC8qKlxuXHQgKiBTdGF0ZSB0aGF0IGlzIGxvY2FsIHRvIHRoZSBicmFuY2ggaXQgaXMgZGVjbGFyZWQgaW4uXG5cdCAqIEl0IHdpbGwgYmUgc2hhbGxvdy1jb3BpZWQgdG8gYWxsIGNoaWxkcmVuLlxuXHQgKlxuXHQgKiBAdHlwZSB7eyBzZWxlY3RfdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCB9fVxuXHQgKi9cblx0bG9jYWw7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U1NSU3RhdGV9IGdsb2JhbFxuXHQgKiBAcGFyYW0ge1JlbmRlcmVyIHwgdW5kZWZpbmVkfSBbcGFyZW50XVxuXHQgKi9cblx0Y29uc3RydWN0b3IoZ2xvYmFsLCBwYXJlbnQpIHtcblx0XHR0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG5cblx0XHR0aGlzLmdsb2JhbCA9IGdsb2JhbDtcblx0XHR0aGlzLmxvY2FsID0gcGFyZW50ID8geyAuLi5wYXJlbnQubG9jYWwgfSA6IHsgc2VsZWN0X3ZhbHVlOiB1bmRlZmluZWQgfTtcblx0XHR0aGlzLnR5cGUgPSBwYXJlbnQgPyBwYXJlbnQudHlwZSA6ICdib2R5Jztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0geyhyZW5kZXJlcjogUmVuZGVyZXIpID0+IHZvaWR9IGZuXG5cdCAqL1xuXHRoZWFkKGZuKSB7XG5cdFx0Y29uc3QgaGVhZCA9IG5ldyBSZW5kZXJlcih0aGlzLmdsb2JhbCwgdGhpcyk7XG5cdFx0aGVhZC50eXBlID0gJ2hlYWQnO1xuXG5cdFx0dGhpcy4jb3V0LnB1c2goaGVhZCk7XG5cdFx0aGVhZC5jaGlsZChmbik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtBcnJheTxQcm9taXNlPHZvaWQ+Pn0gYmxvY2tlcnNcblx0ICogQHBhcmFtIHsocmVuZGVyZXI6IFJlbmRlcmVyKSA9PiB2b2lkfSBmblxuXHQgKi9cblx0YXN5bmNfYmxvY2soYmxvY2tlcnMsIGZuKSB7XG5cdFx0dGhpcy4jb3V0LnB1c2goQkxPQ0tfT1BFTik7XG5cdFx0dGhpcy5hc3luYyhibG9ja2VycywgZm4pO1xuXHRcdHRoaXMuI291dC5wdXNoKEJMT0NLX0NMT1NFKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5PFByb21pc2U8dm9pZD4+fSBibG9ja2Vyc1xuXHQgKiBAcGFyYW0geyhyZW5kZXJlcjogUmVuZGVyZXIpID0+IHZvaWR9IGZuXG5cdCAqL1xuXHRhc3luYyhibG9ja2VycywgZm4pIHtcblx0XHRsZXQgY2FsbGJhY2sgPSBmbjtcblxuXHRcdGlmIChibG9ja2Vycy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCBjb250ZXh0ID0gc3NyX2NvbnRleHQ7XG5cblx0XHRcdGNhbGxiYWNrID0gKHJlbmRlcmVyKSA9PiB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbChibG9ja2VycykudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgcHJldmlvdXNfY29udGV4dCA9IHNzcl9jb250ZXh0O1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHNldF9zc3JfY29udGV4dChjb250ZXh0KTtcblx0XHRcdFx0XHRcdHJldHVybiBmbihyZW5kZXJlcik7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdHNldF9zc3JfY29udGV4dChwcmV2aW91c19jb250ZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0aGlzLmNoaWxkKGNhbGxiYWNrKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5PCgpID0+IHZvaWQ+fSB0aHVua3Ncblx0ICovXG5cdHJ1bih0aHVua3MpIHtcblx0XHRjb25zdCBjb250ZXh0ID0gc3NyX2NvbnRleHQ7XG5cblx0XHRsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aHVua3NbMF0oKSk7XG5cdFx0Y29uc3QgcHJvbWlzZXMgPSBbcHJvbWlzZV07XG5cblx0XHRmb3IgKGNvbnN0IGZuIG9mIHRodW5rcy5zbGljZSgxKSkge1xuXHRcdFx0cHJvbWlzZSA9IHByb21pc2UudGhlbigoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHByZXZpb3VzX2NvbnRleHQgPSBzc3JfY29udGV4dDtcblx0XHRcdFx0c2V0X3Nzcl9jb250ZXh0KGNvbnRleHQpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZuKCk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0c2V0X3Nzcl9jb250ZXh0KHByZXZpb3VzX2NvbnRleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cHJvbWlzZXMucHVzaChwcm9taXNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgY2hpbGQgcmVuZGVyZXIuIFRoZSBjaGlsZCByZW5kZXJlciBpbmhlcml0cyB0aGUgc3RhdGUgZnJvbSB0aGUgcGFyZW50LFxuXHQgKiBidXQgaGFzIGl0cyBvd24gY29udGVudC5cblx0ICogQHBhcmFtIHsocmVuZGVyZXI6IFJlbmRlcmVyKSA9PiBNYXliZVByb21pc2U8dm9pZD59IGZuXG5cdCAqL1xuXHRjaGlsZChmbikge1xuXHRcdGNvbnN0IGNoaWxkID0gbmV3IFJlbmRlcmVyKHRoaXMuZ2xvYmFsLCB0aGlzKTtcblx0XHR0aGlzLiNvdXQucHVzaChjaGlsZCk7XG5cblx0XHRjb25zdCBwYXJlbnQgPSBzc3JfY29udGV4dDtcblxuXHRcdHNldF9zc3JfY29udGV4dCh7XG5cdFx0XHQuLi5zc3JfY29udGV4dCxcblx0XHRcdHA6IHBhcmVudCxcblx0XHRcdGM6IG51bGwsXG5cdFx0XHRyOiBjaGlsZFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gZm4oY2hpbGQpO1xuXG5cdFx0c2V0X3Nzcl9jb250ZXh0KHBhcmVudCk7XG5cblx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHRcdFx0aWYgKGNoaWxkLmdsb2JhbC5tb2RlID09PSAnc3luYycpIHtcblx0XHRcdFx0ZS5hd2FpdF9pbnZhbGlkKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBqdXN0IHRvIGF2b2lkIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnMgLS0gd2UnbGwgZW5kIHVwIHRocm93aW5nIGluIGBjb2xsZWN0X2FzeW5jYCBpZiBzb21ldGhpbmcgZmFpbHNcblx0XHRcdHJlc3VsdC5jYXRjaCgoKSA9PiB7fSk7XG5cdFx0XHRjaGlsZC5wcm9taXNlID0gcmVzdWx0O1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGlsZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBjb21wb25lbnQgcmVuZGVyZXIuIFRoZSBjb21wb25lbnQgcmVuZGVyZXIgaW5oZXJpdHMgdGhlIHN0YXRlIGZyb20gdGhlIHBhcmVudCxcblx0ICogYnV0IGhhcyBpdHMgb3duIGNvbnRlbnQuIEl0IGlzIHRyZWF0ZWQgYXMgYW4gb3JkZXJpbmcgYm91bmRhcnkgZm9yIG9uZGVzdHJveSBjYWxsYmFja3MuXG5cdCAqIEBwYXJhbSB7KHJlbmRlcmVyOiBSZW5kZXJlcikgPT4gTWF5YmVQcm9taXNlPHZvaWQ+fSBmblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcG9uZW50X2ZuXVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGNvbXBvbmVudChmbiwgY29tcG9uZW50X2ZuKSB7XG5cdFx0cHVzaChjb21wb25lbnRfZm4pO1xuXHRcdGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZChmbik7XG5cdFx0Y2hpbGQuI2lzX2NvbXBvbmVudF9ib2R5ID0gdHJ1ZTtcblx0XHRwb3AoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGF0dHJzXG5cdCAqIEBwYXJhbSB7KHJlbmRlcmVyOiBSZW5kZXJlcikgPT4gdm9pZH0gZm5cblx0ICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtjc3NfaGFzaF1cblx0ICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiB8IHVuZGVmaW5lZH0gW2NsYXNzZXNdXG5cdCAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZH0gW3N0eWxlc11cblx0ICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IFtmbGFnc11cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRzZWxlY3QoYXR0cnMsIGZuLCBjc3NfaGFzaCwgY2xhc3Nlcywgc3R5bGVzLCBmbGFncykge1xuXHRcdGNvbnN0IHsgdmFsdWUsIC4uLnNlbGVjdF9hdHRycyB9ID0gYXR0cnM7XG5cblx0XHR0aGlzLnB1c2goYDxzZWxlY3Qke2F0dHJpYnV0ZXMoc2VsZWN0X2F0dHJzLCBjc3NfaGFzaCwgY2xhc3Nlcywgc3R5bGVzLCBmbGFncyl9PmApO1xuXHRcdHRoaXMuY2hpbGQoKHJlbmRlcmVyKSA9PiB7XG5cdFx0XHRyZW5kZXJlci5sb2NhbC5zZWxlY3RfdmFsdWUgPSB2YWx1ZTtcblx0XHRcdGZuKHJlbmRlcmVyKTtcblx0XHR9KTtcblx0XHR0aGlzLnB1c2goJzwvc2VsZWN0PicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gYXR0cnNcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgKChyZW5kZXJlcjogUmVuZGVyZXIpID0+IHZvaWQpfSBib2R5XG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbY3NzX2hhc2hdXG5cdCAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj4gfCB1bmRlZmluZWR9IFtjbGFzc2VzXVxuXHQgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9IFtzdHlsZXNdXG5cdCAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBbZmxhZ3NdXG5cdCAqL1xuXHRvcHRpb24oYXR0cnMsIGJvZHksIGNzc19oYXNoLCBjbGFzc2VzLCBzdHlsZXMsIGZsYWdzKSB7XG5cdFx0dGhpcy4jb3V0LnB1c2goYDxvcHRpb24ke2F0dHJpYnV0ZXMoYXR0cnMsIGNzc19oYXNoLCBjbGFzc2VzLCBzdHlsZXMsIGZsYWdzKX1gKTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG5cdFx0ICogQHBhcmFtIHthbnl9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHt7IGhlYWQ/OiBzdHJpbmcsIGJvZHk6IGFueSB9fSBjb250ZW50XG5cdFx0ICovXG5cdFx0Y29uc3QgY2xvc2UgPSAocmVuZGVyZXIsIHZhbHVlLCB7IGhlYWQsIGJvZHkgfSkgPT4ge1xuXHRcdFx0aWYgKCd2YWx1ZScgaW4gYXR0cnMpIHtcblx0XHRcdFx0dmFsdWUgPSBhdHRycy52YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlID09PSB0aGlzLmxvY2FsLnNlbGVjdF92YWx1ZSkge1xuXHRcdFx0XHRyZW5kZXJlci4jb3V0LnB1c2goJyBzZWxlY3RlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJlci4jb3V0LnB1c2goYD4ke2JvZHl9PC9vcHRpb24+YCk7XG5cblx0XHRcdC8vIHN1cGVyIGVkZ2UgY2FzZSwgYnV0IG1heSBhcyB3ZWxsIGhhbmRsZSBpdFxuXHRcdFx0aWYgKGhlYWQpIHtcblx0XHRcdFx0cmVuZGVyZXIuaGVhZCgoY2hpbGQpID0+IGNoaWxkLnB1c2goaGVhZCkpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRpZiAodHlwZW9mIGJvZHkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMuY2hpbGQoKHJlbmRlcmVyKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHIgPSBuZXcgUmVuZGVyZXIodGhpcy5nbG9iYWwsIHRoaXMpO1xuXHRcdFx0XHRib2R5KHIpO1xuXG5cdFx0XHRcdGlmICh0aGlzLmdsb2JhbC5tb2RlID09PSAnYXN5bmMnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHIuI2NvbGxlY3RfY29udGVudF9hc3luYygpLnRoZW4oKGNvbnRlbnQpID0+IHtcblx0XHRcdFx0XHRcdGNsb3NlKHJlbmRlcmVyLCBjb250ZW50LmJvZHkucmVwbGFjZUFsbCgnPCEtLS0tPicsICcnKSwgY29udGVudCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IHIuI2NvbGxlY3RfY29udGVudCgpO1xuXHRcdFx0XHRcdGNsb3NlKHJlbmRlcmVyLCBjb250ZW50LmJvZHkucmVwbGFjZUFsbCgnPCEtLS0tPicsICcnKSwgY29udGVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjbG9zZSh0aGlzLCBib2R5LCB7IGJvZHkgfSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7KHJlbmRlcmVyOiBSZW5kZXJlcikgPT4gdm9pZH0gZm5cblx0ICovXG5cdHRpdGxlKGZuKSB7XG5cdFx0Y29uc3QgcGF0aCA9IHRoaXMuZ2V0X3BhdGgoKTtcblxuXHRcdC8qKiBAcGFyYW0ge3N0cmluZ30gaGVhZCAqL1xuXHRcdGNvbnN0IGNsb3NlID0gKGhlYWQpID0+IHtcblx0XHRcdHRoaXMuZ2xvYmFsLnNldF90aXRsZShoZWFkLCBwYXRoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5jaGlsZCgocmVuZGVyZXIpID0+IHtcblx0XHRcdGNvbnN0IHIgPSBuZXcgUmVuZGVyZXIocmVuZGVyZXIuZ2xvYmFsLCByZW5kZXJlcik7XG5cdFx0XHRmbihyKTtcblxuXHRcdFx0aWYgKHJlbmRlcmVyLmdsb2JhbC5tb2RlID09PSAnYXN5bmMnKSB7XG5cdFx0XHRcdHJldHVybiByLiNjb2xsZWN0X2NvbnRlbnRfYXN5bmMoKS50aGVuKChjb250ZW50KSA9PiB7XG5cdFx0XHRcdFx0Y2xvc2UoY29udGVudC5oZWFkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gci4jY29sbGVjdF9jb250ZW50KCk7XG5cdFx0XHRcdGNsb3NlKGNvbnRlbnQuaGVhZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmcgfCAoKCkgPT4gUHJvbWlzZTxzdHJpbmc+KX0gY29udGVudFxuXHQgKi9cblx0cHVzaChjb250ZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLmNoaWxkKGFzeW5jIChyZW5kZXJlcikgPT4gcmVuZGVyZXIucHVzaChhd2FpdCBjb250ZW50KCkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4jb3V0LnB1c2goY29udGVudCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cblx0ICovXG5cdG9uX2Rlc3Ryb3koZm4pIHtcblx0XHQodGhpcy4jb25fZGVzdHJveSA/Pz0gW10pLnB1c2goZm4pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGdldF9wYXRoKCkge1xuXHRcdHJldHVybiB0aGlzLiNwYXJlbnQgPyBbLi4udGhpcy4jcGFyZW50LmdldF9wYXRoKCksIHRoaXMuI3BhcmVudC4jb3V0LmluZGV4T2YodGhpcyldIDogW107XG5cdH1cblxuXHQvKipcblx0ICogQGRlcHJlY2F0ZWQgdGhpcyBpcyBuZWVkZWQgZm9yIGxlZ2FjeSBjb21wb25lbnQgYmluZGluZ3Ncblx0ICovXG5cdGNvcHkoKSB7XG5cdFx0Y29uc3QgY29weSA9IG5ldyBSZW5kZXJlcih0aGlzLmdsb2JhbCwgdGhpcy4jcGFyZW50KTtcblx0XHRjb3B5LiNvdXQgPSB0aGlzLiNvdXQubWFwKChpdGVtKSA9PiAoaXRlbSBpbnN0YW5jZW9mIFJlbmRlcmVyID8gaXRlbS5jb3B5KCkgOiBpdGVtKSk7XG5cdFx0Y29weS5wcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXHRcdHJldHVybiBjb3B5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UmVuZGVyZXJ9IG90aGVyXG5cdCAqIEBkZXByZWNhdGVkIHRoaXMgaXMgbmVlZGVkIGZvciBsZWdhY3kgY29tcG9uZW50IGJpbmRpbmdzXG5cdCAqL1xuXHRzdWJzdW1lKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuZ2xvYmFsLm1vZGUgIT09IG90aGVyLmdsb2JhbC5tb2RlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFwiaW52YXJpYW50OiBBIHJlbmRlcmVyIGNhbm5vdCBzd2l0Y2ggbW9kZXMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgdGhlcmUncyBhIGNvbXBpbGVyIGJ1Zy4gRmlsZSBhbiBpc3N1ZSFcIlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLmxvY2FsID0gb3RoZXIubG9jYWw7XG5cdFx0dGhpcy4jb3V0ID0gb3RoZXIuI291dC5tYXAoKGl0ZW0pID0+IHtcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgUmVuZGVyZXIpIHtcblx0XHRcdFx0aXRlbS5zdWJzdW1lKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9taXNlID0gb3RoZXIucHJvbWlzZTtcblx0XHR0aGlzLnR5cGUgPSBvdGhlci50eXBlO1xuXHR9XG5cblx0Z2V0IGxlbmd0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jb3V0Lmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBPbmx5IGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyIGFuZCB3aGVuIGNvbXBpbGluZyB3aXRoIHRoZSBgc2VydmVyYCBvcHRpb24uXG5cdCAqIFRha2VzIGEgY29tcG9uZW50IGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGBib2R5YCBhbmQgYGhlYWRgIHByb3BlcnRpZXMgb24gaXQsIHdoaWNoIHlvdSBjYW4gdXNlIHRvIHBvcHVsYXRlIHRoZSBIVE1MIHdoZW4gc2VydmVyLXJlbmRlcmluZyB5b3VyIGFwcC5cblx0ICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuXHQgKiBAcGFyYW0ge0NvbXBvbmVudDxQcm9wcz59IGNvbXBvbmVudFxuXHQgKiBAcGFyYW0ge3sgcHJvcHM/OiBPbWl0PFByb3BzLCAnJCRzbG90cycgfCAnJCRldmVudHMnPjsgY29udGV4dD86IE1hcDxhbnksIGFueT47IGlkUHJlZml4Pzogc3RyaW5nIH19IFtvcHRpb25zXVxuXHQgKiBAcmV0dXJucyB7UmVuZGVyT3V0cHV0fVxuXHQgKi9cblx0c3RhdGljIHJlbmRlcihjb21wb25lbnQsIG9wdGlvbnMgPSB7fSkge1xuXHRcdC8qKiBAdHlwZSB7QWNjdW11bGF0ZWRDb250ZW50IHwgdW5kZWZpbmVkfSAqL1xuXHRcdGxldCBzeW5jO1xuXHRcdC8qKiBAdHlwZSB7UHJvbWlzZTxBY2N1bXVsYXRlZENvbnRlbnQ+IHwgdW5kZWZpbmVkfSAqL1xuXHRcdGxldCBhc3luYztcblxuXHRcdGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7UmVuZGVyT3V0cHV0fSAqLyAoe30pO1xuXHRcdC8vIG1ha2luZyB0aGVzZSBwcm9wZXJ0aWVzIG5vbi1lbnVtZXJhYmxlIHNvIHRoYXQgY29uc29sZS5sb2dnaW5nXG5cdFx0Ly8gZG9lc24ndCB0cmlnZ2VyIGEgc3luYyByZW5kZXJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIHtcblx0XHRcdGh0bWw6IHtcblx0XHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIChzeW5jID8/PSBSZW5kZXJlci4jcmVuZGVyKGNvbXBvbmVudCwgb3B0aW9ucykpLmJvZHk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRoZWFkOiB7XG5cdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiAoc3luYyA/Pz0gUmVuZGVyZXIuI3JlbmRlcihjb21wb25lbnQsIG9wdGlvbnMpKS5oZWFkO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ym9keToge1xuXHRcdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gKHN5bmMgPz89IFJlbmRlcmVyLiNyZW5kZXIoY29tcG9uZW50LCBvcHRpb25zKSkuYm9keTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHRoZW46IHtcblx0XHRcdFx0dmFsdWU6XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogdGhpcyBpcyBub3QgdHlwZS1zYWZlLCBidXQgaG9uZXN0bHkgaXQncyB0aGUgYmVzdCBJIGNhbiBkbyByaWdodCBub3csIGFuZCBpdCdzIGEgc3RyYWlnaHRmb3J3YXJkIGZ1bmN0aW9uLlxuXHRcdFx0XHRcdCAqXG5cdFx0XHRcdFx0ICogQHRlbXBsYXRlIFRSZXN1bHQxXG5cdFx0XHRcdFx0ICogQHRlbXBsYXRlIFtUUmVzdWx0Mj1uZXZlcl1cblx0XHRcdFx0XHQgKiBAcGFyYW0geyAodmFsdWU6IFN5bmNSZW5kZXJPdXRwdXQpID0+IFRSZXN1bHQxIH0gb25mdWxmaWxsZWRcblx0XHRcdFx0XHQgKiBAcGFyYW0geyAocmVhc29uOiB1bmtub3duKSA9PiBUUmVzdWx0MiB9IG9ucmVqZWN0ZWRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHQob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpID0+IHtcblx0XHRcdFx0XHRcdGlmICghYXN5bmNfbW9kZV9mbGFnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IChzeW5jID8/PSBSZW5kZXJlci4jcmVuZGVyKGNvbXBvbmVudCwgb3B0aW9ucykpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCB1c2VyX3Jlc3VsdCA9IG9uZnVsZmlsbGVkKHtcblx0XHRcdFx0XHRcdFx0XHRoZWFkOiByZXN1bHQuaGVhZCxcblx0XHRcdFx0XHRcdFx0XHRib2R5OiByZXN1bHQuYm9keSxcblx0XHRcdFx0XHRcdFx0XHRodG1sOiByZXN1bHQuYm9keVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh1c2VyX3Jlc3VsdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhc3luYyA/Pz0gaW5pdF9yZW5kZXJfY29udGV4dCgpLnRoZW4oKCkgPT5cblx0XHRcdFx0XHRcdFx0d2l0aF9yZW5kZXJfY29udGV4dCgoKSA9PiBSZW5kZXJlci4jcmVuZGVyX2FzeW5jKGNvbXBvbmVudCwgb3B0aW9ucykpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFzeW5jLnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCAnaHRtbCcsIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2V0dGVyLXJldHVyblxuXHRcdFx0XHRcdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5odG1sX2RlcHJlY2F0ZWQoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb25mdWxmaWxsZWQoLyoqIEB0eXBlIHtTeW5jUmVuZGVyT3V0cHV0fSAqLyAocmVzdWx0KSk7XG5cdFx0XHRcdFx0XHR9LCBvbnJlamVjdGVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbGxlY3QgYWxsIG9mIHRoZSBgb25EZXN0cm95YCBjYWxsYmFja3MgcmVnaXN0ZXJlZCBkdXJpbmcgcmVuZGVyaW5nLiBJbiBhbiBhc3luYyBjb250ZXh0LCB0aGlzIGlzIG9ubHkgc2FmZSB0byBjYWxsXG5cdCAqIGFmdGVyIGF3YWl0aW5nIGBjb2xsZWN0X2FzeW5jYC5cblx0ICpcblx0ICogQ2hpbGQgcmVuZGVyZXJzIGFyZSBcInBvcm91c1wiIGFuZCBkb24ndCBhZmZlY3QgZXhlY3V0aW9uIG9yZGVyLCBidXQgY29tcG9uZW50IGJvZHkgcmVuZGVyZXJzXG5cdCAqIGNyZWF0ZSBvcmRlcmluZyBib3VuZGFyaWVzLiBXaXRoaW4gYSByZW5kZXJlciwgY2FsbGJhY2tzIHJ1biBpbiBvcmRlciB1bnRpbCBoaXR0aW5nIGEgY29tcG9uZW50IGJvdW5kYXJ5LlxuXHQgKiBAcmV0dXJucyB7SXRlcmFibGU8KCkgPT4gdm9pZD59XG5cdCAqL1xuXHQqI2NvbGxlY3Rfb25fZGVzdHJveSgpIHtcblx0XHRmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiB0aGlzLiN0cmF2ZXJzZV9jb21wb25lbnRzKCkpIHtcblx0XHRcdHlpZWxkKiBjb21wb25lbnQuI2NvbGxlY3Rfb25kZXN0cm95KCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGEgZGVwdGgtZmlyc3Qgc2VhcmNoIG9mIHJlbmRlcmVycywgeWllbGRpbmcgdGhlIGRlZXBlc3QgY29tcG9uZW50cyBmaXJzdCwgdGhlbiBhZGRpdGlvbmFsIGNvbXBvbmVudHMgYXMgd2UgYmFja3RyYWNrIHVwIHRoZSB0cmVlLlxuXHQgKiBAcmV0dXJucyB7SXRlcmFibGU8UmVuZGVyZXI+fVxuXHQgKi9cblx0KiN0cmF2ZXJzZV9jb21wb25lbnRzKCkge1xuXHRcdGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jb3V0KSB7XG5cdFx0XHRpZiAodHlwZW9mIGNoaWxkICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR5aWVsZCogY2hpbGQuI3RyYXZlcnNlX2NvbXBvbmVudHMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRoaXMuI2lzX2NvbXBvbmVudF9ib2R5KSB7XG5cdFx0XHR5aWVsZCB0aGlzO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7SXRlcmFibGU8KCkgPT4gdm9pZD59XG5cdCAqL1xuXHQqI2NvbGxlY3Rfb25kZXN0cm95KCkge1xuXHRcdGlmICh0aGlzLiNvbl9kZXN0cm95KSB7XG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIHRoaXMuI29uX2Rlc3Ryb3kpIHtcblx0XHRcdFx0eWllbGQgZm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jb3V0KSB7XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBSZW5kZXJlciAmJiAhY2hpbGQuI2lzX2NvbXBvbmVudF9ib2R5KSB7XG5cdFx0XHRcdHlpZWxkKiBjaGlsZC4jY29sbGVjdF9vbmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIGEgY29tcG9uZW50LiBUaHJvd3MgaWYgYW55IG9mIHRoZSBjaGlsZHJlbiBhcmUgcGVyZm9ybWluZyBhc3luY2hyb25vdXMgd29yay5cblx0ICpcblx0ICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuXHQgKiBAcGFyYW0ge0NvbXBvbmVudDxQcm9wcz59IGNvbXBvbmVudFxuXHQgKiBAcGFyYW0ge3sgcHJvcHM/OiBPbWl0PFByb3BzLCAnJCRzbG90cycgfCAnJCRldmVudHMnPjsgY29udGV4dD86IE1hcDxhbnksIGFueT47IGlkUHJlZml4Pzogc3RyaW5nIH19IG9wdGlvbnNcblx0ICogQHJldHVybnMge0FjY3VtdWxhdGVkQ29udGVudH1cblx0ICovXG5cdHN0YXRpYyAjcmVuZGVyKGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRcdHZhciBwcmV2aW91c19jb250ZXh0ID0gc3NyX2NvbnRleHQ7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHJlbmRlcmVyID0gUmVuZGVyZXIuI29wZW5fcmVuZGVyKCdzeW5jJywgY29tcG9uZW50LCBvcHRpb25zKTtcblxuXHRcdFx0Y29uc3QgY29udGVudCA9IHJlbmRlcmVyLiNjb2xsZWN0X2NvbnRlbnQoKTtcblx0XHRcdHJldHVybiBSZW5kZXJlci4jY2xvc2VfcmVuZGVyKGNvbnRlbnQsIHJlbmRlcmVyKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdHNldF9zc3JfY29udGV4dChwcmV2aW91c19jb250ZXh0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIGEgY29tcG9uZW50LlxuXHQgKlxuXHQgKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG5cdCAqIEBwYXJhbSB7Q29tcG9uZW50PFByb3BzPn0gY29tcG9uZW50XG5cdCAqIEBwYXJhbSB7eyBwcm9wcz86IE9taXQ8UHJvcHMsICckJHNsb3RzJyB8ICckJGV2ZW50cyc+OyBjb250ZXh0PzogTWFwPGFueSwgYW55PjsgaWRQcmVmaXg/OiBzdHJpbmcgfX0gb3B0aW9uc1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxBY2N1bXVsYXRlZENvbnRlbnQ+fVxuXHQgKi9cblx0c3RhdGljIGFzeW5jICNyZW5kZXJfYXN5bmMoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgcHJldmlvdXNfY29udGV4dCA9IHNzcl9jb250ZXh0O1xuXG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHJlbmRlcmVyID0gUmVuZGVyZXIuI29wZW5fcmVuZGVyKCdhc3luYycsIGNvbXBvbmVudCwgb3B0aW9ucyk7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgcmVuZGVyZXIuI2NvbGxlY3RfY29udGVudF9hc3luYygpO1xuXHRcdFx0Y29uc3QgaHlkcmF0YWJsZXMgPSBhd2FpdCByZW5kZXJlci4jY29sbGVjdF9oeWRyYXRhYmxlcygpO1xuXHRcdFx0aWYgKGh5ZHJhdGFibGVzICE9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRlbnQuaGVhZCA9IGh5ZHJhdGFibGVzICsgY29udGVudC5oZWFkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFJlbmRlcmVyLiNjbG9zZV9yZW5kZXIoY29udGVudCwgcmVuZGVyZXIpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfc3NyX2NvbnRleHQocHJldmlvdXNfY29udGV4dCk7XG5cdFx0XHRhYm9ydCgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb2xsZWN0IGFsbCBvZiB0aGUgY29kZSBmcm9tIHRoZSBgb3V0YCBhcnJheSBhbmQgcmV0dXJuIGl0IGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgcmVzb2x2aW5nIHRvIGEgc3RyaW5nLlxuXHQgKiBAcGFyYW0ge0FjY3VtdWxhdGVkQ29udGVudH0gY29udGVudFxuXHQgKiBAcmV0dXJucyB7QWNjdW11bGF0ZWRDb250ZW50fVxuXHQgKi9cblx0I2NvbGxlY3RfY29udGVudChjb250ZW50ID0geyBoZWFkOiAnJywgYm9keTogJycgfSkge1xuXHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNvdXQpIHtcblx0XHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Y29udGVudFt0aGlzLnR5cGVdICs9IGl0ZW07XG5cdFx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBSZW5kZXJlcikge1xuXHRcdFx0XHRpdGVtLiNjb2xsZWN0X2NvbnRlbnQoY29udGVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHQvKipcblx0ICogQ29sbGVjdCBhbGwgb2YgdGhlIGNvZGUgZnJvbSB0aGUgYG91dGAgYXJyYXkgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy5cblx0ICogQHBhcmFtIHtBY2N1bXVsYXRlZENvbnRlbnR9IGNvbnRlbnRcblx0ICogQHJldHVybnMge1Byb21pc2U8QWNjdW11bGF0ZWRDb250ZW50Pn1cblx0ICovXG5cdGFzeW5jICNjb2xsZWN0X2NvbnRlbnRfYXN5bmMoY29udGVudCA9IHsgaGVhZDogJycsIGJvZHk6ICcnIH0pIHtcblx0XHRhd2FpdCB0aGlzLnByb21pc2U7XG5cblx0XHQvLyBubyBkYW5nZXIgdG8gc2VxdWVudGlhbGx5IGF3YWl0aW5nIHN0dWZmIGluIGhlcmU7IGFsbCBvZiB0aGUgd29yayBpcyBhbHJlYWR5IGtpY2tlZCBvZmZcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jb3V0KSB7XG5cdFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGNvbnRlbnRbdGhpcy50eXBlXSArPSBpdGVtO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgUmVuZGVyZXIpIHtcblx0XHRcdFx0YXdhaXQgaXRlbS4jY29sbGVjdF9jb250ZW50X2FzeW5jKGNvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0YXN5bmMgI2NvbGxlY3RfaHlkcmF0YWJsZXMoKSB7XG5cdFx0Y29uc3QgY3R4ID0gZ2V0X3JlbmRlcl9jb250ZXh0KCkuaHlkcmF0YWJsZTtcblxuXHRcdGZvciAoY29uc3QgW18sIGtleV0gb2YgY3R4LnVucmVzb2x2ZWRfcHJvbWlzZXMpIHtcblx0XHRcdC8vIHRoaXMgaXMgYSBwcm9ibGVtIC0tIGl0IG1lYW5zIHdlJ3ZlIGZpbmlzaGVkIHRoZSByZW5kZXIgYnV0IHdlJ3JlIHN0aWxsIHdhaXRpbmcgb24gYSBwcm9taXNlIHRvIHJlc29sdmUgc28gd2UgY2FuXG5cdFx0XHQvLyBzZXJpYWxpemUgaXQsIHNvIHdlJ3JlIGJsb2NraW5nIHRoZSByZXNwb25zZSBvbiB1c2VsZXNzIGNvbnRlbnQuXG5cdFx0XHR3LnVucmVzb2x2ZWRfaHlkcmF0YWJsZShrZXksIGN0eC5sb29rdXAuZ2V0KGtleSk/LnN0YWNrID8/ICc8bWlzc2luZyBzdGFjayB0cmFjZT4nKTtcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IGNvbXBhcmlzb24gb2YgY3R4LmNvbXBhcmlzb25zKSB7XG5cdFx0XHQvLyB0aGVzZSByZWplY3QgaWYgdGhlcmUncyBhIG1pc21hdGNoXG5cdFx0XHRhd2FpdCBjb21wYXJpc29uO1xuXHRcdH1cblxuXHRcdHJldHVybiBhd2FpdCBSZW5kZXJlci4jaHlkcmF0YWJsZV9ibG9jayhjdHgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcblx0ICogQHBhcmFtIHsnc3luYycgfCAnYXN5bmMnfSBtb2RlXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCdzdmVsdGUnKS5Db21wb25lbnQ8UHJvcHM+fSBjb21wb25lbnRcblx0ICogQHBhcmFtIHt7IHByb3BzPzogT21pdDxQcm9wcywgJyQkc2xvdHMnIHwgJyQkZXZlbnRzJz47IGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+OyBpZFByZWZpeD86IHN0cmluZyB9fSBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn1cblx0ICovXG5cdHN0YXRpYyAjb3Blbl9yZW5kZXIobW9kZSwgY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoXG5cdFx0XHRuZXcgU1NSU3RhdGUobW9kZSwgb3B0aW9ucy5pZFByZWZpeCA/IG9wdGlvbnMuaWRQcmVmaXggKyAnLScgOiAnJylcblx0XHQpO1xuXG5cdFx0cmVuZGVyZXIucHVzaChCTE9DS19PUEVOKTtcblxuXHRcdGlmIChvcHRpb25zLmNvbnRleHQpIHtcblx0XHRcdHB1c2goKTtcblx0XHRcdC8qKiBAdHlwZSB7U1NSQ29udGV4dH0gKi8gKHNzcl9jb250ZXh0KS5jID0gb3B0aW9ucy5jb250ZXh0O1xuXHRcdFx0LyoqIEB0eXBlIHtTU1JDb250ZXh0fSAqLyAoc3NyX2NvbnRleHQpLnIgPSByZW5kZXJlcjtcblx0XHR9XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0Y29tcG9uZW50KHJlbmRlcmVyLCBvcHRpb25zLnByb3BzID8/IHt9KTtcblxuXHRcdGlmIChvcHRpb25zLmNvbnRleHQpIHtcblx0XHRcdHBvcCgpO1xuXHRcdH1cblxuXHRcdHJlbmRlcmVyLnB1c2goQkxPQ0tfQ0xPU0UpO1xuXG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QWNjdW11bGF0ZWRDb250ZW50fSBjb250ZW50XG5cdCAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG5cdCAqL1xuXHRzdGF0aWMgI2Nsb3NlX3JlbmRlcihjb250ZW50LCByZW5kZXJlcikge1xuXHRcdGZvciAoY29uc3QgY2xlYW51cCBvZiByZW5kZXJlci4jY29sbGVjdF9vbl9kZXN0cm95KCkpIHtcblx0XHRcdGNsZWFudXAoKTtcblx0XHR9XG5cblx0XHRsZXQgaGVhZCA9IGNvbnRlbnQuaGVhZCArIHJlbmRlcmVyLmdsb2JhbC5nZXRfdGl0bGUoKTtcblx0XHRsZXQgYm9keSA9IGNvbnRlbnQuYm9keTtcblxuXHRcdGZvciAoY29uc3QgeyBoYXNoLCBjb2RlIH0gb2YgcmVuZGVyZXIuZ2xvYmFsLmNzcykge1xuXHRcdFx0aGVhZCArPSBgPHN0eWxlIGlkPVwiJHtoYXNofVwiPiR7Y29kZX08L3N0eWxlPmA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlYWQsXG5cdFx0XHRib2R5XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0h5ZHJhdGFibGVDb250ZXh0fSBjdHhcblx0ICovXG5cdHN0YXRpYyBhc3luYyAjaHlkcmF0YWJsZV9ibG9jayhjdHgpIHtcblx0XHRpZiAoY3R4Lmxvb2t1cC5zaXplID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgZW50cmllcyA9IFtdO1xuXHRcdGxldCBoYXNfcHJvbWlzZXMgPSBmYWxzZTtcblxuXHRcdGZvciAoY29uc3QgW2ssIHZdIG9mIGN0eC5sb29rdXApIHtcblx0XHRcdGlmICh2LnByb21pc2VzKSB7XG5cdFx0XHRcdGhhc19wcm9taXNlcyA9IHRydWU7XG5cdFx0XHRcdGZvciAoY29uc3QgcCBvZiB2LnByb21pc2VzKSBhd2FpdCBwO1xuXHRcdFx0fVxuXG5cdFx0XHRlbnRyaWVzLnB1c2goYFske0pTT04uc3RyaW5naWZ5KGspfSwke3Yuc2VyaWFsaXplZH1dYCk7XG5cdFx0fVxuXG5cdFx0bGV0IHByZWx1ZGUgPSBgY29uc3QgaCA9ICh3aW5kb3cuX19zdmVsdGUgPz89IHt9KS5oID8/PSBuZXcgTWFwKCk7YDtcblxuXHRcdGlmIChoYXNfcHJvbWlzZXMpIHtcblx0XHRcdHByZWx1ZGUgPSBgY29uc3QgciA9ICh2KSA9PiBQcm9taXNlLnJlc29sdmUodik7XG5cdFx0XHRcdCR7cHJlbHVkZX1gO1xuXHRcdH1cblxuXHRcdC8vIFRPRE8gY3NwIC0tIGhhdmUgZGlzY3Vzc2VkIGJ1dCBub3QgaW1wbGVtZW50ZWRcblx0XHRyZXR1cm4gYFxuXHRcdDxzY3JpcHQ+XG5cdFx0XHR7XG5cdFx0XHRcdCR7cHJlbHVkZX1cblxuXHRcdFx0XHRmb3IgKGNvbnN0IFtrLCB2XSBvZiBbXG5cdFx0XHRcdFx0JHtlbnRyaWVzLmpvaW4oJyxcXG5cXHRcXHRcXHRcXHRcXHQnKX1cblx0XHRcdFx0XSkge1xuXHRcdFx0XHRcdGguc2V0KGssIHYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0PC9zY3JpcHQ+YDtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgU1NSU3RhdGUge1xuXHQvKiogQHJlYWRvbmx5IEB0eXBlIHsnc3luYycgfCAnYXN5bmMnfSAqL1xuXHRtb2RlO1xuXG5cdC8qKiBAcmVhZG9ubHkgQHR5cGUgeygpID0+IHN0cmluZ30gKi9cblx0dWlkO1xuXG5cdC8qKiBAcmVhZG9ubHkgQHR5cGUge1NldDx7IGhhc2g6IHN0cmluZzsgY29kZTogc3RyaW5nIH0+fSAqL1xuXHRjc3MgPSBuZXcgU2V0KCk7XG5cblx0LyoqIEB0eXBlIHt7IHBhdGg6IG51bWJlcltdLCB2YWx1ZTogc3RyaW5nIH19ICovXG5cdCN0aXRsZSA9IHsgcGF0aDogW10sIHZhbHVlOiAnJyB9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0geydzeW5jJyB8ICdhc3luYyd9IG1vZGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtpZF9wcmVmaXhdXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihtb2RlLCBpZF9wcmVmaXggPSAnJykge1xuXHRcdHRoaXMubW9kZSA9IG1vZGU7XG5cblx0XHRsZXQgdWlkID0gMTtcblx0XHR0aGlzLnVpZCA9ICgpID0+IGAke2lkX3ByZWZpeH1zJHt1aWQrK31gO1xuXHR9XG5cblx0Z2V0X3RpdGxlKCkge1xuXHRcdHJldHVybiB0aGlzLiN0aXRsZS52YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhIGRlcHRoLWZpcnN0IChsZXhpY29ncmFwaGljKSBjb21wYXJpc29uIHVzaW5nIHRoZSBwYXRoLiBSZWplY3RzIHNldHNcblx0ICogZnJvbSBlYXJsaWVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGN1cnJlbnQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBwYXRoXG5cdCAqL1xuXHRzZXRfdGl0bGUodmFsdWUsIHBhdGgpIHtcblx0XHRjb25zdCBjdXJyZW50ID0gdGhpcy4jdGl0bGUucGF0aDtcblxuXHRcdGxldCBpID0gMDtcblx0XHRsZXQgbCA9IE1hdGgubWluKHBhdGgubGVuZ3RoLCBjdXJyZW50Lmxlbmd0aCk7XG5cblx0XHQvLyBza2lwIGlkZW50aWNhbCBwcmVmaXhlcyAtIFsxLCAyLCAzLCAuLi5dID09PSBbMSwgMiwgMywgLi4uXVxuXHRcdHdoaWxlIChpIDwgbCAmJiBwYXRoW2ldID09PSBjdXJyZW50W2ldKSBpICs9IDE7XG5cblx0XHRpZiAocGF0aFtpXSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cblx0XHQvLyByZXBsYWNlIHRpdGxlIGlmXG5cdFx0Ly8gLSBpbmNvbWluZyBwYXRoIGlzIGxvbmdlciAtIFs3LCA4LCA5XSA+IFs3LCA4XVxuXHRcdC8vIC0gaW5jb21pbmcgcGF0aCBpcyBsYXRlciAgLSBbNywgOCwgOV0gPiBbNywgOCwgOF1cblx0XHRpZiAoY3VycmVudFtpXSA9PT0gdW5kZWZpbmVkIHx8IHBhdGhbaV0gPiBjdXJyZW50W2ldKSB7XG5cdFx0XHR0aGlzLiN0aXRsZS5wYXRoID0gcGF0aDtcblx0XHRcdHRoaXMuI3RpdGxlLnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXHR9XG59XG4iLCAiaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBoYXNoIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHRtbCh2YWx1ZSkge1xuXHR2YXIgaHRtbCA9IFN0cmluZyh2YWx1ZSA/PyAnJyk7XG5cdHZhciBvcGVuID0gREVWID8gYDwhLS0ke2hhc2goaHRtbCl9LS0+YCA6ICc8IS0tLS0+Jztcblx0cmV0dXJuIG9wZW4gKyBodG1sICsgJzwhLS0tLT4nO1xufVxuIiwgIi8qKlxuICogTWFwIG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBjZXJ0YWluIGVsZW1lbnRzIHRoYXQgYXJlIG5vdCBhbGxvd2VkIGluc2lkZSB0aGVtLCBpbiB0aGUgc2Vuc2UgdGhhdCB0aGV5IHdpbGwgYXV0by1jbG9zZSB0aGUgcGFyZW50L2FuY2VzdG9yIGVsZW1lbnQuXG4gKiBUaGVvcmV0aWNhbGx5IG9uZSBjb3VsZCB0YWtlIGFkdmFudGFnZSBvZiBpdCBidXQgbW9zdCBvZiB0aGUgdGltZSBpdCB3aWxsIGp1c3QgcmVzdWx0IGluIGNvbmZ1c2luZyBiZWhhdmlvciBhbmQgYnJlYWsgd2hlbiBTU1InZC5cbiAqIFRoZXJlIGFyZSBtb3JlIGVsZW1lbnRzIHRoYXQgYXJlIGludmFsaWQgaW5zaWRlIG90aGVyIGVsZW1lbnRzLCBidXQgdGhleSdyZSBub3QgYXV0by1jbG9zZWQgYW5kIHNvIGRvbid0IGJyZWFrIFNTUiBhbmQgYXJlIHRoZXJlZm9yZSBub3QgbGlzdGVkIGhlcmUuXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgeyBkaXJlY3Q6IHN0cmluZ1tdfSB8IHsgZGVzY2VuZGFudDogc3RyaW5nW107IHJlc2V0X2J5Pzogc3RyaW5nW10gfT59XG4gKi9cbmNvbnN0IGF1dG9jbG9zaW5nX2NoaWxkcmVuID0ge1xuXHQvLyBiYXNlZCBvbiBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC10YWctb21pc3Npb25cblx0bGk6IHsgZGlyZWN0OiBbJ2xpJ10gfSxcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2R0I3RlY2huaWNhbF9zdW1tYXJ5XG5cdGR0OiB7IGRlc2NlbmRhbnQ6IFsnZHQnLCAnZGQnXSwgcmVzZXRfYnk6IFsnZGwnXSB9LFxuXHRkZDogeyBkZXNjZW5kYW50OiBbJ2R0JywgJ2RkJ10sIHJlc2V0X2J5OiBbJ2RsJ10gfSxcblx0cDoge1xuXHRcdGRlc2NlbmRhbnQ6IFtcblx0XHRcdCdhZGRyZXNzJyxcblx0XHRcdCdhcnRpY2xlJyxcblx0XHRcdCdhc2lkZScsXG5cdFx0XHQnYmxvY2txdW90ZScsXG5cdFx0XHQnZGl2Jyxcblx0XHRcdCdkbCcsXG5cdFx0XHQnZmllbGRzZXQnLFxuXHRcdFx0J2Zvb3RlcicsXG5cdFx0XHQnZm9ybScsXG5cdFx0XHQnaDEnLFxuXHRcdFx0J2gyJyxcblx0XHRcdCdoMycsXG5cdFx0XHQnaDQnLFxuXHRcdFx0J2g1Jyxcblx0XHRcdCdoNicsXG5cdFx0XHQnaGVhZGVyJyxcblx0XHRcdCdoZ3JvdXAnLFxuXHRcdFx0J2hyJyxcblx0XHRcdCdtYWluJyxcblx0XHRcdCdtZW51Jyxcblx0XHRcdCduYXYnLFxuXHRcdFx0J29sJyxcblx0XHRcdCdwJyxcblx0XHRcdCdwcmUnLFxuXHRcdFx0J3NlY3Rpb24nLFxuXHRcdFx0J3RhYmxlJyxcblx0XHRcdCd1bCdcblx0XHRdXG5cdH0sXG5cdHJ0OiB7IGRlc2NlbmRhbnQ6IFsncnQnLCAncnAnXSB9LFxuXHRycDogeyBkZXNjZW5kYW50OiBbJ3J0JywgJ3JwJ10gfSxcblx0b3B0Z3JvdXA6IHsgZGVzY2VuZGFudDogWydvcHRncm91cCddIH0sXG5cdG9wdGlvbjogeyBkZXNjZW5kYW50OiBbJ29wdGlvbicsICdvcHRncm91cCddIH0sXG5cdHRoZWFkOiB7IGRpcmVjdDogWyd0Ym9keScsICd0Zm9vdCddIH0sXG5cdHRib2R5OiB7IGRpcmVjdDogWyd0Ym9keScsICd0Zm9vdCddIH0sXG5cdHRmb290OiB7IGRpcmVjdDogWyd0Ym9keSddIH0sXG5cdHRyOiB7IGRpcmVjdDogWyd0cicsICd0Ym9keSddIH0sXG5cdHRkOiB7IGRpcmVjdDogWyd0ZCcsICd0aCcsICd0ciddIH0sXG5cdHRoOiB7IGRpcmVjdDogWyd0ZCcsICd0aCcsICd0ciddIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0YWcgaXMgZWl0aGVyIHRoZSBsYXN0IGluIHRoZSBsaXN0IG9mIHNpYmxpbmdzIGFuZCB3aWxsIGJlIGF1dG9jbG9zZWQsXG4gKiBvciBub3QgYWxsb3dlZCBpbnNpZGUgdGhlIHBhcmVudCB0YWcgc3VjaCB0aGF0IGl0IHdpbGwgYXV0by1jbG9zZSBpdC4gVGhlIGxhdHRlciByZXN1bHRzXG4gKiBpbiB0aGUgYnJvd3NlciByZXBhaXJpbmcgdGhlIEhUTUwsIHdoaWNoIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiBhbiBlcnJvciBkdXJpbmcgaHlkcmF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmV4dF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3NpbmdfdGFnX29taXR0ZWQoY3VycmVudCwgbmV4dCkge1xuXHRjb25zdCBkaXNhbGxvd2VkID0gYXV0b2Nsb3NpbmdfY2hpbGRyZW5bY3VycmVudF07XG5cdGlmIChkaXNhbGxvd2VkKSB7XG5cdFx0aWYgKFxuXHRcdFx0IW5leHQgfHxcblx0XHRcdCgnZGlyZWN0JyBpbiBkaXNhbGxvd2VkID8gZGlzYWxsb3dlZC5kaXJlY3QgOiBkaXNhbGxvd2VkLmRlc2NlbmRhbnQpLmluY2x1ZGVzKG5leHQpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIE1hcCBvZiBlbGVtZW50cyB0aGF0IGhhdmUgY2VydGFpbiBlbGVtZW50cyB0aGF0IGFyZSBub3QgYWxsb3dlZCBpbnNpZGUgdGhlbSwgaW4gdGhlIHNlbnNlIHRoYXQgdGhlIGJyb3dzZXIgd2lsbCBzb21laG93IHJlcGFpciB0aGUgSFRNTC5cbiAqIFRoZXJlIGFyZSBtb3JlIGVsZW1lbnRzIHRoYXQgYXJlIGludmFsaWQgaW5zaWRlIG90aGVyIGVsZW1lbnRzLCBidXQgdGhleSdyZSBub3QgcmVwYWlyZWQgYW5kIHNvIGRvbid0IGJyZWFrIFNTUiBhbmQgYXJlIHRoZXJlZm9yZSBub3QgbGlzdGVkIGhlcmUuXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgeyBkaXJlY3Q6IHN0cmluZ1tdfSB8IHsgZGVzY2VuZGFudDogc3RyaW5nW107IHJlc2V0X2J5Pzogc3RyaW5nW107IG9ubHk/OiBzdHJpbmdbXSB9IHwgeyBvbmx5OiBzdHJpbmdbXSB9Pn1cbiAqL1xuY29uc3QgZGlzYWxsb3dlZF9jaGlsZHJlbiA9IHtcblx0Li4uYXV0b2Nsb3NpbmdfY2hpbGRyZW4sXG5cdG9wdGdyb3VwOiB7IG9ubHk6IFsnb3B0aW9uJywgJyN0ZXh0J10gfSxcblx0Ly8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PiwgYnV0IHdlIGFzc3VtZSBpdCBoZXJlXG5cdG9wdGlvbjogeyBvbmx5OiBbJyN0ZXh0J10gfSxcblx0Zm9ybTogeyBkZXNjZW5kYW50OiBbJ2Zvcm0nXSB9LFxuXHRhOiB7IGRlc2NlbmRhbnQ6IFsnYSddIH0sXG5cdGJ1dHRvbjogeyBkZXNjZW5kYW50OiBbJ2J1dHRvbiddIH0sXG5cdGgxOiB7IGRlc2NlbmRhbnQ6IFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnXSB9LFxuXHRoMjogeyBkZXNjZW5kYW50OiBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2J10gfSxcblx0aDM6IHsgZGVzY2VuZGFudDogWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddIH0sXG5cdGg0OiB7IGRlc2NlbmRhbnQ6IFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnXSB9LFxuXHRoNTogeyBkZXNjZW5kYW50OiBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2J10gfSxcblx0aDY6IHsgZGVzY2VuZGFudDogWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddIH0sXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuXHRzZWxlY3Q6IHsgb25seTogWydvcHRpb24nLCAnb3B0Z3JvdXAnLCAnI3RleHQnLCAnaHInLCAnc2NyaXB0JywgJ3RlbXBsYXRlJ10gfSxcblxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG5cdC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG5cdC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcblx0dHI6IHsgb25seTogWyd0aCcsICd0ZCcsICdzdHlsZScsICdzY3JpcHQnLCAndGVtcGxhdGUnXSB9LFxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuXHR0Ym9keTogeyBvbmx5OiBbJ3RyJywgJ3N0eWxlJywgJ3NjcmlwdCcsICd0ZW1wbGF0ZSddIH0sXG5cdHRoZWFkOiB7IG9ubHk6IFsndHInLCAnc3R5bGUnLCAnc2NyaXB0JywgJ3RlbXBsYXRlJ10gfSxcblx0dGZvb3Q6IHsgb25seTogWyd0cicsICdzdHlsZScsICdzY3JpcHQnLCAndGVtcGxhdGUnXSB9LFxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuXHRjb2xncm91cDogeyBvbmx5OiBbJ2NvbCcsICd0ZW1wbGF0ZSddIH0sXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG5cdHRhYmxlOiB7XG5cdFx0b25seTogWydjYXB0aW9uJywgJ2NvbGdyb3VwJywgJ3Rib2R5JywgJ3RoZWFkJywgJ3Rmb290JywgJ3N0eWxlJywgJ3NjcmlwdCcsICd0ZW1wbGF0ZSddXG5cdH0sXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcblx0aGVhZDoge1xuXHRcdG9ubHk6IFtcblx0XHRcdCdiYXNlJyxcblx0XHRcdCdiYXNlZm9udCcsXG5cdFx0XHQnYmdzb3VuZCcsXG5cdFx0XHQnbGluaycsXG5cdFx0XHQnbWV0YScsXG5cdFx0XHQndGl0bGUnLFxuXHRcdFx0J25vc2NyaXB0Jyxcblx0XHRcdCdub2ZyYW1lcycsXG5cdFx0XHQnc3R5bGUnLFxuXHRcdFx0J3NjcmlwdCcsXG5cdFx0XHQndGVtcGxhdGUnXG5cdFx0XVxuXHR9LFxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG5cdGh0bWw6IHsgb25seTogWydoZWFkJywgJ2JvZHknLCAnZnJhbWVzZXQnXSB9LFxuXHRmcmFtZXNldDogeyBvbmx5OiBbJ2ZyYW1lJ10gfSxcblx0JyNkb2N1bWVudCc6IHsgb25seTogWydodG1sJ10gfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIHRhZyBpcyBub3QgYWxsb3dlZCBpbnNpZGUgdGhlIGFuY2VzdG9yIHRhZyAod2hpY2ggaXMgZ3JhbmRwYXJlbnQgYW5kIGFib3ZlKSBzdWNoIHRoYXQgaXQgd2lsbCByZXN1bHRcbiAqIGluIHRoZSBicm93c2VyIHJlcGFpcmluZyB0aGUgSFRNTCwgd2hpY2ggd2lsbCBsaWtlbHkgcmVzdWx0IGluIGFuIGVycm9yIGR1cmluZyBoeWRyYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRfdGFnXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhbmNlc3RvcnMgQWxsIG5vZGVzIHN0YXJ0aW5nIHdpdGggdGhlIHBhcmVudCwgdXAgdW50aWwgdGhlIGFuY2VzdG9yLCB3aGljaCBtZWFucyB0d28gZW50cmllcyBtaW5pbXVtXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NoaWxkX2xvY11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYW5jZXN0b3JfbG9jXVxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc190YWdfdmFsaWRfd2l0aF9hbmNlc3RvcihjaGlsZF90YWcsIGFuY2VzdG9ycywgY2hpbGRfbG9jLCBhbmNlc3Rvcl9sb2MpIHtcblx0aWYgKGNoaWxkX3RhZy5pbmNsdWRlcygnLScpKSByZXR1cm4gbnVsbDsgLy8gY3VzdG9tIGVsZW1lbnRzIGNhbiBiZSBhbnl0aGluZ1xuXG5cdGNvbnN0IGFuY2VzdG9yX3RhZyA9IGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoIC0gMV07XG5cdGNvbnN0IGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkX2NoaWxkcmVuW2FuY2VzdG9yX3RhZ107XG5cdGlmICghZGlzYWxsb3dlZCkgcmV0dXJuIG51bGw7XG5cblx0aWYgKCdyZXNldF9ieScgaW4gZGlzYWxsb3dlZCAmJiBkaXNhbGxvd2VkLnJlc2V0X2J5KSB7XG5cdFx0Zm9yIChsZXQgaSA9IGFuY2VzdG9ycy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cdFx0XHRpZiAoYW5jZXN0b3IuaW5jbHVkZXMoJy0nKSkgcmV0dXJuIG51bGw7IC8vIGN1c3RvbSBlbGVtZW50cyBjYW4gYmUgYW55dGhpbmdcblxuXHRcdFx0Ly8gQSByZXNldCBtZWFucyB0aGF0IGZvcmJpZGRlbiBkZXNjZW5kYW50cyBhcmUgYWxsb3dlZCBhZ2FpblxuXHRcdFx0aWYgKGRpc2FsbG93ZWQucmVzZXRfYnkuaW5jbHVkZXMoYW5jZXN0b3JzW2ldKSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoJ2Rlc2NlbmRhbnQnIGluIGRpc2FsbG93ZWQgJiYgZGlzYWxsb3dlZC5kZXNjZW5kYW50LmluY2x1ZGVzKGNoaWxkX3RhZykpIHtcblx0XHRjb25zdCBjaGlsZCA9IGNoaWxkX2xvYyA/IGBcXGA8JHtjaGlsZF90YWd9PlxcYCAoJHtjaGlsZF9sb2N9KWAgOiBgXFxgPCR7Y2hpbGRfdGFnfT5cXGBgO1xuXHRcdGNvbnN0IGFuY2VzdG9yID0gYW5jZXN0b3JfbG9jXG5cdFx0XHQ/IGBcXGA8JHthbmNlc3Rvcl90YWd9PlxcYCAoJHthbmNlc3Rvcl9sb2N9KWBcblx0XHRcdDogYFxcYDwke2FuY2VzdG9yX3RhZ30+XFxgYDtcblxuXHRcdHJldHVybiBgJHtjaGlsZH0gY2Fubm90IGJlIGEgZGVzY2VuZGFudCBvZiAke2FuY2VzdG9yfWA7XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIHRhZyBpcyBub3QgYWxsb3dlZCBpbnNpZGUgdGhlIHBhcmVudCB0YWcgc3VjaCB0aGF0IGl0IHdpbGwgcmVzdWx0XG4gKiBpbiB0aGUgYnJvd3NlciByZXBhaXJpbmcgdGhlIEhUTUwsIHdoaWNoIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiBhbiBlcnJvciBkdXJpbmcgaHlkcmF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkX3RhZ1xuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudF90YWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hpbGRfbG9jXVxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJlbnRfbG9jXVxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc190YWdfdmFsaWRfd2l0aF9wYXJlbnQoY2hpbGRfdGFnLCBwYXJlbnRfdGFnLCBjaGlsZF9sb2MsIHBhcmVudF9sb2MpIHtcblx0aWYgKGNoaWxkX3RhZy5pbmNsdWRlcygnLScpIHx8IHBhcmVudF90YWc/LmluY2x1ZGVzKCctJykpIHJldHVybiBudWxsOyAvLyBjdXN0b20gZWxlbWVudHMgY2FuIGJlIGFueXRoaW5nXG5cblx0aWYgKHBhcmVudF90YWcgPT09ICd0ZW1wbGF0ZScpIHJldHVybiBudWxsOyAvLyBubyBlcnJvcnMgb3Igd2FybmluZyBzaG91bGQgYmUgdGhyb3duIGluIGltbWVkaWF0ZSBjaGlsZHJlbiBvZiB0ZW1wbGF0ZSB0YWdzXG5cblx0Y29uc3QgZGlzYWxsb3dlZCA9IGRpc2FsbG93ZWRfY2hpbGRyZW5bcGFyZW50X3RhZ107XG5cblx0Y29uc3QgY2hpbGQgPSBjaGlsZF9sb2MgPyBgXFxgPCR7Y2hpbGRfdGFnfT5cXGAgKCR7Y2hpbGRfbG9jfSlgIDogYFxcYDwke2NoaWxkX3RhZ30+XFxgYDtcblx0Y29uc3QgcGFyZW50ID0gcGFyZW50X2xvYyA/IGBcXGA8JHtwYXJlbnRfdGFnfT5cXGAgKCR7cGFyZW50X2xvY30pYCA6IGBcXGA8JHtwYXJlbnRfdGFnfT5cXGBgO1xuXG5cdGlmIChkaXNhbGxvd2VkKSB7XG5cdFx0aWYgKCdkaXJlY3QnIGluIGRpc2FsbG93ZWQgJiYgZGlzYWxsb3dlZC5kaXJlY3QuaW5jbHVkZXMoY2hpbGRfdGFnKSkge1xuXHRcdFx0cmV0dXJuIGAke2NoaWxkfSBjYW5ub3QgYmUgYSBkaXJlY3QgY2hpbGQgb2YgJHtwYXJlbnR9YDtcblx0XHR9XG5cblx0XHRpZiAoJ2Rlc2NlbmRhbnQnIGluIGRpc2FsbG93ZWQgJiYgZGlzYWxsb3dlZC5kZXNjZW5kYW50LmluY2x1ZGVzKGNoaWxkX3RhZykpIHtcblx0XHRcdHJldHVybiBgJHtjaGlsZH0gY2Fubm90IGJlIGEgY2hpbGQgb2YgJHtwYXJlbnR9YDtcblx0XHR9XG5cblx0XHRpZiAoJ29ubHknIGluIGRpc2FsbG93ZWQgJiYgZGlzYWxsb3dlZC5vbmx5KSB7XG5cdFx0XHRpZiAoZGlzYWxsb3dlZC5vbmx5LmluY2x1ZGVzKGNoaWxkX3RhZykpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gYCR7Y2hpbGR9IGNhbm5vdCBiZSBhIGNoaWxkIG9mICR7cGFyZW50fS4gXFxgPCR7cGFyZW50X3RhZ30+XFxgIG9ubHkgYWxsb3dzIHRoZXNlIGNoaWxkcmVuOiAke2Rpc2FsbG93ZWQub25seS5tYXAoKGQpID0+IGBcXGA8JHtkfT5cXGBgKS5qb2luKCcsICcpfWA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcblx0Ly8gcGFyc2luZyBydWxlcyAtIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG5cdC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuXHQvLyBjYXNlcyBhcmUgaW52YWxpZCAoYW5kIHdlIG9ubHkgZ2V0IGludG8gdGhpcyBmdW5jdGlvbiBpZiB3ZSBrbm93IHRoZSBwYXJlbnQpLlxuXHRzd2l0Y2ggKGNoaWxkX3RhZykge1xuXHRcdGNhc2UgJ2JvZHknOlxuXHRcdGNhc2UgJ2NhcHRpb24nOlxuXHRcdGNhc2UgJ2NvbCc6XG5cdFx0Y2FzZSAnY29sZ3JvdXAnOlxuXHRcdGNhc2UgJ2ZyYW1lc2V0Jzpcblx0XHRjYXNlICdmcmFtZSc6XG5cdFx0Y2FzZSAnaGVhZCc6XG5cdFx0Y2FzZSAnaHRtbCc6XG5cdFx0XHRyZXR1cm4gYCR7Y2hpbGR9IGNhbm5vdCBiZSBhIGNoaWxkIG9mICR7cGFyZW50fWA7XG5cdFx0Y2FzZSAndGhlYWQnOlxuXHRcdGNhc2UgJ3Rib2R5Jzpcblx0XHRjYXNlICd0Zm9vdCc6XG5cdFx0XHRyZXR1cm4gYCR7Y2hpbGR9IG11c3QgYmUgdGhlIGNoaWxkIG9mIGEgXFxgPHRhYmxlPlxcYCwgbm90IGEgJHtwYXJlbnR9YDtcblx0XHRjYXNlICd0ZCc6XG5cdFx0Y2FzZSAndGgnOlxuXHRcdFx0cmV0dXJuIGAke2NoaWxkfSBtdXN0IGJlIHRoZSBjaGlsZCBvZiBhIFxcYDx0cj5cXGAsIG5vdCBhICR7cGFyZW50fWA7XG5cdFx0Y2FzZSAndHInOlxuXHRcdFx0cmV0dXJuIGBcXGA8dHI+XFxgIG11c3QgYmUgdGhlIGNoaWxkIG9mIGEgXFxgPHRoZWFkPlxcYCwgXFxgPHRib2R5PlxcYCwgb3IgXFxgPHRmb290PlxcYCwgbm90IGEgJHtwYXJlbnR9YDtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgU1NSQ29udGV4dCB9IGZyb20gJyNzZXJ2ZXInICovXG5pbXBvcnQgeyBGSUxFTkFNRSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRpc190YWdfdmFsaWRfd2l0aF9hbmNlc3Rvcixcblx0aXNfdGFnX3ZhbGlkX3dpdGhfcGFyZW50XG59IGZyb20gJy4uLy4uL2h0bWwtdHJlZS12YWxpZGF0aW9uLmpzJztcbmltcG9ydCB7IGdldF9zdGFjayB9IGZyb20gJy4uL3NoYXJlZC9kZXYuanMnO1xuaW1wb3J0IHsgc2V0X3Nzcl9jb250ZXh0LCBzc3JfY29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXJlci5qcyc7XG5cbi8vIFRPRE8gbW92ZSB0aGlzXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdHRhZzogc3RyaW5nO1xuICogXHRwYXJlbnQ6IHVuZGVmaW5lZCB8IEVsZW1lbnQ7XG4gKiAgZmlsZW5hbWU6IHVuZGVmaW5lZCB8IHN0cmluZztcbiAqICBsaW5lOiBudW1iZXI7XG4gKiAgY29sdW1uOiBudW1iZXI7XG4gKiB9fSBFbGVtZW50XG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGV4cG9ydGVkIHNvIHRoYXQgaXQgY2FuIGJlIGNsZWFyZWQgYmV0d2VlbiB0ZXN0c1xuICogQHR5cGUge1NldDxzdHJpbmc+fVxuICovXG5leHBvcnQgbGV0IHNlZW47XG5cbi8qKlxuICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIHByaW50X2Vycm9yKHJlbmRlcmVyLCBtZXNzYWdlKSB7XG5cdG1lc3NhZ2UgPVxuXHRcdGBub2RlX2ludmFsaWRfcGxhY2VtZW50X3NzcjogJHttZXNzYWdlfVxcblxcbmAgK1xuXHRcdCdUaGlzIGNhbiBjYXVzZSBjb250ZW50IHRvIHNoaWZ0IGFyb3VuZCBhcyB0aGUgYnJvd3NlciByZXBhaXJzIHRoZSBIVE1MLCBhbmQgd2lsbCBsaWtlbHkgcmVzdWx0IGluIGEgYGh5ZHJhdGlvbl9taXNtYXRjaGAgd2FybmluZy4nO1xuXG5cdGlmICgoc2VlbiA/Pz0gbmV3IFNldCgpKS5oYXMobWVzc2FnZSkpIHJldHVybjtcblx0c2Vlbi5hZGQobWVzc2FnZSk7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0Y29uc29sZS5lcnJvcihtZXNzYWdlKTtcblx0cmVuZGVyZXIuaGVhZCgocikgPT4gci5wdXNoKGA8c2NyaXB0PmNvbnNvbGUuZXJyb3IoJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX0pPC9zY3JpcHQ+YCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcGFyYW0ge251bWJlcn0gbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtblxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaF9lbGVtZW50KHJlbmRlcmVyLCB0YWcsIGxpbmUsIGNvbHVtbikge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7U1NSQ29udGV4dH0gKi8gKHNzcl9jb250ZXh0KTtcblx0dmFyIGZpbGVuYW1lID0gY29udGV4dC5mdW5jdGlvbltGSUxFTkFNRV07XG5cdHZhciBwYXJlbnQgPSBjb250ZXh0LmVsZW1lbnQ7XG5cdHZhciBlbGVtZW50ID0geyB0YWcsIHBhcmVudCwgZmlsZW5hbWUsIGxpbmUsIGNvbHVtbiB9O1xuXG5cdGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBhbmNlc3RvciA9IHBhcmVudC5wYXJlbnQ7XG5cdFx0dmFyIGFuY2VzdG9ycyA9IFtwYXJlbnQudGFnXTtcblxuXHRcdGNvbnN0IGNoaWxkX2xvYyA9IGZpbGVuYW1lID8gYCR7ZmlsZW5hbWV9OiR7bGluZX06JHtjb2x1bW59YCA6IHVuZGVmaW5lZDtcblx0XHRjb25zdCBwYXJlbnRfbG9jID0gcGFyZW50LmZpbGVuYW1lXG5cdFx0XHQ/IGAke3BhcmVudC5maWxlbmFtZX06JHtwYXJlbnQubGluZX06JHtwYXJlbnQuY29sdW1ufWBcblx0XHRcdDogdW5kZWZpbmVkO1xuXG5cdFx0Y29uc3QgbWVzc2FnZSA9IGlzX3RhZ192YWxpZF93aXRoX3BhcmVudCh0YWcsIHBhcmVudC50YWcsIGNoaWxkX2xvYywgcGFyZW50X2xvYyk7XG5cdFx0aWYgKG1lc3NhZ2UpIHByaW50X2Vycm9yKHJlbmRlcmVyLCBtZXNzYWdlKTtcblxuXHRcdHdoaWxlIChhbmNlc3RvciAhPSBudWxsKSB7XG5cdFx0XHRhbmNlc3RvcnMucHVzaChhbmNlc3Rvci50YWcpO1xuXHRcdFx0Y29uc3QgYW5jZXN0b3JfbG9jID0gYW5jZXN0b3IuZmlsZW5hbWVcblx0XHRcdFx0PyBgJHthbmNlc3Rvci5maWxlbmFtZX06JHthbmNlc3Rvci5saW5lfToke2FuY2VzdG9yLmNvbHVtbn1gXG5cdFx0XHRcdDogdW5kZWZpbmVkO1xuXG5cdFx0XHRjb25zdCBtZXNzYWdlID0gaXNfdGFnX3ZhbGlkX3dpdGhfYW5jZXN0b3IodGFnLCBhbmNlc3RvcnMsIGNoaWxkX2xvYywgYW5jZXN0b3JfbG9jKTtcblx0XHRcdGlmIChtZXNzYWdlKSBwcmludF9lcnJvcihyZW5kZXJlciwgbWVzc2FnZSk7XG5cblx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdHNldF9zc3JfY29udGV4dCh7IC4uLmNvbnRleHQsIHA6IGNvbnRleHQsIGVsZW1lbnQgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BfZWxlbWVudCgpIHtcblx0c2V0X3Nzcl9jb250ZXh0KC8qKiBAdHlwZSB7U1NSQ29udGV4dH0gKi8gKHNzcl9jb250ZXh0KS5wKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc25pcHBldF9hcmdzKHJlbmRlcmVyKSB7XG5cdGlmIChcblx0XHR0eXBlb2YgcmVuZGVyZXIgIT09ICdvYmplY3QnIHx8XG5cdFx0Ly8gZm9yIHNvbWUgcmVhc29uIHR5cGVzY3JpcHQgY29uc2lkZXIgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYXMgbmV2ZXIgYWZ0ZXIgdGhlIGZpcnN0IGluc3RhbmNlb2Zcblx0XHQhKHJlbmRlcmVyIGluc3RhbmNlb2YgUmVuZGVyZXIpXG5cdCkge1xuXHRcdGUuaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50cygpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfdXNlcl9jb2RlX2xvY2F0aW9uKCkge1xuXHRjb25zdCBzdGFjayA9IGdldF9zdGFjaygpO1xuXG5cdHJldHVybiBzdGFja1xuXHRcdC5maWx0ZXIoKGxpbmUpID0+IGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2F0ICcpKVxuXHRcdC5tYXAoKGxpbmUpID0+IGxpbmUucmVwbGFjZSgvXFwoKC4qKTpcXGQrOlxcZCtcXCkkLywgKF8sIGZpbGUpID0+IGAoJHtmaWxlfSlgKSlcblx0XHQuam9pbignXFxuJyk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRUeXBlLCBTdmVsdGVDb21wb25lbnQsIENvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZScgKi9cbi8qKiBAaW1wb3J0IHsgUmVuZGVyT3V0cHV0IH0gZnJvbSAnI3NlcnZlcicgKi9cbi8qKiBAaW1wb3J0IHsgU3RvcmUgfSBmcm9tICcjc2hhcmVkJyAqL1xuLyoqIEBpbXBvcnQgeyBBY2N1bXVsYXRlZENvbnRlbnQgfSBmcm9tICcuL3JlbmRlcmVyLmpzJyAqL1xuZXhwb3J0IHsgRklMRU5BTUUsIEhNUiB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBhdHRyLCBjbHN4LCB0b19jbGFzcywgdG9fc3R5bGUgfSBmcm9tICcuLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBpc19wcm9taXNlLCBub29wIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHN1YnNjcmliZV90b19zdG9yZSB9IGZyb20gJy4uLy4uL3N0b3JlL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdFVOSU5JVElBTElaRUQsXG5cdEVMRU1FTlRfUFJFU0VSVkVfQVRUUklCVVRFX0NBU0UsXG5cdEVMRU1FTlRfSVNfTkFNRVNQQUNFRCxcblx0RUxFTUVOVF9JU19JTlBVVFxufSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZXNjYXBlX2h0bWwgfSBmcm9tICcuLi8uLi9lc2NhcGluZy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IEVNUFRZX0NPTU1FTlQsIEJMT0NLX0NMT1NFLCBCTE9DS19PUEVOLCBCTE9DS19PUEVOX0VMU0UgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZV9zdG9yZSB9IGZyb20gJy4uL3NoYXJlZC92YWxpZGF0ZS5qcyc7XG5pbXBvcnQgeyBpc19ib29sZWFuX2F0dHJpYnV0ZSwgaXNfcmF3X3RleHRfZWxlbWVudCwgaXNfdm9pZCB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXJlci5qcyc7XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuY29uc3QgSU5WQUxJRF9BVFRSX05BTUVfQ0hBUl9SRUdFWCA9XG5cdC9bXFxzJ1wiPi89XFx1e0ZERDB9LVxcdXtGREVGfVxcdXtGRkZFfVxcdXtGRkZGfVxcdXsxRkZGRX1cXHV7MUZGRkZ9XFx1ezJGRkZFfVxcdXsyRkZGRn1cXHV7M0ZGRkV9XFx1ezNGRkZGfVxcdXs0RkZGRX1cXHV7NEZGRkZ9XFx1ezVGRkZFfVxcdXs1RkZGRn1cXHV7NkZGRkV9XFx1ezZGRkZGfVxcdXs3RkZGRX1cXHV7N0ZGRkZ9XFx1ezhGRkZFfVxcdXs4RkZGRn1cXHV7OUZGRkV9XFx1ezlGRkZGfVxcdXtBRkZGRX1cXHV7QUZGRkZ9XFx1e0JGRkZFfVxcdXtCRkZGRn1cXHV7Q0ZGRkV9XFx1e0NGRkZGfVxcdXtERkZGRX1cXHV7REZGRkZ9XFx1e0VGRkZFfVxcdXtFRkZGRn1cXHV7RkZGRkV9XFx1e0ZGRkZGfVxcdXsxMEZGRkV9XFx1ezEwRkZGRn1dL3U7XG5cbi8qKlxuICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gYXR0cmlidXRlc19mblxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjaGlsZHJlbl9mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50KHJlbmRlcmVyLCB0YWcsIGF0dHJpYnV0ZXNfZm4gPSBub29wLCBjaGlsZHJlbl9mbiA9IG5vb3ApIHtcblx0cmVuZGVyZXIucHVzaCgnPCEtLS0tPicpO1xuXG5cdGlmICh0YWcpIHtcblx0XHRyZW5kZXJlci5wdXNoKGA8JHt0YWd9YCk7XG5cdFx0YXR0cmlidXRlc19mbigpO1xuXHRcdHJlbmRlcmVyLnB1c2goYD5gKTtcblxuXHRcdGlmICghaXNfdm9pZCh0YWcpKSB7XG5cdFx0XHRjaGlsZHJlbl9mbigpO1xuXHRcdFx0aWYgKCFpc19yYXdfdGV4dF9lbGVtZW50KHRhZykpIHtcblx0XHRcdFx0cmVuZGVyZXIucHVzaChFTVBUWV9DT01NRU5UKTtcblx0XHRcdH1cblx0XHRcdHJlbmRlcmVyLnB1c2goYDwvJHt0YWd9PmApO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcmVyLnB1c2goJzwhLS0tLT4nKTtcbn1cblxuLyoqXG4gKiBPbmx5IGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyIGFuZCB3aGVuIGNvbXBpbGluZyB3aXRoIHRoZSBgc2VydmVyYCBvcHRpb24uXG4gKiBUYWtlcyBhIGNvbXBvbmVudCBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgYm9keWAgYW5kIGBoZWFkYCBwcm9wZXJ0aWVzIG9uIGl0LCB3aGljaCB5b3UgY2FuIHVzZSB0byBwb3B1bGF0ZSB0aGUgSFRNTCB3aGVuIHNlcnZlci1yZW5kZXJpbmcgeW91ciBhcHAuXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG4gKiBAcGFyYW0ge0NvbXBvbmVudDxQcm9wcz4gfCBDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxQcm9wcz4+fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7eyBwcm9wcz86IE9taXQ8UHJvcHMsICckJHNsb3RzJyB8ICckJGV2ZW50cyc+OyBjb250ZXh0PzogTWFwPGFueSwgYW55PjsgaWRQcmVmaXg/OiBzdHJpbmcgfX0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7UmVuZGVyT3V0cHV0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKGNvbXBvbmVudCwgb3B0aW9ucyA9IHt9KSB7XG5cdHJldHVybiBSZW5kZXJlci5yZW5kZXIoLyoqIEB0eXBlIHtDb21wb25lbnQ8UHJvcHM+fSAqLyAoY29tcG9uZW50KSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcbiAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gKiBAcGFyYW0geyhyZW5kZXJlcjogUmVuZGVyZXIpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFkKGhhc2gsIHJlbmRlcmVyLCBmbikge1xuXHRyZW5kZXJlci5oZWFkKChyZW5kZXJlcikgPT4ge1xuXHRcdHJlbmRlcmVyLnB1c2goYDwhLS0ke2hhc2h9LS0+YCk7XG5cdFx0cmVuZGVyZXIuY2hpbGQoZm4pO1xuXHRcdHJlbmRlcmVyLnB1c2goRU1QVFlfQ09NTUVOVCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX2h0bWxcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gcHJvcHNcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGR5bmFtaWNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3NzX3Byb3BzKHJlbmRlcmVyLCBpc19odG1sLCBwcm9wcywgY29tcG9uZW50LCBkeW5hbWljID0gZmFsc2UpIHtcblx0Y29uc3Qgc3R5bGVzID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhwcm9wcyk7XG5cblx0aWYgKGlzX2h0bWwpIHtcblx0XHRyZW5kZXJlci5wdXNoKGA8c3ZlbHRlLWNzcy13cmFwcGVyIHN0eWxlPVwiZGlzcGxheTogY29udGVudHM7ICR7c3R5bGVzfVwiPmApO1xuXHR9IGVsc2Uge1xuXHRcdHJlbmRlcmVyLnB1c2goYDxnIHN0eWxlPVwiJHtzdHlsZXN9XCI+YCk7XG5cdH1cblxuXHRpZiAoZHluYW1pYykge1xuXHRcdHJlbmRlcmVyLnB1c2goJzwhLS0tLT4nKTtcblx0fVxuXG5cdGNvbXBvbmVudCgpO1xuXG5cdGlmIChpc19odG1sKSB7XG5cdFx0cmVuZGVyZXIucHVzaChgPCEtLS0tPjwvc3ZlbHRlLWNzcy13cmFwcGVyPmApO1xuXHR9IGVsc2Uge1xuXHRcdHJlbmRlcmVyLnB1c2goYDwhLS0tLT48L2c+YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBhdHRyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjc3NfaGFzaF1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59IFtjbGFzc2VzXVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBbc3R5bGVzXVxuICogQHBhcmFtIHtudW1iZXJ9IFtmbGFnc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyaWJ1dGVzKGF0dHJzLCBjc3NfaGFzaCwgY2xhc3Nlcywgc3R5bGVzLCBmbGFncyA9IDApIHtcblx0aWYgKHN0eWxlcykge1xuXHRcdGF0dHJzLnN0eWxlID0gdG9fc3R5bGUoYXR0cnMuc3R5bGUsIHN0eWxlcyk7XG5cdH1cblxuXHRpZiAoYXR0cnMuY2xhc3MpIHtcblx0XHRhdHRycy5jbGFzcyA9IGNsc3goYXR0cnMuY2xhc3MpO1xuXHR9XG5cblx0aWYgKGNzc19oYXNoIHx8IGNsYXNzZXMpIHtcblx0XHRhdHRycy5jbGFzcyA9IHRvX2NsYXNzKGF0dHJzLmNsYXNzLCBjc3NfaGFzaCwgY2xhc3Nlcyk7XG5cdH1cblxuXHRsZXQgYXR0cl9zdHIgPSAnJztcblx0bGV0IG5hbWU7XG5cblx0Y29uc3QgaXNfaHRtbCA9IChmbGFncyAmIEVMRU1FTlRfSVNfTkFNRVNQQUNFRCkgPT09IDA7XG5cdGNvbnN0IGxvd2VyY2FzZSA9IChmbGFncyAmIEVMRU1FTlRfUFJFU0VSVkVfQVRUUklCVVRFX0NBU0UpID09PSAwO1xuXHRjb25zdCBpc19pbnB1dCA9IChmbGFncyAmIEVMRU1FTlRfSVNfSU5QVVQpICE9PSAwO1xuXG5cdGZvciAobmFtZSBpbiBhdHRycykge1xuXHRcdC8vIG9taXQgZnVuY3Rpb25zLCBpbnRlcm5hbCBzdmVsdGUgcHJvcGVydGllcyBhbmQgaW52YWxpZCBhdHRyaWJ1dGUgbmFtZXNcblx0XHRpZiAodHlwZW9mIGF0dHJzW25hbWVdID09PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcblx0XHRpZiAobmFtZVswXSA9PT0gJyQnICYmIG5hbWVbMV0gPT09ICckJykgY29udGludWU7IC8vIGZhc3RlciB0aGFuIG5hbWUuc3RhcnRzV2l0aCgnJCQnKVxuXHRcdGlmIChJTlZBTElEX0FUVFJfTkFNRV9DSEFSX1JFR0VYLnRlc3QobmFtZSkpIGNvbnRpbnVlO1xuXG5cdFx0dmFyIHZhbHVlID0gYXR0cnNbbmFtZV07XG5cblx0XHRpZiAobG93ZXJjYXNlKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdGlmIChpc19pbnB1dCkge1xuXHRcdFx0aWYgKG5hbWUgPT09ICdkZWZhdWx0dmFsdWUnIHx8IG5hbWUgPT09ICdkZWZhdWx0Y2hlY2tlZCcpIHtcblx0XHRcdFx0bmFtZSA9IG5hbWUgPT09ICdkZWZhdWx0dmFsdWUnID8gJ3ZhbHVlJyA6ICdjaGVja2VkJztcblx0XHRcdFx0aWYgKGF0dHJzW25hbWVdKSBjb250aW51ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhdHRyX3N0ciArPSBhdHRyKG5hbWUsIHZhbHVlLCBpc19odG1sICYmIGlzX2Jvb2xlYW5fYXR0cmlidXRlKG5hbWUpKTtcblx0fVxuXG5cdHJldHVybiBhdHRyX3N0cjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+W119IHByb3BzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWRfcHJvcHMocHJvcHMpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gKi9cblx0Y29uc3QgbWVyZ2VkX3Byb3BzID0ge307XG5cdGxldCBrZXk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IG9iaiA9IHByb3BzW2ldO1xuXHRcdGZvciAoa2V5IGluIG9iaikge1xuXHRcdFx0Y29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuXHRcdFx0aWYgKGRlc2MpIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1lcmdlZF9wcm9wcywga2V5LCBkZXNjKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lcmdlZF9wcm9wc1trZXldID0gb2JqW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtZXJnZWRfcHJvcHM7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUgKyAnJztcbn1cblxuLyoqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gc3R5bGVfb2JqZWN0ICovXG5mdW5jdGlvbiBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVfb2JqZWN0KVxuXHRcdC5maWx0ZXIoLyoqIEBwYXJhbSB7YW55fSBrZXkgKi8gKGtleSkgPT4gc3R5bGVfb2JqZWN0W2tleV0gIT0gbnVsbCAmJiBzdHlsZV9vYmplY3Rba2V5XSAhPT0gJycpXG5cdFx0Lm1hcCgvKiogQHBhcmFtIHthbnl9IGtleSAqLyAoa2V5KSA9PiBgJHtrZXl9OiAke2VzY2FwZV9odG1sKHN0eWxlX29iamVjdFtrZXldLCB0cnVlKX07YClcblx0XHQuam9pbignICcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtoYXNoXVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn0gW2RpcmVjdGl2ZXNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyX2NsYXNzKHZhbHVlLCBoYXNoLCBkaXJlY3RpdmVzKSB7XG5cdHZhciByZXN1bHQgPSB0b19jbGFzcyh2YWx1ZSwgaGFzaCwgZGlyZWN0aXZlcyk7XG5cdHJldHVybiByZXN1bHQgPyBgIGNsYXNzPVwiJHtlc2NhcGVfaHRtbChyZXN1bHQsIHRydWUpfVwiYCA6ICcnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLGFueT58W1JlY29yZDxzdHJpbmcsYW55PixSZWNvcmQ8c3RyaW5nLGFueT5dfSBbZGlyZWN0aXZlc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHJfc3R5bGUodmFsdWUsIGRpcmVjdGl2ZXMpIHtcblx0dmFyIHJlc3VsdCA9IHRvX3N0eWxlKHZhbHVlLCBkaXJlY3RpdmVzKTtcblx0cmV0dXJuIHJlc3VsdCA/IGAgc3R5bGU9XCIke2VzY2FwZV9odG1sKHJlc3VsdCwgdHJ1ZSl9XCJgIDogJyc7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgW2FueSwgYW55LCBhbnldPn0gc3RvcmVfdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICogQHBhcmFtIHtTdG9yZTxWPiB8IG51bGwgfCB1bmRlZmluZWR9IHN0b3JlXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2dldChzdG9yZV92YWx1ZXMsIHN0b3JlX25hbWUsIHN0b3JlKSB7XG5cdGlmIChERVYpIHtcblx0XHR2YWxpZGF0ZV9zdG9yZShzdG9yZSwgc3RvcmVfbmFtZS5zbGljZSgxKSk7XG5cdH1cblxuXHQvLyBpdCBjb3VsZCBiZSB0aGF0IHNvbWVvbmUgZWFnZXJseSB1cGRhdGVzIHRoZSBzdG9yZSBpbiB0aGUgaW5zdGFuY2Ugc2NyaXB0LCBzb1xuXHQvLyB3ZSBzaG91bGQgb25seSByZXVzZSB0aGUgc3RvcmUgdmFsdWUgaW4gdGhlIHRlbXBsYXRlXG5cdGlmIChzdG9yZV9uYW1lIGluIHN0b3JlX3ZhbHVlcyAmJiBzdG9yZV92YWx1ZXNbc3RvcmVfbmFtZV1bMF0gPT09IHN0b3JlKSB7XG5cdFx0cmV0dXJuIHN0b3JlX3ZhbHVlc1tzdG9yZV9uYW1lXVsyXTtcblx0fVxuXG5cdHN0b3JlX3ZhbHVlc1tzdG9yZV9uYW1lXT8uWzFdKCk7IC8vIGlmIHN0b3JlIHdhcyBzd2l0Y2hlZCwgdW5zdWJzY3JpYmUgZnJvbSBvbGQgc3RvcmVcblx0c3RvcmVfdmFsdWVzW3N0b3JlX25hbWVdID0gW3N0b3JlLCBudWxsLCB1bmRlZmluZWRdO1xuXHRjb25zdCB1bnN1YiA9IHN1YnNjcmliZV90b19zdG9yZShcblx0XHRzdG9yZSxcblx0XHQvKiogQHBhcmFtIHthbnl9IHYgKi8gKHYpID0+IChzdG9yZV92YWx1ZXNbc3RvcmVfbmFtZV1bMl0gPSB2KVxuXHQpO1xuXHRzdG9yZV92YWx1ZXNbc3RvcmVfbmFtZV1bMV0gPSB1bnN1Yjtcblx0cmV0dXJuIHN0b3JlX3ZhbHVlc1tzdG9yZV9uYW1lXVsyXTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBuZXcgdmFsdWUgb2YgYSBzdG9yZSBhbmQgcmV0dXJucyB0aGF0IHZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U3RvcmU8Vj59IHN0b3JlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX3NldChzdG9yZSwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzdG9yZSB3aXRoIGEgbmV3IHZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgW2FueSwgYW55LCBhbnldPn0gc3RvcmVfdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICogQHBhcmFtIHtTdG9yZTxWPn0gc3RvcmVcbiAqIEBwYXJhbSB7YW55fSBleHByZXNzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9tdXRhdGUoc3RvcmVfdmFsdWVzLCBzdG9yZV9uYW1lLCBzdG9yZSwgZXhwcmVzc2lvbikge1xuXHRzdG9yZV9zZXQoc3RvcmUsIHN0b3JlX2dldChzdG9yZV92YWx1ZXMsIHN0b3JlX25hbWUsIHN0b3JlKSk7XG5cdHJldHVybiBleHByZXNzaW9uO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgW2FueSwgYW55LCBhbnldPn0gc3RvcmVfdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICogQHBhcmFtIHtTdG9yZTxudW1iZXI+fSBzdG9yZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zdG9yZShzdG9yZV92YWx1ZXMsIHN0b3JlX25hbWUsIHN0b3JlLCBkID0gMSkge1xuXHRsZXQgc3RvcmVfdmFsdWUgPSBzdG9yZV9nZXQoc3RvcmVfdmFsdWVzLCBzdG9yZV9uYW1lLCBzdG9yZSk7XG5cdHN0b3JlLnNldChzdG9yZV92YWx1ZSArIGQpO1xuXHRyZXR1cm4gc3RvcmVfdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBbYW55LCBhbnksIGFueV0+fSBzdG9yZV92YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKiBAcGFyYW0ge1N0b3JlPG51bWJlcj59IHN0b3JlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3N0b3JlX3ByZShzdG9yZV92YWx1ZXMsIHN0b3JlX25hbWUsIHN0b3JlLCBkID0gMSkge1xuXHRjb25zdCB2YWx1ZSA9IHN0b3JlX2dldChzdG9yZV92YWx1ZXMsIHN0b3JlX25hbWUsIHN0b3JlKSArIGQ7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgW2FueSwgYW55LCBhbnldPn0gc3RvcmVfdmFsdWVzICovXG5leHBvcnQgZnVuY3Rpb24gdW5zdWJzY3JpYmVfc3RvcmVzKHN0b3JlX3ZhbHVlcykge1xuXHRmb3IgKGNvbnN0IHN0b3JlX25hbWUgaW4gc3RvcmVfdmFsdWVzKSB7XG5cdFx0c3RvcmVfdmFsdWVzW3N0b3JlX25hbWVdWzFdKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gc2xvdF9wcm9wc1xuICogQHBhcmFtIHtudWxsIHwgKCgpID0+IHZvaWQpfSBmYWxsYmFja19mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbG90KHJlbmRlcmVyLCAkJHByb3BzLCBuYW1lLCBzbG90X3Byb3BzLCBmYWxsYmFja19mbikge1xuXHR2YXIgc2xvdF9mbiA9ICQkcHJvcHMuJCRzbG90cz8uW25hbWVdO1xuXHQvLyBJbnRlcm9wOiBDYW4gdXNlIHNuaXBwZXRzIHRvIGZpbGwgc2xvdHNcblx0aWYgKHNsb3RfZm4gPT09IHRydWUpIHtcblx0XHRzbG90X2ZuID0gJCRwcm9wc1tuYW1lID09PSAnZGVmYXVsdCcgPyAnY2hpbGRyZW4nIDogbmFtZV07XG5cdH1cblxuXHRpZiAoc2xvdF9mbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2xvdF9mbihyZW5kZXJlciwgc2xvdF9wcm9wcyk7XG5cdH0gZWxzZSB7XG5cdFx0ZmFsbGJhY2tfZm4/LigpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IHJlc3RcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RfcHJvcHMocHJvcHMsIHJlc3QpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gKi9cblx0Y29uc3QgcmVzdF9wcm9wcyA9IHt9O1xuXHRsZXQga2V5O1xuXHRmb3IgKGtleSBpbiBwcm9wcykge1xuXHRcdGlmICghcmVzdC5pbmNsdWRlcyhrZXkpKSB7XG5cdFx0XHRyZXN0X3Byb3BzW2tleV0gPSBwcm9wc1trZXldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdF9wcm9wcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHVua25vd24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVfcHJvcHMocHJvcHMpIHtcblx0Y29uc3QgeyBjaGlsZHJlbiwgJCRzbG90cywgLi4uc2FuaXRpemVkIH0gPSBwcm9wcztcblx0cmV0dXJuIHNhbml0aXplZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHByb3BzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZV9zbG90cyhwcm9wcykge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuXHRjb25zdCBzYW5pdGl6ZWQgPSB7fTtcblx0aWYgKHByb3BzLmNoaWxkcmVuKSBzYW5pdGl6ZWQuZGVmYXVsdCA9IHRydWU7XG5cdGZvciAoY29uc3Qga2V5IGluIHByb3BzLiQkc2xvdHMpIHtcblx0XHRzYW5pdGl6ZWRba2V5XSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHNhbml0aXplZDtcbn1cblxuLyoqXG4gKiBMZWdhY3kgbW9kZTogSWYgdGhlIHByb3AgaGFzIGEgZmFsbGJhY2sgYW5kIGlzIGJvdW5kIGluIHRoZVxuICogcGFyZW50IGNvbXBvbmVudCwgcHJvcGFnYXRlIHRoZSBmYWxsYmFjayB2YWx1ZSB1cHdhcmRzLlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNfcGFyZW50XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc19ub3dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcHJvcHMocHJvcHNfcGFyZW50LCBwcm9wc19ub3cpIHtcblx0Zm9yIChjb25zdCBrZXkgaW4gcHJvcHNfbm93KSB7XG5cdFx0Y29uc3QgaW5pdGlhbF92YWx1ZSA9IHByb3BzX3BhcmVudFtrZXldO1xuXHRcdGNvbnN0IHZhbHVlID0gcHJvcHNfbm93W2tleV07XG5cdFx0aWYgKFxuXHRcdFx0aW5pdGlhbF92YWx1ZSA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHR2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BzX3BhcmVudCwga2V5KT8uc2V0XG5cdFx0KSB7XG5cdFx0XHRwcm9wc19wYXJlbnRba2V5XSA9IHZhbHVlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICogQHBhcmFtIHtQcm9taXNlPFY+fSBwcm9taXNlXG4gKiBAcGFyYW0ge251bGwgfCAoKCkgPT4gdm9pZCl9IHBlbmRpbmdfZm5cbiAqIEBwYXJhbSB7KHZhbHVlOiBWKSA9PiB2b2lkfSB0aGVuX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gYXdhaXRfYmxvY2socmVuZGVyZXIsIHByb21pc2UsIHBlbmRpbmdfZm4sIHRoZW5fZm4pIHtcblx0aWYgKGlzX3Byb21pc2UocHJvbWlzZSkpIHtcblx0XHRyZW5kZXJlci5wdXNoKEJMT0NLX09QRU4pO1xuXHRcdHByb21pc2UudGhlbihudWxsLCBub29wKTtcblx0XHRpZiAocGVuZGluZ19mbiAhPT0gbnVsbCkge1xuXHRcdFx0cGVuZGluZ19mbigpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0aGVuX2ZuICE9PSBudWxsKSB7XG5cdFx0cmVuZGVyZXIucHVzaChCTE9DS19PUEVOX0VMU0UpO1xuXHRcdHRoZW5fZm4ocHJvbWlzZSk7XG5cdH1cbn1cblxuZXhwb3J0IHsgYXdhaXRfYmxvY2sgYXMgYXdhaXQgfTtcblxuLyoqIEBwYXJhbSB7YW55fSBhcnJheV9saWtlX29yX2l0ZXJhdG9yICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlX2FycmF5X2xpa2UoYXJyYXlfbGlrZV9vcl9pdGVyYXRvcikge1xuXHRpZiAoYXJyYXlfbGlrZV9vcl9pdGVyYXRvcikge1xuXHRcdHJldHVybiBhcnJheV9saWtlX29yX2l0ZXJhdG9yLmxlbmd0aCAhPT0gdW5kZWZpbmVkXG5cdFx0XHQ/IGFycmF5X2xpa2Vfb3JfaXRlcmF0b3Jcblx0XHRcdDogQXJyYXkuZnJvbShhcnJheV9saWtlX29yX2l0ZXJhdG9yKTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZ2V0X3ZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGdldF92YWx1ZSkge1xuXHRsZXQgdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChVTklOSVRJQUxJWkVEKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAodmFsdWUgPT09IFVOSU5JVElBTElaRUQpIHtcblx0XHRcdHZhbHVlID0gZ2V0X3ZhbHVlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gdW5pcXVlIElEXG4gKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BzX2lkKHJlbmRlcmVyKSB7XG5cdGNvbnN0IHVpZCA9IHJlbmRlcmVyLmdsb2JhbC51aWQoKTtcblx0cmVuZGVyZXIucHVzaCgnPCEtLSQnICsgdWlkICsgJy0tPicpO1xuXHRyZXR1cm4gdWlkO1xufVxuXG5leHBvcnQgeyBhdHRyLCBjbHN4IH07XG5cbmV4cG9ydCB7IGh0bWwgfSBmcm9tICcuL2Jsb2Nrcy9odG1sLmpzJztcblxuZXhwb3J0IHsgc2F2ZSB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5cbmV4cG9ydCB7IHB1c2hfZWxlbWVudCwgcG9wX2VsZW1lbnQsIHZhbGlkYXRlX3NuaXBwZXRfYXJncyB9IGZyb20gJy4vZGV2LmpzJztcblxuZXhwb3J0IHsgc25hcHNob3QgfSBmcm9tICcuLi9zaGFyZWQvY2xvbmUuanMnO1xuXG5leHBvcnQgeyBmYWxsYmFjaywgdG9fYXJyYXkgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuXG5leHBvcnQge1xuXHRpbnZhbGlkX2RlZmF1bHRfc25pcHBldCxcblx0dmFsaWRhdGVfZHluYW1pY19lbGVtZW50X3RhZyxcblx0dmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQsXG5cdHByZXZlbnRfc25pcHBldF9zdHJpbmdpZmljYXRpb25cbn0gZnJvbSAnLi4vc2hhcmVkL3ZhbGlkYXRlLmpzJztcblxuZXhwb3J0IHsgZXNjYXBlX2h0bWwgYXMgZXNjYXBlIH07XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCk9PlR9IGZuXG4gKiBAcmV0dXJucyB7KG5ld192YWx1ZT86IFQpID0+IChUIHwgdm9pZCl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKGZuKSB7XG5cdGNvbnN0IGdldF92YWx1ZSA9IG9uY2UoZm4pO1xuXHQvKipcblx0ICogQHR5cGUge1QgfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRsZXQgdXBkYXRlZF92YWx1ZTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKG5ld192YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdXBkYXRlZF92YWx1ZSA/PyBnZXRfdmFsdWUoKTtcblx0XHR9XG5cdFx0dXBkYXRlZF92YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRyZXR1cm4gdXBkYXRlZF92YWx1ZTtcblx0fTtcbn1cbiIsICIvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG5leHBvcnQgY29uc3QgZXNjYXBlZCA9IHtcblx0JzwnOiAnXFxcXHUwMDNDJyxcblx0J1xcXFwnOiAnXFxcXFxcXFwnLFxuXHQnXFxiJzogJ1xcXFxiJyxcblx0J1xcZic6ICdcXFxcZicsXG5cdCdcXG4nOiAnXFxcXG4nLFxuXHQnXFxyJzogJ1xcXFxyJyxcblx0J1xcdCc6ICdcXFxcdCcsXG5cdCdcXHUyMDI4JzogJ1xcXFx1MjAyOCcsXG5cdCdcXHUyMDI5JzogJ1xcXFx1MjAyOSdcbn07XG5cbmV4cG9ydCBjbGFzcyBEZXZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBrZXlzKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gJ0RldmFsdWVFcnJvcic7XG5cdFx0dGhpcy5wYXRoID0ga2V5cy5qb2luKCcnKTtcblx0fVxufVxuXG4vKiogQHBhcmFtIHthbnl9IHRoaW5nICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJpbWl0aXZlKHRoaW5nKSB7XG5cdHJldHVybiBPYmplY3QodGhpbmcpICE9PSB0aGluZztcbn1cblxuY29uc3Qgb2JqZWN0X3Byb3RvX25hbWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFxuXHRPYmplY3QucHJvdG90eXBlXG4pXG5cdC5zb3J0KClcblx0LmpvaW4oJ1xcMCcpO1xuXG4vKiogQHBhcmFtIHthbnl9IHRoaW5nICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcGxhaW5fb2JqZWN0KHRoaW5nKSB7XG5cdGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaW5nKTtcblxuXHRyZXR1cm4gKFxuXHRcdHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8XG5cdFx0cHJvdG8gPT09IG51bGwgfHxcblx0XHRPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pID09PSBudWxsIHx8XG5cdFx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLnNvcnQoKS5qb2luKCdcXDAnKSA9PT0gb2JqZWN0X3Byb3RvX25hbWVzXG5cdCk7XG59XG5cbi8qKiBAcGFyYW0ge2FueX0gdGhpbmcgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfdHlwZSh0aGluZykge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaW5nKS5zbGljZSg4LCAtMSk7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gY2hhciAqL1xuZnVuY3Rpb24gZ2V0X2VzY2FwZWRfY2hhcihjaGFyKSB7XG5cdHN3aXRjaCAoY2hhcikge1xuXHRcdGNhc2UgJ1wiJzpcblx0XHRcdHJldHVybiAnXFxcXFwiJztcblx0XHRjYXNlICc8Jzpcblx0XHRcdHJldHVybiAnXFxcXHUwMDNDJztcblx0XHRjYXNlICdcXFxcJzpcblx0XHRcdHJldHVybiAnXFxcXFxcXFwnO1xuXHRcdGNhc2UgJ1xcbic6XG5cdFx0XHRyZXR1cm4gJ1xcXFxuJztcblx0XHRjYXNlICdcXHInOlxuXHRcdFx0cmV0dXJuICdcXFxccic7XG5cdFx0Y2FzZSAnXFx0Jzpcblx0XHRcdHJldHVybiAnXFxcXHQnO1xuXHRcdGNhc2UgJ1xcYic6XG5cdFx0XHRyZXR1cm4gJ1xcXFxiJztcblx0XHRjYXNlICdcXGYnOlxuXHRcdFx0cmV0dXJuICdcXFxcZic7XG5cdFx0Y2FzZSAnXFx1MjAyOCc6XG5cdFx0XHRyZXR1cm4gJ1xcXFx1MjAyOCc7XG5cdFx0Y2FzZSAnXFx1MjAyOSc6XG5cdFx0XHRyZXR1cm4gJ1xcXFx1MjAyOSc7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBjaGFyIDwgJyAnXG5cdFx0XHRcdD8gYFxcXFx1JHtjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDQsICcwJyl9YFxuXHRcdFx0XHQ6ICcnO1xuXHR9XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gc3RyICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5X3N0cmluZyhzdHIpIHtcblx0bGV0IHJlc3VsdCA9ICcnO1xuXHRsZXQgbGFzdF9wb3MgPSAwO1xuXHRjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRjb25zdCBjaGFyID0gc3RyW2ldO1xuXHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0X2VzY2FwZWRfY2hhcihjaGFyKTtcblx0XHRpZiAocmVwbGFjZW1lbnQpIHtcblx0XHRcdHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdF9wb3MsIGkpICsgcmVwbGFjZW1lbnQ7XG5cdFx0XHRsYXN0X3BvcyA9IGkgKyAxO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBgXCIke2xhc3RfcG9zID09PSAwID8gc3RyIDogcmVzdWx0ICsgc3RyLnNsaWNlKGxhc3RfcG9zKX1cImA7XG59XG5cbi8qKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT59IG9iamVjdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmFibGVfc3ltYm9scyhvYmplY3QpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KS5maWx0ZXIoXG5cdFx0KHN5bWJvbCkgPT4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bWJvbCkuZW51bWVyYWJsZVxuXHQpO1xufVxuXG5jb25zdCBpc19pZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBrZXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlfa2V5KGtleSkge1xuXHRyZXR1cm4gaXNfaWRlbnRpZmllci50ZXN0KGtleSkgPyAnLicgKyBrZXkgOiAnWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nO1xufVxuIiwgImltcG9ydCB7XG5cdERldmFsdWVFcnJvcixcblx0ZW51bWVyYWJsZV9zeW1ib2xzLFxuXHRlc2NhcGVkLFxuXHRnZXRfdHlwZSxcblx0aXNfcGxhaW5fb2JqZWN0LFxuXHRpc19wcmltaXRpdmUsXG5cdHN0cmluZ2lmeV9rZXksXG5cdHN0cmluZ2lmeV9zdHJpbmdcbn0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IGNoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfJCc7XG5jb25zdCB1bnNhZmVfY2hhcnMgPSAvWzxcXGJcXGZcXG5cXHJcXHRcXDBcXHUyMDI4XFx1MjAyOV0vZztcbmNvbnN0IHJlc2VydmVkID1cblx0L14oPzpkb3xpZnxpbnxmb3J8aW50fGxldHxuZXd8dHJ5fHZhcnxieXRlfGNhc2V8Y2hhcnxlbHNlfGVudW18Z290b3xsb25nfHRoaXN8dm9pZHx3aXRofGF3YWl0fGJyZWFrfGNhdGNofGNsYXNzfGNvbnN0fGZpbmFsfGZsb2F0fHNob3J0fHN1cGVyfHRocm93fHdoaWxlfHlpZWxkfGRlbGV0ZXxkb3VibGV8ZXhwb3J0fGltcG9ydHxuYXRpdmV8cmV0dXJufHN3aXRjaHx0aHJvd3N8dHlwZW9mfGJvb2xlYW58ZGVmYXVsdHxleHRlbmRzfGZpbmFsbHl8cGFja2FnZXxwcml2YXRlfGFic3RyYWN0fGNvbnRpbnVlfGRlYnVnZ2VyfGZ1bmN0aW9ufHZvbGF0aWxlfGludGVyZmFjZXxwcm90ZWN0ZWR8dHJhbnNpZW50fGltcGxlbWVudHN8aW5zdGFuY2VvZnxzeW5jaHJvbml6ZWQpJC87XG5cbi8qKlxuICogVHVybiBhIHZhbHVlIGludG8gdGhlIEphdmFTY3JpcHQgdGhhdCBjcmVhdGVzIGFuIGVxdWl2YWxlbnQgdmFsdWVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHsodmFsdWU6IGFueSwgdW5ldmFsOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nKSA9PiBzdHJpbmcgfCB2b2lkfSBbcmVwbGFjZXJdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmV2YWwodmFsdWUsIHJlcGxhY2VyKSB7XG5cdGNvbnN0IGNvdW50cyA9IG5ldyBNYXAoKTtcblxuXHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRjb25zdCBrZXlzID0gW107XG5cblx0Y29uc3QgY3VzdG9tID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBAcGFyYW0ge2FueX0gdGhpbmcgKi9cblx0ZnVuY3Rpb24gd2Fsayh0aGluZykge1xuXHRcdGlmICghaXNfcHJpbWl0aXZlKHRoaW5nKSkge1xuXHRcdFx0aWYgKGNvdW50cy5oYXModGhpbmcpKSB7XG5cdFx0XHRcdGNvdW50cy5zZXQodGhpbmcsIGNvdW50cy5nZXQodGhpbmcpICsgMSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y291bnRzLnNldCh0aGluZywgMSk7XG5cblx0XHRcdGlmIChyZXBsYWNlcikge1xuXHRcdFx0XHRjb25zdCBzdHIgPSByZXBsYWNlcih0aGluZywgKHZhbHVlKSA9PiB1bmV2YWwodmFsdWUsIHJlcGxhY2VyKSk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Y3VzdG9tLnNldCh0aGluZywgc3RyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRGV2YWx1ZUVycm9yKGBDYW5ub3Qgc3RyaW5naWZ5IGEgZnVuY3Rpb25gLCBrZXlzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHlwZSA9IGdldF90eXBlKHRoaW5nKTtcblxuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdGNhc2UgJ0JpZ0ludCc6XG5cdFx0XHRcdGNhc2UgJ1N0cmluZyc6XG5cdFx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRjYXNlICdEYXRlJzpcblx0XHRcdFx0Y2FzZSAnUmVnRXhwJzpcblx0XHRcdFx0Y2FzZSAnVVJMJzpcblx0XHRcdFx0Y2FzZSAnVVJMU2VhcmNoUGFyYW1zJzpcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7YW55W119ICovICh0aGluZykuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcblx0XHRcdFx0XHRcdGtleXMucHVzaChgWyR7aX1dYCk7XG5cdFx0XHRcdFx0XHR3YWxrKHZhbHVlKTtcblx0XHRcdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU2V0Jzpcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaW5nKS5mb3JFYWNoKHdhbGspO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hcCc6XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpbmcpIHtcblx0XHRcdFx0XHRcdGtleXMucHVzaChcblx0XHRcdFx0XHRcdFx0YC5nZXQoJHtpc19wcmltaXRpdmUoa2V5KSA/IHN0cmluZ2lmeV9wcmltaXRpdmUoa2V5KSA6ICcuLi4nfSlgXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0d2Fsayh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdJbnQ4QXJyYXknOlxuXHRcdFx0XHRjYXNlICdVaW50OEFycmF5Jzpcblx0XHRcdFx0Y2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuXHRcdFx0XHRjYXNlICdJbnQxNkFycmF5Jzpcblx0XHRcdFx0Y2FzZSAnVWludDE2QXJyYXknOlxuXHRcdFx0XHRjYXNlICdJbnQzMkFycmF5Jzpcblx0XHRcdFx0Y2FzZSAnVWludDMyQXJyYXknOlxuXHRcdFx0XHRjYXNlICdGbG9hdDMyQXJyYXknOlxuXHRcdFx0XHRjYXNlICdGbG9hdDY0QXJyYXknOlxuXHRcdFx0XHRjYXNlICdCaWdJbnQ2NEFycmF5Jzpcblx0XHRcdFx0Y2FzZSAnQmlnVWludDY0QXJyYXknOlxuXHRcdFx0XHRcdHdhbGsodGhpbmcuYnVmZmVyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0Y2FzZSAnQXJyYXlCdWZmZXInOlxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRjYXNlICdUZW1wb3JhbC5EdXJhdGlvbic6XG5cdFx0XHRcdGNhc2UgJ1RlbXBvcmFsLkluc3RhbnQnOlxuXHRcdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpbkRhdGUnOlxuXHRcdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpblRpbWUnOlxuXHRcdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJzpcblx0XHRcdFx0Y2FzZSAnVGVtcG9yYWwuUGxhaW5Nb250aERheSc6XG5cdFx0XHRcdGNhc2UgJ1RlbXBvcmFsLlBsYWluWWVhck1vbnRoJzpcblx0XHRcdFx0Y2FzZSAnVGVtcG9yYWwuWm9uZWREYXRlVGltZSc6XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYgKCFpc19wbGFpbl9vYmplY3QodGhpbmcpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRGV2YWx1ZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRgQ2Fubm90IHN0cmluZ2lmeSBhcmJpdHJhcnkgbm9uLVBPSk9zYCxcblx0XHRcdFx0XHRcdFx0a2V5c1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZW51bWVyYWJsZV9zeW1ib2xzKHRoaW5nKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRGV2YWx1ZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRgQ2Fubm90IHN0cmluZ2lmeSBQT0pPcyB3aXRoIHN5bWJvbGljIGtleXNgLFxuXHRcdFx0XHRcdFx0XHRrZXlzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIHRoaW5nKSB7XG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goc3RyaW5naWZ5X2tleShrZXkpKTtcblx0XHRcdFx0XHRcdHdhbGsodGhpbmdba2V5XSk7XG5cdFx0XHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR3YWxrKHZhbHVlKTtcblxuXHRjb25zdCBuYW1lcyA9IG5ldyBNYXAoKTtcblxuXHRBcnJheS5mcm9tKGNvdW50cylcblx0XHQuZmlsdGVyKChlbnRyeSkgPT4gZW50cnlbMV0gPiAxKVxuXHRcdC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlcblx0XHQuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcblx0XHRcdG5hbWVzLnNldChlbnRyeVswXSwgZ2V0X25hbWUoaSkpO1xuXHRcdH0pO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gdGhpbmdcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeSh0aGluZykge1xuXHRcdGlmIChuYW1lcy5oYXModGhpbmcpKSB7XG5cdFx0XHRyZXR1cm4gbmFtZXMuZ2V0KHRoaW5nKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfcHJpbWl0aXZlKHRoaW5nKSkge1xuXHRcdFx0cmV0dXJuIHN0cmluZ2lmeV9wcmltaXRpdmUodGhpbmcpO1xuXHRcdH1cblxuXHRcdGlmIChjdXN0b20uaGFzKHRoaW5nKSkge1xuXHRcdFx0cmV0dXJuIGN1c3RvbS5nZXQodGhpbmcpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHR5cGUgPSBnZXRfdHlwZSh0aGluZyk7XG5cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRjYXNlICdTdHJpbmcnOlxuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiBgT2JqZWN0KCR7c3RyaW5naWZ5KHRoaW5nLnZhbHVlT2YoKSl9KWA7XG5cblx0XHRcdGNhc2UgJ1JlZ0V4cCc6XG5cdFx0XHRcdHJldHVybiBgbmV3IFJlZ0V4cCgke3N0cmluZ2lmeV9zdHJpbmcodGhpbmcuc291cmNlKX0sIFwiJHtcblx0XHRcdFx0XHR0aGluZy5mbGFnc1xuXHRcdFx0XHR9XCIpYDtcblxuXHRcdFx0Y2FzZSAnRGF0ZSc6XG5cdFx0XHRcdHJldHVybiBgbmV3IERhdGUoJHt0aGluZy5nZXRUaW1lKCl9KWA7XG5cblx0XHRcdGNhc2UgJ1VSTCc6XG5cdFx0XHRcdHJldHVybiBgbmV3IFVSTCgke3N0cmluZ2lmeV9zdHJpbmcodGhpbmcudG9TdHJpbmcoKSl9KWA7XG5cblx0XHRcdGNhc2UgJ1VSTFNlYXJjaFBhcmFtcyc6XG5cdFx0XHRcdHJldHVybiBgbmV3IFVSTFNlYXJjaFBhcmFtcygke3N0cmluZ2lmeV9zdHJpbmcodGhpbmcudG9TdHJpbmcoKSl9KWA7XG5cblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0Y29uc3QgbWVtYmVycyA9IC8qKiBAdHlwZSB7YW55W119ICovICh0aGluZykubWFwKCh2LCBpKSA9PlxuXHRcdFx0XHRcdGkgaW4gdGhpbmcgPyBzdHJpbmdpZnkodikgOiAnJ1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zdCB0YWlsID0gdGhpbmcubGVuZ3RoID09PSAwIHx8IHRoaW5nLmxlbmd0aCAtIDEgaW4gdGhpbmcgPyAnJyA6ICcsJztcblx0XHRcdFx0cmV0dXJuIGBbJHttZW1iZXJzLmpvaW4oJywnKX0ke3RhaWx9XWA7XG5cblx0XHRcdGNhc2UgJ1NldCc6XG5cdFx0XHRjYXNlICdNYXAnOlxuXHRcdFx0XHRyZXR1cm4gYG5ldyAke3R5cGV9KFske0FycmF5LmZyb20odGhpbmcpLm1hcChzdHJpbmdpZnkpLmpvaW4oJywnKX1dKWA7XG5cblx0XHRcdGNhc2UgJ0ludDhBcnJheSc6XG5cdFx0XHRjYXNlICdVaW50OEFycmF5Jzpcblx0XHRcdGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5Jzpcblx0XHRcdGNhc2UgJ0ludDE2QXJyYXknOlxuXHRcdFx0Y2FzZSAnVWludDE2QXJyYXknOlxuXHRcdFx0Y2FzZSAnSW50MzJBcnJheSc6XG5cdFx0XHRjYXNlICdVaW50MzJBcnJheSc6XG5cdFx0XHRjYXNlICdGbG9hdDMyQXJyYXknOlxuXHRcdFx0Y2FzZSAnRmxvYXQ2NEFycmF5Jzpcblx0XHRcdGNhc2UgJ0JpZ0ludDY0QXJyYXknOlxuXHRcdFx0Y2FzZSAnQmlnVWludDY0QXJyYXknOiB7XG5cdFx0XHRcdGxldCBzdHIgPSBgbmV3ICR7dHlwZX1gO1xuXG5cdFx0XHRcdGlmIChjb3VudHMuZ2V0KHRoaW5nLmJ1ZmZlcikgPT09IDEpIHtcblx0XHRcdFx0XHRjb25zdCBhcnJheSA9IG5ldyB0aGluZy5jb25zdHJ1Y3Rvcih0aGluZy5idWZmZXIpO1xuXHRcdFx0XHRcdHN0ciArPSBgKFske2FycmF5fV0pYDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHIgKz0gYChbJHtzdHJpbmdpZnkodGhpbmcuYnVmZmVyKX1dKWA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBhID0gdGhpbmcuYnl0ZU9mZnNldDtcblx0XHRcdFx0Y29uc3QgYiA9IGEgKyB0aGluZy5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdC8vIGhhbmRsZSBzdWJhcnJheXNcblx0XHRcdFx0aWYgKGEgPiAwIHx8IGIgIT09IHRoaW5nLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29uc3QgbSA9ICsvKFxcZCspLy5leGVjKHR5cGUpWzFdIC8gODtcblx0XHRcdFx0XHRzdHIgKz0gYC5zdWJhcnJheSgke2EgLyBtfSwke2IgLyBtfSlgO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdH1cblxuXHRcdFx0Y2FzZSAnQXJyYXlCdWZmZXInOiB7XG5cdFx0XHRcdGNvbnN0IHVpOCA9IG5ldyBVaW50OEFycmF5KHRoaW5nKTtcblx0XHRcdFx0cmV0dXJuIGBuZXcgVWludDhBcnJheShbJHt1aTgudG9TdHJpbmcoKX1dKS5idWZmZXJgO1xuXHRcdFx0fVxuXG5cdFx0XHRjYXNlICdUZW1wb3JhbC5EdXJhdGlvbic6XG5cdFx0XHRjYXNlICdUZW1wb3JhbC5JbnN0YW50Jzpcblx0XHRcdGNhc2UgJ1RlbXBvcmFsLlBsYWluRGF0ZSc6XG5cdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpblRpbWUnOlxuXHRcdFx0Y2FzZSAnVGVtcG9yYWwuUGxhaW5EYXRlVGltZSc6XG5cdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpbk1vbnRoRGF5Jzpcblx0XHRcdGNhc2UgJ1RlbXBvcmFsLlBsYWluWWVhck1vbnRoJzpcblx0XHRcdGNhc2UgJ1RlbXBvcmFsLlpvbmVkRGF0ZVRpbWUnOlxuXHRcdFx0XHRyZXR1cm4gYCR7dHlwZX0uZnJvbSgke3N0cmluZ2lmeV9zdHJpbmcodGhpbmcudG9TdHJpbmcoKSl9KWA7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGluZyk7XG5cdFx0XHRcdGNvbnN0IG9iaiA9IGtleXNcblx0XHRcdFx0XHQubWFwKChrZXkpID0+IGAke3NhZmVfa2V5KGtleSl9OiR7c3RyaW5naWZ5KHRoaW5nW2tleV0pfWApXG5cdFx0XHRcdFx0LmpvaW4oJywnKTtcblx0XHRcdFx0Y29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpO1xuXHRcdFx0XHRpZiAocHJvdG8gPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4ga2V5cy5sZW5ndGggPiAwXG5cdFx0XHRcdFx0XHQ/IGB7JHtvYmp9LF9fcHJvdG9fXzpudWxsfWBcblx0XHRcdFx0XHRcdDogYHtfX3Byb3RvX186bnVsbH1gO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGB7JHtvYmp9fWA7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgc3RyID0gc3RyaW5naWZ5KHZhbHVlKTtcblxuXHRpZiAobmFtZXMuc2l6ZSkge1xuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cblx0XHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRcdGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcblxuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRuYW1lcy5mb3JFYWNoKChuYW1lLCB0aGluZykgPT4ge1xuXHRcdFx0cGFyYW1zLnB1c2gobmFtZSk7XG5cblx0XHRcdGlmIChjdXN0b20uaGFzKHRoaW5nKSkge1xuXHRcdFx0XHR2YWx1ZXMucHVzaCgvKiogQHR5cGUge3N0cmluZ30gKi8gKGN1c3RvbS5nZXQodGhpbmcpKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzX3ByaW1pdGl2ZSh0aGluZykpIHtcblx0XHRcdFx0dmFsdWVzLnB1c2goc3RyaW5naWZ5X3ByaW1pdGl2ZSh0aGluZykpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHR5cGUgPSBnZXRfdHlwZSh0aGluZyk7XG5cblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdTdHJpbmcnOlxuXHRcdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChgT2JqZWN0KCR7c3RyaW5naWZ5KHRoaW5nLnZhbHVlT2YoKSl9KWApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1JlZ0V4cCc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2godGhpbmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRGF0ZSc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYG5ldyBEYXRlKCR7dGhpbmcuZ2V0VGltZSgpfSlgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYEFycmF5KCR7dGhpbmcubGVuZ3RofSlgKTtcblx0XHRcdFx0XHQvKiogQHR5cGUge2FueVtdfSAqLyAodGhpbmcpLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0XHRcdHN0YXRlbWVudHMucHVzaChgJHtuYW1lfVske2l9XT0ke3N0cmluZ2lmeSh2KX1gKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTZXQnOlxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKGBuZXcgU2V0YCk7XG5cdFx0XHRcdFx0c3RhdGVtZW50cy5wdXNoKFxuXHRcdFx0XHRcdFx0YCR7bmFtZX0uJHtBcnJheS5mcm9tKHRoaW5nKVxuXHRcdFx0XHRcdFx0XHQubWFwKCh2KSA9PiBgYWRkKCR7c3RyaW5naWZ5KHYpfSlgKVxuXHRcdFx0XHRcdFx0XHQuam9pbignLicpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hcCc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYG5ldyBNYXBgKTtcblx0XHRcdFx0XHRzdGF0ZW1lbnRzLnB1c2goXG5cdFx0XHRcdFx0XHRgJHtuYW1lfS4ke0FycmF5LmZyb20odGhpbmcpXG5cdFx0XHRcdFx0XHRcdC5tYXAoKFtrLCB2XSkgPT4gYHNldCgke3N0cmluZ2lmeShrKX0sICR7c3RyaW5naWZ5KHYpfSlgKVxuXHRcdFx0XHRcdFx0XHQuam9pbignLicpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0FycmF5QnVmZmVyJzpcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChcblx0XHRcdFx0XHRcdGBuZXcgVWludDhBcnJheShbJHtuZXcgVWludDhBcnJheSh0aGluZykuam9pbignLCcpfV0pLmJ1ZmZlcmBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goXG5cdFx0XHRcdFx0XHRPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpID09PSBudWxsID8gJ09iamVjdC5jcmVhdGUobnVsbCknIDogJ3t9J1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXModGhpbmcpLmZvckVhY2goKGtleSkgPT4ge1xuXHRcdFx0XHRcdFx0c3RhdGVtZW50cy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRgJHtuYW1lfSR7c2FmZV9wcm9wKGtleSl9PSR7c3RyaW5naWZ5KHRoaW5nW2tleV0pfWBcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRzdGF0ZW1lbnRzLnB1c2goYHJldHVybiAke3N0cn1gKTtcblxuXHRcdHJldHVybiBgKGZ1bmN0aW9uKCR7cGFyYW1zLmpvaW4oJywnKX0peyR7c3RhdGVtZW50cy5qb2luKFxuXHRcdFx0JzsnXG5cdFx0KX19KCR7dmFsdWVzLmpvaW4oJywnKX0pKWA7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxufVxuXG4vKiogQHBhcmFtIHtudW1iZXJ9IG51bSAqL1xuZnVuY3Rpb24gZ2V0X25hbWUobnVtKSB7XG5cdGxldCBuYW1lID0gJyc7XG5cblx0ZG8ge1xuXHRcdG5hbWUgPSBjaGFyc1tudW0gJSBjaGFycy5sZW5ndGhdICsgbmFtZTtcblx0XHRudW0gPSB+fihudW0gLyBjaGFycy5sZW5ndGgpIC0gMTtcblx0fSB3aGlsZSAobnVtID49IDApO1xuXG5cdHJldHVybiByZXNlcnZlZC50ZXN0KG5hbWUpID8gYCR7bmFtZX0wYCA6IG5hbWU7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gYyAqL1xuZnVuY3Rpb24gZXNjYXBlX3Vuc2FmZV9jaGFyKGMpIHtcblx0cmV0dXJuIGVzY2FwZWRbY10gfHwgYztcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzdHIgKi9cbmZ1bmN0aW9uIGVzY2FwZV91bnNhZmVfY2hhcnMoc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSh1bnNhZmVfY2hhcnMsIGVzY2FwZV91bnNhZmVfY2hhcik7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30ga2V5ICovXG5mdW5jdGlvbiBzYWZlX2tleShrZXkpIHtcblx0cmV0dXJuIC9eW18kYS16QS1aXVtfJGEtekEtWjAtOV0qJC8udGVzdChrZXkpXG5cdFx0PyBrZXlcblx0XHQ6IGVzY2FwZV91bnNhZmVfY2hhcnMoSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30ga2V5ICovXG5mdW5jdGlvbiBzYWZlX3Byb3Aoa2V5KSB7XG5cdHJldHVybiAvXltfJGEtekEtWl1bXyRhLXpBLVowLTldKiQvLnRlc3Qoa2V5KVxuXHRcdD8gYC4ke2tleX1gXG5cdFx0OiBgWyR7ZXNjYXBlX3Vuc2FmZV9jaGFycyhKU09OLnN0cmluZ2lmeShrZXkpKX1dYDtcbn1cblxuLyoqIEBwYXJhbSB7YW55fSB0aGluZyAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5X3ByaW1pdGl2ZSh0aGluZykge1xuXHRpZiAodHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJykgcmV0dXJuIHN0cmluZ2lmeV9zdHJpbmcodGhpbmcpO1xuXHRpZiAodGhpbmcgPT09IHZvaWQgMCkgcmV0dXJuICd2b2lkIDAnO1xuXHRpZiAodGhpbmcgPT09IDAgJiYgMSAvIHRoaW5nIDwgMCkgcmV0dXJuICctMCc7XG5cdGNvbnN0IHN0ciA9IFN0cmluZyh0aGluZyk7XG5cdGlmICh0eXBlb2YgdGhpbmcgPT09ICdudW1iZXInKSByZXR1cm4gc3RyLnJlcGxhY2UoL14oLSk/MFxcLi8sICckMS4nKTtcblx0aWYgKHR5cGVvZiB0aGluZyA9PT0gJ2JpZ2ludCcpIHJldHVybiB0aGluZyArICduJztcblx0cmV0dXJuIHN0cjtcbn1cbiIsICJleHBvcnQgeyB1bmV2YWwgfSBmcm9tICcuL3NyYy91bmV2YWwuanMnO1xuZXhwb3J0IHsgcGFyc2UsIHVuZmxhdHRlbiB9IGZyb20gJy4vc3JjL3BhcnNlLmpzJztcbmV4cG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3JjL3N0cmluZ2lmeS5qcyc7XG4iLCAiLyoqIEBpbXBvcnQgeyBIeWRyYXRhYmxlTG9va3VwRW50cnkgfSBmcm9tICcjc2VydmVyJyAqL1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgZ2V0X3JlbmRlcl9jb250ZXh0IH0gZnJvbSAnLi9yZW5kZXItY29udGV4dC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIGRldmFsdWUgZnJvbSAnZGV2YWx1ZSc7XG5pbXBvcnQgeyBnZXRfc3RhY2sgfSBmcm9tICcuLi9zaGFyZWQvZGV2LmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0X3VzZXJfY29kZV9sb2NhdGlvbiB9IGZyb20gJy4vZGV2LmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRhYmxlKGtleSwgZm4pIHtcblx0aWYgKCFhc3luY19tb2RlX2ZsYWcpIHtcblx0XHRlLmV4cGVyaW1lbnRhbF9hc3luY19yZXF1aXJlZCgnaHlkcmF0YWJsZScpO1xuXHR9XG5cblx0Y29uc3QgeyBoeWRyYXRhYmxlIH0gPSBnZXRfcmVuZGVyX2NvbnRleHQoKTtcblxuXHRsZXQgZW50cnkgPSBoeWRyYXRhYmxlLmxvb2t1cC5nZXQoa2V5KTtcblxuXHRpZiAoZW50cnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdGNvbnN0IGNvbXBhcmlzb24gPSBjb21wYXJlKGtleSwgZW50cnksIGVuY29kZShrZXksIGZuKCkpKTtcblx0XHRcdGNvbXBhcmlzb24uY2F0Y2goKCkgPT4ge30pO1xuXHRcdFx0aHlkcmF0YWJsZS5jb21wYXJpc29ucy5wdXNoKGNvbXBhcmlzb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiAvKiogQHR5cGUge1R9ICovIChlbnRyeS52YWx1ZSk7XG5cdH1cblxuXHRjb25zdCB2YWx1ZSA9IGZuKCk7XG5cblx0ZW50cnkgPSBlbmNvZGUoa2V5LCB2YWx1ZSwgaHlkcmF0YWJsZS51bnJlc29sdmVkX3Byb21pc2VzKTtcblx0aHlkcmF0YWJsZS5sb29rdXAuc2V0KGtleSwgZW50cnkpO1xuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7TWFwPFByb21pc2U8YW55Piwgc3RyaW5nPn0gW3VucmVzb2x2ZWRdXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShrZXksIHZhbHVlLCB1bnJlc29sdmVkKSB7XG5cdC8qKiBAdHlwZSB7SHlkcmF0YWJsZUxvb2t1cEVudHJ5fSAqL1xuXHRjb25zdCBlbnRyeSA9IHsgdmFsdWUsIHNlcmlhbGl6ZWQ6ICcnIH07XG5cblx0aWYgKERFVikge1xuXHRcdGVudHJ5LnN0YWNrID0gZ2V0X3VzZXJfY29kZV9sb2NhdGlvbigpO1xuXHR9XG5cblx0bGV0IHVpZCA9IDE7XG5cblx0ZW50cnkuc2VyaWFsaXplZCA9IGRldmFsdWUudW5ldmFsKGVudHJ5LnZhbHVlLCAodmFsdWUsIHVuZXZhbCkgPT4ge1xuXHRcdGlmIChpc19wcm9taXNlKHZhbHVlKSkge1xuXHRcdFx0Y29uc3QgcCA9IHZhbHVlXG5cdFx0XHRcdC50aGVuKCh2KSA9PiBgcigke3VuZXZhbCh2KX0pYClcblx0XHRcdFx0LmNhdGNoKChkZXZhbHVlX2Vycm9yKSA9PlxuXHRcdFx0XHRcdGUuaHlkcmF0YWJsZV9zZXJpYWxpemF0aW9uX2ZhaWxlZChcblx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdHNlcmlhbGl6YXRpb25fc3RhY2soZW50cnkuc3RhY2ssIGRldmFsdWVfZXJyb3I/LnN0YWNrKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gcHJldmVudCB1bmhhbmRsZWQgcmVqZWN0aW9ucyBmcm9tIGNyYXNoaW5nIHRoZSBzZXJ2ZXJcblx0XHRcdHAuY2F0Y2goKCkgPT4ge30pO1xuXG5cdFx0XHQvLyB0cmFjayB3aGljaCBwcm9taXNlcyBhcmUgc3RpbGwgcmVzb2x2aW5nIHdoZW4gcmVuZGVyIGlzIGNvbXBsZXRlXG5cdFx0XHR1bnJlc29sdmVkPy5zZXQocCwga2V5KTtcblx0XHRcdHAuZmluYWxseSgoKSA9PiB1bnJlc29sdmVkPy5kZWxldGUocCkpO1xuXG5cdFx0XHQvLyB3ZSBzZXJpYWxpemUgcHJvbWlzZXMgYXMgYFwiJHtpfVwiYCwgYmVjYXVzZSBpdCdzIGltcG9zc2libGUgZm9yIHRoYXQgc3RyaW5nXG5cdFx0XHQvLyB0byBvY2N1ciAnbmF0dXJhbGx5JyAoc2luY2UgdGhlIHF1b3RlIG1hcmtzIHdvdWxkIGhhdmUgdG8gYmUgZXNjYXBlZClcblx0XHRcdGNvbnN0IHBsYWNlaG9sZGVyID0gYFwiJHt1aWQrK31cImA7XG5cblx0XHRcdChlbnRyeS5wcm9taXNlcyA/Pz0gW10pLnB1c2goXG5cdFx0XHRcdHAudGhlbigocykgPT4ge1xuXHRcdFx0XHRcdGVudHJ5LnNlcmlhbGl6ZWQgPSBlbnRyeS5zZXJpYWxpemVkLnJlcGxhY2UocGxhY2Vob2xkZXIsIHMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHBsYWNlaG9sZGVyO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVudHJ5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2U8YW55Pn1cbiAqL1xuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHQvLyB3ZSB1c2UgdGhpcyBjaGVjayByYXRoZXIgdGhhbiBgaW5zdGFuY2VvZiBQcm9taXNlYFxuXHQvLyBiZWNhdXNlIGl0IHdvcmtzIGNyb3NzLXJlYWxtXG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBQcm9taXNlXSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtIeWRyYXRhYmxlTG9va3VwRW50cnl9IGFcbiAqIEBwYXJhbSB7SHlkcmF0YWJsZUxvb2t1cEVudHJ5fSBiXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbXBhcmUoa2V5LCBhLCBiKSB7XG5cdC8vIG5vdGU6IHRoZXNlIG5lZWQgdG8gYmUgbG9vcHMgKGFzIG9wcG9zZWQgdG8gUHJvbWlzZS5hbGwpIGJlY2F1c2Vcblx0Ly8gYWRkaXRpb25hbCBwcm9taXNlcyBjYW4gZ2V0IHB1c2hlZCB0byB0aGVtIHdoaWxlIHdlJ3JlIGF3YWl0aW5nXG5cdC8vIGFuIGVhcmxpZXIgb25lXG5cdGZvciAoY29uc3QgcCBvZiBhPy5wcm9taXNlcyA/PyBbXSkge1xuXHRcdGF3YWl0IHA7XG5cdH1cblxuXHRmb3IgKGNvbnN0IHAgb2YgYj8ucHJvbWlzZXMgPz8gW10pIHtcblx0XHRhd2FpdCBwO1xuXHR9XG5cblx0aWYgKGEuc2VyaWFsaXplZCAhPT0gYi5zZXJpYWxpemVkKSB7XG5cdFx0Y29uc3QgYV9zdGFjayA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoYS5zdGFjayk7XG5cdFx0Y29uc3QgYl9zdGFjayA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoYi5zdGFjayk7XG5cblx0XHRjb25zdCBzdGFjayA9XG5cdFx0XHRhX3N0YWNrID09PSBiX3N0YWNrXG5cdFx0XHRcdD8gYE9jY3VycmVkIGF0OlxcbiR7YV9zdGFja31gXG5cdFx0XHRcdDogYEZpcnN0IG9jY3VycmVuY2UgYXQ6XFxuJHthX3N0YWNrfVxcblxcblNlY29uZCBvY2N1cnJlbmNlIGF0OlxcbiR7Yl9zdGFja31gO1xuXG5cdFx0ZS5oeWRyYXRhYmxlX2Nsb2JiZXJpbmcoa2V5LCBzdGFjayk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gcm9vdF9zdGFja1xuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHVuZXZhbF9zdGFja1xuICovXG5mdW5jdGlvbiBzZXJpYWxpemF0aW9uX3N0YWNrKHJvb3Rfc3RhY2ssIHVuZXZhbF9zdGFjaykge1xuXHRsZXQgb3V0ID0gJyc7XG5cdGlmIChyb290X3N0YWNrKSB7XG5cdFx0b3V0ICs9IHJvb3Rfc3RhY2sgKyAnXFxuJztcblx0fVxuXHRpZiAodW5ldmFsX3N0YWNrKSB7XG5cdFx0b3V0ICs9ICdDYXVzZWQgYnk6XFxuJyArIHVuZXZhbF9zdGFjayArICdcXG4nO1xuXHR9XG5cdHJldHVybiBvdXQgfHwgJzxtaXNzaW5nIHN0YWNrIHRyYWNlPic7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTbmlwcGV0IH0gZnJvbSAnc3ZlbHRlJyAqL1xuLyoqIEBpbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJy4uL3JlbmRlcmVyJyAqL1xuLyoqIEBpbXBvcnQgeyBHZXR0ZXJzIH0gZnJvbSAnI3NoYXJlZCcgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBzbmlwcGV0IHByb2dyYW1tYXRpY2FsbHlcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bltdfSBQYXJhbXNcbiAqIEBwYXJhbSB7KC4uLnBhcmFtczogR2V0dGVyczxQYXJhbXM+KSA9PiB7XG4gKiAgIHJlbmRlcjogKCkgPT4gc3RyaW5nXG4gKiAgIHNldHVwPzogKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHZvaWQgfCAoKCkgPT4gdm9pZClcbiAqIH19IGZuXG4gKiBAcmV0dXJucyB7U25pcHBldDxQYXJhbXM+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF3U25pcHBldChmbikge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSB0eXBlcyBhcmUgYSBsaWVcblx0cmV0dXJuICgvKiogQHR5cGUge1JlbmRlcmVyfSAqLyByZW5kZXJlciwgLyoqIEB0eXBlIHtQYXJhbXN9ICovIC4uLmFyZ3MpID0+IHtcblx0XHR2YXIgZ2V0dGVycyA9IC8qKiBAdHlwZSB7R2V0dGVyczxQYXJhbXM+fSAqLyAoYXJncy5tYXAoKHZhbHVlKSA9PiAoKSA9PiB2YWx1ZSkpO1xuXHRcdHJlbmRlcmVyLnB1c2goXG5cdFx0XHRmbiguLi5nZXR0ZXJzKVxuXHRcdFx0XHQucmVuZGVyKClcblx0XHRcdFx0LnRyaW0oKVxuXHRcdCk7XG5cdH07XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTU1JDb250ZXh0IH0gZnJvbSAnI3NlcnZlcicgKi9cbi8qKiBAaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICcuL2ludGVybmFsL3NlcnZlci9yZW5kZXJlci5qcycgKi9cbmltcG9ydCB7IHNzcl9jb250ZXh0IH0gZnJvbSAnLi9pbnRlcm5hbC9zZXJ2ZXIvY29udGV4dC5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2ludGVybmFsL3NlcnZlci9lcnJvcnMuanMnO1xuXG4vKiogQHBhcmFtIHsoKSA9PiB2b2lkfSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuXHQvKiogQHR5cGUge1JlbmRlcmVyfSAqLyAoLyoqIEB0eXBlIHtTU1JDb250ZXh0fSAqLyAoc3NyX2NvbnRleHQpLnIpLm9uX2Rlc3Ryb3koZm4pO1xufVxuXG5leHBvcnQge1xuXHRub29wIGFzIGJlZm9yZVVwZGF0ZSxcblx0bm9vcCBhcyBhZnRlclVwZGF0ZSxcblx0bm9vcCBhcyBvbk1vdW50LFxuXHRub29wIGFzIGZsdXNoU3luYyxcblx0cnVuIGFzIHVudHJhY2tcbn0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRyZXR1cm4gbm9vcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50KCkge1xuXHRlLmxpZmVjeWNsZV9mdW5jdGlvbl91bmF2YWlsYWJsZSgnbW91bnQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUoKSB7XG5cdGUubGlmZWN5Y2xlX2Z1bmN0aW9uX3VuYXZhaWxhYmxlKCdoeWRyYXRlJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KCkge1xuXHRlLmxpZmVjeWNsZV9mdW5jdGlvbl91bmF2YWlsYWJsZSgndW5tb3VudCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yaygpIHtcblx0ZS5saWZlY3ljbGVfZnVuY3Rpb25fdW5hdmFpbGFibGUoJ2ZvcmsnKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRpY2soKSB7fVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dGxlZCgpIHt9XG5cbmV4cG9ydCB7IGdldEFib3J0U2lnbmFsIH0gZnJvbSAnLi9pbnRlcm5hbC9zZXJ2ZXIvYWJvcnQtc2lnbmFsLmpzJztcblxuZXhwb3J0IHtcblx0Y3JlYXRlQ29udGV4dCxcblx0Z2V0QWxsQ29udGV4dHMsXG5cdGdldENvbnRleHQsXG5cdGhhc0NvbnRleHQsXG5cdHNldENvbnRleHRcbn0gZnJvbSAnLi9pbnRlcm5hbC9zZXJ2ZXIvY29udGV4dC5qcyc7XG5cbmV4cG9ydCB7IGh5ZHJhdGFibGUgfSBmcm9tICcuL2ludGVybmFsL3NlcnZlci9oeWRyYXRhYmxlLmpzJztcblxuZXhwb3J0IHsgY3JlYXRlUmF3U25pcHBldCB9IGZyb20gJy4vaW50ZXJuYWwvc2VydmVyL2Jsb2Nrcy9zbmlwcGV0LmpzJztcbiIsICIvKipcbiAqIFBob2VuaXggQ2hhbm5lbHMgSmF2YVNjcmlwdCBjbGllbnRcbiAqXG4gKiAjIyBTb2NrZXQgQ29ubmVjdGlvblxuICpcbiAqIEEgc2luZ2xlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgdG8gdGhlIHNlcnZlciBhbmRcbiAqIGNoYW5uZWxzIGFyZSBtdWx0aXBsZXhlZCBvdmVyIHRoZSBjb25uZWN0aW9uLlxuICogQ29ubmVjdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBgU29ja2V0YCBjbGFzczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgc29ja2V0ID0gbmV3IFNvY2tldChcIi9zb2NrZXRcIiwge3BhcmFtczoge3VzZXJUb2tlbjogXCIxMjNcIn19KVxuICogc29ja2V0LmNvbm5lY3QoKVxuICogYGBgXG4gKlxuICogVGhlIGBTb2NrZXRgIGNvbnN0cnVjdG9yIHRha2VzIHRoZSBtb3VudCBwb2ludCBvZiB0aGUgc29ja2V0LFxuICogdGhlIGF1dGhlbnRpY2F0aW9uIHBhcmFtcywgYXMgd2VsbCBhcyBvcHRpb25zIHRoYXQgY2FuIGJlIGZvdW5kIGluXG4gKiB0aGUgU29ja2V0IGRvY3MsIHN1Y2ggYXMgY29uZmlndXJpbmcgdGhlIGBMb25nUG9sbGAgdHJhbnNwb3J0LCBhbmRcbiAqIGhlYXJ0YmVhdC5cbiAqXG4gKiAjIyBDaGFubmVsc1xuICpcbiAqIENoYW5uZWxzIGFyZSBpc29sYXRlZCwgY29uY3VycmVudCBwcm9jZXNzZXMgb24gdGhlIHNlcnZlciB0aGF0XG4gKiBzdWJzY3JpYmUgdG8gdG9waWNzIGFuZCBicm9rZXIgZXZlbnRzIGJldHdlZW4gdGhlIGNsaWVudCBhbmQgc2VydmVyLlxuICogVG8gam9pbiBhIGNoYW5uZWwsIHlvdSBtdXN0IHByb3ZpZGUgdGhlIHRvcGljLCBhbmQgY2hhbm5lbCBwYXJhbXMgZm9yXG4gKiBhdXRob3JpemF0aW9uLiBIZXJlJ3MgYW4gZXhhbXBsZSBjaGF0IHJvb20gZXhhbXBsZSB3aGVyZSBgXCJuZXdfbXNnXCJgXG4gKiBldmVudHMgYXJlIGxpc3RlbmVkIGZvciwgbWVzc2FnZXMgYXJlIHB1c2hlZCB0byB0aGUgc2VydmVyLCBhbmRcbiAqIHRoZSBjaGFubmVsIGlzIGpvaW5lZCB3aXRoIG9rL2Vycm9yL3RpbWVvdXQgbWF0Y2hlczpcbiAqXG4gKiBgYGBcbiAqIGxldCBjaGFubmVsID0gc29ja2V0LmNoYW5uZWwoXCJyb29tOjEyM1wiLCB7dG9rZW46IHJvb21Ub2tlbn0pXG4gKiBjaGFubmVsLm9uKFwibmV3X21zZ1wiLCBtc2cgPT4gY29uc29sZS5sb2coXCJHb3QgbWVzc2FnZVwiLCBtc2cpIClcbiAqICRpbnB1dC5vbkVudGVyKCBlID0+IHtcbiAqICAgY2hhbm5lbC5wdXNoKFwibmV3X21zZ1wiLCB7Ym9keTogZS50YXJnZXQudmFsfSwgMTAwMDApXG4gKiAgICAgLnJlY2VpdmUoXCJva1wiLCAobXNnKSA9PiBjb25zb2xlLmxvZyhcImNyZWF0ZWQgbWVzc2FnZVwiLCBtc2cpIClcbiAqICAgICAucmVjZWl2ZShcImVycm9yXCIsIChyZWFzb25zKSA9PiBjb25zb2xlLmxvZyhcImNyZWF0ZSBmYWlsZWRcIiwgcmVhc29ucykgKVxuICogICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBjb25zb2xlLmxvZyhcIk5ldHdvcmtpbmcgaXNzdWUuLi5cIikgKVxuICogfSlcbiAqXG4gKiBjaGFubmVsLmpvaW4oKVxuICogICAucmVjZWl2ZShcIm9rXCIsICh7bWVzc2FnZXN9KSA9PiBjb25zb2xlLmxvZyhcImNhdGNoaW5nIHVwXCIsIG1lc3NhZ2VzKSApXG4gKiAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgKHtyZWFzb259KSA9PiBjb25zb2xlLmxvZyhcImZhaWxlZCBqb2luXCIsIHJlYXNvbikgKVxuICogICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gY29uc29sZS5sb2coXCJOZXR3b3JraW5nIGlzc3VlLiBTdGlsbCB3YWl0aW5nLi4uXCIpKVxuICpgYGBcbiAqXG4gKiAjIyBKb2luaW5nXG4gKlxuICogQ3JlYXRpbmcgYSBjaGFubmVsIHdpdGggYHNvY2tldC5jaGFubmVsKHRvcGljLCBwYXJhbXMpYCwgYmluZHMgdGhlIHBhcmFtcyB0b1xuICogYGNoYW5uZWwucGFyYW1zYCwgd2hpY2ggYXJlIHNlbnQgdXAgb24gYGNoYW5uZWwuam9pbigpYC5cbiAqIFN1YnNlcXVlbnQgcmVqb2lucyB3aWxsIHNlbmQgdXAgdGhlIG1vZGlmaWVkIHBhcmFtcyBmb3JcbiAqIHVwZGF0aW5nIGF1dGhvcml6YXRpb24gcGFyYW1zLCBvciBwYXNzaW5nIHVwIGxhc3RfbWVzc2FnZV9pZCBpbmZvcm1hdGlvbi5cbiAqIFN1Y2Nlc3NmdWwgam9pbnMgcmVjZWl2ZSBhbiBcIm9rXCIgc3RhdHVzLCB3aGlsZSB1bnN1Y2Nlc3NmdWwgam9pbnNcbiAqIHJlY2VpdmUgXCJlcnJvclwiLlxuICpcbiAqIFdpdGggdGhlIGRlZmF1bHQgc2VyaWFsaXplcnMgYW5kIFdlYlNvY2tldCB0cmFuc3BvcnQsIEpTT04gdGV4dCBmcmFtZXMgYXJlXG4gKiB1c2VkIGZvciBwdXNoaW5nIGEgSlNPTiBvYmplY3QgbGl0ZXJhbC4gSWYgYW4gYEFycmF5QnVmZmVyYCBpbnN0YW5jZSBpcyBwcm92aWRlZCxcbiAqIGJpbmFyeSBlbmNvZGluZyB3aWxsIGJlIHVzZWQgYW5kIHRoZSBtZXNzYWdlIHdpbGwgYmUgc2VudCB3aXRoIHRoZSBiaW5hcnlcbiAqIG9wY29kZS5cbiAqXG4gKiAqTm90ZSo6IGJpbmFyeSBtZXNzYWdlcyBhcmUgb25seSBzdXBwb3J0ZWQgb24gdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQuXG4gKlxuICogIyMgRHVwbGljYXRlIEpvaW4gU3Vic2NyaXB0aW9uc1xuICpcbiAqIFdoaWxlIHRoZSBjbGllbnQgbWF5IGpvaW4gYW55IG51bWJlciBvZiB0b3BpY3Mgb24gYW55IG51bWJlciBvZiBjaGFubmVscyxcbiAqIHRoZSBjbGllbnQgbWF5IG9ubHkgaG9sZCBhIHNpbmdsZSBzdWJzY3JpcHRpb24gZm9yIGVhY2ggdW5pcXVlIHRvcGljIGF0IGFueVxuICogZ2l2ZW4gdGltZS4gV2hlbiBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIGR1cGxpY2F0ZSBzdWJzY3JpcHRpb24sXG4gKiB0aGUgc2VydmVyIHdpbGwgY2xvc2UgdGhlIGV4aXN0aW5nIGNoYW5uZWwsIGxvZyBhIHdhcm5pbmcsIGFuZFxuICogc3Bhd24gYSBuZXcgY2hhbm5lbCBmb3IgdGhlIHRvcGljLiBUaGUgY2xpZW50IHdpbGwgaGF2ZSB0aGVpclxuICogYGNoYW5uZWwub25DbG9zZWAgY2FsbGJhY2tzIGZpcmVkIGZvciB0aGUgZXhpc3RpbmcgY2hhbm5lbCwgYW5kIHRoZSBuZXdcbiAqIGNoYW5uZWwgam9pbiB3aWxsIGhhdmUgaXRzIHJlY2VpdmUgaG9va3MgcHJvY2Vzc2VkIGFzIG5vcm1hbC5cbiAqXG4gKiAjIyBQdXNoaW5nIE1lc3NhZ2VzXG4gKlxuICogRnJvbSB0aGUgcHJldmlvdXMgZXhhbXBsZSwgd2UgY2FuIHNlZSB0aGF0IHB1c2hpbmcgbWVzc2FnZXMgdG8gdGhlIHNlcnZlclxuICogY2FuIGJlIGRvbmUgd2l0aCBgY2hhbm5lbC5wdXNoKGV2ZW50TmFtZSwgcGF5bG9hZClgIGFuZCB3ZSBjYW4gb3B0aW9uYWxseVxuICogcmVjZWl2ZSByZXNwb25zZXMgZnJvbSB0aGUgcHVzaC4gQWRkaXRpb25hbGx5LCB3ZSBjYW4gdXNlXG4gKiBgcmVjZWl2ZShcInRpbWVvdXRcIiwgY2FsbGJhY2spYCB0byBhYm9ydCB3YWl0aW5nIGZvciBvdXIgb3RoZXIgYHJlY2VpdmVgIGhvb2tzXG4gKiAgYW5kIHRha2UgYWN0aW9uIGFmdGVyIHNvbWUgcGVyaW9kIG9mIHdhaXRpbmcuIFRoZSBkZWZhdWx0IHRpbWVvdXQgaXMgMTAwMDBtcy5cbiAqXG4gKlxuICogIyMgU29ja2V0IEhvb2tzXG4gKlxuICogTGlmZWN5Y2xlIGV2ZW50cyBvZiB0aGUgbXVsdGlwbGV4ZWQgY29ubmVjdGlvbiBjYW4gYmUgaG9va2VkIGludG8gdmlhXG4gKiBgc29ja2V0Lm9uRXJyb3IoKWAgYW5kIGBzb2NrZXQub25DbG9zZSgpYCBldmVudHMsIGllOlxuICpcbiAqIGBgYFxuICogc29ja2V0Lm9uRXJyb3IoICgpID0+IGNvbnNvbGUubG9nKFwidGhlcmUgd2FzIGFuIGVycm9yIHdpdGggdGhlIGNvbm5lY3Rpb24hXCIpIClcbiAqIHNvY2tldC5vbkNsb3NlKCAoKSA9PiBjb25zb2xlLmxvZyhcInRoZSBjb25uZWN0aW9uIGRyb3BwZWRcIikgKVxuICogYGBgXG4gKlxuICpcbiAqICMjIENoYW5uZWwgSG9va3NcbiAqXG4gKiBGb3IgZWFjaCBqb2luZWQgY2hhbm5lbCwgeW91IGNhbiBiaW5kIHRvIGBvbkVycm9yYCBhbmQgYG9uQ2xvc2VgIGV2ZW50c1xuICogdG8gbW9uaXRvciB0aGUgY2hhbm5lbCBsaWZlY3ljbGUsIGllOlxuICpcbiAqIGBgYFxuICogY2hhbm5lbC5vbkVycm9yKCAoKSA9PiBjb25zb2xlLmxvZyhcInRoZXJlIHdhcyBhbiBlcnJvciFcIikgKVxuICogY2hhbm5lbC5vbkNsb3NlKCAoKSA9PiBjb25zb2xlLmxvZyhcInRoZSBjaGFubmVsIGhhcyBnb25lIGF3YXkgZ3JhY2VmdWxseVwiKSApXG4gKiBgYGBcbiAqXG4gKiAjIyMgb25FcnJvciBob29rc1xuICpcbiAqIGBvbkVycm9yYCBob29rcyBhcmUgaW52b2tlZCBpZiB0aGUgc29ja2V0IGNvbm5lY3Rpb24gZHJvcHMsIG9yIHRoZSBjaGFubmVsXG4gKiBjcmFzaGVzIG9uIHRoZSBzZXJ2ZXIuIEluIGVpdGhlciBjYXNlLCBhIGNoYW5uZWwgcmVqb2luIGlzIGF0dGVtcHRlZFxuICogYXV0b21hdGljYWxseSBpbiBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIG1hbm5lci5cbiAqXG4gKiAjIyMgb25DbG9zZSBob29rc1xuICpcbiAqIGBvbkNsb3NlYCBob29rcyBhcmUgaW52b2tlZCBvbmx5IGluIHR3byBjYXNlcy4gMSkgdGhlIGNoYW5uZWwgZXhwbGljaXRseVxuICogY2xvc2VkIG9uIHRoZSBzZXJ2ZXIsIG9yIDIpLiBUaGUgY2xpZW50IGV4cGxpY2l0bHkgY2xvc2VkLCBieSBjYWxsaW5nXG4gKiBgY2hhbm5lbC5sZWF2ZSgpYFxuICpcbiAqXG4gKiAjIyBQcmVzZW5jZVxuICpcbiAqIFRoZSBgUHJlc2VuY2VgIG9iamVjdCBwcm92aWRlcyBmZWF0dXJlcyBmb3Igc3luY2luZyBwcmVzZW5jZSBpbmZvcm1hdGlvblxuICogZnJvbSB0aGUgc2VydmVyIHdpdGggdGhlIGNsaWVudCBhbmQgaGFuZGxpbmcgcHJlc2VuY2VzIGpvaW5pbmcgYW5kIGxlYXZpbmcuXG4gKlxuICogIyMjIFN5bmNpbmcgc3RhdGUgZnJvbSB0aGUgc2VydmVyXG4gKlxuICogVG8gc3luYyBwcmVzZW5jZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIsIGZpcnN0IGluc3RhbnRpYXRlIGFuIG9iamVjdCBhbmRcbiAqIHBhc3MgeW91ciBjaGFubmVsIGluIHRvIHRyYWNrIGxpZmVjeWNsZSBldmVudHM6XG4gKlxuICogYGBgXG4gKiBsZXQgY2hhbm5lbCA9IHNvY2tldC5jaGFubmVsKFwic29tZTp0b3BpY1wiKVxuICogbGV0IHByZXNlbmNlID0gbmV3IFByZXNlbmNlKGNoYW5uZWwpXG4gKiBgYGBcbiAqXG4gKiBOZXh0LCB1c2UgdGhlIGBwcmVzZW5jZS5vblN5bmNgIGNhbGxiYWNrIHRvIHJlYWN0IHRvIHN0YXRlIGNoYW5nZXNcbiAqIGZyb20gdGhlIHNlcnZlci4gRm9yIGV4YW1wbGUsIHRvIHJlbmRlciB0aGUgbGlzdCBvZiB1c2VycyBldmVyeSB0aW1lXG4gKiB0aGUgbGlzdCBjaGFuZ2VzLCB5b3UgY291bGQgd3JpdGU6XG4gKlxuICogYGBgXG4gKiBwcmVzZW5jZS5vblN5bmMoKCkgPT4ge1xuICogICBteVJlbmRlclVzZXJzRnVuY3Rpb24ocHJlc2VuY2UubGlzdCgpKVxuICogfSlcbiAqIGBgYFxuICpcbiAqICMjIyBMaXN0aW5nIFByZXNlbmNlc1xuICpcbiAqIGBwcmVzZW5jZS5saXN0YCBpcyB1c2VkIHRvIHJldHVybiBhIGxpc3Qgb2YgcHJlc2VuY2UgaW5mb3JtYXRpb25cbiAqIGJhc2VkIG9uIHRoZSBsb2NhbCBzdGF0ZSBvZiBtZXRhZGF0YS4gQnkgZGVmYXVsdCwgYWxsIHByZXNlbmNlXG4gKiBtZXRhZGF0YSBpcyByZXR1cm5lZCwgYnV0IGEgYGxpc3RCeWAgZnVuY3Rpb24gY2FuIGJlIHN1cHBsaWVkIHRvXG4gKiBhbGxvdyB0aGUgY2xpZW50IHRvIHNlbGVjdCB3aGljaCBtZXRhZGF0YSB0byB1c2UgZm9yIGEgZ2l2ZW4gcHJlc2VuY2UuXG4gKiBGb3IgZXhhbXBsZSwgeW91IG1heSBoYXZlIGEgdXNlciBvbmxpbmUgZnJvbSBkaWZmZXJlbnQgZGV2aWNlcyB3aXRoXG4gKiBhIG1ldGFkYXRhIHN0YXR1cyBvZiBcIm9ubGluZVwiLCBidXQgdGhleSBoYXZlIHNldCB0aGVtc2VsdmVzIHRvIFwiYXdheVwiXG4gKiBvbiBhbm90aGVyIGRldmljZS4gSW4gdGhpcyBjYXNlLCB0aGUgYXBwIG1heSBjaG9vc2UgdG8gdXNlIHRoZSBcImF3YXlcIlxuICogc3RhdHVzIGZvciB3aGF0IGFwcGVhcnMgb24gdGhlIFVJLiBUaGUgZXhhbXBsZSBiZWxvdyBkZWZpbmVzIGEgYGxpc3RCeWBcbiAqIGZ1bmN0aW9uIHdoaWNoIHByaW9yaXRpemVzIHRoZSBmaXJzdCBtZXRhZGF0YSB3aGljaCB3YXMgcmVnaXN0ZXJlZCBmb3JcbiAqIGVhY2ggdXNlci4gVGhpcyBjb3VsZCBiZSB0aGUgZmlyc3QgdGFiIHRoZXkgb3BlbmVkLCBvciB0aGUgZmlyc3QgZGV2aWNlXG4gKiB0aGV5IGNhbWUgb25saW5lIGZyb206XG4gKlxuICogYGBgXG4gKiBsZXQgbGlzdEJ5ID0gKGlkLCB7bWV0YXM6IFtmaXJzdCwgLi4ucmVzdF19KSA9PiB7XG4gKiAgIGZpcnN0LmNvdW50ID0gcmVzdC5sZW5ndGggKyAxIC8vIGNvdW50IG9mIHRoaXMgdXNlcidzIHByZXNlbmNlc1xuICogICBmaXJzdC5pZCA9IGlkXG4gKiAgIHJldHVybiBmaXJzdFxuICogfVxuICogbGV0IG9ubGluZVVzZXJzID0gcHJlc2VuY2UubGlzdChsaXN0QnkpXG4gKiBgYGBcbiAqXG4gKiAjIyMgSGFuZGxpbmcgaW5kaXZpZHVhbCBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZSBldmVudHNcbiAqXG4gKiBUaGUgYHByZXNlbmNlLm9uSm9pbmAgYW5kIGBwcmVzZW5jZS5vbkxlYXZlYCBjYWxsYmFja3MgY2FuIGJlIHVzZWQgdG9cbiAqIHJlYWN0IHRvIGluZGl2aWR1YWwgcHJlc2VuY2VzIGpvaW5pbmcgYW5kIGxlYXZpbmcgdGhlIGFwcC4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiBsZXQgcHJlc2VuY2UgPSBuZXcgUHJlc2VuY2UoY2hhbm5lbClcbiAqXG4gKiAvLyBkZXRlY3QgaWYgdXNlciBoYXMgam9pbmVkIGZvciB0aGUgMXN0IHRpbWUgb3IgZnJvbSBhbm90aGVyIHRhYi9kZXZpY2VcbiAqIHByZXNlbmNlLm9uSm9pbigoaWQsIGN1cnJlbnQsIG5ld1ByZXMpID0+IHtcbiAqICAgaWYoIWN1cnJlbnQpe1xuICogICAgIGNvbnNvbGUubG9nKFwidXNlciBoYXMgZW50ZXJlZCBmb3IgdGhlIGZpcnN0IHRpbWVcIiwgbmV3UHJlcylcbiAqICAgfSBlbHNlIHtcbiAqICAgICBjb25zb2xlLmxvZyhcInVzZXIgYWRkaXRpb25hbCBwcmVzZW5jZVwiLCBuZXdQcmVzKVxuICogICB9XG4gKiB9KVxuICpcbiAqIC8vIGRldGVjdCBpZiB1c2VyIGhhcyBsZWZ0IGZyb20gYWxsIHRhYnMvZGV2aWNlcywgb3IgaXMgc3RpbGwgcHJlc2VudFxuICogcHJlc2VuY2Uub25MZWF2ZSgoaWQsIGN1cnJlbnQsIGxlZnRQcmVzKSA9PiB7XG4gKiAgIGlmKGN1cnJlbnQubWV0YXMubGVuZ3RoID09PSAwKXtcbiAqICAgICBjb25zb2xlLmxvZyhcInVzZXIgaGFzIGxlZnQgZnJvbSBhbGwgZGV2aWNlc1wiLCBsZWZ0UHJlcylcbiAqICAgfSBlbHNlIHtcbiAqICAgICBjb25zb2xlLmxvZyhcInVzZXIgbGVmdCBmcm9tIGEgZGV2aWNlXCIsIGxlZnRQcmVzKVxuICogICB9XG4gKiB9KVxuICogLy8gcmVjZWl2ZSBwcmVzZW5jZSBkYXRhIGZyb20gc2VydmVyXG4gKiBwcmVzZW5jZS5vblN5bmMoKCkgPT4ge1xuICogICBkaXNwbGF5VXNlcnMocHJlc2VuY2UubGlzdCgpKVxuICogfSlcbiAqIGBgYFxuICogQG1vZHVsZSBwaG9lbml4XG4gKi9cblxuaW1wb3J0IENoYW5uZWwgZnJvbSBcIi4vY2hhbm5lbFwiXG5pbXBvcnQgTG9uZ1BvbGwgZnJvbSBcIi4vbG9uZ3BvbGxcIlxuaW1wb3J0IFByZXNlbmNlIGZyb20gXCIuL3ByZXNlbmNlXCJcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gXCIuL3NlcmlhbGl6ZXJcIlxuaW1wb3J0IFNvY2tldCBmcm9tIFwiLi9zb2NrZXRcIlxuXG5leHBvcnQge1xuICBDaGFubmVsLFxuICBMb25nUG9sbCxcbiAgUHJlc2VuY2UsXG4gIFNlcmlhbGl6ZXIsXG4gIFNvY2tldFxufVxuIiwgIi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsdWUpID0+IHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpe1xuICAgIHJldHVybiB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIGxldCBjbG9zdXJlID0gZnVuY3Rpb24gKCl7IHJldHVybiB2YWx1ZSB9XG4gICAgcmV0dXJuIGNsb3N1cmVcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBnbG9iYWxTZWxmID0gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogbnVsbFxuZXhwb3J0IGNvbnN0IHBoeFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsXG5leHBvcnQgY29uc3QgZ2xvYmFsID0gZ2xvYmFsU2VsZiB8fCBwaHhXaW5kb3cgfHwgZ2xvYmFsVGhpc1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVlNOID0gXCIyLjAuMFwiXG5leHBvcnQgY29uc3QgU09DS0VUX1NUQVRFUyA9IHtjb25uZWN0aW5nOiAwLCBvcGVuOiAxLCBjbG9zaW5nOiAyLCBjbG9zZWQ6IDN9XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDBcbmV4cG9ydCBjb25zdCBXU19DTE9TRV9OT1JNQUwgPSAxMDAwXG5leHBvcnQgY29uc3QgQ0hBTk5FTF9TVEFURVMgPSB7XG4gIGNsb3NlZDogXCJjbG9zZWRcIixcbiAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gIGpvaW5lZDogXCJqb2luZWRcIixcbiAgam9pbmluZzogXCJqb2luaW5nXCIsXG4gIGxlYXZpbmc6IFwibGVhdmluZ1wiLFxufVxuZXhwb3J0IGNvbnN0IENIQU5ORUxfRVZFTlRTID0ge1xuICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgZXJyb3I6IFwicGh4X2Vycm9yXCIsXG4gIGpvaW46IFwicGh4X2pvaW5cIixcbiAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gIGxlYXZlOiBcInBoeF9sZWF2ZVwiXG59XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BPUlRTID0ge1xuICBsb25ncG9sbDogXCJsb25ncG9sbFwiLFxuICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbn1cbmV4cG9ydCBjb25zdCBYSFJfU1RBVEVTID0ge1xuICBjb21wbGV0ZTogNFxufVxuZXhwb3J0IGNvbnN0IEFVVEhfVE9LRU5fUFJFRklYID0gXCJiYXNlNjR1cmwuYmVhcmVyLnBoeC5cIlxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBDaGFubmVsXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IDEyM31gXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBldmVudCwgcGF5bG9hZCwgdGltZW91dCl7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbFxuICAgIHRoaXMuZXZlbnQgPSBldmVudFxuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQgfHwgZnVuY3Rpb24gKCl7IHJldHVybiB7fSB9XG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICAgIHRoaXMucmVjSG9va3MgPSBbXVxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICovXG4gIHJlc2VuZCh0aW1lb3V0KXtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy5yZXNldCgpXG4gICAgdGhpcy5zZW5kKClcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2VuZCgpe1xuICAgIGlmKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnN0YXJ0VGltZW91dCgpXG4gICAgdGhpcy5zZW50ID0gdHJ1ZVxuICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQoKSxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGF0dXNcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKHN0YXR1cykpe1xuICAgICAgY2FsbGJhY2sodGhpcy5yZWNlaXZlZFJlc3AucmVzcG9uc2UpXG4gICAgfVxuXG4gICAgdGhpcy5yZWNIb29rcy5wdXNoKHtzdGF0dXMsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldCgpe1xuICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgIHRoaXMucmVmID0gbnVsbFxuICAgIHRoaXMucmVmRXZlbnQgPSBudWxsXG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWF0Y2hSZWNlaXZlKHtzdGF0dXMsIHJlc3BvbnNlLCBfcmVmfSl7XG4gICAgdGhpcy5yZWNIb29rcy5maWx0ZXIoaCA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgLmZvckVhY2goaCA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsUmVmRXZlbnQoKXtcbiAgICBpZighdGhpcy5yZWZFdmVudCl7IHJldHVybiB9XG4gICAgdGhpcy5jaGFubmVsLm9mZih0aGlzLnJlZkV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxUaW1lb3V0KCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKVxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydFRpbWVvdXQoKXtcbiAgICBpZih0aGlzLnRpbWVvdXRUaW1lcil7IHRoaXMuY2FuY2VsVGltZW91dCgpIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQubWFrZVJlZigpXG4gICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5yZXBseUV2ZW50TmFtZSh0aGlzLnJlZilcblxuICAgIHRoaXMuY2hhbm5lbC5vbih0aGlzLnJlZkV2ZW50LCBwYXlsb2FkID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KClcbiAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZFxuICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZClcbiAgICB9KVxuXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pXG4gICAgfSwgdGhpcy50aW1lb3V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNSZWNlaXZlZChzdGF0dXMpe1xuICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyKHN0YXR1cywgcmVzcG9uc2Upe1xuICAgIHRoaXMuY2hhbm5lbC50cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHtzdGF0dXMsIHJlc3BvbnNlfSlcbiAgfVxufVxuIiwgIi8qKlxuICpcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtXG4gKiBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogfSlcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gdGltZXJDYWxjXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYyl7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGNcbiAgICB0aGlzLnRpbWVyID0gbnVsbFxuICAgIHRoaXMudHJpZXMgPSAwXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJpZXMgPSAwXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgICovXG4gIHNjaGVkdWxlVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuXG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxXG4gICAgICB0aGlzLmNhbGxiYWNrKClcbiAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpXG4gIH1cbn1cbiIsICJpbXBvcnQge2Nsb3N1cmV9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTLFxuICBDSEFOTkVMX1NUQVRFUyxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IFB1c2ggZnJvbSBcIi4vcHVzaFwiXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vdGltZXJcIlxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IHBhcmFtc1xuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsIHtcbiAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KXtcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgdGhpcy50b3BpYyA9IHRvcGljXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMuYmluZGluZ3MgPSBbXVxuICAgIHRoaXMuYmluZGluZ1JlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0XG4gICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2VcbiAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dClcbiAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW11cblxuICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0sIHRoaXMuc29ja2V0LnJlam9pbkFmdGVyTXMpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbkVycm9yKCgpID0+IHRoaXMucmVqb2luVGltZXIucmVzZXQoKSkpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICBpZih0aGlzLmlzRXJyb3JlZCgpKXsgdGhpcy5yZWpvaW4oKSB9XG4gICAgfSlcbiAgICApXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaChwdXNoRXZlbnQgPT4gcHVzaEV2ZW50LnNlbmQoKSlcbiAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLmpvaW5SZWYoKX1gKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlKHRoaXMpXG4gICAgfSlcbiAgICB0aGlzLm9uRXJyb3IocmVhc29uID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKVxuICAgICAgaWYodGhpcy5pc0pvaW5pbmcoKSl7IHRoaXMuam9pblB1c2gucmVzZXQoKSB9XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpXG4gICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpXG4gICAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCAocGF5bG9hZCwgcmVmKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSm9pbiB0aGUgY2hhbm5lbFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIGlmKHRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBqb2luIG11bHRpcGxlIHRpbWVzLiAnam9pbicgY2FuIG9ubHkgYmUgY2FsbGVkIGEgc2luZ2xlIHRpbWUgcGVyIGNoYW5uZWwgaW5zdGFuY2VcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZVxuICAgICAgdGhpcy5yZWpvaW4oKVxuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSG9vayBpbnRvIGNoYW5uZWwgY2xvc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGVycm9yc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHJlYXNvbiA9PiBjYWxsYmFjayhyZWFzb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgb24gY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogU3Vic2NyaXB0aW9uIHJldHVybnMgYSByZWYgY291bnRlciwgd2hpY2ggY2FuIGJlIHVzZWQgbGF0ZXIgdG9cbiAgICogdW5zdWJzY3JpYmUgdGhlIGV4YWN0IGV2ZW50IGxpc3RlbmVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNvbnN0IHJlZjIgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fb3RoZXJfc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICogLy8gU2luY2UgdW5zdWJzY3JpcHRpb24sIGRvX3N0dWZmIHdvbid0IGZpcmUsXG4gICAqIC8vIHdoaWxlIGRvX290aGVyX3N0dWZmIHdpbGwga2VlcCBmaXJpbmcgb24gdGhlIFwiZXZlbnRcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge2ludGVnZXJ9IHJlZlxuICAgKi9cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5iaW5kaW5nUmVmKytcbiAgICB0aGlzLmJpbmRpbmdzLnB1c2goe2V2ZW50LCByZWYsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIG9mZiBvZiBjaGFubmVsIGV2ZW50c1xuICAgKlxuICAgKiBVc2UgdGhlIHJlZiByZXR1cm5lZCBmcm9tIGEgY2hhbm5lbC5vbigpIHRvIHVuc3Vic2NyaWJlIG9uZVxuICAgKiBoYW5kbGVyLCBvciBwYXNzIG5vdGhpbmcgZm9yIHRoZSByZWYgdG8gdW5zdWJzY3JpYmUgYWxsXG4gICAqIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVuc3Vic2NyaWJlIHRoZSBkb19zdHVmZiBoYW5kbGVyXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICpcbiAgICogLy8gVW5zdWJzY3JpYmUgYWxsIGhhbmRsZXJzIGZyb20gZXZlbnRcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9mZihldmVudCwgcmVmKXtcbiAgICB0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgIHJldHVybiAhKGJpbmQuZXZlbnQgPT09IGV2ZW50ICYmICh0eXBlb2YgcmVmID09PSBcInVuZGVmaW5lZFwiIHx8IHJlZiA9PT0gYmluZC5yZWYpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhblB1c2goKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5pc0pvaW5lZCgpIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIGBldmVudGAgdG8gcGhvZW5peCB3aXRoIHRoZSBwYXlsb2FkIGBwYXlsb2FkYC5cbiAgICogUGhvZW5peCByZWNlaXZlcyB0aGlzIGluIHRoZSBgaGFuZGxlX2luKGV2ZW50LCBwYXlsb2FkLCBzb2NrZXQpYFxuICAgKiBmdW5jdGlvbi4gaWYgcGhvZW5peCByZXBsaWVzIG9yIGl0IHRpbWVzIG91dCAoZGVmYXVsdCAxMDAwMG1zKSxcbiAgICogdGhlbiBvcHRpb25hbGx5IHRoZSByZXBseSBjYW4gYmUgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYW5uZWwucHVzaChcImV2ZW50XCIpXG4gICAqICAgLnJlY2VpdmUoXCJva1wiLCBwYXlsb2FkID0+IGNvbnNvbGUubG9nKFwicGhvZW5peCByZXBsaWVkOlwiLCBwYXlsb2FkKSlcbiAgICogICAucmVjZWl2ZShcImVycm9yXCIsIGVyciA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggZXJyb3JlZFwiLCBlcnIpKVxuICAgKiAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBjb25zb2xlLmxvZyhcInRpbWVkIG91dCBwdXNoaW5nXCIpKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XVxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIHB1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9XG4gICAgaWYoIXRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKVxuICAgIH1cbiAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIGZ1bmN0aW9uICgpeyByZXR1cm4gcGF5bG9hZCB9LCB0aW1lb3V0KVxuICAgIGlmKHRoaXMuY2FuUHVzaCgpKXtcbiAgICAgIHB1c2hFdmVudC5zZW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1c2hFdmVudFxuICB9XG5cbiAgLyoqIExlYXZlcyB0aGUgY2hhbm5lbFxuICAgKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmRcbiAgICogaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlclxuICAgKlxuICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3NcbiAgICpcbiAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGByZWNlaXZlYFxuICAgKiBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLmxlYXZlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBsZWF2ZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICB0aGlzLmpvaW5QdXNoLmNhbmNlbFRpbWVvdXQoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBsZWF2ZSAke3RoaXMudG9waWN9YClcbiAgICAgIHRoaXMudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgXCJsZWF2ZVwiKVxuICAgIH1cbiAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aW1lb3V0KVxuICAgIGxlYXZlUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4gb25DbG9zZSgpKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgaWYoIXRoaXMuY2FuUHVzaCgpKXsgbGVhdmVQdXNoLnRyaWdnZXIoXCJva1wiLCB7fSkgfVxuXG4gICAgcmV0dXJuIGxlYXZlUHVzaFxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgKlxuICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nXG4gICAqIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAqXG4gICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJlZlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgb25NZXNzYWdlKF9ldmVudCwgcGF5bG9hZCwgX3JlZil7IHJldHVybiBwYXlsb2FkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZil7XG4gICAgaWYodGhpcy50b3BpYyAhPT0gdG9waWMpeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSl7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwge3RvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZn0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGpvaW5SZWYoKXsgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmlzTGVhdmluZygpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnNvY2tldC5sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKVxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKXtcbiAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLm9uTWVzc2FnZShldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKVxuICAgIGlmKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKXsgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXCIpIH1cblxuICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoYmluZCA9PiBiaW5kLmV2ZW50ID09PSBldmVudClcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBldmVudEJpbmRpbmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGxldCBiaW5kID0gZXZlbnRCaW5kaW5nc1tpXVxuICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmLCBqb2luUmVmIHx8IHRoaXMuam9pblJlZigpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwbHlFdmVudE5hbWUocmVmKXsgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9zZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0Vycm9yZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0pvaW5pbmcoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmcgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNMZWF2aW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIFhIUl9TVEFURVNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWpheCB7XG5cbiAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgaGVhZGVycywgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgaWYoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KXtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCkgLy8gSUU4LCBJRTlcbiAgICAgIHJldHVybiB0aGlzLnhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9IGVsc2UgaWYoZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KXtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCkgLy8gSUU3KywgRmlyZWZveCwgQ2hyb21lLCBPcGVyYSwgU2FmYXJpXG4gICAgICByZXR1cm4gdGhpcy54aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgaGVhZGVycywgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9IGVsc2UgaWYoZ2xvYmFsLmZldGNoICYmIGdsb2JhbC5BYm9ydENvbnRyb2xsZXIpe1xuICAgICAgLy8gRmV0Y2ggd2l0aCBBYm9ydENvbnRyb2xsZXIgZm9yIG1vZGVybiBicm93c2Vyc1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hSZXF1ZXN0KG1ldGhvZCwgZW5kUG9pbnQsIGhlYWRlcnMsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1aXRhYmxlIFhNTEh0dHBSZXF1ZXN0IGltcGxlbWVudGF0aW9uIGZvdW5kXCIpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZldGNoUmVxdWVzdChtZXRob2QsIGVuZFBvaW50LCBoZWFkZXJzLCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH1cbiAgICBsZXQgY29udHJvbGxlciA9IG51bGxcbiAgICBpZih0aW1lb3V0KXtcbiAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIGNvbnN0IF90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dClcbiAgICAgIG9wdGlvbnMuc2lnbmFsID0gY29udHJvbGxlci5zaWduYWxcbiAgICB9XG4gICAgZ2xvYmFsLmZldGNoKGVuZFBvaW50LCBvcHRpb25zKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UudGV4dCgpKVxuICAgICAgLnRoZW4oZGF0YSA9PiB0aGlzLnBhcnNlSlNPTihkYXRhKSlcbiAgICAgIC50aGVuKGRhdGEgPT4gY2FsbGJhY2sgJiYgY2FsbGJhY2soZGF0YSkpXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiICYmIG9udGltZW91dCl7XG4gICAgICAgICAgb250aW1lb3V0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIHJldHVybiBjb250cm9sbGVyXG4gIH1cblxuICBzdGF0aWMgeGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50KVxuICAgIHJlcS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgfVxuICAgIGlmKG9udGltZW91dCl7IHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQgfVxuXG4gICAgLy8gV29yayBhcm91bmQgYnVnIGluIElFOSB0aGF0IHJlcXVpcmVzIGFuIGF0dGFjaGVkIG9ucHJvZ3Jlc3MgaGFuZGxlclxuICAgIHJlcS5vbnByb2dyZXNzID0gKCkgPT4geyB9XG5cbiAgICByZXEuc2VuZChib2R5KVxuICAgIHJldHVybiByZXFcbiAgfVxuXG4gIHN0YXRpYyB4aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgaGVhZGVycywgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludCwgdHJ1ZSlcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICBmb3IobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSl7XG4gICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKVxuICAgIH1cbiAgICByZXEub25lcnJvciA9ICgpID0+IGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpXG4gICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmKHJlcS5yZWFkeVN0YXRlID09PSBYSFJfU1RBVEVTLmNvbXBsZXRlICYmIGNhbGxiYWNrKXtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dClcbiAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9udGltZW91dCl7IHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQgfVxuXG4gICAgcmVxLnNlbmQoYm9keSlcbiAgICByZXR1cm4gcmVxXG4gIH1cblxuICBzdGF0aWMgcGFyc2VKU09OKHJlc3Ape1xuICAgIGlmKCFyZXNwIHx8IHJlc3AgPT09IFwiXCIpeyByZXR1cm4gbnVsbCB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcClcbiAgICB9IGNhdGNoIHtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJmYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZVwiLCByZXNwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgcGFyZW50S2V5KXtcbiAgICBsZXQgcXVlcnlTdHIgPSBbXVxuICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICBpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSl7IGNvbnRpbnVlIH1cbiAgICAgIGxldCBwYXJhbUtleSA9IHBhcmVudEtleSA/IGAke3BhcmVudEtleX1bJHtrZXl9XWAgOiBrZXlcbiAgICAgIGxldCBwYXJhbVZhbCA9IG9ialtrZXldXG4gICAgICBpZih0eXBlb2YgcGFyYW1WYWwgPT09IFwib2JqZWN0XCIpe1xuICAgICAgICBxdWVyeVN0ci5wdXNoKHRoaXMuc2VyaWFsaXplKHBhcmFtVmFsLCBwYXJhbUtleSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwYXJhbUtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVN0ci5qb2luKFwiJlwiKVxuICB9XG5cbiAgc3RhdGljIGFwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcyl7XG4gICAgaWYoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApeyByZXR1cm4gdXJsIH1cblxuICAgIGxldCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gXCImXCIgOiBcIj9cIlxuICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHt0aGlzLnNlcmlhbGl6ZShwYXJhbXMpfWBcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFMsXG4gIEFVVEhfVE9LRU5fUFJFRklYXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBBamF4IGZyb20gXCIuL2FqYXhcIlxuXG5sZXQgYXJyYXlCdWZmZXJUb0Jhc2U2NCA9IChidWZmZXIpID0+IHtcbiAgbGV0IGJpbmFyeSA9IFwiXCJcbiAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICBsZXQgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aFxuICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspeyBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkgfVxuICByZXR1cm4gYnRvYShiaW5hcnkpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdQb2xsIHtcblxuICBjb25zdHJ1Y3RvcihlbmRQb2ludCwgcHJvdG9jb2xzKXtcbiAgICAvLyB3ZSBvbmx5IHN1cHBvcnQgc3VicHJvdG9jb2xzIGZvciBhdXRoVG9rZW5cbiAgICAvLyBbXCJwaG9lbml4XCIsIFwiYmFzZTY0dXJsLmJlYXJlci5waHguQkFTRTY0X0VOQ09ERURfVE9LRU5cIl1cbiAgICBpZihwcm90b2NvbHMgJiYgcHJvdG9jb2xzLmxlbmd0aCA9PT0gMiAmJiBwcm90b2NvbHNbMV0uc3RhcnRzV2l0aChBVVRIX1RPS0VOX1BSRUZJWCkpe1xuICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdG9iKHByb3RvY29sc1sxXS5zbGljZShBVVRIX1RPS0VOX1BSRUZJWC5sZW5ndGgpKVxuICAgIH1cbiAgICB0aGlzLmVuZFBvaW50ID0gbnVsbFxuICAgIHRoaXMudG9rZW4gPSBudWxsXG4gICAgdGhpcy5za2lwSGVhcnRiZWF0ID0gdHJ1ZVxuICAgIHRoaXMucmVxcyA9IG5ldyBTZXQoKVxuICAgIHRoaXMuYXdhaXRpbmdCYXRjaEFjayA9IGZhbHNlXG4gICAgdGhpcy5jdXJyZW50QmF0Y2ggPSBudWxsXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IG51bGxcbiAgICB0aGlzLmJhdGNoQnVmZmVyID0gW11cbiAgICB0aGlzLm9ub3BlbiA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMucG9sbEVuZHBvaW50ID0gdGhpcy5ub3JtYWxpemVFbmRwb2ludChlbmRQb2ludClcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgICAvLyB3ZSBtdXN0IHdhaXQgZm9yIHRoZSBjYWxsZXIgdG8gZmluaXNoIHNldHRpbmcgdXAgb3VyIGNhbGxiYWNrcyBhbmQgdGltZW91dCBwcm9wZXJ0aWVzXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnBvbGwoKSwgMClcbiAgfVxuXG4gIG5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KXtcbiAgICByZXR1cm4gKGVuZFBvaW50XG4gICAgICAucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKVxuICAgICAgLnJlcGxhY2UoXCJ3c3M6Ly9cIiwgXCJodHRwczovL1wiKVxuICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChcIiguKilcXC9cIiArIFRSQU5TUE9SVFMud2Vic29ja2V0KSwgXCIkMS9cIiArIFRSQU5TUE9SVFMubG9uZ3BvbGwpKVxuICB9XG5cbiAgZW5kcG9pbnRVUkwoKXtcbiAgICByZXR1cm4gQWpheC5hcHBlbmRQYXJhbXModGhpcy5wb2xsRW5kcG9pbnQsIHt0b2tlbjogdGhpcy50b2tlbn0pXG4gIH1cblxuICBjbG9zZUFuZFJldHJ5KGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pe1xuICAgIHRoaXMuY2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbilcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcbiAgfVxuXG4gIG9udGltZW91dCgpe1xuICAgIHRoaXMub25lcnJvcihcInRpbWVvdXRcIilcbiAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAwNSwgXCJ0aW1lb3V0XCIsIGZhbHNlKVxuICB9XG5cbiAgaXNBY3RpdmUoKXsgcmV0dXJuIHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nIH1cblxuICBwb2xsKCl7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcIkFjY2VwdFwiOiBcImFwcGxpY2F0aW9uL2pzb25cIn1cbiAgICBpZih0aGlzLmF1dGhUb2tlbil7XG4gICAgICBoZWFkZXJzW1wiWC1QaG9lbml4LUF1dGhUb2tlblwiXSA9IHRoaXMuYXV0aFRva2VuXG4gICAgfVxuICAgIHRoaXMuYWpheChcIkdFVFwiLCBoZWFkZXJzLCBudWxsLCAoKSA9PiB0aGlzLm9udGltZW91dCgpLCByZXNwID0+IHtcbiAgICAgIGlmKHJlc3Ape1xuICAgICAgICB2YXIge3N0YXR1cywgdG9rZW4sIG1lc3NhZ2VzfSA9IHJlc3BcbiAgICAgICAgaWYoc3RhdHVzID09PSA0MTAgJiYgdGhpcy50b2tlbiAhPT0gbnVsbCl7XG4gICAgICAgICAgLy8gSW4gY2FzZSB3ZSBhbHJlYWR5IGhhdmUgYSB0b2tlbiwgdGhpcyBtZWFucyB0aGF0IG91ciBleGlzdGluZyBzZXNzaW9uXG4gICAgICAgICAgLy8gaXMgZ29uZS4gV2UgZmFpbCBzbyB0aGF0IHRoZSBjbGllbnQgcmVqb2lucyBpdHMgY2hhbm5lbHMuXG4gICAgICAgICAgdGhpcy5vbmVycm9yKDQxMClcbiAgICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMzQxMCwgXCJzZXNzaW9uX2dvbmVcIiwgZmFsc2UpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAwXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaChzdGF0dXMpe1xuICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICAgICAgICAvLyBUYXNrcyBhcmUgd2hhdCB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgc2V0VGltZW91dCBjYWxsYmFja3MsXG4gICAgICAgICAgICAvLyBwcm9taXNlIHJlc29sdmVzIGFuZCBtb3JlIGFyZSBydW4gd2l0aGluLlxuICAgICAgICAgICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCB0aGVyZSBhcmUgdHdvIGRpZmZlcmVudCBraW5kcyBvZiB0YXNrcyxcbiAgICAgICAgICAgIC8vIG1pY3JvdGFza3MgYW5kIG1hY3JvdGFza3MuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFyZSBtYWlubHkgdXNlZCBmb3IgUHJvbWlzZXMsIHdoaWxlIG1hY3JvdGFza3MgYXJlXG4gICAgICAgICAgICAvLyB1c2VkIGZvciBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFsd2F5cyBoYXZlIHByaW9yaXR5IG92ZXIgbWFjcm90YXNrcy4gSWYgdGhlIEpTIGVuZ2luZVxuICAgICAgICAgICAgLy8gaXMgbG9va2luZyBmb3IgYSB0YXNrIHRvIHJ1biwgaXQgd2lsbCBhbHdheXMgdHJ5IHRvIGVtcHR5IHRoZVxuICAgICAgICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJ1biBhbnl0aGluZyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gbWFjcm90YXNrIHF1ZXVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciB0aGUgV2ViU29ja2V0IHRyYW5zcG9ydCwgbWVzc2FnZXMgYWx3YXlzIGFycml2ZSBpbiB0aGVpciBvd25cbiAgICAgICAgICAgIC8vIGV2ZW50LiBUaGlzIG1lYW5zIHRoYXQgaWYgYW55IHByb21pc2VzIGFyZSByZXNvbHZlZCBmcm9tIHdpdGhpbixcbiAgICAgICAgICAgIC8vIHRoZWlyIGNhbGxiYWNrcyB3aWxsIGFsd2F5cyBmaW5pc2ggZXhlY3V0aW9uIGJ5IHRoZSB0aW1lIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBtZXNzYWdlIGV2ZW50IGhhbmRsZXIgaXMgcnVuLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGVtdWxhdGUgdGhpcyBiZWhhdmlvdXIsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGVhY2hcbiAgICAgICAgICAgIC8vIG9ubWVzc2FnZSBoYW5kbGVyIGlzIHJ1biB3aXRoaW4gaXRzIG93biBtYWNyb3Rhc2suXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25tZXNzYWdlKHtkYXRhOiBtc2d9KSwgMClcbiAgICAgICAgICB9KVxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyMDQ6XG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQxMDpcbiAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLm9wZW5cbiAgICAgICAgICB0aGlzLm9ub3Blbih7fSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgIHRoaXMub25lcnJvcig0MDMpXG4gICAgICAgICAgdGhpcy5jbG9zZSgxMDA4LCBcImZvcmJpZGRlblwiLCBmYWxzZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgNTAwOlxuICAgICAgICAgIHRoaXMub25lcnJvcig1MDApXG4gICAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIDUwMClcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBwb2xsIHN0YXR1cyAke3N0YXR1c31gKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyB3ZSBjb2xsZWN0IGFsbCBwdXNoZXMgd2l0aGluIHRoZSBjdXJyZW50IGV2ZW50IGxvb3AgYnlcbiAgLy8gc2V0VGltZW91dCAwLCB3aGljaCBvcHRpbWl6ZXMgYmFjay10by1iYWNrIHByb2NlZHVyYWxcbiAgLy8gcHVzaGVzIGFnYWluc3QgYW4gZW1wdHkgYnVmZmVyXG5cbiAgc2VuZChib2R5KXtcbiAgICBpZih0eXBlb2YoYm9keSkgIT09IFwic3RyaW5nXCIpeyBib2R5ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChib2R5KSB9XG4gICAgaWYodGhpcy5jdXJyZW50QmF0Y2gpe1xuICAgICAgdGhpcy5jdXJyZW50QmF0Y2gucHVzaChib2R5KVxuICAgIH0gZWxzZSBpZih0aGlzLmF3YWl0aW5nQmF0Y2hBY2spe1xuICAgICAgdGhpcy5iYXRjaEJ1ZmZlci5wdXNoKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudEJhdGNoID0gW2JvZHldXG4gICAgICB0aGlzLmN1cnJlbnRCYXRjaFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYmF0Y2hTZW5kKHRoaXMuY3VycmVudEJhdGNoKVxuICAgICAgICB0aGlzLmN1cnJlbnRCYXRjaCA9IG51bGxcbiAgICAgIH0sIDApXG4gICAgfVxuICB9XG5cbiAgYmF0Y2hTZW5kKG1lc3NhZ2VzKXtcbiAgICB0aGlzLmF3YWl0aW5nQmF0Y2hBY2sgPSB0cnVlXG4gICAgdGhpcy5hamF4KFwiUE9TVFwiLCB7XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LW5kanNvblwifSwgbWVzc2FnZXMuam9pbihcIlxcblwiKSwgKCkgPT4gdGhpcy5vbmVycm9yKFwidGltZW91dFwiKSwgcmVzcCA9PiB7XG4gICAgICB0aGlzLmF3YWl0aW5nQmF0Y2hBY2sgPSBmYWxzZVxuICAgICAgaWYoIXJlc3AgfHwgcmVzcC5zdGF0dXMgIT09IDIwMCl7XG4gICAgICAgIHRoaXMub25lcnJvcihyZXNwICYmIHJlc3Auc3RhdHVzKVxuICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoMTAxMSwgXCJpbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiwgZmFsc2UpXG4gICAgICB9IGVsc2UgaWYodGhpcy5iYXRjaEJ1ZmZlci5sZW5ndGggPiAwKXtcbiAgICAgICAgdGhpcy5iYXRjaFNlbmQodGhpcy5iYXRjaEJ1ZmZlcilcbiAgICAgICAgdGhpcy5iYXRjaEJ1ZmZlciA9IFtdXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pe1xuICAgIGZvcihsZXQgcmVxIG9mIHRoaXMucmVxcyl7IHJlcS5hYm9ydCgpIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNsb3NlZFxuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7Y29kZTogMTAwMCwgcmVhc29uOiB1bmRlZmluZWQsIHdhc0NsZWFuOiB0cnVlfSwge2NvZGUsIHJlYXNvbiwgd2FzQ2xlYW59KVxuICAgIHRoaXMuYmF0Y2hCdWZmZXIgPSBbXVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmN1cnJlbnRCYXRjaFRpbWVyKVxuICAgIHRoaXMuY3VycmVudEJhdGNoVGltZXIgPSBudWxsXG4gICAgaWYodHlwZW9mKENsb3NlRXZlbnQpICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgIHRoaXMub25jbG9zZShuZXcgQ2xvc2VFdmVudChcImNsb3NlXCIsIG9wdHMpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uY2xvc2Uob3B0cylcbiAgICB9XG4gIH1cblxuICBhamF4KG1ldGhvZCwgaGVhZGVycywgYm9keSwgb25DYWxsZXJUaW1lb3V0LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlcVxuICAgIGxldCBvbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlcXMuZGVsZXRlKHJlcSlcbiAgICAgIG9uQ2FsbGVyVGltZW91dCgpXG4gICAgfVxuICAgIHJlcSA9IEFqYXgucmVxdWVzdChtZXRob2QsIHRoaXMuZW5kcG9pbnRVUkwoKSwgaGVhZGVycywgYm9keSwgdGhpcy50aW1lb3V0LCBvbnRpbWVvdXQsIHJlc3AgPT4ge1xuICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpXG4gICAgICBpZih0aGlzLmlzQWN0aXZlKCkpeyBjYWxsYmFjayhyZXNwKSB9XG4gICAgfSlcbiAgICB0aGlzLnJlcXMuYWRkKHJlcSlcbiAgfVxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiBcInN0YXRlXCIsIGRpZmY6IFwiZGlmZlwifX1gXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNlbmNlIHtcblxuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pe1xuICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7c3RhdGU6IFwicHJlc2VuY2Vfc3RhdGVcIiwgZGlmZjogXCJwcmVzZW5jZV9kaWZmXCJ9XG4gICAgdGhpcy5zdGF0ZSA9IHt9XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmpvaW5SZWYgPSBudWxsXG4gICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICBvbkpvaW46IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25MZWF2ZTogZnVuY3Rpb24gKCl7IH0sXG4gICAgICBvblN5bmM6IGZ1bmN0aW9uICgpeyB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5zdGF0ZSwgbmV3U3RhdGUgPT4ge1xuICAgICAgbGV0IHtvbkpvaW4sIG9uTGVhdmUsIG9uU3luY30gPSB0aGlzLmNhbGxlclxuXG4gICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpXG4gICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goZGlmZiA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgICAgb25TeW5jKClcbiAgICB9KVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCBkaWZmID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgaWYodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSl7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICAgIG9uU3luYygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbihjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrIH1cblxuICBvbkxlYXZlKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrIH1cblxuICBvblN5bmMoY2FsbGJhY2speyB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjayB9XG5cbiAgbGlzdChieSl7IHJldHVybiBQcmVzZW5jZS5saXN0KHRoaXMuc3RhdGUsIGJ5KSB9XG5cbiAgaW5QZW5kaW5nU3luY1N0YXRlKCl7XG4gICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgKHRoaXMuam9pblJlZiAhPT0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKSlcbiAgfVxuXG4gIC8vIGxvd2VyLWxldmVsIHB1YmxpYyBzdGF0aWMgQVBJXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlclxuICAgKiB3aXRoIHRoZSBjbGllbnQncyBzdGF0ZS4gQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW5cbiAgICogYmUgcHJvdmlkZWQgdG8gcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGUgY2xpZW50J3MgbG9jYWwgcHJlc2VuY2VzIGFjcm9zc1xuICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSlcbiAgICBsZXQgam9pbnMgPSB7fVxuICAgIGxldCBsZWF2ZXMgPSB7fVxuXG4gICAgdGhpcy5tYXAoc3RhdGUsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICBpZighbmV3U3RhdGVba2V5XSl7XG4gICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZSl7XG4gICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyUmVmcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBqb2luZWRNZXRhcyA9IG5ld1ByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBuZXdSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGlmKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhc1xuICAgICAgICB9XG4gICAgICAgIGlmKGxlZnRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKVxuICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHtqb2luczogam9pbnMsIGxlYXZlczogbGVhdmVzfSwgb25Kb2luLCBvbkxlYXZlKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmVcbiAgICogZXZlbnRzIGZyb20gdGhlIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmBcbiAgICogYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXJcbiAgICogam9pbmluZyBvciBsZWF2aW5nIGZyb20gYSBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQge2pvaW5zLCBsZWF2ZXN9ID0gdGhpcy5jbG9uZShkaWZmKVxuICAgIGlmKCFvbkpvaW4peyBvbkpvaW4gPSBmdW5jdGlvbiAoKXsgfSB9XG4gICAgaWYoIW9uTGVhdmUpeyBvbkxlYXZlID0gZnVuY3Rpb24gKCl7IH0gfVxuXG4gICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgam9pbmVkUmVmcyA9IHN0YXRlW2tleV0ubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gam9pbmVkUmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBzdGF0ZVtrZXldLm1ldGFzLnVuc2hpZnQoLi4uY3VyTWV0YXMpXG4gICAgICB9XG4gICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2UsIG5ld1ByZXNlbmNlKVxuICAgIH0pXG4gICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZighY3VycmVudFByZXNlbmNlKXsgcmV0dXJuIH1cbiAgICAgIGxldCByZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihwID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnNUb1JlbW92ZS5pbmRleE9mKHAucGh4X3JlZikgPCAwXG4gICAgICB9KVxuICAgICAgb25MZWF2ZShrZXksIGN1cnJlbnRQcmVzZW5jZSwgbGVmdFByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlLm1ldGFzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcmVzZW5jZXMsIHdpdGggc2VsZWN0ZWQgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZW5jZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hvb3NlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpe1xuICAgIGlmKCFjaG9vc2VyKXsgY2hvb3NlciA9IGZ1bmN0aW9uIChrZXksIHByZXMpeyByZXR1cm4gcHJlcyB9IH1cblxuICAgIHJldHVybiB0aGlzLm1hcChwcmVzZW5jZXMsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKVxuICAgIH0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgc3RhdGljIG1hcChvYmosIGZ1bmMpe1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcChrZXkgPT4gZnVuYyhrZXksIG9ialtrZXldKSlcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShvYmopeyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSB9XG59XG4iLCAiLyogVGhlIGRlZmF1bHQgc2VyaWFsaXplciBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIG1lc3NhZ2VzICovXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEhFQURFUl9MRU5HVEg6IDEsXG4gIE1FVEFfTEVOR1RIOiA0LFxuICBLSU5EUzoge3B1c2g6IDAsIHJlcGx5OiAxLCBicm9hZGNhc3Q6IDJ9LFxuXG4gIGVuY29kZShtc2csIGNhbGxiYWNrKXtcbiAgICBpZihtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXlsb2FkID0gW21zZy5qb2luX3JlZiwgbXNnLnJlZiwgbXNnLnRvcGljLCBtc2cuZXZlbnQsIG1zZy5wYXlsb2FkXVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgIH1cbiAgfSxcblxuICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spe1xuICAgIGlmKHJhd1BheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeURlY29kZShyYXdQYXlsb2FkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IFtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWRdID0gSlNPTi5wYXJzZShyYXdQYXlsb2FkKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWR9KVxuICAgIH1cbiAgfSxcblxuICAvLyBwcml2YXRlXG5cbiAgYmluYXJ5RW5jb2RlKG1lc3NhZ2Upe1xuICAgIGxldCB7am9pbl9yZWYsIHJlZiwgZXZlbnQsIHRvcGljLCBwYXlsb2FkfSA9IG1lc3NhZ2VcbiAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoXG4gICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKVxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdGhpcy5LSU5EUy5wdXNoKSAvLyBraW5kXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgam9pbl9yZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHJlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdG9waWMubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGV2ZW50Lmxlbmd0aClcbiAgICBBcnJheS5mcm9tKGpvaW5fcmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShyZWYsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHRvcGljLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShldmVudCwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuXG4gICAgdmFyIGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoaGVhZGVyLmJ5dGVMZW5ndGggKyBwYXlsb2FkLmJ5dGVMZW5ndGgpXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGhlYWRlciksIDApXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBoZWFkZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiBjb21iaW5lZC5idWZmZXJcbiAgfSxcblxuICBiaW5hcnlEZWNvZGUoYnVmZmVyKXtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApXG4gICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5wdXNoOiByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTogcmV0dXJuIHRoaXMuZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgICAgY2FzZSB0aGlzLktJTkRTLmJyb2FkY2FzdDogcmV0dXJuIHRoaXMuZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxIC8vIHB1c2hlcyBoYXZlIG5vIHJlZlxuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfSxcblxuICBkZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgcmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDQpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEhcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCByZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyByZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyByZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgbGV0IHBheWxvYWQgPSB7c3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGF9XG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiByZWYsIHRvcGljOiB0b3BpYywgZXZlbnQ6IENIQU5ORUxfRVZFTlRTLnJlcGx5LCBwYXlsb2FkOiBwYXlsb2FkfVxuICB9LFxuXG4gIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMlxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuXG4gICAgcmV0dXJuIHtqb2luX3JlZjogbnVsbCwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIGdsb2JhbCxcbiAgcGh4V2luZG93LFxuICBDSEFOTkVMX0VWRU5UUyxcbiAgREVGQVVMVF9USU1FT1VULFxuICBERUZBVUxUX1ZTTixcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUUyxcbiAgV1NfQ0xPU0VfTk9STUFMLFxuICBBVVRIX1RPS0VOX1BSRUZJWFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9zdXJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5pbXBvcnQgQ2hhbm5lbCBmcm9tIFwiLi9jaGFubmVsXCJcbmltcG9ydCBMb25nUG9sbCBmcm9tIFwiLi9sb25ncG9sbFwiXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tIFwiLi9zZXJpYWxpemVyXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKiBJbml0aWFsaXplcyB0aGUgU29ja2V0ICpcbiAqXG4gKiBGb3IgSUU4IHN1cHBvcnQgdXNlIGFuIEVTNS1zaGltIChodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9zb2NrZXRcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudHJhbnNwb3J0XSAtIFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQgb3IgUGhvZW5peC5Mb25nUG9sbC5cbiAqXG4gKiBEZWZhdWx0cyB0byBXZWJTb2NrZXQgd2l0aCBhdXRvbWF0aWMgTG9uZ1BvbGwgZmFsbGJhY2sgaWYgV2ViU29ja2V0IGlzIG5vdCBkZWZpbmVkLlxuICogVG8gZmFsbGJhY2sgdG8gTG9uZ1BvbGwgd2hlbiBXZWJTb2NrZXQgYXR0ZW1wdHMgZmFpbCwgdXNlIGBsb25nUG9sbEZhbGxiYWNrTXM6IDI1MDBgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5sb25nUG9sbEZhbGxiYWNrTXNdIC0gVGhlIG1pbGxpc2Vjb25kIHRpbWUgdG8gYXR0ZW1wdCB0aGUgcHJpbWFyeSB0cmFuc3BvcnRcbiAqIGJlZm9yZSBmYWxsaW5nIGJhY2sgdG8gdGhlIExvbmdQb2xsIHRyYW5zcG9ydC4gRGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRlYnVnXSAtIFdoZW4gdHJ1ZSwgZW5hYmxlcyBkZWJ1ZyBsb2dnaW5nLiBEZWZhdWx0IGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmVuY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT04gZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5kZWNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0XSAtIFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAqXG4gKiBEZWZhdWx0cyBgREVGQVVMVF9USU1FT1VUYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlYXJ0YmVhdEludGVydmFsTXNdIC0gVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMucmVjb25uZWN0QWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICogc29ja2V0IHJlY29ubmVjdCBpbnRlcnZhbCwgaW4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIERlZmF1bHRzIHRvIHN0ZXBwZWQgYmFja29mZiBvZjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMTAwMCwgMjAwMF1bdHJpZXMgLSAxXSB8fCA1MDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMucmVqb2luQWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsaXNlY1xuICogcmVqb2luIGludGVydmFsIGZvciBpbmRpdmlkdWFsIGNoYW5uZWxzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24oa2luZCwgbXNnLCBkYXRhKSB7XG4gKiAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdwb2xsZXJUaW1lb3V0XSAtIFRoZSBtYXhpbXVtIHRpbWVvdXQgb2YgYSBsb25nIHBvbGwgQUpBWCByZXF1ZXN0LlxuICpcbiAqIERlZmF1bHRzIHRvIDIwcyAoZG91YmxlIHRoZSBzZXJ2ZXIgbG9uZyBwb2xsIHRpbWVyKS5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmF1dGhUb2tlbl0gLSB0aGUgb3B0aW9uYWwgYXV0aGVudGljYXRpb24gdG9rZW4gdG8gYmUgZXhwb3NlZCBvbiB0aGUgc2VydmVyXG4gKiB1bmRlciB0aGUgYDphdXRoX3Rva2VuYCBjb25uZWN0X2luZm8ga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmFyeVR5cGVdIC0gVGhlIGJpbmFyeSB0eXBlIHRvIHVzZSBmb3IgYmluYXJ5IFdlYlNvY2tldCBmcmFtZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gXCJhcnJheWJ1ZmZlclwiXG4gKlxuICogQHBhcmFtIHt2c259IFtvcHRzLnZzbl0gLSBUaGUgc2VyaWFsaXplcidzIHByb3RvY29sIHZlcnNpb24gdG8gc2VuZCBvbiBjb25uZWN0LlxuICpcbiAqIERlZmF1bHRzIHRvIERFRkFVTFRfVlNOLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5zZXNzaW9uU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBQaG9lbml4IHVzZXMgc2Vzc2lvblN0b3JhZ2UgZm9yIGxvbmdwb2xsIGZhbGxiYWNrIGhpc3RvcnkuIE92ZXJyaWRpbmcgdGhlIHN0b3JlIGlzXG4gKiB1c2VmdWwgd2hlbiBQaG9lbml4IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuIEZvciBleGFtcGxlLCBUaGlzIGNvdWxkXG4gKiBoYXBwZW4gaWYgYSBzaXRlIGxvYWRzIGEgY3Jvc3MtZG9tYWluIGNoYW5uZWwgaW4gYW4gaWZyYW1lLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIHx8IG51bGwgfVxuICogICAgICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7IGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgc2V0SXRlbShrZXlOYW1lLCBrZXlWYWx1ZSkgeyB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gPSBrZXlWYWx1ZSB9XG4gKiAgICAgfVxuICpcbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2NrZXQge1xuICBjb25zdHJ1Y3RvcihlbmRQb2ludCwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0ge29wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW119XG4gICAgdGhpcy5jaGFubmVscyA9IFtdXG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLmZhbGxiYWNrUmVmID0gbnVsbFxuICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVRcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG9wdHMudHJhbnNwb3J0IHx8IGdsb2JhbC5XZWJTb2NrZXQgfHwgTG9uZ1BvbGxcbiAgICB0aGlzLnByaW1hcnlQYXNzZWRIZWFsdGhDaGVjayA9IGZhbHNlXG4gICAgdGhpcy5sb25nUG9sbEZhbGxiYWNrTXMgPSBvcHRzLmxvbmdQb2xsRmFsbGJhY2tNc1xuICAgIHRoaXMuZmFsbGJhY2tUaW1lciA9IG51bGxcbiAgICB0aGlzLnNlc3Npb25TdG9yZSA9IG9wdHMuc2Vzc2lvblN0b3JhZ2UgfHwgKGdsb2JhbCAmJiBnbG9iYWwuc2Vzc2lvblN0b3JhZ2UpXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zID0gMFxuICAgIHRoaXMuZGVmYXVsdEVuY29kZXIgPSBTZXJpYWxpemVyLmVuY29kZS5iaW5kKFNlcmlhbGl6ZXIpXG4gICAgdGhpcy5kZWZhdWx0RGVjb2RlciA9IFNlcmlhbGl6ZXIuZGVjb2RlLmJpbmQoU2VyaWFsaXplcilcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuZGlzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy5iaW5hcnlUeXBlID0gb3B0cy5iaW5hcnlUeXBlIHx8IFwiYXJyYXlidWZmZXJcIlxuICAgIHRoaXMuY29ubmVjdENsb2NrID0gMVxuICAgIHRoaXMucGFnZUhpZGRlbiA9IGZhbHNlXG4gICAgaWYodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKXtcbiAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlID0gdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfVxuICAgIGxldCBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgIGlmKHBoeFdpbmRvdyAmJiBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9lID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSB0aGlzLmNvbm5lY3RDbG9ja1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBfZSA9PiB7XG4gICAgICAgIGlmKGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPT09IHRoaXMuY29ubmVjdENsb2NrKXtcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgICAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBpZihkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpe1xuICAgICAgICAgIHRoaXMucGFnZUhpZGRlbiA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhZ2VIaWRkZW4gPSBmYWxzZVxuICAgICAgICAgIC8vIHJlY29ubmVjdCBpbW1lZGlhdGVseVxuICAgICAgICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgICAgICAgdGhpcy50ZWFyZG93bigoKSA9PiB0aGlzLmNvbm5lY3QoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzMDAwMFxuICAgIHRoaXMucmVqb2luQWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWpvaW5BZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVqb2luQWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVjb25uZWN0QWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDEwMDAsIDIwMDBdW3RyaWVzIC0gMV0gfHwgNTAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IG9wdHMubG9nZ2VyIHx8IG51bGxcbiAgICBpZighdGhpcy5sb2dnZXIgJiYgb3B0cy5kZWJ1Zyl7XG4gICAgICB0aGlzLmxvZ2dlciA9IChraW5kLCBtc2csIGRhdGEpID0+IHsgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpIH1cbiAgICB9XG4gICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMjAwMDBcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICBpZih0aGlzLnBhZ2VIaWRkZW4pe1xuICAgICAgICB0aGlzLmxvZyhcIk5vdCByZWNvbm5lY3RpbmcgYXMgcGFnZSBpcyBoaWRkZW4hXCIpXG4gICAgICAgIHRoaXMudGVhcmRvd24oKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMudGVhcmRvd24oKCkgPT4gdGhpcy5jb25uZWN0KCkpXG4gICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKVxuICAgIHRoaXMuYXV0aFRva2VuID0gb3B0cy5hdXRoVG9rZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQgcmVmZXJlbmNlXG4gICAqL1xuICBnZXRMb25nUG9sbFRyYW5zcG9ydCgpeyByZXR1cm4gTG9uZ1BvbGwgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbmQgcmVwbGFjZXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3VHJhbnNwb3J0IC0gVGhlIG5ldyB0cmFuc3BvcnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICpcbiAgICovXG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgaWYodGhpcy5jb25uKXtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29ja2V0IHByb3RvY29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwcm90b2NvbCgpeyByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIiB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxseSBxdWFsaWZpZWQgc29ja2V0IHVybFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5kUG9pbnRVUkwoKXtcbiAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoXG4gICAgICBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwge3ZzbjogdGhpcy52c259KVxuICAgIGlmKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKXsgcmV0dXJuIHVyaSB9XG4gICAgaWYodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpeyByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfToke3VyaX1gIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0XG4gICAqXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXMgZm9yIHZhbGlkIHN0YXR1cyBjb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgc29ja2V0IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBjb2RlIC0gQSBzdGF0dXMgY29kZSBmb3IgZGlzY29ubmVjdGlvbiAoT3B0aW9uYWwpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gQSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb24gdG8gZGlzY29ubmVjdC4gKE9wdGlvbmFsKVxuICAgKi9cbiAgZGlzY29ubmVjdChjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5kaXNjb25uZWN0aW5nID0gdHJ1ZVxuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IHRydWVcbiAgICBjbGVhclRpbWVvdXQodGhpcy5mYWxsYmFja1RpbWVyKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMudGVhcmRvd24oKCkgPT4ge1xuICAgICAgdGhpcy5kaXNjb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9LCBjb2RlLCByZWFzb24pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbXMgdG8gc2VuZCB3aGVuIGNvbm5lY3RpbmcsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogdXNlclRva2VufWBcbiAgICpcbiAgICogUGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkOyBwYXNzIHRoZW0gaW4gdGhlIFNvY2tldCBjb25zdHJ1Y3RvciBpbnN0ZWFkOlxuICAgKiBgbmV3IFNvY2tldChcIi9zb2NrZXRcIiwge3BhcmFtczoge3VzZXJfaWQ6IHVzZXJUb2tlbn19KWAuXG4gICAqL1xuICBjb25uZWN0KHBhcmFtcyl7XG4gICAgaWYocGFyYW1zKXtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJwYXNzaW5nIHBhcmFtcyB0byBjb25uZWN0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgcGFzcyA6cGFyYW1zIHRvIHRoZSBTb2NrZXQgY29uc3RydWN0b3JcIilcbiAgICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMpXG4gICAgfVxuICAgIGlmKHRoaXMuY29ubiAmJiAhdGhpcy5kaXNjb25uZWN0aW5nKXsgcmV0dXJuIH1cbiAgICBpZih0aGlzLmxvbmdQb2xsRmFsbGJhY2tNcyAmJiB0aGlzLnRyYW5zcG9ydCAhPT0gTG9uZ1BvbGwpe1xuICAgICAgdGhpcy5jb25uZWN0V2l0aEZhbGxiYWNrKExvbmdQb2xsLCB0aGlzLmxvbmdQb2xsRmFsbGJhY2tNcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc3BvcnRDb25uZWN0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9ncyB0aGUgbWVzc2FnZS4gT3ZlcnJpZGUgYHRoaXMubG9nZ2VyYCBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZy4gbm9vcHMgYnkgZGVmYXVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBsb2coa2luZCwgbXNnLCBkYXRhKXsgdGhpcy5sb2dnZXIgJiYgdGhpcy5sb2dnZXIoa2luZCwgbXNnLCBkYXRhKSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGxvZ2dlciBoYXMgYmVlbiBzZXQgb24gdGhpcyBzb2NrZXQuXG4gICAqL1xuICBoYXNMb2dnZXIoKXsgcmV0dXJuIHRoaXMubG9nZ2VyICE9PSBudWxsIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBvcGVuIGV2ZW50c1xuICAgKlxuICAgKiBAZXhhbXBsZSBzb2NrZXQub25PcGVuKGZ1bmN0aW9uKCl7IGNvbnNvbGUuaW5mbyhcInRoZSBzb2NrZXQgd2FzIG9wZW5lZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25PcGVuKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4ucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gY2xvc2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNsb3NlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIGVycm9yIGV2ZW50c1xuICAgKlxuICAgKiBAZXhhbXBsZSBzb2NrZXQub25FcnJvcihmdW5jdGlvbihlcnJvcil7IGFsZXJ0KFwiQW4gZXJyb3Igb2NjdXJyZWRcIikgfSlcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uRXJyb3IoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gbWVzc2FnZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uTWVzc2FnZShjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBQaW5ncyB0aGUgc2VydmVyIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBSVFQgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGluZyB3YXMgcHVzaGVkIG9yIGZhbHNlIGlmIHVuYWJsZSB0byBiZSBwdXNoZWQuXG4gICAqL1xuICBwaW5nKGNhbGxiYWNrKXtcbiAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIHRoaXMucHVzaCh7dG9waWM6IFwicGhvZW5peFwiLCBldmVudDogXCJoZWFydGJlYXRcIiwgcGF5bG9hZDoge30sIHJlZjogcmVmfSlcbiAgICBsZXQgb25Nc2dSZWYgPSB0aGlzLm9uTWVzc2FnZShtc2cgPT4ge1xuICAgICAgaWYobXNnLnJlZiA9PT0gcmVmKXtcbiAgICAgICAgdGhpcy5vZmYoW29uTXNnUmVmXSlcbiAgICAgICAgY2FsbGJhY2soRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdHJhbnNwb3J0Q29ubmVjdCgpe1xuICAgIHRoaXMuY29ubmVjdENsb2NrKytcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIGxldCBwcm90b2NvbHMgPSB1bmRlZmluZWRcbiAgICAvLyBTZWMtV2ViU29ja2V0LVByb3RvY29sIGJhc2VkIHRva2VuXG4gICAgLy8gKGxvbmdwb2xsIHVzZXMgQXV0aG9yaXphdGlvbiBoZWFkZXIgaW5zdGVhZClcbiAgICBpZih0aGlzLmF1dGhUb2tlbil7XG4gICAgICBwcm90b2NvbHMgPSBbXCJwaG9lbml4XCIsIGAke0FVVEhfVE9LRU5fUFJFRklYfSR7YnRvYSh0aGlzLmF1dGhUb2tlbikucmVwbGFjZSgvPS9nLCBcIlwiKX1gXVxuICAgIH1cbiAgICB0aGlzLmNvbm4gPSBuZXcgdGhpcy50cmFuc3BvcnQodGhpcy5lbmRQb2ludFVSTCgpLCBwcm90b2NvbHMpXG4gICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGVcbiAgICB0aGlzLmNvbm4udGltZW91dCA9IHRoaXMubG9uZ3BvbGxlclRpbWVvdXRcbiAgICB0aGlzLmNvbm4ub25vcGVuID0gKCkgPT4gdGhpcy5vbkNvbm5PcGVuKClcbiAgICB0aGlzLmNvbm4ub25lcnJvciA9IGVycm9yID0+IHRoaXMub25Db25uRXJyb3IoZXJyb3IpXG4gICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHRoaXMub25Db25uTWVzc2FnZShldmVudClcbiAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGV2ZW50ID0+IHRoaXMub25Db25uQ2xvc2UoZXZlbnQpXG4gIH1cblxuICBnZXRTZXNzaW9uKGtleSl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yZSAmJiB0aGlzLnNlc3Npb25TdG9yZS5nZXRJdGVtKGtleSkgfVxuXG4gIHN0b3JlU2Vzc2lvbihrZXksIHZhbCl7IHRoaXMuc2Vzc2lvblN0b3JlICYmIHRoaXMuc2Vzc2lvblN0b3JlLnNldEl0ZW0oa2V5LCB2YWwpIH1cblxuICBjb25uZWN0V2l0aEZhbGxiYWNrKGZhbGxiYWNrVHJhbnNwb3J0LCBmYWxsYmFja1RocmVzaG9sZCA9IDI1MDApe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgbGV0IGVzdGFibGlzaGVkID0gZmFsc2VcbiAgICBsZXQgcHJpbWFyeVRyYW5zcG9ydCA9IHRydWVcbiAgICBsZXQgb3BlblJlZiwgZXJyb3JSZWZcbiAgICBsZXQgZmFsbGJhY2sgPSAocmVhc29uKSA9PiB7XG4gICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgZmFsbGluZyBiYWNrIHRvICR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX0uLi5gLCByZWFzb24pXG4gICAgICB0aGlzLm9mZihbb3BlblJlZiwgZXJyb3JSZWZdKVxuICAgICAgcHJpbWFyeVRyYW5zcG9ydCA9IGZhbHNlXG4gICAgICB0aGlzLnJlcGxhY2VUcmFuc3BvcnQoZmFsbGJhY2tUcmFuc3BvcnQpXG4gICAgICB0aGlzLnRyYW5zcG9ydENvbm5lY3QoKVxuICAgIH1cbiAgICBpZih0aGlzLmdldFNlc3Npb24oYHBoeDpmYWxsYmFjazoke2ZhbGxiYWNrVHJhbnNwb3J0Lm5hbWV9YCkpeyByZXR1cm4gZmFsbGJhY2soXCJtZW1vcml6ZWRcIikgfVxuXG4gICAgdGhpcy5mYWxsYmFja1RpbWVyID0gc2V0VGltZW91dChmYWxsYmFjaywgZmFsbGJhY2tUaHJlc2hvbGQpXG5cbiAgICBlcnJvclJlZiA9IHRoaXMub25FcnJvcihyZWFzb24gPT4ge1xuICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJlcnJvclwiLCByZWFzb24pXG4gICAgICBpZihwcmltYXJ5VHJhbnNwb3J0ICYmICFlc3RhYmxpc2hlZCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgICAgIGZhbGxiYWNrKHJlYXNvbilcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmKHRoaXMuZmFsbGJhY2tSZWYpe1xuICAgICAgdGhpcy5vZmYoW3RoaXMuZmFsbGJhY2tSZWZdKVxuICAgIH1cbiAgICB0aGlzLmZhbGxiYWNrUmVmID0gdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgZXN0YWJsaXNoZWQgPSB0cnVlXG4gICAgICBpZighcHJpbWFyeVRyYW5zcG9ydCl7XG4gICAgICAgIC8vIG9ubHkgbWVtb3JpemUgTFAgaWYgd2UgbmV2ZXIgY29ubmVjdGVkIHRvIHByaW1hcnlcbiAgICAgICAgaWYoIXRoaXMucHJpbWFyeVBhc3NlZEhlYWx0aENoZWNrKXsgdGhpcy5zdG9yZVNlc3Npb24oYHBoeDpmYWxsYmFjazoke2ZhbGxiYWNrVHJhbnNwb3J0Lm5hbWV9YCwgXCJ0cnVlXCIpIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBlc3RhYmxpc2hlZCAke2ZhbGxiYWNrVHJhbnNwb3J0Lm5hbWV9IGZhbGxiYWNrYClcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlJ3ZlIGVzdGFibGlzaGVkIHByaW1hcnksIGdpdmUgdGhlIGZhbGxiYWNrIGEgbmV3IHBlcmlvZCB0byBhdHRlbXB0IHBpbmdcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZhbGxiYWNrLCBmYWxsYmFja1RocmVzaG9sZClcbiAgICAgIHRoaXMucGluZyhydHQgPT4ge1xuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImNvbm5lY3RlZCB0byBwcmltYXJ5IGFmdGVyXCIsIHJ0dClcbiAgICAgICAgdGhpcy5wcmltYXJ5UGFzc2VkSGVhbHRoQ2hlY2sgPSB0cnVlXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy50cmFuc3BvcnRDb25uZWN0KClcbiAgfVxuXG4gIGNsZWFySGVhcnRiZWF0cygpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lcilcbiAgfVxuXG4gIG9uQ29ubk9wZW4oKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgJHt0aGlzLnRyYW5zcG9ydC5uYW1lfSBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZFBvaW50VVJMKCl9YClcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuZGlzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zKytcbiAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy5yZXNldEhlYXJ0YmVhdCgpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBoZWFydGJlYXRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpeyB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImhlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uXCIpIH1cbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpXG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgICAgdGhpcy50ZWFyZG93bigoKSA9PiB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpLCBXU19DTE9TRV9OT1JNQUwsIFwiaGVhcnRiZWF0IHRpbWVvdXRcIilcbiAgICB9XG4gIH1cblxuICByZXNldEhlYXJ0YmVhdCgpe1xuICAgIGlmKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4uc2tpcEhlYXJ0YmVhdCl7IHJldHVybiB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICB9XG5cbiAgdGVhcmRvd24oY2FsbGJhY2ssIGNvZGUsIHJlYXNvbil7XG4gICAgaWYoIXRoaXMuY29ubil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cbiAgICBsZXQgY29ubmVjdENsb2NrID0gdGhpcy5jb25uZWN0Q2xvY2tcblxuICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoKCkgPT4ge1xuICAgICAgaWYoY29ubmVjdENsb2NrICE9PSB0aGlzLmNvbm5lY3RDbG9jayl7IHJldHVybiB9XG4gICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICBpZihjb2RlKXsgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiB8fCBcIlwiKSB9IGVsc2UgeyB0aGlzLmNvbm4uY2xvc2UoKSB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZCgoKSA9PiB7XG4gICAgICAgIGlmKGNvbm5lY3RDbG9jayAhPT0gdGhpcy5jb25uZWN0Q2xvY2speyByZXR1cm4gfVxuICAgICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB3YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8ICF0aGlzLmNvbm4uYnVmZmVyZWRBbW91bnQpe1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyArIDEpXG4gICAgfSwgMTUwICogdHJpZXMpXG4gIH1cblxuICB3YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyA9IDEpe1xuICAgIGlmKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgdGhpcy5jb25uLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY2xvc2VkKXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyArIDEpXG4gICAgfSwgMTUwICogdHJpZXMpXG4gIH1cblxuICBvbkNvbm5DbG9zZShldmVudCl7XG4gICAgaWYodGhpcy5jb25uKSB0aGlzLmNvbm4ub25jbG9zZSA9ICgpID0+IHt9IC8vIG5vb3AgdG8gcHJldmVudCByZWN1cnNpdmUgY2FsbHMgaW4gdGVhcmRvd25cbiAgICBsZXQgY2xvc2VDb2RlID0gZXZlbnQgJiYgZXZlbnQuY29kZVxuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiY2xvc2VcIiwgZXZlbnQpXG4gICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgaWYoIXRoaXMuY2xvc2VXYXNDbGVhbiAmJiBjbG9zZUNvZGUgIT09IDEwMDApe1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIH1cbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soZXZlbnQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkNvbm5FcnJvcihlcnJvcil7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgZXJyb3IpXG4gICAgbGV0IHRyYW5zcG9ydEJlZm9yZSA9IHRoaXMudHJhbnNwb3J0XG4gICAgbGV0IGVzdGFibGlzaGVkQmVmb3JlID0gdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCB0cmFuc3BvcnRCZWZvcmUsIGVzdGFibGlzaGVkQmVmb3JlKVxuICAgIH0pXG4gICAgaWYodHJhbnNwb3J0QmVmb3JlID09PSB0aGlzLnRyYW5zcG9ydCB8fCBlc3RhYmxpc2hlZEJlZm9yZSA+IDApe1xuICAgICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXJDaGFuRXJyb3IoKXtcbiAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgICBpZighKGNoYW5uZWwuaXNFcnJvcmVkKCkgfHwgY2hhbm5lbC5pc0xlYXZpbmcoKSB8fCBjaGFubmVsLmlzQ2xvc2VkKCkpKXtcbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNvbm5lY3Rpb25TdGF0ZSgpe1xuICAgIHN3aXRjaCh0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnJlYWR5U3RhdGUpe1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc6IHJldHVybiBcImNvbm5lY3RpbmdcIlxuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46IHJldHVybiBcIm9wZW5cIlxuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNsb3Npbmc6IHJldHVybiBcImNsb3NpbmdcIlxuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiY2xvc2VkXCJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gXCJvcGVuXCIgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0NoYW5uZWx9XG4gICAqL1xuICByZW1vdmUoY2hhbm5lbCl7XG4gICAgdGhpcy5vZmYoY2hhbm5lbC5zdGF0ZUNoYW5nZVJlZnMpXG4gICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKGMgPT4gYyAhPT0gY2hhbm5lbClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBvbk9wZW5gLCBgb25DbG9zZWAsIGBvbkVycm9yLGAgYW5kIGBvbk1lc3NhZ2VgIHJlZ2lzdHJhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7cmVmc30gLSBsaXN0IG9mIHJlZnMgcmV0dXJuZWQgYnkgY2FsbHMgdG9cbiAgICogICAgICAgICAgICAgICAgIGBvbk9wZW5gLCBgb25DbG9zZWAsIGBvbkVycm9yLGAgYW5kIGBvbk1lc3NhZ2VgXG4gICAqL1xuICBvZmYocmVmcyl7XG4gICAgZm9yKGxldCBrZXkgaW4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyl7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2tleV0gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2tleV0uZmlsdGVyKChbcmVmXSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVmcy5pbmRleE9mKHJlZikgPT09IC0xXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBuZXcgY2hhbm5lbCBmb3IgdGhlIGdpdmVuIHRvcGljXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhblBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBjaGFubmVsXG4gICAqIEByZXR1cm5zIHtDaGFubmVsfVxuICAgKi9cbiAgY2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcyA9IHt9KXtcbiAgICBsZXQgY2hhbiA9IG5ldyBDaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zLCB0aGlzKVxuICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKVxuICAgIHJldHVybiBjaGFuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIHB1c2goZGF0YSl7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSl7XG4gICAgICBsZXQge3RvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZn0gPSBkYXRhXG4gICAgICB0aGlzLmxvZyhcInB1c2hcIiwgYCR7dG9waWN9ICR7ZXZlbnR9ICgke2pvaW5fcmVmfSwgJHtyZWZ9KWAsIHBheWxvYWQpXG4gICAgfVxuXG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpKXtcbiAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIHJlc3VsdCA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaCgoKSA9PiB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBtZXNzYWdlIHJlZiwgYWNjb3VudGluZyBmb3Igb3ZlcmZsb3dzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBtYWtlUmVmKCl7XG4gICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMVxuICAgIGlmKG5ld1JlZiA9PT0gdGhpcy5yZWYpeyB0aGlzLnJlZiA9IDAgfSBlbHNlIHsgdGhpcy5yZWYgPSBuZXdSZWYgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIHNlbmRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgJiYgIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnB1c2goe3RvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZn0pXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGVhcnRiZWF0VGltZW91dCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICBmbHVzaFNlbmRCdWZmZXIoKXtcbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApe1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSlcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgfVxuICB9XG5cbiAgb25Db25uTWVzc2FnZShyYXdNZXNzYWdlKXtcbiAgICB0aGlzLmRlY29kZShyYXdNZXNzYWdlLmRhdGEsIG1zZyA9PiB7XG4gICAgICBsZXQge3RvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZn0gPSBtc2dcbiAgICAgIGlmKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInJlY2VpdmVcIiwgYCR7cGF5bG9hZC5zdGF0dXMgfHwgXCJcIn0gJHt0b3BpY30gJHtldmVudH0gJHtyZWYgJiYgXCIoXCIgKyByZWYgKyBcIilcIiB8fCBcIlwifWAsIHBheWxvYWQpXG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV1cbiAgICAgICAgaWYoIWNoYW5uZWwuaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luX3JlZikpeyBjb250aW51ZSB9XG4gICAgICAgIGNoYW5uZWwudHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZilcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGxldCBbLCBjYWxsYmFja10gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2VbaV1cbiAgICAgICAgY2FsbGJhY2sobXNnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBsZWF2ZU9wZW5Ub3BpYyh0b3BpYyl7XG4gICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoYyA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5pc0pvaW5lZCgpIHx8IGMuaXNKb2luaW5nKCkpKVxuICAgIGlmKGR1cENoYW5uZWwpe1xuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApXG4gICAgICBkdXBDaGFubmVsLmxlYXZlKClcbiAgICB9XG4gIH1cbn1cbiIsICJleHBvcnQgeyByZW5kZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9zZXJ2ZXIvaW5kZXguanMnO1xuIiwgImV4cG9ydCB7Z2V0UmVuZGVyfSBmcm9tIFwiLi9yZW5kZXJcIlxuZXhwb3J0IHtnZXRIb29rc30gZnJvbSBcIi4vaG9va3Muc3ZlbHRlXCJcbiIsICJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbXBvbmVudHMuZGVmYXVsdCkgfHwgIUFycmF5LmlzQXJyYXkoY29tcG9uZW50cy5maWxlbmFtZXMpKSByZXR1cm4gY29tcG9uZW50c1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIG1vZHVsZV0gb2YgY29tcG9uZW50cy5kZWZhdWx0LmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBtb2R1bGUuZGVmYXVsdFxuICAgICAgICBjb25zdCBuYW1lID0gY29tcG9uZW50cy5maWxlbmFtZXNbaW5kZXhdLnJlcGxhY2UoXCIuLi9zdmVsdGUvXCIsIFwiXCIpLnJlcGxhY2UoXCIuc3ZlbHRlXCIsIFwiXCIpXG4gICAgICAgIG5vcm1hbGl6ZWRbbmFtZV0gPSBDb21wb25lbnRcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRcbn1cbiIsICJpbXBvcnQge25vcm1hbGl6ZUNvbXBvbmVudHN9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7cmVuZGVyfSBmcm9tIFwic3ZlbHRlL3NlcnZlclwiXG5pbXBvcnQge2NyZWF0ZVJhd1NuaXBwZXR9IGZyb20gXCJzdmVsdGVcIlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVuZGVyKGNvbXBvbmVudHMpIHtcbiAgICBjb21wb25lbnRzID0gbm9ybWFsaXplQ29tcG9uZW50cyhjb21wb25lbnRzKVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHIobmFtZSwgcHJvcHMsIHNsb3RzKSB7XG4gICAgICAgIGNvbnN0IHNuaXBwZXRzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoc2xvdHMpLm1hcCgoW3Nsb3ROYW1lLCB2XSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNuaXBwZXQgPSBjcmVhdGVSYXdTbmlwcGV0KG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyOiAoKSA9PiB2LFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBpZiAoc2xvdE5hbWUgPT09IFwiZGVmYXVsdFwiKSByZXR1cm4gW1wiY2hpbGRyZW5cIiwgc25pcHBldF1cbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBbc2xvdE5hbWUsIHNuaXBwZXRdXG4gICAgICAgICAgICB9KVxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcihjb21wb25lbnRzW25hbWVdLCB7cHJvcHM6IHsuLi5wcm9wcywgLi4uc25pcHBldHN9fSlcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtub3JtYWxpemVDb21wb25lbnRzfSBmcm9tIFwiLi91dGlsc1wiXG5pbXBvcnQge21vdW50LCBoeWRyYXRlLCB1bm1vdW50LCBjcmVhdGVSYXdTbmlwcGV0fSBmcm9tIFwic3ZlbHRlXCJcblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlSnNvbihyZWYsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBkYXRhID0gcmVmLmVsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKVxuICAgIHJldHVybiBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IHt9XG59XG5cbmZ1bmN0aW9uIGdldFNsb3RzKHJlZikge1xuICAgIGxldCBzbmlwcGV0cyA9IHt9XG5cbiAgICBmb3IgKGNvbnN0IHNsb3ROYW1lIGluIGdldEF0dHJpYnV0ZUpzb24ocmVmLCBcImRhdGEtc2xvdHNcIikpIHtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gZ2V0QXR0cmlidXRlSnNvbihyZWYsIFwiZGF0YS1zbG90c1wiKVtzbG90TmFtZV1cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBhdG9iKGJhc2U2NCkudHJpbSgpXG5cbiAgICAgICAgY29uc3Qgc25pcHBldCA9IGNyZWF0ZVJhd1NuaXBwZXQobmFtZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlbmRlcjogKCkgPT4gZWxlbWVudC5vdXRlckhUTUwsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHNsb3ROYW1lID09PSBcImRlZmF1bHRcIikgc25pcHBldHNbXCJjaGlsZHJlblwiXSA9IHNuaXBwZXRcbiAgICAgICAgZWxzZSBzbmlwcGV0c1tzbG90TmFtZV0gPSBzbmlwcGV0XG4gICAgfVxuXG4gICAgcmV0dXJuIHNuaXBwZXRzXG59XG5cbmZ1bmN0aW9uIGdldExpdmVKc29uUHJvcHMocmVmKSB7XG4gICAgY29uc3QganNvbiA9IGdldEF0dHJpYnV0ZUpzb24ocmVmLCBcImRhdGEtbGl2ZS1qc29uXCIpXG5cbiAgICAvLyBPbiBTU1IsIGRhdGEtbGl2ZS1qc29uIGlzIHRoZSBmdWxsIG9iamVjdCB3ZSB3YW50XG4gICAgLy8gQWZ0ZXIgU1NSLCBkYXRhLWxpdmUtanNvbiBpcyBhbiBhcnJheSBvZiBrZXlzLCBhbmQgd2UnbGwgZ2V0IHRoZSBkYXRhIGZyb20gdGhlIHdpbmRvd1xuICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSkgcmV0dXJuIGpzb25cblxuICAgIGNvbnN0IGxpdmVKc29uRGF0YSA9IHt9XG4gICAgZm9yIChjb25zdCBsaXZlSnNvblZhcmlhYmxlIG9mIGpzb24pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHdpbmRvd1tsaXZlSnNvblZhcmlhYmxlXVxuICAgICAgICBpZiAoZGF0YSkgbGl2ZUpzb25EYXRhW2xpdmVKc29uVmFyaWFibGVdID0gZGF0YVxuICAgIH1cbiAgICByZXR1cm4gbGl2ZUpzb25EYXRhXG59XG5cbmZ1bmN0aW9uIGdldFByb3BzKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdldEF0dHJpYnV0ZUpzb24ocmVmLCBcImRhdGEtcHJvcHNcIiksXG4gICAgICAgIC4uLmdldExpdmVKc29uUHJvcHMocmVmKSxcbiAgICAgICAgLi4uZ2V0U2xvdHMocmVmKSxcbiAgICAgICAgbGl2ZTogcmVmLFxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmluZFNsb3RDdHgoY29tcG9uZW50KSB7XG4gICAgLy8gVGhlIGRlZmF1bHQgc2xvdCBhbHdheXMgZXhpc3RzIGlmIHRoZXJlJ3MgYSBzbG90IHNldFxuICAgIC8vIGV2ZW4gaWYgbm8gc2xvdCBpcyBzZXQgZm9yIHRoZSBleHBsaWNpdCBkZWZhdWx0IHNsb3RcbiAgICByZXR1cm4gY29tcG9uZW50LiQkLmN0eC5maW5kKGN0eEVsZW1lbnQgPT4gY3R4RWxlbWVudD8uZGVmYXVsdClcbn1cblxuZnVuY3Rpb24gdXBkYXRlX3N0YXRlKHJlZikge1xuICAgIGNvbnN0IG5ld1Byb3BzID0gZ2V0UHJvcHMocmVmKVxuICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgICAgIHJlZi5faW5zdGFuY2Uuc3RhdGVba2V5XSA9IG5ld1Byb3BzW2tleV1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb29rcyhjb21wb25lbnRzKSB7XG4gICAgY29tcG9uZW50cyA9IG5vcm1hbGl6ZUNvbXBvbmVudHMoY29tcG9uZW50cylcblxuICAgIGNvbnN0IFN2ZWx0ZUhvb2sgPSB7XG4gICAgICAgIG1vdW50ZWQoKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSAkc3RhdGUoZ2V0UHJvcHModGhpcykpXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnROYW1lID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5hbWVcIilcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50TmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IG5hbWUgbXVzdCBiZSBwcm92aWRlZFwiKVxuXG4gICAgICAgICAgICBjb25zdCBDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudE5hbWVdXG4gICAgICAgICAgICBpZiAoIUNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCAke2NvbXBvbmVudE5hbWV9IGNvbXBvbmVudC5gKVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpdmVKc29uRWxlbWVudCBvZiBPYmplY3Qua2V5cyhnZXRBdHRyaWJ1dGVKc29uKHRoaXMsIFwiZGF0YS1saXZlLWpzb25cIikpKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYCR7bGl2ZUpzb25FbGVtZW50fV9pbml0aWFsaXplZGAsIF9ldmVudCA9PiB1cGRhdGVfc3RhdGUodGhpcyksIGZhbHNlKVxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGAke2xpdmVKc29uRWxlbWVudH1fcGF0Y2hlZGAsIF9ldmVudCA9PiB1cGRhdGVfc3RhdGUodGhpcyksIGZhbHNlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIGZvciB0aGUgbG9hZGluZyBzbG90IHRvIGJlIGNsZWFyZWQgb25jZSB3ZSBtb3VudCB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWwuaGFzQXR0cmlidXRlKFwiZGF0YS1zc3JcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IFwiXCJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaHlkcmF0ZU9yTW91bnQgPSB0aGlzLmVsLmhhc0F0dHJpYnV0ZShcImRhdGEtc3NyXCIpID8gaHlkcmF0ZSA6IG1vdW50XG5cbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gaHlkcmF0ZU9yTW91bnQoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmVsLFxuICAgICAgICAgICAgICAgIHByb3BzOiBzdGF0ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdGF0ZSA9IHN0YXRlXG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlZCgpIHtcbiAgICAgICAgICAgIHVwZGF0ZV9zdGF0ZSh0aGlzKVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3llZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgKCkgPT4gdW5tb3VudCh0aGlzLl9pbnN0YW5jZSksIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfSxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBTdmVsdGVIb29rLFxuICAgIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBDb21wb25lbnRzIGZyb20gXCIuLi9zdmVsdGUvKiovKi5zdmVsdGVcIlxuaW1wb3J0IHtnZXRSZW5kZXJ9IGZyb20gXCJsaXZlX3N2ZWx0ZVwiXG5cbmV4cG9ydCBjb25zdCByZW5kZXIgPSBnZXRSZW5kZXIoQ29tcG9uZW50cylcbiIsICJcbiAgICAgICAgaW1wb3J0ICogYXMgbW9kdWxlMCBmcm9tICcuLi9zdmVsdGUvQXV0aE1vZGFsLnN2ZWx0ZSc7aW1wb3J0ICogYXMgbW9kdWxlMSBmcm9tICcuLi9zdmVsdGUvQ2hhdFdpbmRvdy5zdmVsdGUnO2ltcG9ydCAqIGFzIG1vZHVsZTIgZnJvbSAnLi4vc3ZlbHRlL0NvZGVTbmlwcGV0Q2FyZC5zdmVsdGUnO2ltcG9ydCAqIGFzIG1vZHVsZTMgZnJvbSAnLi4vc3ZlbHRlL0NvdW50ZXIuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGU0IGZyb20gJy4uL3N2ZWx0ZS9Hb29nbGVTaWduSW5CdXR0b24uc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGU1IGZyb20gJy4uL3N2ZWx0ZS9OYXZiYXIuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGU2IGZyb20gJy4uL3N2ZWx0ZS9TdWJOYXYuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGU3IGZyb20gJy4uL3N2ZWx0ZS9UaGVtZVNlbGVjdG9yLnN2ZWx0ZSc7aW1wb3J0ICogYXMgbW9kdWxlOCBmcm9tICcuLi9zdmVsdGUvVGhlbWVUb2dnbGUuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGU5IGZyb20gJy4uL3N2ZWx0ZS9Vc2VyTWVudS5zdmVsdGUnO2ltcG9ydCAqIGFzIG1vZHVsZTEwIGZyb20gJy4uL3N2ZWx0ZS9Xb3JrZmxvd1N0YXR1c0NhcmQuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGUxMSBmcm9tICcuLi9zdmVsdGUvbGliL3lvdXR1YmUvWW91VHViZVBsYXllci5zdmVsdGUnXG5cbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IFttb2R1bGUwLG1vZHVsZTEsbW9kdWxlMixtb2R1bGUzLG1vZHVsZTQsbW9kdWxlNSxtb2R1bGU2LG1vZHVsZTcsbW9kdWxlOCxtb2R1bGU5LG1vZHVsZTEwLG1vZHVsZTExXTtcblxuICAgICAgICBleHBvcnQgZGVmYXVsdCBtb2R1bGVzO1xuICAgICAgICBleHBvcnQgY29uc3QgZmlsZW5hbWVzID0gWycuLi9zdmVsdGUvQXV0aE1vZGFsLnN2ZWx0ZScsJy4uL3N2ZWx0ZS9DaGF0V2luZG93LnN2ZWx0ZScsJy4uL3N2ZWx0ZS9Db2RlU25pcHBldENhcmQuc3ZlbHRlJywnLi4vc3ZlbHRlL0NvdW50ZXIuc3ZlbHRlJywnLi4vc3ZlbHRlL0dvb2dsZVNpZ25JbkJ1dHRvbi5zdmVsdGUnLCcuLi9zdmVsdGUvTmF2YmFyLnN2ZWx0ZScsJy4uL3N2ZWx0ZS9TdWJOYXYuc3ZlbHRlJywnLi4vc3ZlbHRlL1RoZW1lU2VsZWN0b3Iuc3ZlbHRlJywnLi4vc3ZlbHRlL1RoZW1lVG9nZ2xlLnN2ZWx0ZScsJy4uL3N2ZWx0ZS9Vc2VyTWVudS5zdmVsdGUnLCcuLi9zdmVsdGUvV29ya2Zsb3dTdGF0dXNDYXJkLnN2ZWx0ZScsJy4uL3N2ZWx0ZS9saWIveW91dHViZS9Zb3VUdWJlUGxheWVyLnN2ZWx0ZSddXG4gICAgICAiLCAiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtc3ZlbHRlIHYwLjU1Ni4wIC0gSVNDXG4gKlxuICogSVNDIExpY2Vuc2VcbiAqIFxuICogQ29weXJpZ2h0IChjKSBmb3IgcG9ydGlvbnMgb2YgTHVjaWRlIGFyZSBoZWxkIGJ5IENvbGUgQmVtaXMgMjAxMy0yMDIzIGFzIHBhcnQgb2YgRmVhdGhlciAoTUlUKS4gQWxsIG90aGVyIGNvcHlyaWdodCAoYykgZm9yIEx1Y2lkZSBhcmUgaGVsZCBieSBMdWNpZGUgQ29udHJpYnV0b3JzIDIwMjUuXG4gKiBcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICogXG4gKiAtLS1cbiAqIFxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpIChmb3IgcG9ydGlvbnMgZGVyaXZlZCBmcm9tIEZlYXRoZXIpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDIzIENvbGUgQmVtaXNcbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICogXG4gKi9cbmNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0ge1xuICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIHdpZHRoOiAyNCxcbiAgICBoZWlnaHQ6IDI0LFxuICAgIHZpZXdCb3g6ICcwIDAgMjQgMjQnLFxuICAgIGZpbGw6ICdub25lJyxcbiAgICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsXG4gICAgJ3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcsXG59O1xuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdEF0dHJpYnV0ZXM7XG4iLCAiPHNjcmlwdD5pbXBvcnQgZGVmYXVsdEF0dHJpYnV0ZXMgZnJvbSAnLi9kZWZhdWx0QXR0cmlidXRlcyc7XG5leHBvcnQgbGV0IG5hbWUgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGNvbG9yID0gJ2N1cnJlbnRDb2xvcic7XG5leHBvcnQgbGV0IHNpemUgPSAyNDtcbmV4cG9ydCBsZXQgc3Ryb2tlV2lkdGggPSAyO1xuZXhwb3J0IGxldCBhYnNvbHV0ZVN0cm9rZVdpZHRoID0gZmFsc2U7XG5leHBvcnQgbGV0IGljb25Ob2RlID0gW107XG5jb25zdCBtZXJnZUNsYXNzZXMgPSAoLi4uY2xhc3NlcykgPT4gY2xhc3Nlcy5maWx0ZXIoKGNsYXNzTmFtZSwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oY2xhc3NOYW1lKSAmJiBhcnJheS5pbmRleE9mKGNsYXNzTmFtZSkgPT09IGluZGV4O1xufSlcbiAgICAuam9pbignICcpO1xuPC9zY3JpcHQ+XG5cbjxzdmdcbiAgey4uLmRlZmF1bHRBdHRyaWJ1dGVzfVxuICB7Li4uJCRyZXN0UHJvcHN9XG4gIHdpZHRoPXtzaXplfVxuICBoZWlnaHQ9e3NpemV9XG4gIHN0cm9rZT17Y29sb3J9XG4gIHN0cm9rZS13aWR0aD17XG4gICAgYWJzb2x1dGVTdHJva2VXaWR0aFxuICAgICAgPyBOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQgLyBOdW1iZXIoc2l6ZSlcbiAgICAgIDogc3Ryb2tlV2lkdGhcbiAgfVxuICBjbGFzcz17XG4gICAgbWVyZ2VDbGFzc2VzKFxuICAgICAgJ2x1Y2lkZS1pY29uJyxcbiAgICAgICdsdWNpZGUnLFxuICAgICAgbmFtZSA/IGBsdWNpZGUtJHtuYW1lfWA6ICcnLFxuICAgICAgJCRwcm9wcy5jbGFzc1xuICAgIClcbiAgfVxuPlxuICB7I2VhY2ggaWNvbk5vZGUgYXMgW3RhZywgYXR0cnNdfVxuICAgIDxzdmVsdGU6ZWxlbWVudCB0aGlzPXt0YWd9IHsuLi5hdHRyc30vPlxuICB7L2VhY2h9XG4gIDxzbG90IC8+XG48L3N2Zz5cbiIsICI8c2NyaXB0Pi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXN2ZWx0ZSB2MC41NTYuMCAtIElTQ1xuICpcbiAqIElTQyBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSBmb3IgcG9ydGlvbnMgb2YgTHVjaWRlIGFyZSBoZWxkIGJ5IENvbGUgQmVtaXMgMjAxMy0yMDIzIGFzIHBhcnQgb2YgRmVhdGhlciAoTUlUKS4gQWxsIG90aGVyIGNvcHlyaWdodCAoYykgZm9yIEx1Y2lkZSBhcmUgaGVsZCBieSBMdWNpZGUgQ29udHJpYnV0b3JzIDIwMjUuXG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVCkgKGZvciBwb3J0aW9ucyBkZXJpdmVkIGZyb20gRmVhdGhlcilcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAyMyBDb2xlIEJlbWlzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKi9cbmltcG9ydCBJY29uIGZyb20gJy4uL0ljb24uc3ZlbHRlJztcbmNvbnN0IGljb25Ob2RlID0gW1tcInBhdGhcIiwgeyBcImRcIjogXCJNMTIgN3YxNFwiIH1dLCBbXCJwYXRoXCIsIHsgXCJkXCI6IFwiTTMgMThhMSAxIDAgMCAxLTEtMVY0YTEgMSAwIDAgMSAxLTFoNWE0IDQgMCAwIDEgNCA0IDQgNCAwIDAgMSA0LTRoNWExIDEgMCAwIDEgMSAxdjEzYTEgMSAwIDAgMS0xIDFoLTZhMyAzIDAgMCAwLTMgMyAzIDMgMCAwIDAtMy0zelwiIH1dXTtcbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBCb29rT3BlblxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRJZ04zWXhOQ0lnTHo0S0lDQThjR0YwYUNCa1BTSk5NeUF4T0dFeElERWdNQ0F3SURFdE1TMHhWalJoTVNBeElEQWdNQ0F4SURFdE1XZzFZVFFnTkNBd0lEQWdNU0EwSURRZ05DQTBJREFnTUNBeElEUXROR2cxWVRFZ01TQXdJREFnTVNBeElERjJNVE5oTVNBeElEQWdNQ0F4TFRFZ01XZ3RObUV6SURNZ01DQXdJREF0TXlBeklETWdNeUF3SURBZ01DMHpMVE42SWlBdlBnbzhMM04yWno0SykgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvYm9vay1vcGVuXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtc3ZlbHRlIC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbmFsQ29tcG9uZW50fSBTdmVsdGUgY29tcG9uZW50XG4gKlxuICovXG48L3NjcmlwdD5cblxuPEljb24gbmFtZT1cImJvb2stb3BlblwiIHsuLi4kJHByb3BzfSBpY29uTm9kZT17aWNvbk5vZGV9PlxuICA8c2xvdC8+XG48L0ljb24+XG4iLCAiPHNjcmlwdD4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1zdmVsdGUgdjAuNTU2LjAgLSBJU0NcbiAqXG4gKiBJU0MgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgZm9yIHBvcnRpb25zIG9mIEx1Y2lkZSBhcmUgaGVsZCBieSBDb2xlIEJlbWlzIDIwMTMtMjAyMyBhcyBwYXJ0IG9mIEZlYXRoZXIgKE1JVCkuIEFsbCBvdGhlciBjb3B5cmlnaHQgKGMpIGZvciBMdWNpZGUgYXJlIGhlbGQgYnkgTHVjaWRlIENvbnRyaWJ1dG9ycyAyMDI1LlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuICogV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbiAqIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcbiAqIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKlxuICogLS0tXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpIChmb3IgcG9ydGlvbnMgZGVyaXZlZCBmcm9tIEZlYXRoZXIpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMjMgQ29sZSBCZW1pc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICovXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9JY29uLnN2ZWx0ZSc7XG5jb25zdCBpY29uTm9kZSA9IFtbXCJwYXRoXCIsIHsgXCJkXCI6IFwibTE5IDIxLTctNC03IDRWNWEyIDIgMCAwIDEgMi0yaDEwYTIgMiAwIDAgMSAyIDJ2MTZ6XCIgfV1dO1xuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIEJvb2ttYXJrXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSnRNVGtnTWpFdE55MDBMVGNnTkZZMVlUSWdNaUF3SURBZ01TQXlMVEpvTVRCaE1pQXlJREFnTUNBeElESWdNbll4Tm5vaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2Jvb2ttYXJrXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtc3ZlbHRlIC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbmFsQ29tcG9uZW50fSBTdmVsdGUgY29tcG9uZW50XG4gKlxuICovXG48L3NjcmlwdD5cblxuPEljb24gbmFtZT1cImJvb2ttYXJrXCIgey4uLiQkcHJvcHN9IGljb25Ob2RlPXtpY29uTm9kZX0+XG4gIDxzbG90Lz5cbjwvSWNvbj5cbiIsICI8c2NyaXB0Pi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXN2ZWx0ZSB2MC41NTYuMCAtIElTQ1xuICpcbiAqIElTQyBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSBmb3IgcG9ydGlvbnMgb2YgTHVjaWRlIGFyZSBoZWxkIGJ5IENvbGUgQmVtaXMgMjAxMy0yMDIzIGFzIHBhcnQgb2YgRmVhdGhlciAoTUlUKS4gQWxsIG90aGVyIGNvcHlyaWdodCAoYykgZm9yIEx1Y2lkZSBhcmUgaGVsZCBieSBMdWNpZGUgQ29udHJpYnV0b3JzIDIwMjUuXG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVCkgKGZvciBwb3J0aW9ucyBkZXJpdmVkIGZyb20gRmVhdGhlcilcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAyMyBDb2xlIEJlbWlzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKi9cbmltcG9ydCBJY29uIGZyb20gJy4uL0ljb24uc3ZlbHRlJztcbmNvbnN0IGljb25Ob2RlID0gW1tcInBhdGhcIiwgeyBcImRcIjogXCJNMTAuNzMzIDUuMDc2YTEwLjc0NCAxMC43NDQgMCAwIDEgMTEuMjA1IDYuNTc1IDEgMSAwIDAgMSAwIC42OTYgMTAuNzQ3IDEwLjc0NyAwIDAgMS0xLjQ0NCAyLjQ5XCIgfV0sIFtcInBhdGhcIiwgeyBcImRcIjogXCJNMTQuMDg0IDE0LjE1OGEzIDMgMCAwIDEtNC4yNDItNC4yNDJcIiB9XSwgW1wicGF0aFwiLCB7IFwiZFwiOiBcIk0xNy40NzkgMTcuNDk5YTEwLjc1IDEwLjc1IDAgMCAxLTE1LjQxNy01LjE1MSAxIDEgMCAwIDEgMC0uNjk2IDEwLjc1IDEwLjc1IDAgMCAxIDQuNDQ2LTUuMTQzXCIgfV0sIFtcInBhdGhcIiwgeyBcImRcIjogXCJtMiAyIDIwIDIwXCIgfV1dO1xuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIEV5ZU9mZlxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRBdU56TXpJRFV1TURjMllURXdMamMwTkNBeE1DNDNORFFnTUNBd0lERWdNVEV1TWpBMUlEWXVOVGMxSURFZ01TQXdJREFnTVNBd0lDNDJPVFlnTVRBdU56UTNJREV3TGpjME55QXdJREFnTVMweExqUTBOQ0F5TGpRNUlpQXZQZ29nSUR4d1lYUm9JR1E5SWsweE5DNHdPRFFnTVRRdU1UVTRZVE1nTXlBd0lEQWdNUzAwTGpJME1pMDBMakkwTWlJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0pOTVRjdU5EYzVJREUzTGpRNU9XRXhNQzQzTlNBeE1DNDNOU0F3SURBZ01TMHhOUzQwTVRjdE5TNHhOVEVnTVNBeElEQWdNQ0F4SURBdExqWTVOaUF4TUM0M05TQXhNQzQzTlNBd0lEQWdNU0EwTGpRME5pMDFMakUwTXlJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0p0TWlBeUlESXdJREl3SWlBdlBnbzhMM04yWno0SykgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvZXllLW9mZlxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXN2ZWx0ZSAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25hbENvbXBvbmVudH0gU3ZlbHRlIGNvbXBvbmVudFxuICpcbiAqL1xuPC9zY3JpcHQ+XG5cbjxJY29uIG5hbWU9XCJleWUtb2ZmXCIgey4uLiQkcHJvcHN9IGljb25Ob2RlPXtpY29uTm9kZX0+XG4gIDxzbG90Lz5cbjwvSWNvbj5cbiIsICI8c2NyaXB0Pi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXN2ZWx0ZSB2MC41NTYuMCAtIElTQ1xuICpcbiAqIElTQyBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSBmb3IgcG9ydGlvbnMgb2YgTHVjaWRlIGFyZSBoZWxkIGJ5IENvbGUgQmVtaXMgMjAxMy0yMDIzIGFzIHBhcnQgb2YgRmVhdGhlciAoTUlUKS4gQWxsIG90aGVyIGNvcHlyaWdodCAoYykgZm9yIEx1Y2lkZSBhcmUgaGVsZCBieSBMdWNpZGUgQ29udHJpYnV0b3JzIDIwMjUuXG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVCkgKGZvciBwb3J0aW9ucyBkZXJpdmVkIGZyb20gRmVhdGhlcilcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAyMyBDb2xlIEJlbWlzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKi9cbmltcG9ydCBJY29uIGZyb20gJy4uL0ljb24uc3ZlbHRlJztcbmNvbnN0IGljb25Ob2RlID0gW1tcInBhdGhcIiwgeyBcImRcIjogXCJNMi4wNjIgMTIuMzQ4YTEgMSAwIDAgMSAwLS42OTYgMTAuNzUgMTAuNzUgMCAwIDEgMTkuODc2IDAgMSAxIDAgMCAxIDAgLjY5NiAxMC43NSAxMC43NSAwIDAgMS0xOS44NzYgMFwiIH1dLCBbXCJjaXJjbGVcIiwgeyBcImN4XCI6IFwiMTJcIiwgXCJjeVwiOiBcIjEyXCIsIFwiclwiOiBcIjNcIiB9XV07XG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgRXllXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NaTR3TmpJZ01USXVNelE0WVRFZ01TQXdJREFnTVNBd0xTNDJPVFlnTVRBdU56VWdNVEF1TnpVZ01DQXdJREVnTVRrdU9EYzJJREFnTVNBeElEQWdNQ0F4SURBZ0xqWTVOaUF4TUM0M05TQXhNQzQzTlNBd0lEQWdNUzB4T1M0NE56WWdNQ0lnTHo0S0lDQThZMmx5WTJ4bElHTjRQU0l4TWlJZ1kzazlJakV5SWlCeVBTSXpJaUF2UGdvOEwzTjJaejRLKSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9leWVcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1zdmVsdGUgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0Z1bmN0aW9uYWxDb21wb25lbnR9IFN2ZWx0ZSBjb21wb25lbnRcbiAqXG4gKi9cbjwvc2NyaXB0PlxuXG48SWNvbiBuYW1lPVwiZXllXCIgey4uLiQkcHJvcHN9IGljb25Ob2RlPXtpY29uTm9kZX0+XG4gIDxzbG90Lz5cbjwvSWNvbj5cbiIsICI8c2NyaXB0Pi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXN2ZWx0ZSB2MC41NTYuMCAtIElTQ1xuICpcbiAqIElTQyBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSBmb3IgcG9ydGlvbnMgb2YgTHVjaWRlIGFyZSBoZWxkIGJ5IENvbGUgQmVtaXMgMjAxMy0yMDIzIGFzIHBhcnQgb2YgRmVhdGhlciAoTUlUKS4gQWxsIG90aGVyIGNvcHlyaWdodCAoYykgZm9yIEx1Y2lkZSBhcmUgaGVsZCBieSBMdWNpZGUgQ29udHJpYnV0b3JzIDIwMjUuXG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVCkgKGZvciBwb3J0aW9ucyBkZXJpdmVkIGZyb20gRmVhdGhlcilcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAyMyBDb2xlIEJlbWlzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKi9cbmltcG9ydCBJY29uIGZyb20gJy4uL0ljb24uc3ZlbHRlJztcbmNvbnN0IGljb25Ob2RlID0gW1tcInJlY3RcIiwgeyBcIndpZHRoXCI6IFwiN1wiLCBcImhlaWdodFwiOiBcIjlcIiwgXCJ4XCI6IFwiM1wiLCBcInlcIjogXCIzXCIsIFwicnhcIjogXCIxXCIgfV0sIFtcInJlY3RcIiwgeyBcIndpZHRoXCI6IFwiN1wiLCBcImhlaWdodFwiOiBcIjVcIiwgXCJ4XCI6IFwiMTRcIiwgXCJ5XCI6IFwiM1wiLCBcInJ4XCI6IFwiMVwiIH1dLCBbXCJyZWN0XCIsIHsgXCJ3aWR0aFwiOiBcIjdcIiwgXCJoZWlnaHRcIjogXCI5XCIsIFwieFwiOiBcIjE0XCIsIFwieVwiOiBcIjEyXCIsIFwicnhcIjogXCIxXCIgfV0sIFtcInJlY3RcIiwgeyBcIndpZHRoXCI6IFwiN1wiLCBcImhlaWdodFwiOiBcIjVcIiwgXCJ4XCI6IFwiM1wiLCBcInlcIjogXCIxNlwiLCBcInJ4XCI6IFwiMVwiIH1dXTtcbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBMYXlvdXREYXNoYm9hcmRcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNtVmpkQ0IzYVdSMGFEMGlOeUlnYUdWcFoyaDBQU0k1SWlCNFBTSXpJaUI1UFNJeklpQnllRDBpTVNJZ0x6NEtJQ0E4Y21WamRDQjNhV1IwYUQwaU55SWdhR1ZwWjJoMFBTSTFJaUI0UFNJeE5DSWdlVDBpTXlJZ2NuZzlJakVpSUM4K0NpQWdQSEpsWTNRZ2QybGtkR2c5SWpjaUlHaGxhV2RvZEQwaU9TSWdlRDBpTVRRaUlIazlJakV5SWlCeWVEMGlNU0lnTHo0S0lDQThjbVZqZENCM2FXUjBhRDBpTnlJZ2FHVnBaMmgwUFNJMUlpQjRQU0l6SWlCNVBTSXhOaUlnY25nOUlqRWlJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9sYXlvdXQtZGFzaGJvYXJkXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtc3ZlbHRlIC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbmFsQ29tcG9uZW50fSBTdmVsdGUgY29tcG9uZW50XG4gKlxuICovXG48L3NjcmlwdD5cblxuPEljb24gbmFtZT1cImxheW91dC1kYXNoYm9hcmRcIiB7Li4uJCRwcm9wc30gaWNvbk5vZGU9e2ljb25Ob2RlfT5cbiAgPHNsb3QvPlxuPC9JY29uPlxuIiwgIjxzY3JpcHQ+LyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtc3ZlbHRlIHYwLjU1Ni4wIC0gSVNDXG4gKlxuICogSVNDIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIGZvciBwb3J0aW9ucyBvZiBMdWNpZGUgYXJlIGhlbGQgYnkgQ29sZSBCZW1pcyAyMDEzLTIwMjMgYXMgcGFydCBvZiBGZWF0aGVyIChNSVQpLiBBbGwgb3RoZXIgY29weXJpZ2h0IChjKSBmb3IgTHVjaWRlIGFyZSBoZWxkIGJ5IEx1Y2lkZSBDb250cmlidXRvcnMgMjAyNS5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqIC0tLVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKSAoZm9yIHBvcnRpb25zIGRlcml2ZWQgZnJvbSBGZWF0aGVyKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDIzIENvbGUgQmVtaXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqL1xuaW1wb3J0IEljb24gZnJvbSAnLi4vSWNvbi5zdmVsdGUnO1xuY29uc3QgaWNvbk5vZGUgPSBbW1wicGF0aFwiLCB7IFwiZFwiOiBcIk0yMSAxMmE5IDkgMCAxIDEtNi4yMTktOC41NlwiIH1dXTtcbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBMb2FkZXJDaXJjbGVcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1qRWdNVEpoT1NBNUlEQWdNU0F4TFRZdU1qRTVMVGd1TlRZaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2xvYWRlci1jaXJjbGVcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1zdmVsdGUgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0Z1bmN0aW9uYWxDb21wb25lbnR9IFN2ZWx0ZSBjb21wb25lbnRcbiAqXG4gKi9cbjwvc2NyaXB0PlxuXG48SWNvbiBuYW1lPVwibG9hZGVyLWNpcmNsZVwiIHsuLi4kJHByb3BzfSBpY29uTm9kZT17aWNvbk5vZGV9PlxuICA8c2xvdC8+XG48L0ljb24+XG4iLCAiPHNjcmlwdD4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1zdmVsdGUgdjAuNTU2LjAgLSBJU0NcbiAqXG4gKiBJU0MgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgZm9yIHBvcnRpb25zIG9mIEx1Y2lkZSBhcmUgaGVsZCBieSBDb2xlIEJlbWlzIDIwMTMtMjAyMyBhcyBwYXJ0IG9mIEZlYXRoZXIgKE1JVCkuIEFsbCBvdGhlciBjb3B5cmlnaHQgKGMpIGZvciBMdWNpZGUgYXJlIGhlbGQgYnkgTHVjaWRlIENvbnRyaWJ1dG9ycyAyMDI1LlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuICogV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbiAqIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcbiAqIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKlxuICogLS0tXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpIChmb3IgcG9ydGlvbnMgZGVyaXZlZCBmcm9tIEZlYXRoZXIpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMjMgQ29sZSBCZW1pc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICovXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9JY29uLnN2ZWx0ZSc7XG5jb25zdCBpY29uTm9kZSA9IFtbXCJwYXRoXCIsIHsgXCJkXCI6IFwibTE2IDE3IDUtNS01LTVcIiB9XSwgW1wicGF0aFwiLCB7IFwiZFwiOiBcIk0yMSAxMkg5XCIgfV0sIFtcInBhdGhcIiwgeyBcImRcIjogXCJNOSAyMUg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDRcIiB9XV07XG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgTG9nT3V0XG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSnRNVFlnTVRjZ05TMDFMVFV0TlNJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0pOTWpFZ01USklPU0lnTHo0S0lDQThjR0YwYUNCa1BTSk5PU0F5TVVnMVlUSWdNaUF3SURBZ01TMHlMVEpXTldFeUlESWdNQ0F3SURFZ01pMHlhRFFpSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvbG9nLW91dFxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXN2ZWx0ZSAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25hbENvbXBvbmVudH0gU3ZlbHRlIGNvbXBvbmVudFxuICpcbiAqL1xuPC9zY3JpcHQ+XG5cbjxJY29uIG5hbWU9XCJsb2ctb3V0XCIgey4uLiQkcHJvcHN9IGljb25Ob2RlPXtpY29uTm9kZX0+XG4gIDxzbG90Lz5cbjwvSWNvbj5cbiIsICI8c2NyaXB0Pi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXN2ZWx0ZSB2MC41NTYuMCAtIElTQ1xuICpcbiAqIElTQyBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSBmb3IgcG9ydGlvbnMgb2YgTHVjaWRlIGFyZSBoZWxkIGJ5IENvbGUgQmVtaXMgMjAxMy0yMDIzIGFzIHBhcnQgb2YgRmVhdGhlciAoTUlUKS4gQWxsIG90aGVyIGNvcHlyaWdodCAoYykgZm9yIEx1Y2lkZSBhcmUgaGVsZCBieSBMdWNpZGUgQ29udHJpYnV0b3JzIDIwMjUuXG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVCkgKGZvciBwb3J0aW9ucyBkZXJpdmVkIGZyb20gRmVhdGhlcilcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAyMyBDb2xlIEJlbWlzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKi9cbmltcG9ydCBJY29uIGZyb20gJy4uL0ljb24uc3ZlbHRlJztcbmNvbnN0IGljb25Ob2RlID0gW1tcInBhdGhcIiwgeyBcImRcIjogXCJNOS42NzEgNC4xMzZhMi4zNCAyLjM0IDAgMCAxIDQuNjU5IDAgMi4zNCAyLjM0IDAgMCAwIDMuMzE5IDEuOTE1IDIuMzQgMi4zNCAwIDAgMSAyLjMzIDQuMDMzIDIuMzQgMi4zNCAwIDAgMCAwIDMuODMxIDIuMzQgMi4zNCAwIDAgMS0yLjMzIDQuMDMzIDIuMzQgMi4zNCAwIDAgMC0zLjMxOSAxLjkxNSAyLjM0IDIuMzQgMCAwIDEtNC42NTkgMCAyLjM0IDIuMzQgMCAwIDAtMy4zMi0xLjkxNSAyLjM0IDIuMzQgMCAwIDEtMi4zMy00LjAzMyAyLjM0IDIuMzQgMCAwIDAgMC0zLjgzMUEyLjM0IDIuMzQgMCAwIDEgNi4zNSA2LjA1MWEyLjM0IDIuMzQgMCAwIDAgMy4zMTktMS45MTVcIiB9XSwgW1wiY2lyY2xlXCIsIHsgXCJjeFwiOiBcIjEyXCIsIFwiY3lcIjogXCIxMlwiLCBcInJcIjogXCIzXCIgfV1dO1xuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIFNldHRpbmdzXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5PUzQyTnpFZ05DNHhNelpoTWk0ek5DQXlMak0wSURBZ01DQXhJRFF1TmpVNUlEQWdNaTR6TkNBeUxqTTBJREFnTUNBd0lETXVNekU1SURFdU9URTFJREl1TXpRZ01pNHpOQ0F3SURBZ01TQXlMak16SURRdU1ETXpJREl1TXpRZ01pNHpOQ0F3SURBZ01DQXdJRE11T0RNeElESXVNelFnTWk0ek5DQXdJREFnTVMweUxqTXpJRFF1TURNeklESXVNelFnTWk0ek5DQXdJREFnTUMwekxqTXhPU0F4TGpreE5TQXlMak0wSURJdU16UWdNQ0F3SURFdE5DNDJOVGtnTUNBeUxqTTBJREl1TXpRZ01DQXdJREF0TXk0ek1pMHhMamt4TlNBeUxqTTBJREl1TXpRZ01DQXdJREV0TWk0ek15MDBMakF6TXlBeUxqTTBJREl1TXpRZ01DQXdJREFnTUMwekxqZ3pNVUV5TGpNMElESXVNelFnTUNBd0lERWdOaTR6TlNBMkxqQTFNV0V5TGpNMElESXVNelFnTUNBd0lEQWdNeTR6TVRrdE1TNDVNVFVpSUM4K0NpQWdQR05wY21Oc1pTQmplRDBpTVRJaUlHTjVQU0l4TWlJZ2NqMGlNeUlnTHo0S1BDOXpkbWMrQ2c9PSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvc2V0dGluZ3NcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1zdmVsdGUgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0Z1bmN0aW9uYWxDb21wb25lbnR9IFN2ZWx0ZSBjb21wb25lbnRcbiAqXG4gKi9cbjwvc2NyaXB0PlxuXG48SWNvbiBuYW1lPVwic2V0dGluZ3NcIiB7Li4uJCRwcm9wc30gaWNvbk5vZGU9e2ljb25Ob2RlfT5cbiAgPHNsb3QvPlxuPC9JY29uPlxuIiwgIjxzY3JpcHQ+LyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtc3ZlbHRlIHYwLjU1Ni4wIC0gSVNDXG4gKlxuICogSVNDIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIGZvciBwb3J0aW9ucyBvZiBMdWNpZGUgYXJlIGhlbGQgYnkgQ29sZSBCZW1pcyAyMDEzLTIwMjMgYXMgcGFydCBvZiBGZWF0aGVyIChNSVQpLiBBbGwgb3RoZXIgY29weXJpZ2h0IChjKSBmb3IgTHVjaWRlIGFyZSBoZWxkIGJ5IEx1Y2lkZSBDb250cmlidXRvcnMgMjAyNS5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqIC0tLVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKSAoZm9yIHBvcnRpb25zIGRlcml2ZWQgZnJvbSBGZWF0aGVyKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDIzIENvbGUgQmVtaXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqL1xuaW1wb3J0IEljb24gZnJvbSAnLi4vSWNvbi5zdmVsdGUnO1xuY29uc3QgaWNvbk5vZGUgPSBbW1wicGF0aFwiLCB7IFwiZFwiOiBcIk0xOSAyMXYtMmE0IDQgMCAwIDAtNC00SDlhNCA0IDAgMCAwLTQgNHYyXCIgfV0sIFtcImNpcmNsZVwiLCB7IFwiY3hcIjogXCIxMlwiLCBcImN5XCI6IFwiN1wiLCBcInJcIjogXCI0XCIgfV1dO1xuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIFVzZXJcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1Ua2dNakYyTFRKaE5DQTBJREFnTUNBd0xUUXRORWc1WVRRZ05DQXdJREFnTUMwMElEUjJNaUlnTHo0S0lDQThZMmx5WTJ4bElHTjRQU0l4TWlJZ1kzazlJamNpSUhJOUlqUWlJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy91c2VyXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtc3ZlbHRlIC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbmFsQ29tcG9uZW50fSBTdmVsdGUgY29tcG9uZW50XG4gKlxuICovXG48L3NjcmlwdD5cblxuPEljb24gbmFtZT1cInVzZXJcIiB7Li4uJCRwcm9wc30gaWNvbk5vZGU9e2ljb25Ob2RlfT5cbiAgPHNsb3QvPlxuPC9JY29uPlxuIiwgIjxzY3JpcHQ+LyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtc3ZlbHRlIHYwLjU1Ni4wIC0gSVNDXG4gKlxuICogSVNDIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIGZvciBwb3J0aW9ucyBvZiBMdWNpZGUgYXJlIGhlbGQgYnkgQ29sZSBCZW1pcyAyMDEzLTIwMjMgYXMgcGFydCBvZiBGZWF0aGVyIChNSVQpLiBBbGwgb3RoZXIgY29weXJpZ2h0IChjKSBmb3IgTHVjaWRlIGFyZSBoZWxkIGJ5IEx1Y2lkZSBDb250cmlidXRvcnMgMjAyNS5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqIC0tLVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKSAoZm9yIHBvcnRpb25zIGRlcml2ZWQgZnJvbSBGZWF0aGVyKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDIzIENvbGUgQmVtaXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqL1xuaW1wb3J0IEljb24gZnJvbSAnLi4vSWNvbi5zdmVsdGUnO1xuY29uc3QgaWNvbk5vZGUgPSBbW1wicGF0aFwiLCB7IFwiZFwiOiBcIk0xOCA2IDYgMThcIiB9XSwgW1wicGF0aFwiLCB7IFwiZFwiOiBcIm02IDYgMTIgMTJcIiB9XV07XG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgWFxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRnZ05pQTJJREU0SWlBdlBnb2dJRHh3WVhSb0lHUTlJbTAySURZZ01USWdNVElpSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMveFxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXN2ZWx0ZSAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25hbENvbXBvbmVudH0gU3ZlbHRlIGNvbXBvbmVudFxuICpcbiAqL1xuPC9zY3JpcHQ+XG5cbjxJY29uIG5hbWU9XCJ4XCIgey4uLiQkcHJvcHN9IGljb25Ob2RlPXtpY29uTm9kZX0+XG4gIDxzbG90Lz5cbjwvSWNvbj5cbiIsICI8c2NyaXB0PlxuICBsZXQgeyBkaXNhYmxlZCA9IGZhbHNlLCB0ZXh0ID0gJ0NvbnRpbnVlIHdpdGggR29vZ2xlJyB9ID0gJHByb3BzKClcblxuICBmdW5jdGlvbiBoYW5kbGVHb29nbGVTaWduSW4oKSB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm5cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvYXV0aC9nb29nbGUnXG4gIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uXG4gIHR5cGU9XCJidXR0b25cIlxuICBvbmNsaWNrPXtoYW5kbGVHb29nbGVTaWduSW59XG4gIHtkaXNhYmxlZH1cbiAgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUgdy1mdWxsIGdhcC0zXCJcbj5cbiAgPCEtLSBPZmZpY2lhbCBHb29nbGUgNC1jb2xvciBsb2dvIFNWRyAtLT5cbiAgPHN2ZyBjbGFzcz1cInctNSBoLTVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgPHBhdGhcbiAgICAgIGZpbGw9XCIjNDI4NUY0XCJcbiAgICAgIGQ9XCJNMjIuNTYgMTIuMjVjMC0uNzgtLjA3LTEuNTMtLjItMi4yNUgxMnY0LjI2aDUuOTJjLS4yNiAxLjM3LTEuMDQgMi41My0yLjIxIDMuMzF2Mi43N2gzLjU3YzIuMDgtMS45MiAzLjI4LTQuNzQgMy4yOC04LjA5elwiXG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgZmlsbD1cIiMzNEE4NTNcIlxuICAgICAgZD1cIk0xMiAyM2MyLjk3IDAgNS40Ni0uOTggNy4yOC0yLjY2bC0zLjU3LTIuNzdjLS45OC42Ni0yLjIzIDEuMDYtMy43MSAxLjA2LTIuODYgMC01LjI5LTEuOTMtNi4xNi00LjUzSDIuMTh2Mi44NEMzLjk5IDIwLjUzIDcuNyAyMyAxMiAyM3pcIlxuICAgIC8+XG4gICAgPHBhdGhcbiAgICAgIGZpbGw9XCIjRkJCQzA1XCJcbiAgICAgIGQ9XCJNNS44NCAxNC4wOWMtLjIyLS42Ni0uMzUtMS4zNi0uMzUtMi4wOXMuMTMtMS40My4zNS0yLjA5VjcuMDdIMi4xOEMxLjQzIDguNTUgMSAxMC4yMiAxIDEycy40MyAzLjQ1IDEuMTggNC45M2wyLjg1LTIuMjIuODEtLjYyelwiXG4gICAgLz5cbiAgICA8cGF0aFxuICAgICAgZmlsbD1cIiNFQTQzMzVcIlxuICAgICAgZD1cIk0xMiA1LjM4YzEuNjIgMCAzLjA2LjU2IDQuMjEgMS42NGwzLjE1LTMuMTVDMTcuNDUgMi4wOSAxNC45NyAxIDEyIDEgNy43IDEgMy45OSAzLjQ3IDIuMTggNy4wN2wzLjY2IDIuODRjLjg3LTIuNiAzLjMtNC41MyA2LjE2LTQuNTN6XCJcbiAgICAvPlxuICA8L3N2Zz5cbiAgPHNwYW4+e3RleHR9PC9zcGFuPlxuPC9idXR0b24+XG4iLCAiPHNjcmlwdD5cbiAgaW1wb3J0IHsgRXllLCBFeWVPZmYsIFggfSBmcm9tICdsdWNpZGUtc3ZlbHRlJ1xuICBpbXBvcnQgR29vZ2xlU2lnbkluQnV0dG9uIGZyb20gJy4vR29vZ2xlU2lnbkluQnV0dG9uLnN2ZWx0ZSdcblxuICBsZXQgeyBpc09wZW4gPSAkYmluZGFibGUoZmFsc2UpLCBsaXZlIH0gPSAkcHJvcHMoKVxuXG4gIGxldCBtb2RlID0gJHN0YXRlKCdzaWduaW4nKSAvLyAnc2lnbmluJyBvciAnc2lnbnVwJ1xuICBsZXQgZW1haWwgPSAkc3RhdGUoJycpXG4gIGxldCBwYXNzd29yZCA9ICRzdGF0ZSgnJylcbiAgbGV0IG5hbWUgPSAkc3RhdGUoJycpXG4gIGxldCBlcnJvciA9ICRzdGF0ZSgnJylcbiAgbGV0IGxvYWRpbmcgPSAkc3RhdGUoZmFsc2UpXG4gIGxldCBzaG93UGFzc3dvcmQgPSAkc3RhdGUoZmFsc2UpXG5cbiAgZnVuY3Rpb24gY2xvc2VNb2RhbCgpIHtcbiAgICBpc09wZW4gPSBmYWxzZVxuICAgIGVtYWlsID0gJydcbiAgICBwYXNzd29yZCA9ICcnXG4gICAgbmFtZSA9ICcnXG4gICAgZXJyb3IgPSAnJ1xuICAgIHNob3dQYXNzd29yZCA9IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBzd2l0Y2hNb2RlKCkge1xuICAgIG1vZGUgPSBtb2RlID09PSAnc2lnbmluJyA/ICdzaWdudXAnIDogJ3NpZ25pbidcbiAgICBlcnJvciA9ICcnXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVFbWFpbEF1dGgoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXJyb3IgPSAnJ1xuICAgIGxvYWRpbmcgPSB0cnVlXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5kcG9pbnQgPSBtb2RlID09PSAnc2lnbmluJyA/ICcvYXV0aC9zaWduaW4nIDogJy9hdXRoL3NpZ251cCdcbiAgICAgIGNvbnN0IGJvZHkgPSBtb2RlID09PSAnc2lnbmluJ1xuICAgICAgICA/IHsgZW1haWwsIHBhc3N3b3JkIH1cbiAgICAgICAgOiB7IGVtYWlsLCBwYXNzd29yZCwgbmFtZSB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdYLUNTUkYtVG9rZW4nOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJyk/LmNvbnRlbnQgfHwgJydcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgZXJyb3IgPSBkYXRhLmVycm9yIHx8ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSAnTmV0d29yayBlcnJvci4gUGxlYXNlIHRyeSBhZ2Fpbi4nXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGxvYWRpbmcgPSBmYWxzZVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxkaWFsb2cgY2xhc3M9XCJtb2RhbFwiIGNsYXNzOm1vZGFsLW9wZW49e2lzT3Blbn0+XG4gIDxkaXYgY2xhc3M9XCJtb2RhbC1ib3ggYmctYmFzZS0yMDAgbWF4LXctbWRcIj5cbiAgICA8Zm9ybSBtZXRob2Q9XCJkaWFsb2dcIj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgb25jbGljaz17Y2xvc2VNb2RhbH1cbiAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1jaXJjbGUgYnRuLWdob3N0IGFic29sdXRlIHJpZ2h0LTIgdG9wLTJcIlxuICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIlxuICAgICAgPlxuICAgICAgICA8WCBjbGFzcz1cInctNCBoLTRcIiAvPlxuICAgICAgPC9idXR0b24+XG4gICAgPC9mb3JtPlxuXG4gICAgPGgzIGNsYXNzPVwiZm9udC1ib2xkIHRleHQtMnhsIG1iLTJcIj57bW9kZSA9PT0gJ3NpZ25pbicgPyAnV2VsY29tZSBCYWNrJyA6ICdDcmVhdGUgQWNjb3VudCd9PC9oMz5cbiAgICA8cCBjbGFzcz1cInRleHQtYmFzZS1jb250ZW50LzcwIG1iLTZcIj5cbiAgICAgIHttb2RlID09PSAnc2lnbmluJyA/ICdTaWduIGluIHRvIHNhdmUgcHJvbXB0cywgbGVhdmUgY29tbWVudHMsIGFuZCBtb3JlJyA6ICdKb2luIHRvIHVubG9jayBhbGwgZmVhdHVyZXMnfVxuICAgIDwvcD5cblxuICAgIDwhLS0gR29vZ2xlIE9BdXRoIC0tPlxuICAgIDxHb29nbGVTaWduSW5CdXR0b24gZGlzYWJsZWQ9e2xvYWRpbmd9IC8+XG5cbiAgICA8IS0tIERpdmlkZXIgLS0+XG4gICAgPGRpdiBjbGFzcz1cImRpdmlkZXIgdGV4dC14cyB0ZXh0LWJhc2UtY29udGVudC81MFwiPm9yPC9kaXY+XG5cbiAgICA8IS0tIEVtYWlsL1Bhc3N3b3JkIEZvcm0gLS0+XG4gICAgPGZvcm0gb25zdWJtaXQ9e2hhbmRsZUVtYWlsQXV0aH0gY2xhc3M9XCJmbGV4IGZsZXgtY29sIGdhcC00XCI+XG4gICAgICB7I2lmIG1vZGUgPT09ICdzaWdudXAnfVxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jb250cm9sIHctZnVsbFwiPlxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImxhYmVsIHBiLTFcIiBmb3I9XCJuYW1lXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxhYmVsLXRleHQgdGV4dC1zbVwiPk5hbWU8L3NwYW4+XG4gICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIGlkPVwibmFtZVwiXG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICBiaW5kOnZhbHVlPXtuYW1lfVxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJZb3VyIG5hbWVcIlxuICAgICAgICAgICAgY2xhc3M9XCJpbnB1dCBpbnB1dC1ib3JkZXJlZCB3LWZ1bGxcIlxuICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgIGRpc2FibGVkPXtsb2FkaW5nfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgey9pZn1cblxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY29udHJvbCB3LWZ1bGxcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwibGFiZWwgcGItMVwiIGZvcj1cImVtYWlsXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbC10ZXh0IHRleHQtc21cIj5FbWFpbDwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgaWQ9XCJlbWFpbFwiXG4gICAgICAgICAgdHlwZT1cImVtYWlsXCJcbiAgICAgICAgICBiaW5kOnZhbHVlPXtlbWFpbH1cbiAgICAgICAgICBwbGFjZWhvbGRlcj1cInlvdUBleGFtcGxlLmNvbVwiXG4gICAgICAgICAgY2xhc3M9XCJpbnB1dCBpbnB1dC1ib3JkZXJlZCB3LWZ1bGxcIlxuICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY29udHJvbCB3LWZ1bGxcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwibGFiZWwgcGItMVwiIGZvcj1cInBhc3N3b3JkXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbC10ZXh0IHRleHQtc21cIj5QYXNzd29yZDwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiaW5wdXQgaW5wdXQtYm9yZGVyZWQgdy1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICBpZD1cInBhc3N3b3JkXCJcbiAgICAgICAgICAgIHR5cGU9e3Nob3dQYXNzd29yZCA/ICd0ZXh0JyA6ICdwYXNzd29yZCd9XG4gICAgICAgICAgICBiaW5kOnZhbHVlPXtwYXNzd29yZH1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwi4oCi4oCi4oCi4oCi4oCi4oCi4oCi4oCiXCJcbiAgICAgICAgICAgIGNsYXNzPVwiZ3JvdyBiZy10cmFuc3BhcmVudCBvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgIG1pbmxlbmd0aD1cIjhcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIG9uY2xpY2s9eygpID0+IHNob3dQYXNzd29yZCA9ICFzaG93UGFzc3dvcmR9XG4gICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tZ2hvc3QgYnRuLXhzIGJ0bi1jaXJjbGVcIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD17c2hvd1Bhc3N3b3JkID8gJ0hpZGUgcGFzc3dvcmQnIDogJ1Nob3cgcGFzc3dvcmQnfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgc2hvd1Bhc3N3b3JkfVxuICAgICAgICAgICAgICA8RXllIGNsYXNzPVwidy00IGgtNFwiIC8+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgIDxFeWVPZmYgY2xhc3M9XCJ3LTQgaC00XCIgLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICA8L2Rpdj5cblxuICAgICAgeyNpZiBlcnJvcn1cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LWVycm9yIHRleHQtc21cIj5cbiAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImgtNSB3LTVcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYgMThMMTggNk02IDZsMTIgMTJcIiAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDxzcGFuPntlcnJvcn08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgey9pZn1cblxuICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLWxnIHctZnVsbFwiIGRpc2FibGVkPXtsb2FkaW5nfT5cbiAgICAgICAgeyNpZiBsb2FkaW5nfVxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwibG9hZGluZyBsb2FkaW5nLXNwaW5uZXJcIj48L3NwYW4+XG4gICAgICAgICAgTG9hZGluZy4uLlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAge21vZGUgPT09ICdzaWduaW4nID8gJ1NpZ24gSW4nIDogJ1NpZ24gVXAnfVxuICAgICAgICB7L2lmfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9mb3JtPlxuXG4gICAgPCEtLSBTd2l0Y2ggbW9kZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwibXQtNCB0ZXh0LWNlbnRlciB0ZXh0LXNtXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cInRleHQtYmFzZS1jb250ZW50LzcwXCI+XG4gICAgICAgIHttb2RlID09PSAnc2lnbmluJyA/IFwiRG9uJ3QgaGF2ZSBhbiBhY2NvdW50P1wiIDogJ0FscmVhZHkgaGF2ZSBhbiBhY2NvdW50Pyd9XG4gICAgICA8L3NwYW4+XG4gICAgICA8YnV0dG9uIG9uY2xpY2s9e3N3aXRjaE1vZGV9IGNsYXNzPVwibGluayBsaW5rLXByaW1hcnkgbWwtMVwiPlxuICAgICAgICB7bW9kZSA9PT0gJ3NpZ25pbicgPyAnU2lnbiB1cCcgOiAnU2lnbiBpbid9XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJtdC02IHRleHQteHMgdGV4dC1iYXNlLWNvbnRlbnQvNTAgdGV4dC1jZW50ZXJcIj5cbiAgICAgIEJ5IGNvbnRpbnVpbmcsIHlvdSBhZ3JlZSB0byBvdXIgVGVybXMgb2YgU2VydmljZSBhbmQgUHJpdmFjeSBQb2xpY3lcbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIDxmb3JtIG1ldGhvZD1cImRpYWxvZ1wiIGNsYXNzPVwibW9kYWwtYmFja2Ryb3BcIj5cbiAgICA8YnV0dG9uIG9uY2xpY2s9e2Nsb3NlTW9kYWx9PmNsb3NlPC9idXR0b24+XG4gIDwvZm9ybT5cbjwvZGlhbG9nPlxuIiwgIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCJcbiAgaW1wb3J0IHsgU29ja2V0IH0gZnJvbSBcInBob2VuaXhcIlxuICBpbXBvcnQgeyBmbHkgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIlxuXG4gIGV4cG9ydCBsZXQgcm9vbVxuICBleHBvcnQgbGV0IG1lc3NhZ2VzID0gW11cbiAgZXhwb3J0IGxldCB1c2VySWRcblxuICBsZXQgbmV3TWVzc2FnZSA9IFwiXCJcbiAgbGV0IGNoYW5uZWwgPSBudWxsXG4gIGxldCBzb2NrZXQgPSBudWxsXG4gIGxldCBpc0Nvbm5lY3RlZCA9IGZhbHNlXG4gIGxldCBtZXNzYWdlTGlzdCA9IG51bGxcbiAgbGV0IHRleHRhcmVhRWxlbWVudCA9IG51bGxcblxuICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KFwiL3NvY2tldFwiLCB7XG4gICAgICBwYXJhbXM6IHsgdXNlcl9pZDogdXNlcklkIH1cbiAgICB9KVxuICAgIHNvY2tldC5jb25uZWN0KClcblxuICAgIGNoYW5uZWwgPSBzb2NrZXQuY2hhbm5lbChgcm9vbToke3Jvb20uaWR9YClcblxuICAgIGNoYW5uZWwub24oXCJtZXNzYWdlX2NyZWF0ZWRcIiwgKHBheWxvYWQpID0+IHtcbiAgICAgIG1lc3NhZ2VzID0gWy4uLm1lc3NhZ2VzLCBwYXlsb2FkXVxuICAgICAgc2Nyb2xsVG9Cb3R0b20oKVxuICAgIH0pXG5cbiAgICBjaGFubmVsLm9uKFwidHlwaW5nXCIsIChwYXlsb2FkKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtwYXlsb2FkLnVzZXJuYW1lfSBpcyB0eXBpbmcuLi5gKVxuICAgIH0pXG5cbiAgICBjaGFubmVsXG4gICAgICAuam9pbigpXG4gICAgICAucmVjZWl2ZShcIm9rXCIsIChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgbWVzc2FnZXMgPSByZXNwLm1lc3NhZ2VzXG4gICAgICAgIH1cbiAgICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlXG4gICAgICAgIHNjcm9sbFRvQm90dG9tKClcbiAgICAgIH0pXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIChyZXNwKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gam9pblwiLCByZXNwKVxuICAgICAgICBpc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB9KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjaGFubmVsKSBjaGFubmVsLmxlYXZlKClcbiAgICAgIGlmIChzb2NrZXQpIHNvY2tldC5kaXNjb25uZWN0KClcbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2UoKSB7XG4gICAgaWYgKCFuZXdNZXNzYWdlLnRyaW0oKSB8fCAhaXNDb25uZWN0ZWQpIHJldHVyblxuICAgIGNoYW5uZWwucHVzaChcIm5ld19tZXNzYWdlXCIsIHsgYm9keTogbmV3TWVzc2FnZS50cmltKCkgfSlcbiAgICBuZXdNZXNzYWdlID0gXCJcIlxuICAgIGlmICh0ZXh0YXJlYUVsZW1lbnQpIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvQm90dG9tKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VMaXN0KSB7XG4gICAgICAgIG1lc3NhZ2VMaXN0LnNjcm9sbFRvcCA9IG1lc3NhZ2VMaXN0LnNjcm9sbEhlaWdodFxuICAgICAgfVxuICAgIH0sIDEwMClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVR5cGluZygpIHtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgY2hhbm5lbC5wdXNoKFwidHlwaW5nXCIsIHt9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUlucHV0KGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldFxuICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBNYXRoLm1pbih0YXJnZXQuc2Nyb2xsSGVpZ2h0LCAxMjApICsgXCJweFwiXG4gICAgaGFuZGxlVHlwaW5nKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFRpbWUodGltZXN0YW1wKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcClcbiAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoXCJlbi1VU1wiLCB7XG4gICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyMTI6IHRydWVcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNNZXNzYWdlU2VxdWVuY2UoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPiAwICYmIG1lc3NhZ2VzW2luZGV4IC0gMV0udXNlcl9pZCA9PT0gbWVzc2FnZXNbaW5kZXhdLnVzZXJfaWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ3VycmVudFVzZXIodXNlcklkKSB7XG4gICAgcmV0dXJuIHVzZXJJZCA9PT0gcGFyc2VJbnQodXNlcklkKVxuICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNoYXQtd3JhcHBlciBiZy1iYXNlLTEwMCBmbGV4IGZsZXgtY29sIGgtZnVsbFwiPlxuICA8IS0tIEhlYWRlciAtLT5cbiAgPGRpdiBjbGFzcz1cImNoYXQtaGVhZGVyIGJnLWJhc2UtMTAwIGJvcmRlci1iIGJvcmRlci1iYXNlLTMwMCBweC02IHB5LTQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgPGRpdj5cbiAgICAgIDxoMiBjbGFzcz1cInRleHQteGwgZm9udC1ib2xkIHRleHQtYmFzZS1jb250ZW50XCI+IyB7cm9vbS5uYW1lfTwvaDI+XG4gICAgICB7I2lmIHJvb20uZGVzY3JpcHRpb259XG4gICAgICAgIDxwIGNsYXNzPVwidGV4dC1zbSB0ZXh0LWJhc2UtY29udGVudC83MCBtdC0xXCI+e3Jvb20uZGVzY3JpcHRpb259PC9wPlxuICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYmFkZ2VcIiBjbGFzczpiYWRnZS1zdWNjZXNzPXtpc0Nvbm5lY3RlZH0gY2xhc3M6YmFkZ2UtZXJyb3I9eyFpc0Nvbm5lY3RlZH0+XG4gICAgICA8c3BhbiBjbGFzcz1cImlubGluZS1ibG9jayB3LTIgaC0yIHJvdW5kZWQtZnVsbCBtci0yXCIgY2xhc3M6Ymctc3VjY2Vzcz17aXNDb25uZWN0ZWR9IGNsYXNzOmJnLWVycm9yPXshaXNDb25uZWN0ZWR9IC8+XG4gICAgICB7aXNDb25uZWN0ZWQgPyBcIk9ubGluZVwiIDogXCJPZmZsaW5lXCJ9XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDwhLS0gTWVzc2FnZXMgLS0+XG4gIDxkaXYgYmluZDp0aGlzPXttZXNzYWdlTGlzdH0gY2xhc3M9XCJtZXNzYWdlcy1jb250YWluZXIgZmxleC0xIG92ZXJmbG93LXktYXV0byBweC00IHB5LTQgYmctYmFzZS0xMDBcIj5cbiAgICB7I2lmIG1lc3NhZ2VzLmxlbmd0aCA9PT0gMH1cbiAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBoLWZ1bGwgZ2FwLTMgdGV4dC1iYXNlLWNvbnRlbnQvNTBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtNXhsIG9wYWNpdHktNjBcIj7wn5KsPC9kaXY+XG4gICAgICAgIDxwIGNsYXNzPVwidGV4dC1sZyBmb250LXNlbWlib2xkIHRleHQtYmFzZS1jb250ZW50XCI+V2VsY29tZSB0byAje3Jvb20ubmFtZX08L3A+XG4gICAgICAgIDxwIGNsYXNzPVwidGV4dC1zbVwiPlN0YXJ0IHRoZSBjb252ZXJzYXRpb248L3A+XG4gICAgICA8L2Rpdj5cbiAgICB7OmVsc2V9XG4gICAgICB7I2VhY2ggbWVzc2FnZXMgYXMgbXNnLCBpIChtc2cuaWQpfVxuICAgICAgICB7QGNvbnN0IGlzU2VxdWVuY2UgPSBpc01lc3NhZ2VTZXF1ZW5jZShpKX1cbiAgICAgICAge0Bjb25zdCBpc01pbmUgPSBtc2cudXNlcl9pZC50b1N0cmluZygpID09PSB1c2VySWR9XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQge2lzTWluZSA/ICdjaGF0LWVuZCcgOiAnY2hhdC1zdGFydCd9IHtpc1NlcXVlbmNlID8gJ210LTEnIDogJ210LTQnfVwiIGluOmZseT17eyB5OiAyMCwgZHVyYXRpb246IDMwMCB9fT5cbiAgICAgICAgICB7I2lmICFpc1NlcXVlbmNlfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQtaW1hZ2UgYXZhdGFyXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3LTggaC04IHJvdW5kZWQtZnVsbCBiZy1ncmFkaWVudC10by1iciBmcm9tLXByaW1hcnkgdG8tc2Vjb25kYXJ5IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRleHQtcHJpbWFyeS1jb250ZW50IGZvbnQtYm9sZCB0ZXh0LXhzIHNoYWRvdy1tZFwiPlxuICAgICAgICAgICAgICAgIHsobXNnLnVzZXJuYW1lIHx8IFwiP1wiKS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LWhlYWRlciB0ZXh0LXhzIHRleHQtYmFzZS1jb250ZW50LzYwIG1iLTFcIj5cbiAgICAgICAgICAgICAge21zZy51c2VybmFtZSB8fCBcIlVua25vd25cIn1cbiAgICAgICAgICAgICAgPHRpbWUgY2xhc3M9XCJ0ZXh0LVsxMHB4XSB0ZXh0LWJhc2UtY29udGVudC80MCBtbC0yXCI+e2Zvcm1hdFRpbWUobXNnLmluc2VydGVkX2F0KX08L3RpbWU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7L2lmfVxuXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQtYnViYmxlIHtpc01pbmUgPyAnYmctcHJpbWFyeSB0ZXh0LXByaW1hcnktY29udGVudCcgOiAnYmctYmFzZS0yMDAgdGV4dC1iYXNlLWNvbnRlbnQnfSBtYXgtdy14cyBicmVhay13b3Jkc1wiPlxuICAgICAgICAgICAge21zZy5ib2R5fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIHsvZWFjaH1cbiAgICB7L2lmfVxuICA8L2Rpdj5cblxuICA8IS0tIElucHV0IEFyZWEgLS0+XG4gIDxkaXYgY2xhc3M9XCJpbnB1dC1zZWN0aW9uIGJnLWJhc2UtMTAwIGJvcmRlci10IGJvcmRlci1iYXNlLTMwMCBweC00IHB5LTNcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZmxleCBnYXAtMiBpdGVtcy1lbmQgcm91bmRlZC0zeGwgYmctYmFzZS0yMDAgcHgtNCBweS0yXCI+XG4gICAgICA8dGV4dGFyZWFcbiAgICAgICAgYmluZDp0aGlzPXt0ZXh0YXJlYUVsZW1lbnR9XG4gICAgICAgIGJpbmQ6dmFsdWU9e25ld01lc3NhZ2V9XG4gICAgICAgIG9uOmtleWRvd249eyhlKSA9PiB7XG4gICAgICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgc2VuZE1lc3NhZ2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgICAgb246aW5wdXQ9e2hhbmRsZUlucHV0fVxuICAgICAgICBwbGFjZWhvbGRlcj1cIk1lc3NhZ2UgI3tyb29tLm5hbWV9XCJcbiAgICAgICAgZGlzYWJsZWQ9eyFpc0Nvbm5lY3RlZH1cbiAgICAgICAgYXV0b2NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgcm93cz1cIjFcIlxuICAgICAgICBjbGFzcz1cInRleHRhcmVhIHRleHRhcmVhLWJvcmRlcmVkLTAgZmxleC0xIGJnLWJhc2UtMjAwIHRleHQtYmFzZS1jb250ZW50IHBsYWNlaG9sZGVyLWJhc2UtY29udGVudC81MCBmb2N1czpvdXRsaW5lLW5vbmUgcmVzaXplLW5vbmUgbWF4LWgtWzEyMHB4XSBwLTAgYm9yZGVyLTBcIlxuICAgICAgLz5cbiAgICAgIDxidXR0b25cbiAgICAgICAgb246Y2xpY2s9e3NlbmRNZXNzYWdlfVxuICAgICAgICBkaXNhYmxlZD17IWlzQ29ubmVjdGVkIHx8ICFuZXdNZXNzYWdlLnRyaW0oKX1cbiAgICAgICAgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtIGJ0bi1jaXJjbGUgZmxleC1zaHJpbmstMFwiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJTZW5kIG1lc3NhZ2VcIlxuICAgICAgPlxuICAgICAgICA8c3ZnIHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIxOFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIj5cbiAgICAgICAgICA8bGluZSB4MT1cIjIyXCIgeTE9XCIyXCIgeDI9XCIxMVwiIHkyPVwiMTNcIiAvPlxuICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz1cIjIyIDIgMTUgMjIgMTEgMTMgMiA5IDIyIDJcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIDpnbG9iYWwge1xuICAgIEBpbXBvcnQgdXJsKFwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1JbnRlcjp3Z2h0QDQwMDs1MDA7NjAwOzcwMCZkaXNwbGF5PXN3YXBcIik7XG4gIH1cblxuICAuY2hhdC13cmFwcGVyIHtcbiAgICBmb250LWZhbWlseTogXCJJbnRlclwiLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFwiU2Vnb2UgVUlcIiwgc2Fucy1zZXJpZjtcbiAgfVxuXG4gIC5tZXNzYWdlcy1jb250YWluZXIge1xuICAgIHNjcm9sbC1iZWhhdmlvcjogc21vb3RoO1xuICB9XG5cbiAgLm1lc3NhZ2VzLWNvbnRhaW5lcjo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICAgIHdpZHRoOiA4cHg7XG4gIH1cblxuICAubWVzc2FnZXMtY29udGFpbmVyOjotd2Via2l0LXNjcm9sbGJhci10cmFjayB7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gIH1cblxuICAubWVzc2FnZXMtY29udGFpbmVyOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XG4gICAgQGFwcGx5IGJnLWJhc2UtNzAwIHJvdW5kZWQ7XG4gIH1cblxuICAubWVzc2FnZXMtY29udGFpbmVyOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciB7XG4gICAgQGFwcGx5IGJnLWJhc2UtNjAwO1xuICB9XG48L3N0eWxlPlxuIiwgIi8qKiBAaW1wb3J0IHsgQmx1clBhcmFtcywgQ3Jvc3NmYWRlUGFyYW1zLCBEcmF3UGFyYW1zLCBGYWRlUGFyYW1zLCBGbHlQYXJhbXMsIFNjYWxlUGFyYW1zLCBTbGlkZVBhcmFtcywgVHJhbnNpdGlvbkNvbmZpZyB9IGZyb20gJy4vcHVibGljJyAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3dhcm5pbmdzLmpzJztcblxuLyoqIEBwYXJhbSB7bnVtYmVyfSB4ICovXG5jb25zdCBsaW5lYXIgPSAoeCkgPT4geDtcblxuLyoqIEBwYXJhbSB7bnVtYmVyfSB0ICovXG5mdW5jdGlvbiBjdWJpY19vdXQodCkge1xuXHRjb25zdCBmID0gdCAtIDEuMDtcblx0cmV0dXJuIGYgKiBmICogZiArIDEuMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY3ViaWNfaW5fb3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyA0LjAgKiB0ICogdCAqIHQgOiAwLjUgKiBNYXRoLnBvdygyLjAgKiB0IC0gMi4wLCAzLjApICsgMS4wO1xufVxuXG4vKiogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7W251bWJlciwgc3RyaW5nXX1cbiAqL1xuZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcblx0Y29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcblx0cmV0dXJuIHNwbGl0ID8gW3BhcnNlRmxvYXQoc3BsaXRbMV0pLCBzcGxpdFsyXSB8fCAncHgnXSA6IFsvKiogQHR5cGUge251bWJlcn0gKi8gKHZhbHVlKSwgJ3B4J107XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgYSBgYmx1cmAgZmlsdGVyIGFsb25nc2lkZSBhbiBlbGVtZW50J3Mgb3BhY2l0eS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7Qmx1clBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtUcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmx1cihcblx0bm9kZSxcblx0eyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY19pbl9vdXQsIGFtb3VudCA9IDUsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgZiA9IHN0eWxlLmZpbHRlciA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS5maWx0ZXI7XG5cdGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuXHRjb25zdCBbdmFsdWUsIHVuaXRdID0gc3BsaXRfY3NzX3VuaXQoYW1vdW50KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoX3QsIHUpID0+IGBvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fTsgZmlsdGVyOiAke2Z9IGJsdXIoJHt1ICogdmFsdWV9JHt1bml0fSk7YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgZnJvbSAwIHRvIHRoZSBjdXJyZW50IG9wYWNpdHkgZm9yIGBpbmAgdHJhbnNpdGlvbnMgYW5kIGZyb20gdGhlIGN1cnJlbnQgb3BhY2l0eSB0byAwIGZvciBgb3V0YCB0cmFuc2l0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7RmFkZVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtUcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGxpbmVhciB9ID0ge30pIHtcblx0Y29uc3QgbyA9ICtnZXRDb21wdXRlZFN0eWxlKG5vZGUpLm9wYWNpdHk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKHQpID0+IGBvcGFjaXR5OiAke3QgKiBvfWBcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgeCBhbmQgeSBwb3NpdGlvbnMgYW5kIHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQuIGBpbmAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIHRoZSBwcm92aWRlZCB2YWx1ZXMsIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIHRvIHRoZSBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMuIGBvdXRgIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSB0aGUgZWxlbWVudCdzIGRlZmF1bHQgdmFsdWVzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0ZseVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtUcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx5KFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljX291dCwgeCA9IDAsIHkgPSAwLCBvcGFjaXR5ID0gMCB9ID0ge31cbikge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuXHRjb25zdCBbeF92YWx1ZSwgeF91bml0XSA9IHNwbGl0X2Nzc191bml0KHgpO1xuXHRjb25zdCBbeV92YWx1ZSwgeV91bml0XSA9IHNwbGl0X2Nzc191bml0KHkpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHsoMSAtIHQpICogeF92YWx1ZX0ke3hfdW5pdH0sICR7KDEgLSB0KSAqIHlfdmFsdWV9JHt5X3VuaXR9KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSBvZCAqIHV9YFxuXHR9O1xufVxuXG52YXIgc2xpZGVfd2FybmluZyA9IGZhbHNlO1xuXG4vKipcbiAqIFNsaWRlcyBhbiBlbGVtZW50IGluIGFuZCBvdXQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge1NsaWRlUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGlkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljX291dCwgYXhpcyA9ICd5JyB9ID0ge30pIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG5cdGlmIChERVYgJiYgIXNsaWRlX3dhcm5pbmcgJiYgLyhjb250ZW50c3xpbmxpbmV8dGFibGUpLy50ZXN0KHN0eWxlLmRpc3BsYXkpKSB7XG5cdFx0c2xpZGVfd2FybmluZyA9IHRydWU7XG5cdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiAoc2xpZGVfd2FybmluZyA9IGZhbHNlKSk7XG5cdFx0dy50cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXkoc3R5bGUuZGlzcGxheSk7XG5cdH1cblxuXHRjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IHByaW1hcnlfcHJvcGVydHkgPSBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cdGNvbnN0IHByaW1hcnlfcHJvcGVydHlfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW3ByaW1hcnlfcHJvcGVydHldKTtcblx0Y29uc3Qgc2Vjb25kYXJ5X3Byb3BlcnRpZXMgPSBheGlzID09PSAneScgPyBbJ3RvcCcsICdib3R0b20nXSA6IFsnbGVmdCcsICdyaWdodCddO1xuXHRjb25zdCBjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllcyA9IHNlY29uZGFyeV9wcm9wZXJ0aWVzLm1hcChcblx0XHQoZSkgPT4gLyoqIEB0eXBlIHsnTGVmdCcgfCAnUmlnaHQnIHwgJ1RvcCcgfCAnQm90dG9tJ30gKi8gKGAke2VbMF0udG9VcHBlckNhc2UoKX0ke2Uuc2xpY2UoMSl9YClcblx0KTtcblx0Y29uc3QgcGFkZGluZ19zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYHBhZGRpbmcke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfWBdKTtcblx0Y29uc3QgcGFkZGluZ19lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BwYWRkaW5nJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1gXSk7XG5cdGNvbnN0IG1hcmdpbl9zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYG1hcmdpbiR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19YF0pO1xuXHRjb25zdCBtYXJnaW5fZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgbWFyZ2luJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1gXSk7XG5cdGNvbnN0IGJvcmRlcl93aWR0aF9zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoXG5cdFx0c3R5bGVbYGJvcmRlciR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19V2lkdGhgXVxuXHQpO1xuXHRjb25zdCBib3JkZXJfd2lkdGhfZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChcblx0XHRzdHlsZVtgYm9yZGVyJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1XaWR0aGBdXG5cdCk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKHQpID0+XG5cdFx0XHQnb3ZlcmZsb3c6IGhpZGRlbjsnICtcblx0XHRcdGBvcGFjaXR5OiAke01hdGgubWluKHQgKiAyMCwgMSkgKiBvcGFjaXR5fTtgICtcblx0XHRcdGAke3ByaW1hcnlfcHJvcGVydHl9OiAke3QgKiBwcmltYXJ5X3Byb3BlcnR5X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YHBhZGRpbmctJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX06ICR7dCAqIHBhZGRpbmdfc3RhcnRfdmFsdWV9cHg7YCArXG5cdFx0XHRgcGFkZGluZy0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfTogJHt0ICogcGFkZGluZ19lbmRfdmFsdWV9cHg7YCArXG5cdFx0XHRgbWFyZ2luLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19OiAke3QgKiBtYXJnaW5fc3RhcnRfdmFsdWV9cHg7YCArXG5cdFx0XHRgbWFyZ2luLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19OiAke3QgKiBtYXJnaW5fZW5kX3ZhbHVlfXB4O2AgK1xuXHRcdFx0YGJvcmRlci0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfS13aWR0aDogJHt0ICogYm9yZGVyX3dpZHRoX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YGJvcmRlci0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfS13aWR0aDogJHt0ICogYm9yZGVyX3dpZHRoX2VuZF92YWx1ZX1weDtgICtcblx0XHRcdGBtaW4tJHtwcmltYXJ5X3Byb3BlcnR5fTogMGBcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgb3BhY2l0eSBhbmQgc2NhbGUgb2YgYW4gZWxlbWVudC4gYGluYCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIHByb3ZpZGVkIHZhbHVlcywgcGFzc2VkIGFzIHBhcmFtZXRlcnMsIHRvIGFuIGVsZW1lbnQncyBjdXJyZW50IChkZWZhdWx0KSB2YWx1ZXMuIGBvdXRgIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSBhbiBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U2NhbGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljX291dCwgc3RhcnQgPSAwLCBvcGFjaXR5ID0gMCB9ID0ge31cbikge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdGNvbnN0IHNkID0gMSAtIHN0YXJ0O1xuXHRjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoX3QsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHNjYWxlKCR7MSAtIHNkICogdX0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIG9kICogdX1cblx0XHRgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIHN0cm9rZSBvZiBhbiBTVkcgZWxlbWVudCwgbGlrZSBhIHNuYWtlIGluIGEgdHViZS4gYGluYCB0cmFuc2l0aW9ucyBiZWdpbiB3aXRoIHRoZSBwYXRoIGludmlzaWJsZSBhbmQgZHJhdyB0aGUgcGF0aCB0byB0aGUgc2NyZWVuIG92ZXIgdGltZS4gYG91dGAgdHJhbnNpdGlvbnMgc3RhcnQgaW4gYSB2aXNpYmxlIHN0YXRlIGFuZCBncmFkdWFsbHkgZXJhc2UgdGhlIHBhdGguIGBkcmF3YCBvbmx5IHdvcmtzIHdpdGggZWxlbWVudHMgdGhhdCBoYXZlIGEgYGdldFRvdGFsTGVuZ3RoYCBtZXRob2QsIGxpa2UgYDxwYXRoPmAgYW5kIGA8cG9seWxpbmU+YC5cbiAqXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnQgJiB7IGdldFRvdGFsTGVuZ3RoKCk6IG51bWJlciB9fSBub2RlXG4gKiBAcGFyYW0ge0RyYXdQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXcobm9kZSwgeyBkZWxheSA9IDAsIHNwZWVkLCBkdXJhdGlvbiwgZWFzaW5nID0gY3ViaWNfaW5fb3V0IH0gPSB7fSkge1xuXHRsZXQgbGVuID0gbm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGlmIChzdHlsZS5zdHJva2VMaW5lY2FwICE9PSAnYnV0dCcpIHtcblx0XHRsZW4gKz0gcGFyc2VJbnQoc3R5bGUuc3Ryb2tlV2lkdGgpO1xuXHR9XG5cdGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGR1cmF0aW9uID0gODAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkdXJhdGlvbiA9IGxlbiAvIHNwZWVkO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRkdXJhdGlvbiA9IGR1cmF0aW9uKGxlbik7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoXywgdSkgPT4gYFxuXHRcdFx0c3Ryb2tlLWRhc2hhcnJheTogJHtsZW59O1xuXHRcdFx0c3Ryb2tlLWRhc2hvZmZzZXQ6ICR7dSAqIGxlbn07XG5cdFx0YFxuXHR9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgU1xuICogQHBhcmFtIHtUfSB0YXJcbiAqIEBwYXJhbSB7U30gc3JjXG4gKiBAcmV0dXJucyB7VCAmIFN9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGZvciAoY29uc3QgayBpbiBzcmMpIHRhcltrXSA9IHNyY1trXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VCAmIFN9ICovICh0YXIpO1xufVxuXG4vKipcbiAqIFRoZSBgY3Jvc3NmYWRlYCBmdW5jdGlvbiBjcmVhdGVzIGEgcGFpciBvZiBbdHJhbnNpdGlvbnNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS90cmFuc2l0aW9uKSBjYWxsZWQgYHNlbmRgIGFuZCBgcmVjZWl2ZWAuIFdoZW4gYW4gZWxlbWVudCBpcyAnc2VudCcsIGl0IGxvb2tzIGZvciBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBiZWluZyAncmVjZWl2ZWQnLCBhbmQgZ2VuZXJhdGVzIGEgdHJhbnNpdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIGVsZW1lbnQgdG8gaXRzIGNvdW50ZXJwYXJ0J3MgcG9zaXRpb24gYW5kIGZhZGVzIGl0IG91dC4gV2hlbiBhbiBlbGVtZW50IGlzICdyZWNlaXZlZCcsIHRoZSByZXZlcnNlIGhhcHBlbnMuIElmIHRoZXJlIGlzIG5vIGNvdW50ZXJwYXJ0LCB0aGUgYGZhbGxiYWNrYCB0cmFuc2l0aW9uIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIHtDcm9zc2ZhZGVQYXJhbXMgJiB7XG4gKiBcdGZhbGxiYWNrPzogKG5vZGU6IEVsZW1lbnQsIHBhcmFtczogQ3Jvc3NmYWRlUGFyYW1zLCBpbnRybzogYm9vbGVhbikgPT4gVHJhbnNpdGlvbkNvbmZpZztcbiAqIH19IHBhcmFtc1xuICogQHJldHVybnMge1sobm9kZTogYW55LCBwYXJhbXM6IENyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IFRyYW5zaXRpb25Db25maWcsIChub2RlOiBhbnksIHBhcmFtczogQ3Jvc3NmYWRlUGFyYW1zICYgeyBrZXk6IGFueTsgfSkgPT4gKCkgPT4gVHJhbnNpdGlvbkNvbmZpZ119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zc2ZhZGUoeyBmYWxsYmFjaywgLi4uZGVmYXVsdHMgfSkge1xuXHQvKiogQHR5cGUge01hcDxhbnksIEVsZW1lbnQ+fSAqL1xuXHRjb25zdCB0b19yZWNlaXZlID0gbmV3IE1hcCgpO1xuXHQvKiogQHR5cGUge01hcDxhbnksIEVsZW1lbnQ+fSAqL1xuXHRjb25zdCB0b19zZW5kID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21fbm9kZVxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcblx0ICogQHBhcmFtIHtDcm9zc2ZhZGVQYXJhbXN9IHBhcmFtc1xuXHQgKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cblx0ICovXG5cdGZ1bmN0aW9uIGNyb3NzZmFkZShmcm9tX25vZGUsIG5vZGUsIHBhcmFtcykge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gLyoqIEBwYXJhbSB7bnVtYmVyfSBkICovIChkKSA9PiBNYXRoLnNxcnQoZCkgKiAzMCxcblx0XHRcdGVhc2luZyA9IGN1YmljX291dFxuXHRcdH0gPSBhc3NpZ24oYXNzaWduKHt9LCBkZWZhdWx0cyksIHBhcmFtcyk7XG5cdFx0Y29uc3QgZnJvbSA9IGZyb21fbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Y29uc3QgZHggPSBmcm9tLmxlZnQgLSB0by5sZWZ0O1xuXHRcdGNvbnN0IGR5ID0gZnJvbS50b3AgLSB0by50b3A7XG5cdFx0Y29uc3QgZHcgPSBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG5cdFx0Y29uc3QgZGggPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcblx0XHRjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdFx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0XHRjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlbGF5LFxuXHRcdFx0ZHVyYXRpb246IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGR1cmF0aW9uKGQpIDogZHVyYXRpb24sXG5cdFx0XHRlYXNpbmcsXG5cdFx0XHRjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHQgICBvcGFjaXR5OiAke3QgKiBvcGFjaXR5fTtcblx0XHRcdCAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuXHRcdFx0ICAgdHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dSAqIGR4fXB4LCR7dSAqIGR5fXB4KSBzY2FsZSgke3QgKyAoMSAtIHQpICogZHd9LCAke1xuXHRcdFx0XHRcdFx0dCArICgxIC0gdCkgKiBkaFxuXHRcdFx0XHRcdH0pO1xuXHRcdCAgIGBcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TWFwPGFueSwgRWxlbWVudD59IGl0ZW1zXG5cdCAqIEBwYXJhbSB7TWFwPGFueSwgRWxlbWVudD59IGNvdW50ZXJwYXJ0c1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGludHJvXG5cdCAqIEByZXR1cm5zIHsobm9kZTogYW55LCBwYXJhbXM6IENyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IFRyYW5zaXRpb25Db25maWd9XG5cdCAqL1xuXHRmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGltcHJvdmUgdHlwaW5ncyAoYXJlIHRoZSBwdWJsaWMgdHlwZXMgd3Jvbmc/KVxuXHRcdHJldHVybiAobm9kZSwgcGFyYW1zKSA9PiB7XG5cdFx0XHRpdGVtcy5zZXQocGFyYW1zLmtleSwgbm9kZSk7XG5cdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRpZiAoY291bnRlcnBhcnRzLmhhcyhwYXJhbXMua2V5KSkge1xuXHRcdFx0XHRcdGNvbnN0IG90aGVyX25vZGUgPSBjb3VudGVycGFydHMuZ2V0KHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRcdGNvdW50ZXJwYXJ0cy5kZWxldGUocGFyYW1zLmtleSk7XG5cdFx0XHRcdFx0cmV0dXJuIGNyb3NzZmFkZSgvKiogQHR5cGUge0VsZW1lbnR9ICovIChvdGhlcl9ub2RlKSwgbm9kZSwgcGFyYW1zKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGUgbm9kZSBpcyBkaXNhcHBlYXJpbmcgYWx0b2dldGhlclxuXHRcdFx0XHQvLyAoaS5lLiB3YXNuJ3QgY2xhaW1lZCBieSB0aGUgb3RoZXIgbGlzdClcblx0XHRcdFx0Ly8gdGhlbiB3ZSBuZWVkIHRvIHN1cHBseSBhbiBvdXRyb1xuXHRcdFx0XHRpdGVtcy5kZWxldGUocGFyYW1zLmtleSk7XG5cdFx0XHRcdHJldHVybiBmYWxsYmFjayAmJiBmYWxsYmFjayhub2RlLCBwYXJhbXMsIGludHJvKTtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW3RyYW5zaXRpb24odG9fc2VuZCwgdG9fcmVjZWl2ZSwgZmFsc2UpLCB0cmFuc2l0aW9uKHRvX3JlY2VpdmUsIHRvX3NlbmQsIHRydWUpXTtcbn1cbiIsICI8c2NyaXB0PlxuICBsZXQgeyBkZWxheSA9IDAgfSA9ICRwcm9wcygpXG48L3NjcmlwdD5cblxuPGRpdlxuICBjbGFzcz1cImFic29sdXRlIGhpZGRlbiBsZzpibG9jayB0b3AtMS80IGxlZnQtMTAgeGw6bGVmdC0zMiB3LTY0IGJnLWJhc2UtMjAwLzkwIGJhY2tkcm9wLWJsdXIteGwgYm9yZGVyIGJvcmRlci1iYXNlLTMwMCBzaGFkb3ctWzBfMjBweF80MHB4Xy0xNXB4X3JnYmEoMCwwLDAsMC4xKV0gcm91bmRlZC0yeGwgcC00IGFuaW1hdGUtZmxvYXQgcm90YXRlLVstM2RlZ11cIlxuICBzdHlsZT1cImFuaW1hdGlvbi1kZWxheToge2RlbGF5fXNcIlxuPlxuICA8ZGl2IGNsYXNzPVwiZm9udC1tb25vIHRleHQtWzEwcHhdIHRleHQtYmFzZS1jb250ZW50LzcwIGxlYWRpbmctcmVsYXhlZFwiPlxuICAgIDxkaXYgY2xhc3M9XCJmbGV4IGdhcC0yIG1iLTIgYm9yZGVyLWIgYm9yZGVyLWJhc2UtMzAwIHBiLTJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ3LTIgaC0yIHJvdW5kZWQtZnVsbCBiZy1yZWQtNTAwXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwidy0yIGgtMiByb3VuZGVkLWZ1bGwgYmcteWVsbG93LTUwMFwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInctMiBoLTIgcm91bmRlZC1mdWxsIGJnLWdyZWVuLTUwMFwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWJsdWUtNDAwXCI+XG4gICAgICBjb25zdCA8c3BhbiBjbGFzcz1cInRleHQteWVsbG93LTIwMFwiPmF1dG9tYXRlPC9zcGFuPiA9IDxzcGFuIGNsYXNzPVwidGV4dC1wdXJwbGUtNDAwXCI+YXN5bmM8L3NwYW4+ICgpID0+IHsneyd9XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInBsLTRcIj5cbiAgICAgIGF3YWl0IDxzcGFuIGNsYXNzPVwidGV4dC1ncmVlbi0zMDBcIj5uOG48L3NwYW4+LnRyaWdnZXIoKTtcbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicGwtNFwiPlxuICAgICAgcmV0dXJuIDxzcGFuIGNsYXNzPVwidGV4dC1vcmFuZ2UtMzAwXCI+XCJGcmVlZG9tXCI8L3NwYW4+O1xuICAgIDwvZGl2PlxuICAgIDxkaXY+eyd9J308L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbiIsICI8c2NyaXB0PlxuICBsZXQgeyBjb3VudCA9IDAsIGxpdmUgfSA9ICRwcm9wcygpXG5cbiAgZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICAgIGxpdmUucHVzaEV2ZW50KCdpbmNyZW1lbnQnLCB7fSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY3JlbWVudCgpIHtcbiAgICBsaXZlLnB1c2hFdmVudCgnZGVjcmVtZW50Jywge30pXG4gIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZ2FwLTQgcC04XCI+XG4gIDxoMiBjbGFzcz1cInRleHQtM3hsIGZvbnQtYm9sZFwiPkNvdW50ZXI6IHtjb3VudH08L2gyPlxuXG4gIDxkaXYgY2xhc3M9XCJmbGV4IGdhcC0yXCI+XG4gICAgPGJ1dHRvblxuICAgICAgb25jbGljaz17ZGVjcmVtZW50fVxuICAgICAgY2xhc3M9XCJidG4gYnRuLWVycm9yXCJcbiAgICA+XG4gICAgICBEZWNyZW1lbnRcbiAgICA8L2J1dHRvbj5cblxuICAgIDxidXR0b25cbiAgICAgIG9uY2xpY2s9e2luY3JlbWVudH1cbiAgICAgIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCJcbiAgICA+XG4gICAgICBJbmNyZW1lbnRcbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Rpdj5cbiIsICI8c2NyaXB0PlxuICBpbXBvcnQgeyBMYXlvdXREYXNoYm9hcmQsIEJvb2tPcGVuLCBCb29rbWFyaywgVXNlciwgU2V0dGluZ3MsIExvZ091dCwgTG9hZGVyMiB9IGZyb20gJ2x1Y2lkZS1zdmVsdGUnXG5cbiAgbGV0IHsgY3VycmVudFVzZXIgfSA9ICRwcm9wcygpXG5cbiAgbGV0IGlzTG9nZ2luZ091dCA9ICRzdGF0ZShmYWxzZSlcblxuICBmdW5jdGlvbiBnZXRVc2VySW5pdGlhbHMoKSB7XG4gICAgaWYgKGN1cnJlbnRVc2VyLm5hbWUpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VXNlci5uYW1lXG4gICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgIC5tYXAobiA9PiBuLmNoYXJBdCgwKSlcbiAgICAgICAgLmpvaW4oJycpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIC5zbGljZSgwLCAyKVxuICAgIH1cbiAgICBpZiAoY3VycmVudFVzZXIuZW1haWwpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VXNlci5lbWFpbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKVxuICAgIH1cbiAgICByZXR1cm4gJ1UnXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2dvdXQoKSB7XG4gICAgaWYgKGlzTG9nZ2luZ091dCkgcmV0dXJuXG5cbiAgICBpc0xvZ2dpbmdPdXQgPSB0cnVlXG5cbiAgICAvLyBDcmVhdGUgYSBmb3JtIGFuZCBzdWJtaXQgaXQgdG8gcGVyZm9ybSBERUxFVEUgcmVxdWVzdFxuICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJylcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJ1xuICAgIGZvcm0uYWN0aW9uID0gJy9hdXRoL2xvZ291dCdcblxuICAgIGNvbnN0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImNzcmYtdG9rZW5cIl0nKT8uY29udGVudFxuICAgIGlmIChjc3JmVG9rZW4pIHtcbiAgICAgIGNvbnN0IGNzcmZJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgIGNzcmZJbnB1dC50eXBlID0gJ2hpZGRlbidcbiAgICAgIGNzcmZJbnB1dC5uYW1lID0gJ19jc3JmX3Rva2VuJ1xuICAgICAgY3NyZklucHV0LnZhbHVlID0gY3NyZlRva2VuXG4gICAgICBmb3JtLmFwcGVuZENoaWxkKGNzcmZJbnB1dClcbiAgICB9XG5cbiAgICBjb25zdCBtZXRob2RJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICBtZXRob2RJbnB1dC50eXBlID0gJ2hpZGRlbidcbiAgICBtZXRob2RJbnB1dC5uYW1lID0gJ19tZXRob2QnXG4gICAgbWV0aG9kSW5wdXQudmFsdWUgPSAnREVMRVRFJ1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQobWV0aG9kSW5wdXQpXG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pXG4gICAgZm9ybS5zdWJtaXQoKVxuICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImRyb3Bkb3duIGRyb3Bkb3duLWVuZFwiPlxuICA8YnV0dG9uXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICBjbGFzcz1cImJ0biBidG4tZ2hvc3QgYnRuLWNpcmNsZSBhdmF0YXJcIlxuICAgIGFyaWEtbGFiZWw9XCJ7Y3VycmVudFVzZXIubmFtZSB8fCBjdXJyZW50VXNlci5lbWFpbH0gYWNjb3VudCBtZW51XCJcbiAgPlxuICAgIDxkaXYgY2xhc3M9XCJ3LTEwIHJvdW5kZWQtZnVsbFwiPlxuICAgICAgeyNpZiBjdXJyZW50VXNlci5hdmF0YXJVcmx9XG4gICAgICAgIDxpbWdcbiAgICAgICAgICBzcmM9e2N1cnJlbnRVc2VyLmF2YXRhclVybH1cbiAgICAgICAgICBhbHQ9e2N1cnJlbnRVc2VyLm5hbWUgfHwgY3VycmVudFVzZXIuZW1haWx9XG4gICAgICAgIC8+XG4gICAgICB7OmVsc2V9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhdmF0YXIgcGxhY2Vob2xkZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiYmctcHJpbWFyeSB0ZXh0LXByaW1hcnktY29udGVudCB3LTEwIHJvdW5kZWQtZnVsbFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LXNtXCI+e2dldFVzZXJJbml0aWFscygpfTwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2lmfVxuICAgIDwvZGl2PlxuICA8L2J1dHRvbj5cblxuICA8dWwgdGFiaW5kZXg9XCIwXCIgY2xhc3M9XCJtZW51IGRyb3Bkb3duLWNvbnRlbnQgYmctYmFzZS0xMDAgcm91bmRlZC1ib3ggei1bMV0gdy01MiBwLTIgc2hhZG93IG10LTNcIj5cbiAgICA8bGkgY2xhc3M9XCJtZW51LXRpdGxlXCI+XG4gICAgICA8c3Bhbj57Y3VycmVudFVzZXIubmFtZSB8fCAnVXNlcid9PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LXhzIG9wYWNpdHktNTBcIj5Ae2N1cnJlbnRVc2VyLnVzZXJuYW1lIHx8IGN1cnJlbnRVc2VyLmVtYWlsPy5zcGxpdCgnQCcpWzBdIHx8ICd1c2VyJ308L3NwYW4+XG4gICAgPC9saT5cbiAgICA8bGk+PGRpdiBjbGFzcz1cImRpdmlkZXIgbXktMFwiPjwvZGl2PjwvbGk+XG4gICAgPGxpPlxuICAgICAgPGEgaHJlZj1cIi9cIj5cbiAgICAgICAgPExheW91dERhc2hib2FyZCBjbGFzcz1cInctNCBoLTRcIiAvPlxuICAgICAgICBEYXNoYm9hcmRcbiAgICAgIDwvYT5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgIDxhIGhyZWY9XCIvbGVzc29uc1wiPlxuICAgICAgICA8Qm9va09wZW4gY2xhc3M9XCJ3LTQgaC00XCIgLz5cbiAgICAgICAgQ291cnNlc1xuICAgICAgPC9hPlxuICAgIDwvbGk+XG4gICAgPGxpPlxuICAgICAgPGEgaHJlZj1cIi9yb21hbm92LXByb21wdHNcIj5cbiAgICAgICAgPEJvb2ttYXJrIGNsYXNzPVwidy00IGgtNFwiIC8+XG4gICAgICAgIFNhdmVkXG4gICAgICA8L2E+XG4gICAgPC9saT5cbiAgICA8bGk+XG4gICAgICA8YSBocmVmPVwiL3Byb2ZpbGVcIj5cbiAgICAgICAgPFVzZXIgY2xhc3M9XCJ3LTQgaC00XCIgLz5cbiAgICAgICAgUHJvZmlsZVxuICAgICAgPC9hPlxuICAgIDwvbGk+XG4gICAgPGxpPlxuICAgICAgPGEgaHJlZj1cIi9zZXR0aW5nc1wiPlxuICAgICAgICA8U2V0dGluZ3MgY2xhc3M9XCJ3LTQgaC00XCIgLz5cbiAgICAgICAgU2V0dGluZ3NcbiAgICAgIDwvYT5cbiAgICA8L2xpPlxuICAgIDxsaT48ZGl2IGNsYXNzPVwiZGl2aWRlciBteS0wXCI+PC9kaXY+PC9saT5cbiAgICA8bGk+XG4gICAgICA8YnV0dG9uIG9uY2xpY2s9e2hhbmRsZUxvZ291dH0gZGlzYWJsZWQ9e2lzTG9nZ2luZ091dH0+XG4gICAgICAgIHsjaWYgaXNMb2dnaW5nT3V0fVxuICAgICAgICAgIDxMb2FkZXIyIGNsYXNzPVwidy00IGgtNCBhbmltYXRlLXNwaW5cIiAvPlxuICAgICAgICAgIExvZ2dpbmcgb3V0Li4uXG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICA8TG9nT3V0IGNsYXNzPVwidy00IGgtNFwiIC8+XG4gICAgICAgICAgTG9nIG91dFxuICAgICAgICB7L2lmfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9saT5cbiAgPC91bD5cbjwvZGl2PlxuIiwgIjxzY3JpcHQ+XG4gIGltcG9ydCBBdXRoTW9kYWwgZnJvbSAnLi9BdXRoTW9kYWwuc3ZlbHRlJztcbiAgaW1wb3J0IFVzZXJNZW51IGZyb20gJy4vVXNlck1lbnUuc3ZlbHRlJztcblxuICBsZXQgeyBjdXJyZW50UGFnZSA9ICcnLCBjdXJyZW50VXNlciA9IG51bGwgfSA9ICRwcm9wcygpXG5cbiAgbGV0IGlzU2Nyb2xsZWQgPSAkc3RhdGUoZmFsc2UpXG4gIGxldCBpc01lbnVPcGVuID0gJHN0YXRlKGZhbHNlKVxuICBsZXQgc2hvd0F1dGhNb2RhbCA9ICRzdGF0ZShmYWxzZSlcbiAgbGV0IGRyb3Bkb3duUmVmXG5cbiAgZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCkge1xuICAgIGlzU2Nyb2xsZWQgPSB3aW5kb3cuc2Nyb2xsWSA+IDIwXG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xuICAgIGlzTWVudU9wZW4gPSAhaXNNZW51T3BlblxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VNZW51KCkge1xuICAgIGlzTWVudU9wZW4gPSBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gb3BlbkF1dGhNb2RhbCgpIHtcbiAgICBzaG93QXV0aE1vZGFsID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgaWYgKGRyb3Bkb3duUmVmICYmICFkcm9wZG93blJlZi5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICBjbG9zZU1lbnUoKVxuICAgIH1cbiAgfVxuXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIC8vIHJ1biBvbmNlIG9uIG1vdW50OyByZS1ydW4gaWYgaGFuZGxlcnMgY2hhbmdlICh0aGV5IGRvbid0KVxuICAgIGhhbmRsZVNjcm9sbCgpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrT3V0c2lkZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbClcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2tPdXRzaWRlKVxuICAgIH1cbiAgfSlcbjwvc2NyaXB0PlxuXG48ZGl2XG4gIGNsYXNzPXtgbmF2YmFyIGZpeGVkIHRvcC0wIGxlZnQtMCByaWdodC0wIHotNTAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwICR7XG4gICAgaXNTY3JvbGxlZCA/ICdiZy1iYXNlLTEwMC84MCBiYWNrZHJvcC1ibHVyLW1kIGJvcmRlci1iIGJvcmRlci1iYXNlLTMwMCcgOiAnYmctdHJhbnNwYXJlbnQnXG4gIH1gfVxuPlxuICA8ZGl2IGNsYXNzPVwibmF2YmFyLXN0YXJ0XCI+XG4gICAgPCEtLSBNb2JpbGUgRHJvcGRvd24gLS0+XG4gICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duIGxnOmhpZGRlblwiIGNsYXNzOmRyb3Bkb3duLW9wZW49e2lzTWVudU9wZW59IGJpbmQ6dGhpcz17ZHJvcGRvd25SZWZ9PlxuICAgICAgPGJ1dHRvblxuICAgICAgICBvbmNsaWNrPXt0b2dnbGVNZW51fVxuICAgICAgICBhcmlhLWxhYmVsPVwiVG9nZ2xlIG5hdmlnYXRpb24gbWVudVwiXG4gICAgICAgIGFyaWEtZXhwYW5kZWQ9e2lzTWVudU9wZW59XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJtb2JpbGUtbmF2XCJcbiAgICAgICAgY2xhc3M9XCJidG4gYnRuLWdob3N0XCJcbiAgICAgID5cbiAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJoLTUgdy01XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNCA2aDE2TTQgMTJoMTZNNCAxOGgxNlwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgICB7I2lmIGlzTWVudU9wZW59XG4gICAgICAgIDx1bCBpZD1cIm1vYmlsZS1uYXZcIiBjbGFzcz1cIm1lbnUgbWVudS1zbSBkcm9wZG93bi1jb250ZW50IGJnLWJhc2UtMTAwIHJvdW5kZWQtYm94IHotWzFdIG10LTMgdy01MiBwLTIgc2hhZG93XCI+XG4gICAgICAgICAgPGxpPjxhIGhyZWY9XCIvXCIgY2xhc3M6YWN0aXZlPXtjdXJyZW50UGFnZSA9PT0gJ2hvbWUnfSBvbmNsaWNrPXtjbG9zZU1lbnV9PkhvbWU8L2E+PC9saT5cbiAgICAgICAgICA8bGk+PGEgaHJlZj1cIi9ibG9nXCIgY2xhc3M6YWN0aXZlPXtjdXJyZW50UGFnZSA9PT0gJ2Jsb2cnfSBvbmNsaWNrPXtjbG9zZU1lbnV9PkJsb2c8L2E+PC9saT5cbiAgICAgICAgICA8bGk+PGEgaHJlZj1cIi9yb21hbm92LXByb21wdHM/Y2F0ZWdvcnk9Y29kaW5nXCIgb25jbGljaz17Y2xvc2VNZW51fT5Db2Rpbmc8L2E+PC9saT5cbiAgICAgICAgICA8bGk+PGEgaHJlZj1cIi9yb21hbm92LXByb21wdHM/Y2F0ZWdvcnk9YWlcIiBvbmNsaWNrPXtjbG9zZU1lbnV9PkFJPC9hPjwvbGk+XG4gICAgICAgICAgPGxpPjxhIGhyZWY9XCIvcm9tYW5vdi1wcm9tcHRzP2NhdGVnb3J5PW44blwiIG9uY2xpY2s9e2Nsb3NlTWVudX0+bjhuPC9hPjwvbGk+XG4gICAgICAgICAgPGxpPjxhIGhyZWY9XCIvcm9tYW5vdi1wcm9tcHRzP2NhdGVnb3J5PXRvb2xzXCIgb25jbGljaz17Y2xvc2VNZW51fT5Ub29sczwvYT48L2xpPlxuICAgICAgICAgIDxsaT48YSBocmVmPVwiL3JvbWFub3YtcHJvbXB0c1wiIGNsYXNzOmFjdGl2ZT17Y3VycmVudFBhZ2UgPT09ICdyZWZlcmVuY2VzJ30gb25jbGljaz17Y2xvc2VNZW51fT5Qcm9tcHRzPC9hPjwvbGk+XG4gICAgICAgIDwvdWw+XG4gICAgICB7L2lmfVxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBMb2dvIC0tPlxuICAgIDxhIGhyZWY9XCIvXCIgY2xhc3M9XCJidG4gYnRuLWdob3N0IHRleHQteGwgZm9udC1zZW1pYm9sZCB0cmFja2luZy10aWdodFwiPlxuICAgICAgVXJpZWxNPHNwYW4gY2xhc3M9XCJ0ZXh0LWJhc2UtY29udGVudC81MFwiPi5kZXY8L3NwYW4+XG4gICAgPC9hPlxuICA8L2Rpdj5cblxuICA8IS0tIERlc2t0b3AgTmF2aWdhdGlvbiAtIENlbnRlciAtLT5cbiAgPGRpdiBjbGFzcz1cIm5hdmJhci1jZW50ZXIgaGlkZGVuIGxnOmZsZXhcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLThcIj5cbiAgICAgIDxhXG4gICAgICAgIGhyZWY9XCIvXCJcbiAgICAgICAgY2xhc3M9e2Bmb250LW1lZGl1bSB0cmFuc2l0aW9uLWNvbG9ycyAke2N1cnJlbnRQYWdlID09PSAnaG9tZScgPyAndGV4dC1wcmltYXJ5IGZvbnQtYm9sZCcgOiAndGV4dC1iYXNlLWNvbnRlbnQgaG92ZXI6dGV4dC1wcmltYXJ5J31gfVxuICAgICAgPlxuICAgICAgICBIb21lXG4gICAgICA8L2E+XG4gICAgICA8YVxuICAgICAgICBocmVmPVwiL2Jsb2dcIlxuICAgICAgICBjbGFzcz17YGZvbnQtbWVkaXVtIHRyYW5zaXRpb24tY29sb3JzICR7Y3VycmVudFBhZ2UgPT09ICdibG9nJyA/ICd0ZXh0LXByaW1hcnkgZm9udC1ib2xkJyA6ICd0ZXh0LWJhc2UtY29udGVudCBob3Zlcjp0ZXh0LXByaW1hcnknfWB9XG4gICAgICA+XG4gICAgICAgIEJsb2dcbiAgICAgIDwvYT5cbiAgICAgIDxhXG4gICAgICAgIGhyZWY9XCIvcm9tYW5vdi1wcm9tcHRzP2NhdGVnb3J5PWNvZGluZ1wiXG4gICAgICAgIGNsYXNzPVwiZm9udC1tZWRpdW0gdGV4dC1iYXNlLWNvbnRlbnQgaG92ZXI6dGV4dC1wcmltYXJ5IHRyYW5zaXRpb24tY29sb3JzXCJcbiAgICAgID5cbiAgICAgICAgQ29kaW5nXG4gICAgICA8L2E+XG4gICAgICA8YVxuICAgICAgICBocmVmPVwiL3JvbWFub3YtcHJvbXB0cz9jYXRlZ29yeT1haVwiXG4gICAgICAgIGNsYXNzPVwiZm9udC1tZWRpdW0gdGV4dC1iYXNlLWNvbnRlbnQgaG92ZXI6dGV4dC1wcmltYXJ5IHRyYW5zaXRpb24tY29sb3JzXCJcbiAgICAgID5cbiAgICAgICAgQUlcbiAgICAgIDwvYT5cbiAgICAgIDxhXG4gICAgICAgIGhyZWY9XCIvcm9tYW5vdi1wcm9tcHRzP2NhdGVnb3J5PW44blwiXG4gICAgICAgIGNsYXNzPVwiZm9udC1tZWRpdW0gdGV4dC1iYXNlLWNvbnRlbnQgaG92ZXI6dGV4dC1wcmltYXJ5IHRyYW5zaXRpb24tY29sb3JzXCJcbiAgICAgID5cbiAgICAgICAgbjhuXG4gICAgICA8L2E+XG4gICAgICA8YVxuICAgICAgICBocmVmPVwiL3JvbWFub3YtcHJvbXB0cz9jYXRlZ29yeT10b29sc1wiXG4gICAgICAgIGNsYXNzPVwiZm9udC1tZWRpdW0gdGV4dC1iYXNlLWNvbnRlbnQgaG92ZXI6dGV4dC1wcmltYXJ5IHRyYW5zaXRpb24tY29sb3JzXCJcbiAgICAgID5cbiAgICAgICAgVG9vbHNcbiAgICAgIDwvYT5cbiAgICAgIDxhXG4gICAgICAgIGhyZWY9XCIvcm9tYW5vdi1wcm9tcHRzXCJcbiAgICAgICAgY2xhc3M9e2Bmb250LW1lZGl1bSB0cmFuc2l0aW9uLWNvbG9ycyAke2N1cnJlbnRQYWdlID09PSAncmVmZXJlbmNlcycgPyAndGV4dC1wcmltYXJ5IGZvbnQtYm9sZCcgOiAndGV4dC1iYXNlLWNvbnRlbnQgaG92ZXI6dGV4dC1wcmltYXJ5J31gfVxuICAgICAgPlxuICAgICAgICBQcm9tcHRzXG4gICAgICA8L2E+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDwhLS0gQ1RBIEJ1dHRvbiAtIFJpZ2h0IC0tPlxuICA8ZGl2IGNsYXNzPVwibmF2YmFyLWVuZCBnYXAtMlwiPlxuICAgIHsjaWYgY3VycmVudFVzZXJ9XG4gICAgICA8VXNlck1lbnUge2N1cnJlbnRVc2VyfSAvPlxuICAgIHs6ZWxzZX1cbiAgICAgIDxidXR0b25cbiAgICAgICAgb25jbGljaz17b3BlbkF1dGhNb2RhbH1cbiAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1wcmltYXJ5IHJvdW5kZWQtZnVsbCBweC02XCJcbiAgICAgID5cbiAgICAgICAgU2lnbiBJblxuICAgICAgPC9idXR0b24+XG4gICAgey9pZn1cbiAgPC9kaXY+XG48L2Rpdj5cblxuPEF1dGhNb2RhbCBiaW5kOmlzT3Blbj17c2hvd0F1dGhNb2RhbH0gLz5cbiIsICI8c2NyaXB0PlxuICBsZXQgeyBhY3RpdmVGaWx0ZXIgPSAnYWxsJywgY2F0ZWdvcmllcyA9IFtdLCBsaXZlIH0gPSAkcHJvcHMoKVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEZpbHRlcihmaWx0ZXIpIHtcbiAgICBsaXZlLnB1c2hFdmVudCgnZmlsdGVyX2NoYW5nZWQnLCB7IGNhdGVnb3J5OiBmaWx0ZXIgfSlcbiAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJiZy1iYXNlLTEwMCBib3JkZXItYiBib3JkZXItYmFzZS0zMDBcIj5cbiAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBteC1hdXRvIHB4LTRcIj5cbiAgICA8ZGl2IGNsYXNzPVwidGFicyB0YWJzLWJvcmRlcmVkIG92ZXJmbG93LXgtYXV0byBzY3JvbGxiYXItaGlkZVwiIGFyaWEtbGFiZWw9XCJSZWZlcmVuY2UgZmlsdGVyc1wiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBvbmNsaWNrPXsoKSA9PiBzZWxlY3RGaWx0ZXIoJ2FsbCcpfVxuICAgICAgICByb2xlPVwidGFiXCJcbiAgICAgICAgYXJpYS1zZWxlY3RlZD17YWN0aXZlRmlsdGVyID09PSAnYWxsJ31cbiAgICAgICAgY2xhc3M9e2B0YWIgdGFiLXNtIHNtOnRhYi1tZCB3aGl0ZXNwYWNlLW5vd3JhcCB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgaG92ZXI6dGV4dC1wcmltYXJ5ICR7YWN0aXZlRmlsdGVyID09PSAnYWxsJyA/ICd0YWItYWN0aXZlJyA6ICcnfWB9XG4gICAgICA+XG4gICAgICAgIEFsbFxuICAgICAgPC9idXR0b24+XG4gICAgICB7I2VhY2ggY2F0ZWdvcmllcyBhcyBjYXRlZ29yeX1cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uY2xpY2s9eygpID0+IHNlbGVjdEZpbHRlcihjYXRlZ29yeSl9XG4gICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgYXJpYS1zZWxlY3RlZD17YWN0aXZlRmlsdGVyID09PSBjYXRlZ29yeX1cbiAgICAgICAgICBjbGFzcz17YHRhYiB0YWItc20gc206dGFiLW1kIHdoaXRlc3BhY2Utbm93cmFwIGNhcGl0YWxpemUgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGhvdmVyOnRleHQtcHJpbWFyeSAke2FjdGl2ZUZpbHRlciA9PT0gY2F0ZWdvcnkgPyAndGFiLWFjdGl2ZScgOiAnJ31gfVxuICAgICAgICA+XG4gICAgICAgICAge2NhdGVnb3J5fVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIFxuPC9kaXY+XG4iLCAiPHNjcmlwdD5cbiAgY29uc3QgdGhlbWVzID0gW1xuICAgIHsgdmFsdWU6ICdsaWdodCcsIGxhYmVsOiAnTGlnaHQnLCBpY29uOiAn4piA77iPJyB9LFxuICAgIHsgdmFsdWU6ICdkYXJrJywgbGFiZWw6ICdEYXJrJywgaWNvbjogJ/CfjJknIH0sXG4gICAgeyB2YWx1ZTogJ2RyYWN1bGEnLCBsYWJlbDogJ0RyYWN1bGEnLCBpY29uOiAn8J+nmycgfSxcbiAgICB7IHZhbHVlOiAnc3ludGh3YXZlJywgbGFiZWw6ICdTeW50aHdhdmUnLCBpY29uOiAn8J+MhicgfSxcbiAgICB7IHZhbHVlOiAnYnVzaW5lc3MnLCBsYWJlbDogJ0J1c2luZXNzJywgaWNvbjogJ/CfkrwnIH0sXG4gICAgeyB2YWx1ZTogJ2RpbScsIGxhYmVsOiAnRGltJywgaWNvbjogJ/CfjJEnIH1cbiAgXVxuXG4gIGxldCBjdXJyZW50VGhlbWUgPSAkc3RhdGUoJ2RhcmsnKVxuICBsZXQgaXNPcGVuID0gJHN0YXRlKGZhbHNlKVxuXG4gIGZ1bmN0aW9uIGFwcGx5VGhlbWUodGhlbWUpIHtcbiAgICBjdXJyZW50VGhlbWUgPSB0aGVtZVxuICAgIGlmICh0aGVtZSA9PT0gJ3N5c3RlbScpIHtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKVxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3BoeDp0aGVtZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnLCB0aGVtZSlcbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBzdG9yYWdlIGtleSBhcyBQaG9lbml4ICsgb3RoZXIgdG9nZ2xlc1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BoeDp0aGVtZScsIHRoZW1lKVxuICAgIH1cbiAgICAvLyBOb3RpZnkgbGlzdGVuZXJzIChlLmcuLCBQaG9lbml4IGhlYWQgc2NyaXB0KVxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncGh4OnNldC10aGVtZScsIHsgZGV0YWlsOiB7IHRoZW1lIH0gfSkpXG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RUaGVtZSh0aGVtZSkge1xuICAgIGFwcGx5VGhlbWUodGhlbWUpXG4gICAgaXNPcGVuID0gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZURyb3Bkb3duKCkge1xuICAgIGlzT3BlbiA9ICFpc09wZW5cbiAgfVxuXG4gIC8vIENsb3NlIGRyb3Bkb3duIHdoZW4gY2xpY2tpbmcgb3V0c2lkZVxuICBmdW5jdGlvbiBoYW5kbGVDbGlja091dHNpZGUoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldC5jbG9zZXN0KCcudGhlbWUtc2VsZWN0b3InKSkge1xuICAgICAgaXNPcGVuID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAkZWZmZWN0KCgpID0+IHtcbiAgICAvLyBTeW5jIGZyb20gcGFnZS9oZWFkIGluaXRpYWxpemF0aW9uXG4gICAgY29uc3Qgc2F2ZWRUaGVtZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwaHg6dGhlbWUnKSB8fCAnc3lzdGVtJ1xuICAgIGlmIChzYXZlZFRoZW1lID09PSAnc3lzdGVtJykge1xuICAgICAgY3VycmVudFRoZW1lID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10aGVtZScpIHx8ICdsaWdodCdcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFRoZW1lID0gc2F2ZWRUaGVtZVxuICAgIH1cblxuICAgIC8vIEtlZXAgaW4gc3luYyB3aXRoIG90aGVyIGNvbnRyb2xzIChMYXlvdXRzLnRoZW1lX3RvZ2dsZSwgb3RoZXIgdGFicylcbiAgICBjb25zdCBzdG9yYWdlSGFuZGxlciA9IChlKSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09ICdwaHg6dGhlbWUnKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBlLm5ld1ZhbHVlIHx8ICdzeXN0ZW0nXG4gICAgICAgIGN1cnJlbnRUaGVtZSA9IG5leHQgPT09ICdzeXN0ZW0nID8gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKSB8fCAnbGlnaHQnKSA6IG5leHRcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGhlbWVFdmVudEhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgbmV4dCA9IGUuZGV0YWlsPy50aGVtZSA/PyBlLnRhcmdldD8uZGF0YXNldD8ucGh4VGhlbWUgPz8gJ3N5c3RlbSdcbiAgICAgIGN1cnJlbnRUaGVtZSA9IG5leHQgPT09ICdzeXN0ZW0nID8gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKSB8fCAnbGlnaHQnKSA6IG5leHRcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrT3V0c2lkZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIHN0b3JhZ2VIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwaHg6c2V0LXRoZW1lJywgdGhlbWVFdmVudEhhbmRsZXIpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2tPdXRzaWRlKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBzdG9yYWdlSGFuZGxlcilcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwaHg6c2V0LXRoZW1lJywgdGhlbWVFdmVudEhhbmRsZXIpXG4gICAgfVxuICB9KVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJ0aGVtZS1zZWxlY3RvciByZWxhdGl2ZVwiPlxuICA8YnV0dG9uXG4gICAgb25jbGljaz17dG9nZ2xlRHJvcGRvd259XG4gICAgY2xhc3M9XCJidG4gYnRuLWdob3N0IGJ0bi1zbSBnYXAtMlwiXG4gICAgYXJpYS1sYWJlbD1cIlNlbGVjdCB0aGVtZVwiXG4gID5cbiAgICA8c3BhbiBjbGFzcz1cInRleHQtbGdcIj57dGhlbWVzLmZpbmQodCA9PiB0LnZhbHVlID09PSBjdXJyZW50VGhlbWUpPy5pY29uIHx8ICfwn4yZJ308L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJoaWRkZW4gbWQ6aW5saW5lXCI+VGhlbWU8L3NwYW4+XG4gICAgPHN2Z1xuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICBjbGFzcz1cImgtNCB3LTQgdHJhbnNpdGlvbi10cmFuc2Zvcm0ge2lzT3BlbiA/ICdyb3RhdGUtMTgwJyA6ICcnfVwiXG4gICAgICBmaWxsPVwibm9uZVwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgPlxuICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTkgOWwtNyA3LTctN1wiIC8+XG4gICAgPC9zdmc+XG4gIDwvYnV0dG9uPlxuXG4gIHsjaWYgaXNPcGVufVxuICAgIDxkaXYgY2xhc3M9XCJhYnNvbHV0ZSByaWdodC0wIG10LTIgdy00OCBiZy1iYXNlLTIwMCByb3VuZGVkLWxnIHNoYWRvdy14bCBib3JkZXIgYm9yZGVyLWJhc2UtMzAwIHotNTBcIj5cbiAgICAgIDx1bCBjbGFzcz1cIm1lbnUgcC0yXCI+XG4gICAgICAgIHsjZWFjaCB0aGVtZXMgYXMgdGhlbWV9XG4gICAgICAgICAgPGxpPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBvbmNsaWNrPXsoKSA9PiBzZWxlY3RUaGVtZSh0aGVtZS52YWx1ZSl9XG4gICAgICAgICAgICAgIGNsYXNzPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTMge2N1cnJlbnRUaGVtZSA9PT0gdGhlbWUudmFsdWUgPyAnYWN0aXZlIGJnLXByaW1hcnkgdGV4dC1wcmltYXJ5LWNvbnRlbnQnIDogJyd9XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LWxnXCI+e3RoZW1lLmljb259PC9zcGFuPlxuICAgICAgICAgICAgICA8c3Bhbj57dGhlbWUubGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICB7I2lmIGN1cnJlbnRUaGVtZSA9PT0gdGhlbWUudmFsdWV9XG4gICAgICAgICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImgtNCB3LTQgbWwtYXV0b1wiXG4gICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNSAxM2w0IDRMMTkgN1wiIC8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L2xpPlxuICAgICAgICB7L2VhY2h9XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICB7L2lmfVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnRoZW1lLXNlbGVjdG9yIHtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgfVxuPC9zdHlsZT5cbiIsICI8c2NyaXB0PlxuICBsZXQgY3VycmVudFRoZW1lID0gJHN0YXRlKCdsaWdodCcpXG5cbiAgZnVuY3Rpb24gdG9nZ2xlVGhlbWUoKSB7XG4gICAgY29uc3QgbmV3VGhlbWUgPSBjdXJyZW50VGhlbWUgPT09ICdsaWdodCcgPyAnZGFyaycgOiAnbGlnaHQnXG4gICAgY3VycmVudFRoZW1lID0gbmV3VGhlbWVcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJywgbmV3VGhlbWUpXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BoeDp0aGVtZScsIG5ld1RoZW1lKVxuXG4gICAgLy8gRGlzcGF0Y2ggZXZlbnQgZm9yIG90aGVyIGNvbXBvbmVudHNcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3BoeDpzZXQtdGhlbWUnLCB7XG4gICAgICBkZXRhaWw6IHsgdGhlbWU6IG5ld1RoZW1lIH1cbiAgICB9KSlcbiAgfVxuXG4gICRlZmZlY3QoKCkgPT4ge1xuICAgIC8vIEdldCBpbml0aWFsIHRoZW1lXG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3BoeDp0aGVtZScpXG4gICAgY29uc3QgcHJlZmVyc0RhcmsgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpLm1hdGNoZXNcbiAgICBjdXJyZW50VGhlbWUgPSBzdG9yZWQgfHwgKHByZWZlcnNEYXJrID8gJ2RhcmsnIDogJ2xpZ2h0JylcblxuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS10aGVtZScpKSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJywgY3VycmVudFRoZW1lKVxuICAgIH1cbiAgfSlcbjwvc2NyaXB0PlxuXG48YnV0dG9uXG4gIG9uY2xpY2s9e3RvZ2dsZVRoZW1lfVxuICBjbGFzcz1cImJ0biBidG4tZ2hvc3QgYnRuLWNpcmNsZSBidG4tc21cIlxuICBhcmlhLWxhYmVsPVwiVG9nZ2xlIHRoZW1lXCJcbj5cbiAgeyNpZiBjdXJyZW50VGhlbWUgPT09ICdsaWdodCd9XG4gICAgPCEtLSBNb29uIGljb24gLS0+XG4gICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyMCAyMFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTcuNDU1IDIuMDA0YS43NS43NSAwIDAxLjI2Ljc3IDcgNyAwIDAwOS45NTggNy45NjcuNzUuNzUgMCAwMTEuMDY3Ljg1M0E4LjUgOC41IDAgMTE2LjY0NyAxLjkyMWEuNzUuNzUgMCAwMS44MDguMDgzelwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgIDwvc3ZnPlxuICB7OmVsc2V9XG4gICAgPCEtLSBTdW4gaWNvbiAtLT5cbiAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICAgICAgPHBhdGggZD1cIk0xMCAyYS43NS43NSAwIDAxLjc1Ljc1djEuNWEuNzUuNzUgMCAwMS0xLjUgMHYtMS41QS43NS43NSAwIDAxMTAgMnpNMTAgMTVhLjc1Ljc1IDAgMDEuNzUuNzV2MS41YS43NS43NSAwIDAxLTEuNSAwdi0xLjVBLjc1Ljc1IDAgMDExMCAxNXpNMTAgN2EzIDMgMCAxMDAgNiAzIDMgMCAwMDAtNnpNMTUuNjU3IDUuNDA0YS43NS43NSAwIDEwLTEuMDYtMS4wNmwtMS4wNjEgMS4wNmEuNzUuNzUgMCAwMDEuMDYgMS4wNmwxLjA2LTEuMDZ6TTYuNDY0IDE0LjU5NmEuNzUuNzUgMCAxMC0xLjA2LTEuMDZsLTEuMDYgMS4wNmEuNzUuNzUgMCAwMDEuMDYgMS4wNmwxLjA2LTEuMDZ6TTE4IDEwYS43NS43NSAwIDAxLS43NS43NWgtMS41YS43NS43NSAwIDAxMC0xLjVoMS41QS43NS43NSAwIDAxMTggMTB6TTUgMTBhLjc1Ljc1IDAgMDEtLjc1Ljc1aC0xLjVhLjc1Ljc1IDAgMDEwLTEuNWgxLjVBLjc1Ljc1IDAgMDE1IDEwek0xNC41OTYgMTUuNjU3YS43NS43NSAwIDAwMS4wNi0xLjA2bC0xLjA2LTEuMDYxYS43NS43NSAwIDEwLTEuMDYgMS4wNmwxLjA2IDEuMDZ6TTUuNDA0IDYuNDY0YS43NS43NSAwIDAwMS4wNi0xLjA2bC0xLjA2LTEuMDZhLjc1Ljc1IDAgMTAtMS4wNjEgMS4wNmwxLjA2IDEuMDZ6XCIgLz5cbiAgICA8L3N2Zz5cbiAgey9pZn1cbjwvYnV0dG9uPlxuIiwgIjxzY3JpcHQ+XG4gIGxldCB7IGRlbGF5ID0gMCB9ID0gJHByb3BzKClcbjwvc2NyaXB0PlxuXG48ZGl2XG4gIGNsYXNzPVwiYWJzb2x1dGUgaGlkZGVuIGxnOmJsb2NrIGJvdHRvbS0yMCByaWdodC0xMCB4bDpyaWdodC0zMiB3LWF1dG8gYmctYmFzZS0xMDAvNDAgYmFja2Ryb3AtYmx1ci14bCBib3JkZXIgYm9yZGVyLWJhc2UtMzAwLzUwIHNoYWRvdy1bMF8yMHB4XzQwcHhfLTE1cHhfcmdiYSgwLDAsMCwwLjEpXSByb3VuZGVkLTJ4bCBwLTQgYW5pbWF0ZS1mbG9hdCByb3RhdGUtWzNkZWddXCJcbiAgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6IHtkZWxheX1zXCJcbj5cbiAgPGRpdiBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMyBwci0yXCI+XG4gICAgPGRpdiBjbGFzcz1cInctMTAgaC0xMCByb3VuZGVkLXhsIGJnLVsjRUE0QjcxXSBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LXdoaXRlIHNoYWRvdy1sZyBzaGFkb3ctcGluay01MDAvMjBcIj5cbiAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjAgMjBcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTE1LjMxMiAxMS40MjRhNS41IDUuNSAwIDAxLTkuMjAxIDIuNDY2bC0uMzEyLS4zMTFoMi40MzNhLjc1Ljc1IDAgMDAwLTEuNUgzLjk4OWEuNzUuNzUgMCAwMC0uNzUuNzV2NC4yNDJhLjc1Ljc1IDAgMDAxLjUgMHYtMi40M2wuMzEuMzFhNyA3IDAgMDAxMS43MTItMy4xMzguNzUuNzUgMCAwMC0xLjQ0OS0uMzl6bTEuMjMtMy43MjNhLjc1Ljc1IDAgMDAuMjE5LS41M1YyLjkyOWEuNzUuNzUgMCAwMC0xLjUgMFY1LjM2bC0uMzEtLjMxQTcgNyAwIDAwMy4yMzkgOC4xODhhLjc1Ljc1IDAgMTAxLjQ0OC4zODlBNS41IDUuNSAwIDAxMTMuODkgNi4xMWwuMzExLjMxaC0yLjQzMmEuNzUuNzUgMCAwMDAgMS41aDQuMjQzYS43NS43NSAwIDAwLjUzLS4yMTl6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidGV4dC1sZWZ0XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidGV4dC14cyB0ZXh0LWJhc2UtY29udGVudC82MCBmb250LW1lZGl1bVwiPkFjdGl2ZSBXb3JrZmxvdzwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInRleHQtc20gZm9udC1ib2xkIHRleHQtYmFzZS1jb250ZW50XCI+TGVhZCBHZW4gQm90IMK3IFJ1bm5pbmc8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgeyBvbk1vdW50LCBvbkRlc3Ryb3ksIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcblxuICBjb25zdCBZVF9TUkMgPSBcImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2lmcmFtZV9hcGlcIjtcblxuICBjb25zdCBkaXNwYXRjaGVyID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgLy8gUHJvcHNcbiAgZXhwb3J0IGxldCB2aWRlb0lkOiBzdHJpbmc7XG4gIGV4cG9ydCBsZXQgc3RhcnRTZWNvbmRzOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgZXhwb3J0IGxldCBhdXRvcGxheTogYm9vbGVhbiA9IGZhbHNlO1xuICBleHBvcnQgbGV0IGNvbnRyb2xzOiBib29sZWFuID0gdHJ1ZTtcbiAgZXhwb3J0IGxldCByZWw6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBtb2Rlc3RCcmFuZGluZzogYm9vbGVhbiA9IHRydWU7XG4gIGV4cG9ydCBsZXQgbG9vcDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIEV4dGVybmFsIGNvbnRyb2wgcHJvcHNcbiAgZXhwb3J0IGxldCBwbGF5VHJpZ2dlcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIGV4cG9ydCBsZXQgcGF1c2VUcmlnZ2VyOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgZXhwb3J0IGxldCBzZWVrVG9TZWNvbmRzOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBsZXQgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudDtcbiAgbGV0IHBsYXllcjogYW55O1xuICBsZXQgcGxheWVyUmVhZHkgPSBmYWxzZTtcbiAgbGV0IHNjcmlwdExvYWRlZCA9IGZhbHNlO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGxldCBwbGF5ZXJJZCA9IGB5dC1wbGF5ZXItJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcblxuICBmdW5jdGlvbiBlbnN1cmVZb3VUdWJlU2NyaXB0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoKHdpbmRvdyBhcyBhbnkpLllUICYmICh3aW5kb3cgYXMgYW55KS5ZVC5QbGF5ZXIpIHtcbiAgICAgICAgc2NyaXB0TG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhpc3RpbmcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjPVwiJHtZVF9TUkN9XCJdYCk7XG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgY29uc3QgY2hlY2tSZWFkeSA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBpZiAoKHdpbmRvdyBhcyBhbnkpLllUICYmICh3aW5kb3cgYXMgYW55KS5ZVC5QbGF5ZXIpIHtcbiAgICAgICAgICAgIHNjcmlwdExvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGNoZWNrUmVhZHkpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgdGFnLnNyYyA9IFlUX1NSQztcbiAgICAgIHRhZy5hc3luYyA9IHRydWU7XG5cbiAgICAgICh3aW5kb3cgYXMgYW55KS5vbllvdVR1YmVJZnJhbWVBUElSZWFkeSA9ICgpID0+IHtcbiAgICAgICAgc2NyaXB0TG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgdGFnLm9uZXJyb3IgPSAoZXJyKSA9PiByZWplY3QoZXJyKTtcblxuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0YWcpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGxheWVyKCkge1xuICAgIGlmICghc2NyaXB0TG9hZGVkIHx8ICFjb250YWluZXIgfHwgIXZpZGVvSWQgfHwgZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBjb25zdCBZVCA9ICh3aW5kb3cgYXMgYW55KS5ZVDtcblxuICAgIHBsYXllciA9IG5ldyBZVC5QbGF5ZXIoY29udGFpbmVyLCB7XG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgdmlkZW9JZCxcbiAgICAgIHBsYXllclZhcnM6IHtcbiAgICAgICAgYXV0b3BsYXk6IGF1dG9wbGF5ID8gMSA6IDAsXG4gICAgICAgIGNvbnRyb2xzOiBjb250cm9scyA/IDEgOiAwLFxuICAgICAgICByZWw6IHJlbCA/IDEgOiAwLFxuICAgICAgICBtb2Rlc3RicmFuZGluZzogbW9kZXN0QnJhbmRpbmcgPyAxIDogMCxcbiAgICAgICAgbG9vcDogbG9vcCA/IDEgOiAwLFxuICAgICAgICBwbGF5bGlzdDogbG9vcCA/IHZpZGVvSWQgOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0OiBzdGFydFNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG9uUmVhZHk6IG9uUGxheWVyUmVhZHksXG4gICAgICAgIG9uU3RhdGVDaGFuZ2U6IG9uUGxheWVyU3RhdGVDaGFuZ2UsXG4gICAgICAgIG9uRXJyb3I6IG9uUGxheWVyRXJyb3JcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUGxheWVyUmVhZHkoZXZlbnQ6IGFueSkge1xuICAgIHBsYXllclJlYWR5ID0gdHJ1ZTtcbiAgICBkaXNwYXRjaGVyKFwicmVhZHlcIiwgeyBkdXJhdGlvbjogcGxheWVyLmdldER1cmF0aW9uPy4oKSB9KTtcblxuICAgIGlmIChhdXRvcGxheSkge1xuICAgICAgcGxheWVyLnBsYXlWaWRlbygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUGxheWVyU3RhdGVDaGFuZ2UoZXZlbnQ6IGFueSkge1xuICAgIGNvbnN0IHN0YXRlID0gZXZlbnQuZGF0YTtcblxuICAgIGRpc3BhdGNoZXIoXCJzdGF0ZUNoYW5nZVwiLCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIGN1cnJlbnRUaW1lOiBzYWZlR2V0Q3VycmVudFRpbWUoKSxcbiAgICAgIGR1cmF0aW9uOiBzYWZlR2V0RHVyYXRpb24oKVxuICAgIH0pO1xuXG4gICAgaWYgKHN0YXRlID09PSAxKSBkaXNwYXRjaGVyKFwicGxheVwiKTtcbiAgICBpZiAoc3RhdGUgPT09IDIpIGRpc3BhdGNoZXIoXCJwYXVzZVwiKTtcbiAgICBpZiAoc3RhdGUgPT09IDApIGRpc3BhdGNoZXIoXCJlbmRlZFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUGxheWVyRXJyb3IoZXZlbnQ6IGFueSkge1xuICAgIGRpc3BhdGNoZXIoXCJlcnJvclwiLCB7IGNvZGU6IGV2ZW50LmRhdGEgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlR2V0Q3VycmVudFRpbWUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBwbGF5ZXI/LmdldEN1cnJlbnRUaW1lID8gcGxheWVyLmdldEN1cnJlbnRUaW1lKCkgOiBudWxsO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVHZXREdXJhdGlvbigpOiBudW1iZXIgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHBsYXllcj8uZ2V0RHVyYXRpb24gPyBwbGF5ZXIuZ2V0RHVyYXRpb24oKSA6IG51bGw7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhY3QgdG8gZXh0ZXJuYWwgY29udHJvbCBwcm9wc1xuICAkOiBpZiAocGxheWVyUmVhZHkgJiYgcGxheVRyaWdnZXIgIT09IG51bGwpIHtcbiAgICBwbGF5ZXIucGxheVZpZGVvKCk7XG4gIH1cblxuICAkOiBpZiAocGxheWVyUmVhZHkgJiYgcGF1c2VUcmlnZ2VyICE9PSBudWxsKSB7XG4gICAgcGxheWVyLnBhdXNlVmlkZW8oKTtcbiAgfVxuXG4gICQ6IGlmIChwbGF5ZXJSZWFkeSAmJiBzZWVrVG9TZWNvbmRzICE9PSBudWxsKSB7XG4gICAgcGxheWVyLnNlZWtUbyhzZWVrVG9TZWNvbmRzLCB0cnVlKTtcbiAgfVxuXG4gIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGVuc3VyZVlvdVR1YmVTY3JpcHQoKTtcbiAgICBjcmVhdGVQbGF5ZXIoKTtcbiAgfSk7XG5cbiAgb25EZXN0cm95KCgpID0+IHtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBwbGF5ZXI/LmRlc3Ryb3k/LigpO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxkaXYgYmluZDp0aGlzPXtjb250YWluZXJ9IHtwbGF5ZXJJZH0gc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1wiPjwvZGl2PlxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFhLG9CQUNBLHFCQUVBLG9CQUNBLGtCQUNBLHFCQUVBLG9CQUNBLGdCQUNBLGtCQUNBLG1CQUNBLHVCQUVBLGVBQ0EsZ0JBQ0EsbUJBRUEsbUJBQ0EsMEJBQ0Esa0JBQ0EscUJBRUEsaUJBRUEsc0JBQ0EsZUFDQSxpQkFFQSx1QkFDQSxpQ0FDQSxrQkFFQSxlQUdBLFVBQ0EsS0FFQSxnQkFDQSxlQUNBLGtCQXVCQTtBQS9EYjtBQUFBO0FBQU8sSUFBTSxxQkFBcUI7QUFDM0IsSUFBTSxzQkFBc0IsS0FBSztBQUVqQyxJQUFNLHFCQUFxQixLQUFLO0FBQ2hDLElBQU0sbUJBQW1CLEtBQUs7QUFDOUIsSUFBTSxzQkFBc0IsS0FBSztBQUVqQyxJQUFNLHFCQUFxQjtBQUMzQixJQUFNLGlCQUFpQixLQUFLO0FBQzVCLElBQU0sbUJBQW1CLEtBQUs7QUFDOUIsSUFBTSxvQkFBb0IsS0FBSztBQUMvQixJQUFNLHdCQUF3QixLQUFLO0FBRW5DLElBQU0sZ0JBQWdCO0FBQ3RCLElBQU0saUJBQWlCLEtBQUs7QUFDNUIsSUFBTSxvQkFBb0IsS0FBSztBQUUvQixJQUFNLG9CQUFvQjtBQUMxQixJQUFNLDJCQUEyQixLQUFLO0FBQ3RDLElBQU0sbUJBQW1CLEtB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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQSx1QkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBQUM7QUFDQTtBQUNBO0FBQ0EsSUFBQUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFBQztBQUNBO0FBQ0EsSUFBQUM7QUFDQSxJQUFBQztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFRQTtBQUNBLElBQUFDO0FBTUE7QUFXQTtBQVFBO0FBQ0E7QUFLQTtBQWFBO0FBQ0EsSUFBQUM7QUFRQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBVUEsSUFBQUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBT0EsSUFBQUM7QUFDQTtBQUNBO0FBQUE7QUFBQTs7O0FDdExBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSxJQUFBQztBQUNBO0FBQUE7QUFBQTs7O0FDSkE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUFDO0FBQ0E7QUFDQTtBQUNBO0FBME9BO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQW5QQSxRQUFJLGNBQUs7QUFJUixVQUFTLG1CQUFULFNBQTBCLE1BQU07QUFDL0IsWUFBSSxFQUFFLFFBQVEsYUFBYTtBQUcxQixjQUFJO0FBQ0osaUJBQU8sZUFBZSxZQUFZLE1BQU07QUFBQSxZQUN2QyxjQUFjO0FBQUE7QUFBQSxZQUVkLEtBQUssTUFBTTtBQUNWLGtCQUFJLFVBQVUsUUFBVztBQUN4Qix1QkFBTztBQUFBLGNBQ1I7QUFFQSxjQUFFLG9CQUFvQixJQUFJO0FBQUEsWUFDM0I7QUFBQSxZQUNBLEtBQUssQ0FBQyxNQUFNO0FBQ1gsc0JBQVE7QUFBQSxZQUNUO0FBQUEsVUFDRCxDQUFDO0FBQUEsUUFDRjtBQUFBLE1BQ0Q7QUFFQSx1QkFBaUIsUUFBUTtBQUN6Qix1QkFBaUIsU0FBUztBQUMxQix1QkFBaUIsVUFBVTtBQUMzQix1QkFBaUIsVUFBVTtBQUMzQix1QkFBaUIsUUFBUTtBQUN6Qix1QkFBaUIsV0FBVztBQUFBLElBQzdCO0FBQUE7QUFBQTs7O0FDaENPLFNBQVMsbUJBQW1CLE9BQU9DLE1BQUssWUFBWTtBQUMxRCxNQUFJLFNBQVMsTUFBTTtBQUVsQixJQUFBQSxLQUFJLE1BQVM7QUFHYixRQUFJLFdBQVksWUFBVyxNQUFTO0FBRXBDLFdBQU87QUFBQSxFQUNSO0FBSUEsUUFBTSxRQUFRO0FBQUEsSUFBUSxNQUNyQixNQUFNO0FBQUEsTUFDTEE7QUFBQTtBQUFBLE1BRUE7QUFBQSxJQUNEO0FBQUEsRUFDRDtBQUlBLFNBQU8sTUFBTSxjQUFjLE1BQU0sTUFBTSxZQUFZLElBQUk7QUFDeEQ7QUFuQ0EsSUFBQUMsY0FBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7OztBQ0ZBLElBRWEsWUFDQSxpQkFDQSxhQUNBO0FBTGIsSUFBQUMsa0JBQUE7QUFBQTtBQUFBO0FBRU8sSUFBTSxhQUFhLE9BQU8sZUFBZTtBQUN6QyxJQUFNLGtCQUFrQixPQUFPLG9CQUFvQjtBQUNuRCxJQUFNLGNBQWMsT0FBTyxhQUFhO0FBQ3hDLElBQU0sZ0JBQWdCO0FBQUE7QUFBQTs7O0FDQXRCLFNBQVMsUUFBUTtBQUN2QixjQUFZLE1BQU0sY0FBYztBQUNoQyxlQUFhO0FBQ2Q7QUFFTyxTQUFTLGlCQUFpQjtBQUNoQyxVQUFRLGVBQWUsSUFBSSxnQkFBZ0IsR0FBRztBQUMvQztBQVpBLElBR0k7QUFISjtBQUFBO0FBQUEsSUFBQUM7QUFHQSxJQUFJLGFBQWE7QUFBQTtBQUFBOzs7QUNLVixTQUFTLGtDQUFrQztBQUNqRCxRQUFNLFFBQVEsSUFBSSxNQUFNO0FBQUE7QUFBQSxxREFBNEw7QUFFcE4sUUFBTSxPQUFPO0FBRWIsUUFBTTtBQUNQO0FBTU8sU0FBUyxnQkFBZ0I7QUFDL0IsUUFBTSxRQUFRLElBQUksTUFBTTtBQUFBO0FBQUEsbUNBQWlIO0FBRXpJLFFBQU0sT0FBTztBQUViLFFBQU07QUFDUDtBQU1PLFNBQVMsa0JBQWtCO0FBQ2pDLFFBQU0sUUFBUSxJQUFJLE1BQU07QUFBQTtBQUFBLHFDQUFrSjtBQUUxSyxRQUFNLE9BQU87QUFFYixRQUFNO0FBQ1A7QUFVTyxTQUFTLHNCQUFzQkMsTUFBS0MsUUFBTztBQUNqRCxRQUFNLFFBQVEsSUFBSSxNQUFNO0FBQUEsNkNBQXFFRCxJQUFHO0FBQUE7QUFBQSxFQUUvRkMsTUFBSztBQUFBLDJDQUE4QztBQUVwRCxRQUFNLE9BQU87QUFFYixRQUFNO0FBQ1A7QUFhTyxTQUFTLGdDQUFnQ0QsTUFBS0MsUUFBTztBQUMzRCxRQUFNLFFBQVEsSUFBSSxNQUFNO0FBQUEsb0RBQXNGRCxJQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtoSEMsTUFBSztBQUFBLHFEQUF3RDtBQUU5RCxRQUFNLE9BQU87QUFFYixRQUFNO0FBQ1A7QUFPTyxTQUFTLCtCQUErQixNQUFNO0FBQ3BELFFBQU0sUUFBUSxJQUFJLE1BQU07QUFBQSxJQUFxQyxJQUFJO0FBQUEsb0RBQTZGO0FBRTlKLFFBQU0sT0FBTztBQUViLFFBQU07QUFDUDtBQU1PLFNBQVMsMEJBQTBCO0FBQ3pDLFFBQU0sUUFBUSxJQUFJLE1BQU07QUFBQTtBQUFBLDZDQUE4RztBQUV0SSxRQUFNLE9BQU87QUFFYixRQUFNO0FBQ1A7QUF6R0EsSUFBQUMsZUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBOzs7QUNNTyxTQUFTLGdCQUFnQixHQUFHO0FBQ2xDLGdCQUFjO0FBQ2Y7QUFPTyxTQUFTQyxpQkFBZ0I7QUFDL0IsUUFBTUMsT0FBTSxDQUFDO0FBQ2IsU0FBTyxDQUFDLE1BQU1DLFlBQVdELElBQUcsR0FBRyxDQUFDRSxhQUFZQyxZQUFXSCxNQUFLRSxRQUFPLENBQUM7QUFDckU7QUFPTyxTQUFTRCxZQUFXRCxNQUFLO0FBQy9CLFFBQU0sY0FBYyx3QkFBd0IsWUFBWTtBQUN4RCxRQUFNO0FBQUE7QUFBQSxJQUEyQixZQUFZLElBQUlBLElBQUc7QUFBQTtBQUVwRCxTQUFPO0FBQ1I7QUFRTyxTQUFTRyxZQUFXSCxNQUFLRSxVQUFTO0FBQ3hDLDBCQUF3QixZQUFZLEVBQUUsSUFBSUYsTUFBS0UsUUFBTztBQUN0RCxTQUFPQTtBQUNSO0FBTU8sU0FBU0UsWUFBV0osTUFBSztBQUMvQixTQUFPLHdCQUF3QixZQUFZLEVBQUUsSUFBSUEsSUFBRztBQUNyRDtBQUdPLFNBQVNLLGtCQUFpQjtBQUNoQyxTQUFPLHdCQUF3QixnQkFBZ0I7QUFDaEQ7QUFNQSxTQUFTLHdCQUF3QixNQUFNO0FBQ3RDLE1BQUksZ0JBQWdCLE1BQU07QUFDekIsSUFBRSw0QkFBNEIsSUFBSTtBQUFBLEVBQ25DO0FBRUEsU0FBUSxZQUFZLE1BQU0sSUFBSSxJQUFJLG1CQUFtQixXQUFXLEtBQUssTUFBUztBQUMvRTtBQUtPLFNBQVNDLE1BQUssSUFBSTtBQUN4QixnQkFBYyxFQUFFLEdBQUcsYUFBYSxHQUFHLE1BQU0sR0FBRyxLQUFLO0FBRWpELE1BQUksY0FBSztBQUNSLGdCQUFZLFdBQVc7QUFDdkIsZ0JBQVksVUFBVSxZQUFZLEdBQUc7QUFBQSxFQUN0QztBQUNEO0FBRU8sU0FBU0MsT0FBTTtBQUNyQjtBQUFBLEVBQXlDLFlBQWE7QUFDdkQ7QUFNQSxTQUFTLG1CQUFtQkMsY0FBYTtBQUN4QyxNQUFJLFNBQVNBLGFBQVk7QUFFekIsU0FBTyxXQUFXLE1BQU07QUFDdkIsVUFBTSxjQUFjLE9BQU87QUFDM0IsUUFBSSxnQkFBZ0IsTUFBTTtBQUN6QixhQUFPO0FBQUEsSUFDUjtBQUNBLGFBQVMsT0FBTztBQUFBLEVBQ2pCO0FBRUEsU0FBTztBQUNSO0FBdEdBLElBS1c7QUFMWCxJQUFBQyxnQkFBQTtBQUFBO0FBQ0E7QUFDQSxJQUFBQztBQUdPLElBQUksY0FBYztBQUFBO0FBQUE7OztBQ1VsQixTQUFTLHNCQUFzQkMsTUFBS0MsUUFBTztBQUNqRCxNQUFJLGNBQUs7QUFDUixZQUFRO0FBQUEsTUFDUDtBQUFBLHNDQUF5RUQsSUFBRztBQUFBO0FBQUE7QUFBQSxFQUc3RUMsTUFBSztBQUFBO0FBQUEsTUFDSkM7QUFBQSxNQUNBQztBQUFBLElBQ0Q7QUFBQSxFQUNELE9BQU87QUFDTixZQUFRLEtBQUssNENBQTRDO0FBQUEsRUFDMUQ7QUFDRDtBQTVCQSxJQUlJRCxPQUNBQztBQUxKLElBQUFDLGlCQUFBO0FBQUE7QUFFQTtBQUVBLElBQUlGLFFBQU87QUFDWCxJQUFJQyxVQUFTO0FBQUE7QUFBQTs7O0FDU04sU0FBUyxxQkFBcUI7QUFDcEMsUUFBTSxRQUFRLFdBQVcsS0FBSyxTQUFTO0FBRXZDLE1BQUksQ0FBQyxPQUFPO0FBQ1gsSUFBRSx3QkFBd0I7QUFBQSxFQUMzQjtBQUVBLFNBQU87QUFDUjtBQU9BLGVBQXNCLG9CQUFvQixJQUFJO0FBQzdDLFlBQVU7QUFBQSxJQUNULFlBQVk7QUFBQSxNQUNYLFFBQVEsb0JBQUksSUFBSTtBQUFBLE1BQ2hCLGFBQWEsQ0FBQztBQUFBLE1BQ2QscUJBQXFCLG9CQUFJLElBQUk7QUFBQSxJQUM5QjtBQUFBLEVBQ0Q7QUFFQSxNQUFJLGdCQUFnQixHQUFHO0FBQ3RCLFVBQU0sRUFBRSxTQUFTLFFBQVEsSUFBSSxTQUFTO0FBQ3RDLFVBQU0sa0JBQWtCO0FBQ3hCLHFCQUFpQjtBQUNqQixVQUFNO0FBQ04sV0FBTyxHQUFHLEVBQUUsUUFBUSxPQUFPO0FBQUEsRUFDNUI7QUFFQSxNQUFJO0FBQ0gsUUFBSSxRQUFRLE1BQU07QUFDakIsTUFBRSxnQ0FBZ0M7QUFBQSxJQUNuQztBQUNBLFdBQU8sSUFBSSxJQUFJLFNBQVMsRUFBRTtBQUFBLEVBQzNCLFVBQUU7QUFDRCxjQUFVO0FBQUEsRUFDWDtBQUNEO0FBS0EsZUFBc0JFLHVCQUFzQjtBQUMzQyxNQUFJLFFBQVEsS0FBTTtBQUNsQixNQUFJO0FBRUgsVUFBTSxFQUFFLGtCQUFrQixJQUFJLE1BQU0sT0FBTyxrQkFBa0I7QUFDN0QsVUFBTSxJQUFJLGtCQUFrQjtBQUFBLEVBQzdCLFFBQVE7QUFBQSxFQUFDO0FBQ1Y7QUFHQSxTQUFTLGtCQUFrQjtBQUcxQixTQUFPLENBQUMsQ0FBQyxXQUFXLFNBQVMsVUFBVTtBQUN4QztBQXpFQSxJQVFJLGdCQUdBLFNBOENBO0FBekRKO0FBQUE7QUFJQTtBQUNBLElBQUFDO0FBR0EsSUFBSSxpQkFBaUI7QUFHckIsSUFBSSxVQUFVO0FBOENkLElBQUksTUFBTTtBQUFBO0FBQUE7OztBQ3pEVixJQTZCYSxVQWtwQkE7QUEvcUJiO0FBQUE7QUFHQTtBQUNBO0FBQ0EsSUFBQUM7QUFDQSxJQUFBQztBQUNBLElBQUFDO0FBQ0EsSUFBQUM7QUFDQTtBQUNBO0FBQ0E7QUFrQk8sSUFBTSxXQUFOLE1BQU0sVUFBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLckIsT0FBTyxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1SLGNBQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTWQscUJBQXFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1yQjtBQUFBO0FBQUEsTUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRVjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsWUFBWSxRQUFRLFFBQVE7QUFDM0IsYUFBSyxVQUFVO0FBRWYsYUFBSyxTQUFTO0FBQ2QsYUFBSyxRQUFRLFNBQVMsRUFBRSxHQUFHLE9BQU8sTUFBTSxJQUFJLEVBQUUsY0FBYyxPQUFVO0FBQ3RFLGFBQUssT0FBTyxTQUFTLE9BQU8sT0FBTztBQUFBLE1BQ3BDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxLQUFLLElBQUk7QUFDUixjQUFNQyxRQUFPLElBQUksVUFBUyxLQUFLLFFBQVEsSUFBSTtBQUMzQyxRQUFBQSxNQUFLLE9BQU87QUFFWixhQUFLLEtBQUssS0FBS0EsS0FBSTtBQUNuQixRQUFBQSxNQUFLLE1BQU0sRUFBRTtBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsWUFBWSxVQUFVLElBQUk7QUFDekIsYUFBSyxLQUFLLEtBQUssVUFBVTtBQUN6QixhQUFLLE1BQU0sVUFBVSxFQUFFO0FBQ3ZCLGFBQUssS0FBSyxLQUFLLFdBQVc7QUFBQSxNQUMzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxNQUFNLFVBQVUsSUFBSTtBQUNuQixZQUFJLFdBQVc7QUFFZixZQUFJLFNBQVMsU0FBUyxHQUFHO0FBQ3hCLGdCQUFNQyxXQUFVO0FBRWhCLHFCQUFXLENBQUMsYUFBYTtBQUN4QixtQkFBTyxRQUFRLElBQUksUUFBUSxFQUFFLEtBQUssTUFBTTtBQUN2QyxvQkFBTSxtQkFBbUI7QUFFekIsa0JBQUk7QUFDSCxnQ0FBZ0JBLFFBQU87QUFDdkIsdUJBQU8sR0FBRyxRQUFRO0FBQUEsY0FDbkIsVUFBRTtBQUNELGdDQUFnQixnQkFBZ0I7QUFBQSxjQUNqQztBQUFBLFlBQ0QsQ0FBQztBQUFBLFVBQ0Y7QUFBQSxRQUNEO0FBRUEsYUFBSyxNQUFNLFFBQVE7QUFBQSxNQUNwQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsSUFBSSxRQUFRO0FBQ1gsY0FBTUEsV0FBVTtBQUVoQixZQUFJLFVBQVUsUUFBUSxRQUFRLE9BQU8sQ0FBQyxFQUFFLENBQUM7QUFDekMsY0FBTSxXQUFXLENBQUMsT0FBTztBQUV6QixtQkFBVyxNQUFNLE9BQU8sTUFBTSxDQUFDLEdBQUc7QUFDakMsb0JBQVUsUUFBUSxLQUFLLE1BQU07QUFDNUIsa0JBQU0sbUJBQW1CO0FBQ3pCLDRCQUFnQkEsUUFBTztBQUV2QixnQkFBSTtBQUNILHFCQUFPLEdBQUc7QUFBQSxZQUNYLFVBQUU7QUFDRCw4QkFBZ0IsZ0JBQWdCO0FBQUEsWUFDakM7QUFBQSxVQUNELENBQUM7QUFFRCxtQkFBUyxLQUFLLE9BQU87QUFBQSxRQUN0QjtBQUVBLGVBQU87QUFBQSxNQUNSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsTUFBTSxJQUFJO0FBQ1QsY0FBTUMsU0FBUSxJQUFJLFVBQVMsS0FBSyxRQUFRLElBQUk7QUFDNUMsYUFBSyxLQUFLLEtBQUtBLE1BQUs7QUFFcEIsY0FBTSxTQUFTO0FBRWYsd0JBQWdCO0FBQUEsVUFDZixHQUFHO0FBQUEsVUFDSCxHQUFHO0FBQUEsVUFDSCxHQUFHO0FBQUEsVUFDSCxHQUFHQTtBQUFBLFFBQ0osQ0FBQztBQUVELGNBQU0sU0FBUyxHQUFHQSxNQUFLO0FBRXZCLHdCQUFnQixNQUFNO0FBRXRCLFlBQUksa0JBQWtCLFNBQVM7QUFDOUIsY0FBSUEsT0FBTSxPQUFPLFNBQVMsUUFBUTtBQUNqQyxZQUFFLGNBQWM7QUFBQSxVQUNqQjtBQUVBLGlCQUFPLE1BQU0sTUFBTTtBQUFBLFVBQUMsQ0FBQztBQUNyQixVQUFBQSxPQUFNLFVBQVU7QUFBQSxRQUNqQjtBQUVBLGVBQU9BO0FBQUEsTUFDUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxVQUFVLElBQUksY0FBYztBQUMzQixRQUFBQyxNQUFLLFlBQVk7QUFDakIsY0FBTUQsU0FBUSxLQUFLLE1BQU0sRUFBRTtBQUMzQixRQUFBQSxPQUFNLHFCQUFxQjtBQUMzQixRQUFBRSxLQUFJO0FBQUEsTUFDTDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BV0EsT0FBTyxPQUFPLElBQUksVUFBVSxTQUFTLFFBQVFDLFFBQU87QUFDbkQsY0FBTSxFQUFFLE9BQU8sR0FBRyxhQUFhLElBQUk7QUFFbkMsYUFBSyxLQUFLLFVBQVUsV0FBVyxjQUFjLFVBQVUsU0FBUyxRQUFRQSxNQUFLLENBQUMsR0FBRztBQUNqRixhQUFLLE1BQU0sQ0FBQyxhQUFhO0FBQ3hCLG1CQUFTLE1BQU0sZUFBZTtBQUM5QixhQUFHLFFBQVE7QUFBQSxRQUNaLENBQUM7QUFDRCxhQUFLLEtBQUssV0FBVztBQUFBLE1BQ3RCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BVUEsT0FBTyxPQUFPLE1BQU0sVUFBVSxTQUFTLFFBQVFBLFFBQU87QUFDckQsYUFBSyxLQUFLLEtBQUssVUFBVSxXQUFXLE9BQU8sVUFBVSxTQUFTLFFBQVFBLE1BQUssQ0FBQyxFQUFFO0FBTzlFLGNBQU0sUUFBUSxDQUFDLFVBQVUsT0FBTyxFQUFFLE1BQUFMLE9BQU0sTUFBQU0sTUFBSyxNQUFNO0FBQ2xELGNBQUksV0FBVyxPQUFPO0FBQ3JCLG9CQUFRLE1BQU07QUFBQSxVQUNmO0FBRUEsY0FBSSxVQUFVLEtBQUssTUFBTSxjQUFjO0FBQ3RDLHFCQUFTLEtBQUssS0FBSyxXQUFXO0FBQUEsVUFDL0I7QUFFQSxtQkFBUyxLQUFLLEtBQUssSUFBSUEsS0FBSSxXQUFXO0FBR3RDLGNBQUlOLE9BQU07QUFDVCxxQkFBUyxLQUFLLENBQUNFLFdBQVVBLE9BQU0sS0FBS0YsS0FBSSxDQUFDO0FBQUEsVUFDMUM7QUFBQSxRQUNEO0FBRUEsWUFBSSxPQUFPLFNBQVMsWUFBWTtBQUMvQixlQUFLLE1BQU0sQ0FBQyxhQUFhO0FBQ3hCLGtCQUFNTyxLQUFJLElBQUksVUFBUyxLQUFLLFFBQVEsSUFBSTtBQUN4QyxpQkFBS0EsRUFBQztBQUVOLGdCQUFJLEtBQUssT0FBTyxTQUFTLFNBQVM7QUFDakMscUJBQU9BLEdBQUUsdUJBQXVCLEVBQUUsS0FBSyxDQUFDLFlBQVk7QUFDbkQsc0JBQU0sVUFBVSxRQUFRLEtBQUssV0FBVyxXQUFXLEVBQUUsR0FBRyxPQUFPO0FBQUEsY0FDaEUsQ0FBQztBQUFBLFlBQ0YsT0FBTztBQUNOLG9CQUFNLFVBQVVBLEdBQUUsaUJBQWlCO0FBQ25DLG9CQUFNLFVBQVUsUUFBUSxLQUFLLFdBQVcsV0FBVyxFQUFFLEdBQUcsT0FBTztBQUFBLFlBQ2hFO0FBQUEsVUFDRCxDQUFDO0FBQUEsUUFDRixPQUFPO0FBQ04sZ0JBQU0sTUFBTSxNQUFNLEVBQUUsS0FBSyxDQUFDO0FBQUEsUUFDM0I7QUFBQSxNQUNEO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxNQUFNLElBQUk7QUFDVCxjQUFNLE9BQU8sS0FBSyxTQUFTO0FBRzNCLGNBQU0sUUFBUSxDQUFDUCxVQUFTO0FBQ3ZCLGVBQUssT0FBTyxVQUFVQSxPQUFNLElBQUk7QUFBQSxRQUNqQztBQUVBLGFBQUssTUFBTSxDQUFDLGFBQWE7QUFDeEIsZ0JBQU1PLEtBQUksSUFBSSxVQUFTLFNBQVMsUUFBUSxRQUFRO0FBQ2hELGFBQUdBLEVBQUM7QUFFSixjQUFJLFNBQVMsT0FBTyxTQUFTLFNBQVM7QUFDckMsbUJBQU9BLEdBQUUsdUJBQXVCLEVBQUUsS0FBSyxDQUFDLFlBQVk7QUFDbkQsb0JBQU0sUUFBUSxJQUFJO0FBQUEsWUFDbkIsQ0FBQztBQUFBLFVBQ0YsT0FBTztBQUNOLGtCQUFNLFVBQVVBLEdBQUUsaUJBQWlCO0FBQ25DLGtCQUFNLFFBQVEsSUFBSTtBQUFBLFVBQ25CO0FBQUEsUUFDRCxDQUFDO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsS0FBSyxTQUFTO0FBQ2IsWUFBSSxPQUFPLFlBQVksWUFBWTtBQUNsQyxlQUFLLE1BQU0sT0FBTyxhQUFhLFNBQVMsS0FBSyxNQUFNLFFBQVEsQ0FBQyxDQUFDO0FBQUEsUUFDOUQsT0FBTztBQUNOLGVBQUssS0FBSyxLQUFLLE9BQU87QUFBQSxRQUN2QjtBQUFBLE1BQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFdBQVcsSUFBSTtBQUNkLFNBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxHQUFHLEtBQUssRUFBRTtBQUFBLE1BQ2xDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxXQUFXO0FBQ1YsZUFBTyxLQUFLLFVBQVUsQ0FBQyxHQUFHLEtBQUssUUFBUSxTQUFTLEdBQUcsS0FBSyxRQUFRLEtBQUssUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQUEsTUFDeEY7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLE9BQU87QUFDTixjQUFNLE9BQU8sSUFBSSxVQUFTLEtBQUssUUFBUSxLQUFLLE9BQU87QUFDbkQsYUFBSyxPQUFPLEtBQUssS0FBSyxJQUFJLENBQUMsU0FBVSxnQkFBZ0IsWUFBVyxLQUFLLEtBQUssSUFBSSxJQUFLO0FBQ25GLGFBQUssVUFBVSxLQUFLO0FBQ3BCLGVBQU87QUFBQSxNQUNSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFFBQVEsT0FBTztBQUNkLFlBQUksS0FBSyxPQUFPLFNBQVMsTUFBTSxPQUFPLE1BQU07QUFDM0MsZ0JBQU0sSUFBSTtBQUFBLFlBQ1Q7QUFBQSxVQUNEO0FBQUEsUUFDRDtBQUVBLGFBQUssUUFBUSxNQUFNO0FBQ25CLGFBQUssT0FBTyxNQUFNLEtBQUssSUFBSSxDQUFDLFNBQVM7QUFDcEMsY0FBSSxnQkFBZ0IsV0FBVTtBQUM3QixpQkFBSyxRQUFRLElBQUk7QUFBQSxVQUNsQjtBQUNBLGlCQUFPO0FBQUEsUUFDUixDQUFDO0FBQ0QsYUFBSyxVQUFVLE1BQU07QUFDckIsYUFBSyxPQUFPLE1BQU07QUFBQSxNQUNuQjtBQUFBLE1BRUEsSUFBSSxTQUFTO0FBQ1osZUFBTyxLQUFLLEtBQUs7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLE9BQU8sT0FBT0MsWUFBVyxVQUFVLENBQUMsR0FBRztBQUV0QyxZQUFJO0FBRUosWUFBSUM7QUFFSixjQUFNO0FBQUE7QUFBQSxVQUFzQyxDQUFDO0FBQUE7QUFHN0MsZUFBTyxpQkFBaUIsUUFBUTtBQUFBLFVBQy9CLE1BQU07QUFBQSxZQUNMLEtBQUssTUFBTTtBQUNWLHNCQUFRLFNBQVMsVUFBUyxRQUFRRCxZQUFXLE9BQU8sR0FBRztBQUFBLFlBQ3hEO0FBQUEsVUFDRDtBQUFBLFVBQ0EsTUFBTTtBQUFBLFlBQ0wsS0FBSyxNQUFNO0FBQ1Ysc0JBQVEsU0FBUyxVQUFTLFFBQVFBLFlBQVcsT0FBTyxHQUFHO0FBQUEsWUFDeEQ7QUFBQSxVQUNEO0FBQUEsVUFDQSxNQUFNO0FBQUEsWUFDTCxLQUFLLE1BQU07QUFDVixzQkFBUSxTQUFTLFVBQVMsUUFBUUEsWUFBVyxPQUFPLEdBQUc7QUFBQSxZQUN4RDtBQUFBLFVBQ0Q7QUFBQSxVQUNBLE1BQU07QUFBQSxZQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBU0MsQ0FBQyxhQUFhLGVBQWU7QUFDNUIsb0JBQUksQ0FBQyxpQkFBaUI7QUFDckIsd0JBQU1FLFVBQVUsU0FBUyxVQUFTLFFBQVFGLFlBQVcsT0FBTztBQUM1RCx3QkFBTSxjQUFjLFlBQVk7QUFBQSxvQkFDL0IsTUFBTUUsUUFBTztBQUFBLG9CQUNiLE1BQU1BLFFBQU87QUFBQSxvQkFDYixNQUFNQSxRQUFPO0FBQUEsa0JBQ2QsQ0FBQztBQUNELHlCQUFPLFFBQVEsUUFBUSxXQUFXO0FBQUEsZ0JBQ25DO0FBQ0EsZ0JBQUFELFdBQVVFLHFCQUFvQixFQUFFO0FBQUEsa0JBQUssTUFDcEMsb0JBQW9CLE1BQU0sVUFBUyxjQUFjSCxZQUFXLE9BQU8sQ0FBQztBQUFBLGdCQUNyRTtBQUNBLHVCQUFPQyxPQUFNLEtBQUssQ0FBQ0MsWUFBVztBQUM3Qix5QkFBTyxlQUFlQSxTQUFRLFFBQVE7QUFBQTtBQUFBLG9CQUVyQyxLQUFLLE1BQU07QUFDVixzQkFBRSxnQkFBZ0I7QUFBQSxvQkFDbkI7QUFBQSxrQkFDRCxDQUFDO0FBQ0QseUJBQU87QUFBQTtBQUFBLG9CQUE2Q0E7QUFBQSxrQkFBTztBQUFBLGdCQUM1RCxHQUFHLFVBQVU7QUFBQSxjQUNkO0FBQUE7QUFBQSxVQUNGO0FBQUEsUUFDRCxDQUFDO0FBRUQsZUFBTztBQUFBLE1BQ1I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxDQUFDLHNCQUFzQjtBQUN0QixtQkFBV0YsY0FBYSxLQUFLLHFCQUFxQixHQUFHO0FBQ3BELGlCQUFPQSxXQUFVLG1CQUFtQjtBQUFBLFFBQ3JDO0FBQUEsTUFDRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxDQUFDLHVCQUF1QjtBQUN2QixtQkFBV04sVUFBUyxLQUFLLE1BQU07QUFDOUIsY0FBSSxPQUFPQSxXQUFVLFVBQVU7QUFDOUIsbUJBQU9BLE9BQU0scUJBQXFCO0FBQUEsVUFDbkM7QUFBQSxRQUNEO0FBQ0EsWUFBSSxLQUFLLG9CQUFvQjtBQUM1QixnQkFBTTtBQUFBLFFBQ1A7QUFBQSxNQUNEO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxDQUFDLHFCQUFxQjtBQUNyQixZQUFJLEtBQUssYUFBYTtBQUNyQixxQkFBVyxNQUFNLEtBQUssYUFBYTtBQUNsQyxrQkFBTTtBQUFBLFVBQ1A7QUFBQSxRQUNEO0FBQ0EsbUJBQVdBLFVBQVMsS0FBSyxNQUFNO0FBQzlCLGNBQUlBLGtCQUFpQixhQUFZLENBQUNBLE9BQU0sb0JBQW9CO0FBQzNELG1CQUFPQSxPQUFNLG1CQUFtQjtBQUFBLFVBQ2pDO0FBQUEsUUFDRDtBQUFBLE1BQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxPQUFPLFFBQVFNLFlBQVcsU0FBUztBQUNsQyxZQUFJLG1CQUFtQjtBQUN2QixZQUFJO0FBQ0gsZ0JBQU0sV0FBVyxVQUFTLGFBQWEsUUFBUUEsWUFBVyxPQUFPO0FBRWpFLGdCQUFNLFVBQVUsU0FBUyxpQkFBaUI7QUFDMUMsaUJBQU8sVUFBUyxjQUFjLFNBQVMsUUFBUTtBQUFBLFFBQ2hELFVBQUU7QUFDRCxnQkFBTTtBQUNOLDBCQUFnQixnQkFBZ0I7QUFBQSxRQUNqQztBQUFBLE1BQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxhQUFhLGNBQWNBLFlBQVcsU0FBUztBQUM5QyxjQUFNLG1CQUFtQjtBQUV6QixZQUFJO0FBQ0gsZ0JBQU0sV0FBVyxVQUFTLGFBQWEsU0FBU0EsWUFBVyxPQUFPO0FBQ2xFLGdCQUFNLFVBQVUsTUFBTSxTQUFTLHVCQUF1QjtBQUN0RCxnQkFBTSxjQUFjLE1BQU0sU0FBUyxxQkFBcUI7QUFDeEQsY0FBSSxnQkFBZ0IsTUFBTTtBQUN6QixvQkFBUSxPQUFPLGNBQWMsUUFBUTtBQUFBLFVBQ3RDO0FBQ0EsaUJBQU8sVUFBUyxjQUFjLFNBQVMsUUFBUTtBQUFBLFFBQ2hELFVBQUU7QUFDRCwwQkFBZ0IsZ0JBQWdCO0FBQ2hDLGdCQUFNO0FBQUEsUUFDUDtBQUFBLE1BQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxpQkFBaUIsVUFBVSxFQUFFLE1BQU0sSUFBSSxNQUFNLEdBQUcsR0FBRztBQUNsRCxtQkFBVyxRQUFRLEtBQUssTUFBTTtBQUM3QixjQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzdCLG9CQUFRLEtBQUssSUFBSSxLQUFLO0FBQUEsVUFDdkIsV0FBVyxnQkFBZ0IsV0FBVTtBQUNwQyxpQkFBSyxpQkFBaUIsT0FBTztBQUFBLFVBQzlCO0FBQUEsUUFDRDtBQUVBLGVBQU87QUFBQSxNQUNSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsTUFBTSx1QkFBdUIsVUFBVSxFQUFFLE1BQU0sSUFBSSxNQUFNLEdBQUcsR0FBRztBQUM5RCxjQUFNLEtBQUs7QUFHWCxtQkFBVyxRQUFRLEtBQUssTUFBTTtBQUM3QixjQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzdCLG9CQUFRLEtBQUssSUFBSSxLQUFLO0FBQUEsVUFDdkIsV0FBVyxnQkFBZ0IsV0FBVTtBQUNwQyxrQkFBTSxLQUFLLHVCQUF1QixPQUFPO0FBQUEsVUFDMUM7QUFBQSxRQUNEO0FBRUEsZUFBTztBQUFBLE1BQ1I7QUFBQSxNQUVBLE1BQU0sdUJBQXVCO0FBQzVCLGNBQU0sTUFBTSxtQkFBbUIsRUFBRTtBQUVqQyxtQkFBVyxDQUFDLEdBQUdJLElBQUcsS0FBSyxJQUFJLHFCQUFxQjtBQUcvQyxVQUFFLHNCQUFzQkEsTUFBSyxJQUFJLE9BQU8sSUFBSUEsSUFBRyxHQUFHLFNBQVMsdUJBQXVCO0FBQUEsUUFDbkY7QUFFQSxtQkFBVyxjQUFjLElBQUksYUFBYTtBQUV6QyxnQkFBTTtBQUFBLFFBQ1A7QUFFQSxlQUFPLE1BQU0sVUFBUyxrQkFBa0IsR0FBRztBQUFBLE1BQzVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLE9BQU8sYUFBYSxNQUFNSixZQUFXLFNBQVM7QUFDN0MsY0FBTSxXQUFXLElBQUk7QUFBQSxVQUNwQixJQUFJLFNBQVMsTUFBTSxRQUFRLFdBQVcsUUFBUSxXQUFXLE1BQU0sRUFBRTtBQUFBLFFBQ2xFO0FBRUEsaUJBQVMsS0FBSyxVQUFVO0FBRXhCLFlBQUksUUFBUSxTQUFTO0FBQ3BCLFVBQUFMLE1BQUs7QUFDcUIsVUFBQyxZQUFhLElBQUksUUFBUTtBQUMxQixVQUFDLFlBQWEsSUFBSTtBQUFBLFFBQzdDO0FBR0EsUUFBQUssV0FBVSxVQUFVLFFBQVEsU0FBUyxDQUFDLENBQUM7QUFFdkMsWUFBSSxRQUFRLFNBQVM7QUFDcEIsVUFBQUosS0FBSTtBQUFBLFFBQ0w7QUFFQSxpQkFBUyxLQUFLLFdBQVc7QUFFekIsZUFBTztBQUFBLE1BQ1I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsT0FBTyxjQUFjLFNBQVMsVUFBVTtBQUN2QyxtQkFBVyxXQUFXLFNBQVMsb0JBQW9CLEdBQUc7QUFDckQsa0JBQVE7QUFBQSxRQUNUO0FBRUEsWUFBSUosUUFBTyxRQUFRLE9BQU8sU0FBUyxPQUFPLFVBQVU7QUFDcEQsWUFBSSxPQUFPLFFBQVE7QUFFbkIsbUJBQVcsRUFBRSxNQUFBYSxPQUFNLEtBQUssS0FBSyxTQUFTLE9BQU8sS0FBSztBQUNqRCxVQUFBYixTQUFRLGNBQWNhLEtBQUksS0FBSyxJQUFJO0FBQUEsUUFDcEM7QUFFQSxlQUFPO0FBQUEsVUFDTixNQUFBYjtBQUFBLFVBQ0E7QUFBQSxRQUNEO0FBQUEsTUFDRDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsYUFBYSxrQkFBa0IsS0FBSztBQUNuQyxZQUFJLElBQUksT0FBTyxTQUFTLEdBQUc7QUFDMUIsaUJBQU87QUFBQSxRQUNSO0FBRUEsWUFBSSxVQUFVLENBQUM7QUFDZixZQUFJLGVBQWU7QUFFbkIsbUJBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxJQUFJLFFBQVE7QUFDaEMsY0FBSSxFQUFFLFVBQVU7QUFDZiwyQkFBZTtBQUNmLHVCQUFXLEtBQUssRUFBRSxTQUFVLE9BQU07QUFBQSxVQUNuQztBQUVBLGtCQUFRLEtBQUssSUFBSSxLQUFLLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxVQUFVLEdBQUc7QUFBQSxRQUN0RDtBQUVBLFlBQUksVUFBVTtBQUVkLFlBQUksY0FBYztBQUNqQixvQkFBVTtBQUFBLE1BQ1AsT0FBTztBQUFBLFFBQ1g7QUFHQSxlQUFPO0FBQUE7QUFBQTtBQUFBLE1BR0gsT0FBTztBQUFBO0FBQUE7QUFBQSxPQUdOLFFBQVEsS0FBSyxVQUFlLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNbkM7QUFBQSxJQUNEO0FBRU8sSUFBTSxXQUFOLE1BQWU7QUFBQTtBQUFBLE1BRXJCO0FBQUE7QUFBQSxNQUdBO0FBQUE7QUFBQSxNQUdBLE1BQU0sb0JBQUksSUFBSTtBQUFBO0FBQUEsTUFHZCxTQUFTLEVBQUUsTUFBTSxDQUFDLEdBQUcsT0FBTyxHQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU0vQixZQUFZLE1BQU0sWUFBWSxJQUFJO0FBQ2pDLGFBQUssT0FBTztBQUVaLFlBQUksTUFBTTtBQUNWLGFBQUssTUFBTSxNQUFNLEdBQUcsU0FBUyxJQUFJLEtBQUs7QUFBQSxNQUN2QztBQUFBLE1BRUEsWUFBWTtBQUNYLGVBQU8sS0FBSyxPQUFPO0FBQUEsTUFDcEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFVBQVUsT0FBTyxNQUFNO0FBQ3RCLGNBQU0sVUFBVSxLQUFLLE9BQU87QUFFNUIsWUFBSSxJQUFJO0FBQ1IsWUFBSSxJQUFJLEtBQUssSUFBSSxLQUFLLFFBQVEsUUFBUSxNQUFNO0FBRzVDLGVBQU8sSUFBSSxLQUFLLEtBQUssQ0FBQyxNQUFNLFFBQVEsQ0FBQyxFQUFHLE1BQUs7QUFFN0MsWUFBSSxLQUFLLENBQUMsTUFBTSxPQUFXO0FBSzNCLFlBQUksUUFBUSxDQUFDLE1BQU0sVUFBYSxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRztBQUNyRCxlQUFLLE9BQU8sT0FBTztBQUNuQixlQUFLLE9BQU8sUUFBUTtBQUFBLFFBQ3JCO0FBQUEsTUFDRDtBQUFBLElBQ0Q7QUFBQTtBQUFBOzs7QUNwdUJBLElBQUFjLGFBQUE7QUFBQTtBQUFBO0FBQ0EsSUFBQUM7QUFBQTtBQUFBOzs7QUNnSk8sU0FBUywyQkFBMkIsV0FBVyxXQUFXLFdBQVcsY0FBYztBQUN6RixNQUFJLFVBQVUsU0FBUyxHQUFHLEVBQUcsUUFBTztBQUVwQyxRQUFNLGVBQWUsVUFBVSxVQUFVLFNBQVMsQ0FBQztBQUNuRCxRQUFNLGFBQWEsb0JBQW9CLFlBQVk7QUFDbkQsTUFBSSxDQUFDLFdBQVksUUFBTztBQUV4QixNQUFJLGNBQWMsY0FBYyxXQUFXLFVBQVU7QUFDcEQsYUFBUyxJQUFJLFVBQVUsU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQy9DLFlBQU0sV0FBVyxVQUFVLENBQUM7QUFDNUIsVUFBSSxTQUFTLFNBQVMsR0FBRyxFQUFHLFFBQU87QUFHbkMsVUFBSSxXQUFXLFNBQVMsU0FBUyxVQUFVLENBQUMsQ0FBQyxHQUFHO0FBQy9DLGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRDtBQUFBLEVBQ0Q7QUFFQSxNQUFJLGdCQUFnQixjQUFjLFdBQVcsV0FBVyxTQUFTLFNBQVMsR0FBRztBQUM1RSxVQUFNQyxTQUFRLFlBQVksTUFBTSxTQUFTLFFBQVEsU0FBUyxNQUFNLE1BQU0sU0FBUztBQUMvRSxVQUFNLFdBQVcsZUFDZCxNQUFNLFlBQVksUUFBUSxZQUFZLE1BQ3RDLE1BQU0sWUFBWTtBQUVyQixXQUFPLEdBQUdBLE1BQUssOEJBQThCLFFBQVE7QUFBQSxFQUN0RDtBQUVBLFNBQU87QUFDUjtBQVdPLFNBQVMseUJBQXlCLFdBQVcsWUFBWSxXQUFXLFlBQVk7QUFDdEYsTUFBSSxVQUFVLFNBQVMsR0FBRyxLQUFLLFlBQVksU0FBUyxHQUFHLEVBQUcsUUFBTztBQUVqRSxNQUFJLGVBQWUsV0FBWSxRQUFPO0FBRXRDLFFBQU0sYUFBYSxvQkFBb0IsVUFBVTtBQUVqRCxRQUFNQSxTQUFRLFlBQVksTUFBTSxTQUFTLFFBQVEsU0FBUyxNQUFNLE1BQU0sU0FBUztBQUMvRSxRQUFNLFNBQVMsYUFBYSxNQUFNLFVBQVUsUUFBUSxVQUFVLE1BQU0sTUFBTSxVQUFVO0FBRXBGLE1BQUksWUFBWTtBQUNmLFFBQUksWUFBWSxjQUFjLFdBQVcsT0FBTyxTQUFTLFNBQVMsR0FBRztBQUNwRSxhQUFPLEdBQUdBLE1BQUssZ0NBQWdDLE1BQU07QUFBQSxJQUN0RDtBQUVBLFFBQUksZ0JBQWdCLGNBQWMsV0FBVyxXQUFXLFNBQVMsU0FBUyxHQUFHO0FBQzVFLGFBQU8sR0FBR0EsTUFBSyx5QkFBeUIsTUFBTTtBQUFBLElBQy9DO0FBRUEsUUFBSSxVQUFVLGNBQWMsV0FBVyxNQUFNO0FBQzVDLFVBQUksV0FBVyxLQUFLLFNBQVMsU0FBUyxHQUFHO0FBQ3hDLGVBQU87QUFBQSxNQUNSLE9BQU87QUFDTixlQUFPLEdBQUdBLE1BQUsseUJBQXlCLE1BQU0sUUFBUSxVQUFVLG1DQUFtQyxXQUFXLEtBQUssSUFBSSxDQUFDLE1BQU0sTUFBTSxDQUFDLEtBQUssRUFBRSxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ3ZKO0FBQUEsSUFDRDtBQUFBLEVBQ0Q7QUFNQSxVQUFRLFdBQVc7QUFBQSxJQUNsQixLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQ0osYUFBTyxHQUFHQSxNQUFLLHlCQUF5QixNQUFNO0FBQUEsSUFDL0MsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUNKLGFBQU8sR0FBR0EsTUFBSyw4Q0FBOEMsTUFBTTtBQUFBLElBQ3BFLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFDSixhQUFPLEdBQUdBLE1BQUssMkNBQTJDLE1BQU07QUFBQSxJQUNqRSxLQUFLO0FBQ0osYUFBTyxtRkFBbUYsTUFBTTtBQUFBLEVBQ2xHO0FBRUEsU0FBTztBQUNSO0FBL09BLElBTU0sc0JBMEVBO0FBaEZOO0FBQUE7QUFNQSxJQUFNLHVCQUF1QjtBQUFBO0FBQUEsTUFFNUIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEVBQUU7QUFBQTtBQUFBLE1BRXJCLElBQUksRUFBRSxZQUFZLENBQUMsTUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2pELElBQUksRUFBRSxZQUFZLENBQUMsTUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2pELEdBQUc7QUFBQSxRQUNGLFlBQVk7QUFBQSxVQUNYO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNEO0FBQUEsTUFDRDtBQUFBLE1BQ0EsSUFBSSxFQUFFLFlBQVksQ0FBQyxNQUFNLElBQUksRUFBRTtBQUFBLE1BQy9CLElBQUksRUFBRSxZQUFZLENBQUMsTUFBTSxJQUFJLEVBQUU7QUFBQSxNQUMvQixVQUFVLEVBQUUsWUFBWSxDQUFDLFVBQVUsRUFBRTtBQUFBLE1BQ3JDLFFBQVEsRUFBRSxZQUFZLENBQUMsVUFBVSxVQUFVLEVBQUU7QUFBQSxNQUM3QyxPQUFPLEVBQUUsUUFBUSxDQUFDLFNBQVMsT0FBTyxFQUFFO0FBQUEsTUFDcEMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxTQUFTLE9BQU8sRUFBRTtBQUFBLE1BQ3BDLE9BQU8sRUFBRSxRQUFRLENBQUMsT0FBTyxFQUFFO0FBQUEsTUFDM0IsSUFBSSxFQUFFLFFBQVEsQ0FBQyxNQUFNLE9BQU8sRUFBRTtBQUFBLE1BQzlCLElBQUksRUFBRSxRQUFRLENBQUMsTUFBTSxNQUFNLElBQUksRUFBRTtBQUFBLE1BQ2pDLElBQUksRUFBRSxRQUFRLENBQUMsTUFBTSxNQUFNLElBQUksRUFBRTtBQUFBLElBQ2xDO0FBMkJBLElBQU0sc0JBQXNCO0FBQUEsTUFDM0IsR0FBRztBQUFBLE1BQ0gsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVLE9BQU8sRUFBRTtBQUFBO0FBQUEsTUFFdEMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxPQUFPLEVBQUU7QUFBQSxNQUMxQixNQUFNLEVBQUUsWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUFBLE1BQzdCLEdBQUcsRUFBRSxZQUFZLENBQUMsR0FBRyxFQUFFO0FBQUEsTUFDdkIsUUFBUSxFQUFFLFlBQVksQ0FBQyxRQUFRLEVBQUU7QUFBQSxNQUNqQyxJQUFJLEVBQUUsWUFBWSxDQUFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxJQUFJLEVBQUU7QUFBQSxNQUN2RCxJQUFJLEVBQUUsWUFBWSxDQUFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxJQUFJLEVBQUU7QUFBQSxNQUN2RCxJQUFJLEVBQUUsWUFBWSxDQUFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxJQUFJLEVBQUU7QUFBQSxNQUN2RCxJQUFJLEVBQUUsWUFBWSxDQUFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxJQUFJLEVBQUU7QUFBQSxNQUN2RCxJQUFJLEVBQUUsWUFBWSxDQUFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxJQUFJLEVBQUU7QUFBQSxNQUN2RCxJQUFJLEVBQUUsWUFBWSxDQUFDLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxJQUFJLEVBQUU7QUFBQTtBQUFBLE1BRXZELFFBQVEsRUFBRSxNQUFNLENBQUMsVUFBVSxZQUFZLFNBQVMsTUFBTSxVQUFVLFVBQVUsRUFBRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVE1RSxJQUFJLEVBQUUsTUFBTSxDQUFDLE1BQU0sTUFBTSxTQUFTLFVBQVUsVUFBVSxFQUFFO0FBQUE7QUFBQSxNQUV4RCxPQUFPLEVBQUUsTUFBTSxDQUFDLE1BQU0sU0FBUyxVQUFVLFVBQVUsRUFBRTtBQUFBLE1BQ3JELE9BQU8sRUFBRSxNQUFNLENBQUMsTUFBTSxTQUFTLFVBQVUsVUFBVSxFQUFFO0FBQUEsTUFDckQsT0FBTyxFQUFFLE1BQU0sQ0FBQyxNQUFNLFNBQVMsVUFBVSxVQUFVLEVBQUU7QUFBQTtBQUFBLE1BRXJELFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxVQUFVLEVBQUU7QUFBQTtBQUFBLE1BRXRD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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJDTmhDO1VBQWlCLFlBQUEsUUFBQSxLQUFBLGFBQUEsU0FBQSxTQUFBLFlBQUEsR0FBQSxXQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQ0E2SlcsUUFBUSxDQUFBLHNDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBekIxSjVCLElBQU0sVUFBVSxDQUFDLG1CQUFRLG9CQUFRLHlCQUFRLGlCQUFRLDRCQUFRLGdCQUFRLGdCQUFRLHVCQUFRLHFCQUFRLGtCQUFRLDRCQUFTLHFCQUFRO0FBRWxILElBQU8sWUFBUTtBQUNSLElBQU0sWUFBWSxDQUFDLDhCQUE2QiwrQkFBOEIsb0NBQW1DLDRCQUEyQix1Q0FBc0MsMkJBQTBCLDJCQUEwQixrQ0FBaUMsZ0NBQStCLDZCQUE0Qix1Q0FBc0MsNENBQTRDOzs7QURMbmEseUJBQXdCO0FBRWpCLElBQU1DLGNBQVMsOEJBQVUsU0FBVTsiLAogICJuYW1lcyI6IFsiZXNjYXBlZCIsICJjbHN4IiwgImhhc2giLCAia2V5IiwgImZhbGxiYWNrIiwgImVsZW1lbnQiLCAiaW5pdF9jb25zdGFudHMiLCAiY29tcG9uZW50IiwgImtleSIsICJpbml0X2Vycm9ycyIsICJsb2NhdGlvbiIsICJodG1sIiwgInByb3AiLCAiY2hpbGQiLCAibmV4dCIsICJpbml0X2NvbnN0YW50cyIsICJ0YWciLCAiYm9sZCIsICJub3JtYWwiLCAiaW5pdF93YXJuaW5ncyIsICJlbGVtZW50IiwgImtleSIsICJpbml0X3dhcm5pbmdzIiwgInRyYWNlIiwgInNvdXJjZSIsICJpbml0X2NvbnN0YW50cyIsICJzdGFjayIsICJjb250ZXh0IiwgInN0YWNrIiwgImNvbXBvbmVudCIsICJpbml0X2Vycm9ycyIsICJpbml0X2NvbnN0YW50cyIsICJlZmZlY3QiLCAiY29udGV4dCIsICJpbml0X2NvbnN0YW50cyIsICJzb3VyY2UiLCAic3RhY2siLCAidXBkYXRlIiwgImVmZmVjdCIsICJlIiwgImZsYWdzIiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfZXJyb3JzIiwgImNoaWxkIiwgImJvdW5kYXJ5IiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfZXJyb3JzIiwgImNvbW1lbnQiLCAicGVuZGluZyIsICJyZXNldCIsICJlcnJvciIsICJzdGF0ZSIsICJpIiwgImZsYWdzIiwgImZhbGxiYWNrIiwgImVmZmVjdCIsICJrZXkiLCAiaXRlbSIsICJzZWVuIiwgIm5leHQiLCAiaW5kZXgiLCAiaW5pdF9jb25zdGFudHMiLCAiYXN5bmMiLCAicnVuIiwgInByZXZpb3VzX2JhdGNoIiwgImJvdW5kYXJ5IiwgImhhbmRsZV9lcnJvciIsICJpbml0X2NvbnN0YW50cyIsICJmbGFncyIsICJsb2NhdGlvbiIsICJib3VuZGFyeSIsICJkIiwgIm5leHQiLCAiZGVyaXZlZCIsICJpbml0X2NvbnN0YW50cyIsICJpbml0X2Vycm9ycyIsICJzdGFjayIsICJzb3VyY2UiLCAiZWZmZWN0IiwgImZsYWdzIiwgImRlcml2ZWQiLCAiaW5pdF9jb25zdGFudHMiLCAiaW5pdF9lcnJvcnMiLCAic3RhY2siLCAidmVyc2lvbiIsICJwcm9wIiwgInNvdXJjZSIsICJzIiwgInZhbHVlIiwgImtleSIsICJpbml0X2NvbnN0YW50cyIsICJpbml0X2Vycm9ycyIsICJhcnJheV9wcm90b3R5cGUiLCAiaW5kZXgiLCAiZXF1YWxzIiwgImluaXRfZXF1YWxpdHkiLCAiaW5pdF9vcGVyYXRpb25zIiwgImNoaWxkIiwgInRleHQiLCAiZmxhZ3MiLCAidGFnIiwgImlzIiwgImVsZW1lbnQiLCAia2V5IiwgImluaXRfZXF1YWxpdHkiLCAiaW5pdF9jb25zdGFudHMiLCAibmFtZSIsICJlbGVtZW50IiwgImV2ZW50IiwgImVmZmVjdCIsICJlIiwgImRlcml2ZWQiLCAiZmxhZ3MiLCAiY29udGV4dCIsICJhc3luYyIsICJ0ZWFyZG93biIsICJjb250cm9sbGVyIiwgIm5leHQiLCAidHJhbnNpdGlvbiIsICJjaGlsZCIsICJzaWJsaW5nIiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfZXJyb3JzIiwgImVmZmVjdCIsICJmbGFncyIsICJpbmRleCIsICJ0ZWFyZG93biIsICJ0cmFjZSIsICJkZXJpdmVkIiwgImtleSIsICJwcm9wIiwgImdldCIsICJpbml0X2NvbnN0YW50cyIsICJoYXNoIiwgImxvY2F0aW9uIiwgImluaXRfdXRpbHMiLCAibG9jYXRpb24iLCAiaW5pdF91dGlscyIsICJoYXNoIiwgImVsZW1lbnQiLCAibG9jYXRpb24iLCAiY29tbWVudCIsICJpbml0X2NvbnN0YW50cyIsICJldmVudCIsICJjYXB0dXJlIiwgInBhc3NpdmUiLCAiZWxlbWVudCIsICJjb21wb25lbnQiLCAibG9jYXRpb24iLCAiaHRtbCIsICJlZmZlY3QiLCAiZmxhZ3MiLCAiY2xvbmUiLCAiYXR0cmlidXRlcyIsICJlbGVtZW50IiwgImtleSIsICJpbml0X2NvbnN0YW50cyIsICJ0ZXh0IiwgImNvbXBvbmVudCIsICJpbml0X29wZXJhdGlvbnMiLCAiY29udGV4dCIsICJldmVudHMiLCAicGFzc2l2ZSIsICJ1bm1vdW50IiwgImFuY2hvcl9ub2RlIiwgImluaXRfZXJyb3JzIiwgImluaXRfdXRpbHMiLCAiaW5pdF9jb25zdGFudHMiLCAiZWZmZWN0IiwgInNvdXJjZSIsICJjb21wb25lbnQiLCAiaW5pdF9jb25zdGFudHMiLCAiY29tcG9uZW50IiwgInByb3AiLCAibG9jYXRpb24iLCAia2V5IiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfdXRpbHMiLCAiY29tcG9uZW50IiwgImluaXRfbGVnYWN5IiwgImluaXRfZXJyb3JzIiwgInN0YWNrIiwgImJvdW5kYXJ5IiwgImluaXRfYXN5bmMiLCAiaW5pdF9lcnJvcnMiLCAidHJhbnNpdGlvbiIsICJrZXkiLCAib2Zmc2NyZWVuIiwgImVmZmVjdCIsICJicmFuY2giLCAidiIsICJmbGFncyIsICJmbiIsICJpbml0X2NvbnN0YW50cyIsICJrZXkiLCAiZWxlbWVudCIsICJrZXkiLCAiZWxlbWVudCIsICJsb2NhdGlvbiIsICJlZmZlY3QiLCAiaGFzaCIsICJuZXh0IiwgImh0bWwiLCAibm9kZSIsICJpbml0X3V0aWxzIiwgImluaXRfY29uc3RhbnRzIiwgImtleSIsICJ0YWciLCAiaW5pdF91dGlscyIsICJpbml0X3dhcm5pbmdzIiwgInNuaXBwZXQiLCAiY29tcG9uZW50IiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfZXJyb3JzIiwgImNvbXBvbmVudCIsICJpbml0X2NvbnN0YW50cyIsICJsb2NhdGlvbiIsICJlbGVtZW50IiwgImFuY2hvciIsICJpbml0X2NvbnN0YW50cyIsICJpbml0X3V0aWxzIiwgImhhc2giLCAiaW5pdF9jb25zdGFudHMiLCAiYXBwZW5kX3N0eWxlcyIsICJpbml0X2NzcyIsICJhY3Rpb24iLCAiaW5pdF9hdHRhY2htZW50cyIsICJoYXNoIiwgImtleSIsICJuZXh0IiwgImtleSIsICJpbml0X3NlbGVjdCIsICJnZXQiLCAic2V0IiwgImJhdGNoZXMiLCAic2V0X2F0dHJpYnV0ZSIsICJlbGVtZW50IiwgImF0dHJpYnV0ZXMiLCAicHJvcCIsICJuZXh0IiwgImtleSIsICJjbHN4IiwgImlucHV0IiwgImFzeW5jIiwgImluaXRfc2VsZWN0IiwgImluaXRfYXR0cmlidXRlcyIsICJpbml0X2NvbnN0YW50cyIsICJpbml0X3V0aWxzIiwgImluaXRfYXR0YWNobWVudHMiLCAibm93IiwgImVsZW1lbnQiLCAiYW5pbWF0aW9uIiwgInRvIiwgImZsYWdzIiwgInRyYW5zaXRpb24iLCAicnVuIiwgImJsb2NrIiwgImFib3J0ZWQiLCAidGljayIsICJrZXlmcmFtZXMiLCAic3R5bGVzIiwgInQiLCAiaW5pdF9jb25zdGFudHMiLCAidXBkYXRlIiwgImV2ZW50IiwgImdldCIsICJzZXQiLCAiYmF0Y2hlcyIsICJoeWRyYXRpb25fbWlzbWF0Y2giLCAiaW5kZXgiLCAicGVuZGluZyIsICJpbnB1dCIsICJpbml0X2Vycm9ycyIsICJnZXQiLCAic2V0IiwgInVwZGF0ZSIsICJ1cGRhdGUiLCAicHJvcCIsICJlbGVtZW50IiwgInNldCIsICJsaXN0ZW5lcnMiLCAidXBkYXRlIiwgImluaXRfY29uc3RhbnRzIiwgImVsZW1lbnQiLCAiZ2V0IiwgInNldCIsICJnZXQiLCAic2V0IiwgImV2ZW50IiwgInNlbGYiLCAiY29udGV4dCIsICJwcm9wcyIsICJrZXkiLCAiZXZlbnQiLCAia2V5IiwgImluaXRfbWlzYyIsICJnZXQiLCAiaW5pdF9zaGFyZWQiLCAiaW5pdF91dGlscyIsICJnZXQiLCAiaW5pdF91dGlscyIsICJpbml0X3NoYXJlZCIsICJrZXkiLCAiZmxhZ3MiLCAiZmFsbGJhY2siLCAiaW5pdF9wcm9wcyIsICJpbml0X2Vycm9ycyIsICJpbml0X2NvbnN0YW50cyIsICJrZXkiLCAiZWZmZWN0IiwgImxvY2F0aW9uIiwgImluaXRfdmFsaWRhdGUiLCAiaW5pdF9lcnJvcnMiLCAiaW5pdF9jb25zdGFudHMiLCAiaW5pdF9lcnJvcnMiLCAia2V5IiwgInByb3AiLCAibmV4dCIsICJldmVudCIsICJwcm9wIiwgImVsZW1lbnQiLCAiZXhwb3J0cyIsICJrZXkiLCAiY29tcG9uZW50IiwgInNsb3QiLCAiYXR0ciIsICJpbml0X2NvbnN0YW50cyIsICJhcHBlbmRfc3R5bGVzIiwgImNsc3giLCAiZXF1YWxzIiwgImluaXRfc2VsZWN0IiwgInJ1biIsICJzZWxmIiwgInNldF9hdHRyaWJ1dGUiLCAiaW5pdF9sZWdhY3kiLCAiaW5pdF9hc3luYyIsICJpbml0X2NzcyIsICJpbml0X2F0dGFjaG1lbnRzIiwgImluaXRfYXR0cmlidXRlcyIsICJpbml0X21pc2MiLCAiaW5pdF9wcm9wcyIsICJpbml0X3ZhbGlkYXRlIiwgImluaXRfZXF1YWxpdHkiLCAiaW5pdF9lcnJvcnMiLCAiaW5pdF9lcnJvcnMiLCAicnVuIiwgImluaXRfdXRpbHMiLCAiaW5pdF9oeWRyYXRpb24iLCAiaW5pdF9jb25zdGFudHMiLCAia2V5IiwgInN0YWNrIiwgImluaXRfZXJyb3JzIiwgImNyZWF0ZUNvbnRleHQiLCAia2V5IiwgImdldENvbnRleHQiLCAiY29udGV4dCIsICJzZXRDb250ZXh0IiwgImhhc0NvbnRleHQiLCAiZ2V0QWxsQ29udGV4dHMiLCAicHVzaCIsICJwb3AiLCAic3NyX2NvbnRleHQiLCAiaW5pdF9jb250ZXh0IiwgImluaXRfZXJyb3JzIiwgImtleSIsICJzdGFjayIsICJib2xkIiwgIm5vcm1hbCIsICJpbml0X3dhcm5pbmdzIiwgImluaXRfcmVuZGVyX2NvbnRleHQiLCAiaW5pdF9lcnJvcnMiLCAiaW5pdF9jb250ZXh0IiwgImluaXRfZXJyb3JzIiwgImluaXRfd2FybmluZ3MiLCAiaW5pdF9oeWRyYXRpb24iLCAiaGVhZCIsICJjb250ZXh0IiwgImNoaWxkIiwgInB1c2giLCAicG9wIiwgImZsYWdzIiwgImJvZHkiLCAiciIsICJjb21wb25lbnQiLCAiYXN5bmMiLCAicmVzdWx0IiwgImluaXRfcmVuZGVyX2NvbnRleHQiLCAia2V5IiwgImhhc2giLCAiaW5pdF9odG1sIiwgImluaXRfdXRpbHMiLCAiY2hpbGQiLCAiciIsICJ0YWciLCAiY29udGV4dCIsICJlbGVtZW50IiwgIm1lc3NhZ2UiLCAic3RhY2siLCAiaW5pdF9kZXYiLCAiaW5pdF9jb250ZXh0IiwgImluaXRfZXJyb3JzIiwgImVsZW1lbnQiLCAidGFnIiwgImNvbXBvbmVudCIsICJmbGFncyIsICJjbHN4IiwgInNwcmVhZF9wcm9wcyIsICJrZXkiLCAiaGFzaCIsICJzbG90IiwgInJlc3RfcHJvcHMiLCAiaW5pdF91dGlscyIsICJpbml0X2h5ZHJhdGlvbiIsICJpbml0X2h0bWwiLCAiaW5pdF9jb250ZXh0IiwgImluaXRfZGV2IiwgImdldF90eXBlIiwgImtleSIsICJpbml0X3V0aWxzIiwgInN0ciIsICJ2YWx1ZSIsICJnZXRfdHlwZSIsICJrZXkiLCAic3RyaW5naWZ5IiwgImtleXMiLCAiaW5pdF91dGlscyIsICJoeWRyYXRhYmxlIiwgImtleSIsICJjb21wYXJlIiwgInZhbHVlIiwgInVuZXZhbCIsICJpc19wcm9taXNlIiwgInN0YWNrIiwgImluaXRfaHlkcmF0YWJsZSIsICJpbml0X2Vycm9ycyIsICJpbml0X2RldiIsICJjcmVhdGVSYXdTbmlwcGV0IiwgImluaXRfc25pcHBldCIsICJjcmVhdGVDb250ZXh0IiwgImNyZWF0ZVJhd1NuaXBwZXQiLCAiZm9yayIsICJnZXRBbGxDb250ZXh0cyIsICJnZXRDb250ZXh0IiwgImhhc0NvbnRleHQiLCAiaHlkcmF0YWJsZSIsICJoeWRyYXRlIiwgIm1vdW50IiwgInNldENvbnRleHQiLCAic2V0dGxlZCIsICJ0aWNrIiwgInVubW91bnQiLCAiaW5pdF9jb250ZXh0IiwgImluaXRfZXJyb3JzIiwgImluaXRfaHlkcmF0YWJsZSIsICJpbml0X3NuaXBwZXQiLCAiX19leHBvcnQiLCAiU29ja2V0IiwgIm1vZHVsZSIsICJfX3RvQ29tbW9uSlMiLCAiY2xvc3VyZSIsICJldmVudCIsICJjb250cm9sbGVyIiwgImtleSIsICJzdGF0ZSIsICJmYWxsYmFjayIsICJzZXJ2ZXJfZXhwb3J0cyIsICJpbml0X3NlcnZlciIsICJfX2V4cG9ydCIsICJnZXRSZW5kZXIiLCAibW9kdWxlIiwgIl9fdG9Db21tb25KUyIsICJpbmRleCIsICJpbXBvcnRfc2VydmVyIiwgImltcG9ydF9zdmVsdGUiLCAiciIsICJzbmlwcGV0IiwgIm5hbWUiLCAiZWxlbWVudCIsICJpbXBvcnRfc3ZlbHRlMiIsICJrZXkiLCAic3RhdGUiLCAic2VydmVyX2V4cG9ydHMiLCAicmVuZGVyIiwgImluZGV4IiwgInRhZyIsICJ0ZXh0IiwgImV2ZW50IiwgImluZGV4IiwgInVzZXJJZCIsICJpbmNyZW1lbnQiLCAiZXZlbnQiLCAiZXZlbnQiLCAicmVuZGVyIl0KfQo=
