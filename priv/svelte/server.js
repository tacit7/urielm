var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE, EACH_INDEX_REACTIVE, EACH_IS_CONTROLLED, EACH_IS_ANIMATED, EACH_ITEM_IMMUTABLE, PROPS_IS_IMMUTABLE, PROPS_IS_RUNES, PROPS_IS_UPDATED, PROPS_IS_BINDABLE, PROPS_IS_LAZY_INITIAL, TRANSITION_IN, TRANSITION_OUT, TRANSITION_GLOBAL, TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE, TEMPLATE_USE_SVG, TEMPLATE_USE_MATHML, HYDRATION_START, HYDRATION_START_ELSE, HYDRATION_END, HYDRATION_ERROR, ELEMENT_IS_NAMESPACED, ELEMENT_PRESERVE_ATTRIBUTE_CASE, ELEMENT_IS_INPUT, UNINITIALIZED, FILENAME, HMR, NAMESPACE_HTML, NAMESPACE_SVG, NAMESPACE_MATHML, ATTACHMENT_KEY;
var init_constants = __esm({
  "node_modules/svelte/src/constants.js"() {
    EACH_ITEM_REACTIVE = 1;
    EACH_INDEX_REACTIVE = 1 << 1;
    EACH_IS_CONTROLLED = 1 << 2;
    EACH_IS_ANIMATED = 1 << 3;
    EACH_ITEM_IMMUTABLE = 1 << 4;
    PROPS_IS_IMMUTABLE = 1;
    PROPS_IS_RUNES = 1 << 1;
    PROPS_IS_UPDATED = 1 << 2;
    PROPS_IS_BINDABLE = 1 << 3;
    PROPS_IS_LAZY_INITIAL = 1 << 4;
    TRANSITION_IN = 1;
    TRANSITION_OUT = 1 << 1;
    TRANSITION_GLOBAL = 1 << 2;
    TEMPLATE_FRAGMENT = 1;
    TEMPLATE_USE_IMPORT_NODE = 1 << 1;
    TEMPLATE_USE_SVG = 1 << 2;
    TEMPLATE_USE_MATHML = 1 << 3;
    HYDRATION_START = "[";
    HYDRATION_START_ELSE = "[!";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    ELEMENT_IS_NAMESPACED = 1;
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    ELEMENT_IS_INPUT = 1 << 2;
    UNINITIALIZED = Symbol();
    FILENAME = Symbol("filename");
    HMR = Symbol("hmr");
    NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
    NAMESPACE_SVG = "http://www.w3.org/2000/svg";
    NAMESPACE_MATHML = "http://www.w3.org/1998/Math/MathML";
    ATTACHMENT_KEY = "@attach";
  }
});

// node_modules/svelte/src/escaping.js
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped2 = "";
  let last = 0;
  while (pattern.test(str)) {
    const i = pattern.lastIndex - 1;
    const ch = str[i];
    escaped2 += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped2 + str.substring(last);
}
var ATTR_REGEX, CONTENT_REGEX;
var init_escaping = __esm({
  "node_modules/svelte/src/escaping.js"() {
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
  }
});

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
  }
});

// node_modules/svelte/src/internal/shared/attributes.js
function attr(name, value, is_boolean = false) {
  if (name === "hidden" && value !== "until-found") {
    is_boolean = true;
  }
  if (value == null || !value && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value) || value;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
function clsx2(value) {
  if (typeof value === "object") {
    return clsx(value);
  } else {
    return value ?? "";
  }
}
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i = 0; i < len; i++) {
        var c = value[i];
        if (in_comment) {
          if (c === "/" && value[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c) {
            in_str = false;
          }
        } else if (c === "/" && value[i + 1] === "*") {
          in_comment = true;
        } else if (c === '"' || c === "'") {
          in_str = c;
        } else if (c === "(") {
          in_apo++;
        } else if (c === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c === ":" && name_index === -1) {
            name_index = i;
          } else if (c === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c !== ";") {
                  i++;
                }
                var property = value.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}
var replacements, whitespace;
var init_attributes = __esm({
  "node_modules/svelte/src/internal/shared/attributes.js"() {
    init_escaping();
    init_clsx();
    replacements = {
      translate: /* @__PURE__ */ new Map([
        [true, "yes"],
        [false, "no"]
      ])
    };
    whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
  }
});

// node_modules/svelte/src/internal/shared/utils.js
function is_function(thing) {
  return typeof thing === "function";
}
function is_promise(value) {
  return typeof value?.then === "function";
}
function run(fn) {
  return fn();
}
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function fallback(value, fallback2, lazy = false) {
  return value === void 0 ? lazy ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value;
}
function to_array(value, n) {
  if (Array.isArray(value)) {
    return value;
  }
  if (n === void 0 || !(Symbol.iterator in value)) {
    return Array.from(value);
  }
  const array = [];
  for (const element2 of value) {
    array.push(element2);
    if (array.length === n) break;
  }
  return array;
}
var is_array, index_of, array_from, object_keys, define_property, get_descriptor, get_descriptors, object_prototype, array_prototype, get_prototype_of, is_extensible, noop;
var init_utils = __esm({
  "node_modules/svelte/src/internal/shared/utils.js"() {
    is_array = Array.isArray;
    index_of = Array.prototype.indexOf;
    array_from = Array.from;
    object_keys = Object.keys;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    get_descriptors = Object.getOwnPropertyDescriptors;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    is_extensible = Object.isExtensible;
    noop = () => {
    };
  }
});

// node_modules/esm-env/false.js
var false_default;
var init_false = __esm({
  "node_modules/esm-env/false.js"() {
    false_default = false;
  }
});

// node_modules/esm-env/true.js
var true_default;
var init_true = __esm({
  "node_modules/esm-env/true.js"() {
    true_default = true;
  }
});

// node_modules/esm-env/index.js
var init_esm_env = __esm({
  "node_modules/esm-env/index.js"() {
    init_false();
    init_true();
    init_true();
  }
});

// node_modules/svelte/src/internal/client/constants.js
var DERIVED, EFFECT, RENDER_EFFECT, MANAGED_EFFECT, BLOCK_EFFECT, BRANCH_EFFECT, ROOT_EFFECT, BOUNDARY_EFFECT, CONNECTED, CLEAN, DIRTY, MAYBE_DIRTY, INERT, DESTROYED, EFFECT_RAN, EFFECT_TRANSPARENT, EAGER_EFFECT, HEAD_EFFECT, EFFECT_PRESERVED, USER_EFFECT, WAS_MARKED, REACTION_IS_UPDATING, ASYNC, ERROR_VALUE, STATE_SYMBOL, LEGACY_PROPS, LOADING_ATTR_SYMBOL, PROXY_PATH_SYMBOL, STALE_REACTION, ELEMENT_NODE, TEXT_NODE, COMMENT_NODE, DOCUMENT_FRAGMENT_NODE;
var init_constants2 = __esm({
  "node_modules/svelte/src/internal/client/constants.js"() {
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    RENDER_EFFECT = 1 << 3;
    MANAGED_EFFECT = 1 << 24;
    BLOCK_EFFECT = 1 << 4;
    BRANCH_EFFECT = 1 << 5;
    ROOT_EFFECT = 1 << 6;
    BOUNDARY_EFFECT = 1 << 7;
    CONNECTED = 1 << 9;
    CLEAN = 1 << 10;
    DIRTY = 1 << 11;
    MAYBE_DIRTY = 1 << 12;
    INERT = 1 << 13;
    DESTROYED = 1 << 14;
    EFFECT_RAN = 1 << 15;
    EFFECT_TRANSPARENT = 1 << 16;
    EAGER_EFFECT = 1 << 17;
    HEAD_EFFECT = 1 << 18;
    EFFECT_PRESERVED = 1 << 19;
    USER_EFFECT = 1 << 20;
    WAS_MARKED = 1 << 15;
    REACTION_IS_UPDATING = 1 << 21;
    ASYNC = 1 << 22;
    ERROR_VALUE = 1 << 23;
    STATE_SYMBOL = Symbol("$state");
    LEGACY_PROPS = Symbol("legacy props");
    LOADING_ATTR_SYMBOL = Symbol("");
    PROXY_PATH_SYMBOL = Symbol("proxy path");
    STALE_REACTION = new class StaleReactionError extends Error {
      name = "StaleReactionError";
      message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
    }();
    ELEMENT_NODE = 1;
    TEXT_NODE = 3;
    COMMENT_NODE = 8;
    DOCUMENT_FRAGMENT_NODE = 11;
  }
});

// node_modules/svelte/src/internal/shared/errors.js
function experimental_async_required(name) {
  if (true_default) {
    const error = new Error(`experimental_async_required
Cannot use \`${name}(...)\` unless the \`experimental.async\` compiler option is \`true\`
https://svelte.dev/e/experimental_async_required`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/experimental_async_required`);
  }
}
function invalid_default_snippet() {
  if (true_default) {
    const error = new Error(`invalid_default_snippet
Cannot use \`{@render children(...)}\` if the parent component uses \`let:\` directives. Consider using a named snippet instead
https://svelte.dev/e/invalid_default_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_default_snippet`);
  }
}
function invalid_snippet_arguments() {
  if (true_default) {
    const error = new Error(`invalid_snippet_arguments
A snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`
https://svelte.dev/e/invalid_snippet_arguments`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
  }
}
function lifecycle_outside_component(name) {
  if (true_default) {
    const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
function snippet_without_render_tag() {
  if (true_default) {
    const error = new Error(`snippet_without_render_tag
Attempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.
https://svelte.dev/e/snippet_without_render_tag`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
  }
}
function store_invalid_shape(name) {
  if (true_default) {
    const error = new Error(`store_invalid_shape
\`${name}\` is not a store with a \`subscribe\` method
https://svelte.dev/e/store_invalid_shape`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/store_invalid_shape`);
  }
}
function svelte_element_invalid_this_value() {
  if (true_default) {
    const error = new Error(`svelte_element_invalid_this_value
The \`this\` prop on \`<svelte:element>\` must be a string, if defined
https://svelte.dev/e/svelte_element_invalid_this_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
  }
}
var init_errors = __esm({
  "node_modules/svelte/src/internal/shared/errors.js"() {
    init_esm_env();
  }
});

// node_modules/svelte/src/internal/client/errors.js
function async_derived_orphan() {
  if (true_default) {
    const error = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
function bind_invalid_checkbox_value() {
  if (true_default) {
    const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
  }
}
function component_api_changed(method, component2) {
  if (true_default) {
    const error = new Error(`component_api_changed
Calling \`${method}\` on a component instance (of ${component2}) is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_changed`);
  }
}
function component_api_invalid_new(component2, name) {
  if (true_default) {
    const error = new Error(`component_api_invalid_new
Attempted to instantiate ${component2} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
  }
}
function derived_references_self() {
  if (true_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function each_key_duplicate(a, b, value) {
  if (true_default) {
    const error = new Error(`each_key_duplicate
${value ? `Keyed each block has duplicate key \`${value}\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}
https://svelte.dev/e/each_key_duplicate`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/each_key_duplicate`);
  }
}
function effect_in_teardown(rune) {
  if (true_default) {
    const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
function effect_in_unowned_derived() {
  if (true_default) {
    const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
function effect_orphan(rune) {
  if (true_default) {
    const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
function effect_pending_outside_reaction() {
  if (true_default) {
    const error = new Error(`effect_pending_outside_reaction
\`$effect.pending()\` can only be called inside an effect or derived
https://svelte.dev/e/effect_pending_outside_reaction`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_pending_outside_reaction`);
  }
}
function effect_update_depth_exceeded() {
  if (true_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function hydration_failed() {
  if (true_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function invalid_snippet() {
  if (true_default) {
    const error = new Error(`invalid_snippet
Could not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`
https://svelte.dev/e/invalid_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet`);
  }
}
function props_invalid_value(key2) {
  if (true_default) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key2}={undefined}\` when \`${key2}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
function props_rest_readonly(property) {
  if (true_default) {
    const error = new Error(`props_rest_readonly
Rest element properties of \`$props()\` such as \`${property}\` are readonly
https://svelte.dev/e/props_rest_readonly`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_rest_readonly`);
  }
}
function rune_outside_svelte(rune) {
  if (true_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function state_descriptors_fixed() {
  if (true_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (true_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (true_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (true_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
var init_errors2 = __esm({
  "node_modules/svelte/src/internal/client/errors.js"() {
    init_esm_env();
    init_errors();
  }
});

// node_modules/svelte/src/internal/client/warnings.js
function assignment_value_stale(property, location) {
  if (true_default) {
    console.warn(`%c[svelte] assignment_value_stale
%cAssignment to \`${property}\` property (${location}) will evaluate to the right-hand side, not the value of \`${property}\` following the assignment. This may result in unexpected behaviour.
https://svelte.dev/e/assignment_value_stale`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/assignment_value_stale`);
  }
}
function await_waterfall(name, location) {
  if (true_default) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
function binding_property_non_reactive(binding, location) {
  if (true_default) {
    console.warn(
      `%c[svelte] binding_property_non_reactive
%c${location ? `\`${binding}\` (${location}) is binding to a non-reactive property` : `\`${binding}\` is binding to a non-reactive property`}
https://svelte.dev/e/binding_property_non_reactive`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/binding_property_non_reactive`);
  }
}
function console_log_state(method) {
  if (true_default) {
    console.warn(`%c[svelte] console_log_state
%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead
https://svelte.dev/e/console_log_state`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/console_log_state`);
  }
}
function event_handler_invalid(handler, suggestion) {
  if (true_default) {
    console.warn(`%c[svelte] event_handler_invalid
%c${handler} should be a function. Did you mean to ${suggestion}?
https://svelte.dev/e/event_handler_invalid`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/event_handler_invalid`);
  }
}
function hydration_attribute_changed(attribute, html3, value) {
  if (true_default) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html3}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
function hydration_html_changed(location) {
  if (true_default) {
    console.warn(
      `%c[svelte] hydration_html_changed
%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_html_changed`);
  }
}
function hydration_mismatch(location) {
  if (true_default) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (true_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function ownership_invalid_binding(parent, prop2, child2, owner) {
  if (true_default) {
    console.warn(`%c[svelte] ownership_invalid_binding
%c${parent} passed property \`${prop2}\` to ${child2} with \`bind:\`, but its parent component ${owner} did not declare \`${prop2}\` as a binding. Consider creating a binding between ${owner} and ${parent} (e.g. \`bind:${prop2}={...}\` instead of \`${prop2}={...}\`)
https://svelte.dev/e/ownership_invalid_binding`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
  }
}
function ownership_invalid_mutation(name, location, prop2, parent) {
  if (true_default) {
    console.warn(`%c[svelte] ownership_invalid_mutation
%cMutating unbound props (\`${name}\`, at ${location}) is strongly discouraged. Consider using \`bind:${prop2}={...}\` in ${parent} (or using a callback) instead
https://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
  }
}
function select_multiple_invalid_value() {
  if (true_default) {
    console.warn(`%c[svelte] select_multiple_invalid_value
%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.
https://svelte.dev/e/select_multiple_invalid_value`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (true_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function state_proxy_unmount() {
  if (true_default) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
function svelte_boundary_reset_noop() {
  if (true_default) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
var bold, normal;
var init_warnings = __esm({
  "node_modules/svelte/src/internal/client/warnings.js"() {
    init_esm_env();
    bold = "font-weight: bold";
    normal = "font-weight: normal";
  }
});

// node_modules/svelte/src/internal/client/dom/hydration.js
function set_hydrating(value) {
  hydrating = value;
}
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    get_next_sibling(hydrate_node)
  );
}
function reset(node) {
  if (!hydrating) return;
  if (get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
function hydrate_template(template) {
  if (hydrating) {
    hydrate_node = template.content;
  }
}
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    if (remove) node.remove();
    node = next2;
  }
}
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (
    /** @type {Comment} */
    node.data
  );
}
var hydrating, hydrate_node;
var init_hydration = __esm({
  "node_modules/svelte/src/internal/client/dom/hydration.js"() {
    init_constants2();
    init_constants();
    init_warnings();
    init_operations();
    hydrating = false;
  }
});

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
var init_equality = __esm({
  "node_modules/svelte/src/internal/client/reactivity/equality.js"() {
  }
});

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag, legacy_mode_flag, tracing_mode_flag;
var init_flags = __esm({
  "node_modules/svelte/src/internal/flags/index.js"() {
    async_mode_flag = false;
    legacy_mode_flag = false;
    tracing_mode_flag = false;
  }
});

// node_modules/svelte/src/internal/shared/warnings.js
function dynamic_void_element_content(tag2) {
  if (true_default) {
    console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag2}">\` is a void element \u2014 it cannot have content
https://svelte.dev/e/dynamic_void_element_content`, bold2, normal2);
  } else {
    console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
  }
}
function state_snapshot_uncloneable(properties) {
  if (true_default) {
    console.warn(
      `%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` \u2014 the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` \u2014 the original value was returned"}
https://svelte.dev/e/state_snapshot_uncloneable`,
      bold2,
      normal2
    );
  } else {
    console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
  }
}
var bold2, normal2;
var init_warnings2 = __esm({
  "node_modules/svelte/src/internal/shared/warnings.js"() {
    init_esm_env();
    bold2 = "font-weight: bold";
    normal2 = "font-weight: normal";
  }
});

// node_modules/svelte/src/internal/shared/clone.js
function snapshot(value, skip_warning = false, no_tojson = false) {
  if (true_default && !skip_warning) {
    const paths = [];
    const copy = clone(value, /* @__PURE__ */ new Map(), "", paths, null, no_tojson);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone(value, /* @__PURE__ */ new Map(), "", empty, null, no_tojson);
}
function clone(value, cloned, path, paths, original = null, no_tojson = false) {
  if (typeof value === "object" && value !== null) {
    var unwrapped = cloned.get(value);
    if (unwrapped !== void 0) return unwrapped;
    if (value instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(value)
    );
    if (value instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(value)
    );
    if (is_array(value)) {
      var copy = (
        /** @type {Snapshot<any>} */
        Array(value.length)
      );
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var i = 0; i < value.length; i += 1) {
        var element2 = value[i];
        if (i in value) {
          copy[i] = clone(element2, cloned, true_default ? `${path}[${i}]` : path, paths, null, no_tojson);
        }
      }
      return copy;
    }
    if (get_prototype_of(value) === object_prototype) {
      copy = {};
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var key2 in value) {
        copy[key2] = clone(
          // @ts-expect-error
          value[key2],
          cloned,
          true_default ? `${path}.${key2}` : path,
          paths,
          null,
          no_tojson
        );
      }
      return copy;
    }
    if (value instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value.toJSON === "function" && !no_tojson) {
      return clone(
        /** @type {T & { toJSON(): any } } */
        value.toJSON(),
        cloned,
        true_default ? `${path}.toJSON()` : path,
        paths,
        // Associate the instance with the toJSON clone
        value
      );
    }
  }
  if (value instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value)
    );
  } catch (e) {
    if (true_default) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
}
var empty;
var init_clone = __esm({
  "node_modules/svelte/src/internal/shared/clone.js"() {
    init_esm_env();
    init_warnings2();
    init_utils();
    empty = [];
  }
});

// node_modules/svelte/src/internal/client/dev/tracing.js
function log_entry(signal, entry) {
  const value = signal.v;
  if (value === UNINITIALIZED) {
    return;
  }
  const type = get_type(signal);
  const current_reaction = (
    /** @type {Reaction} */
    active_reaction
  );
  const dirty = signal.wv > current_reaction.wv || current_reaction.wv === 0;
  const style = dirty ? "color: CornflowerBlue; font-weight: bold" : "color: grey; font-weight: normal";
  console.groupCollapsed(
    signal.label ? `%c${type}%c ${signal.label}` : `%c${type}%c`,
    style,
    dirty ? "font-weight: normal" : style,
    typeof value === "object" && value !== null && STATE_SYMBOL in value ? snapshot(value, true) : value
  );
  if (type === "$derived") {
    const deps = new Set(
      /** @type {Derived} */
      signal.deps
    );
    for (const dep of deps) {
      log_entry(dep);
    }
  }
  if (signal.created) {
    console.log(signal.created);
  }
  if (dirty && signal.updated) {
    for (const updated of signal.updated.values()) {
      if (updated.error) {
        console.log(updated.error);
      }
    }
  }
  if (entry) {
    for (var trace2 of entry.traces) {
      console.log(trace2);
    }
  }
  console.groupEnd();
}
function get_type(signal) {
  if ((signal.f & (DERIVED | ASYNC)) !== 0) return "$derived";
  return signal.label?.startsWith("$") ? "store" : "$state";
}
function trace(label, fn) {
  var previously_tracing_expressions = tracing_expressions;
  try {
    tracing_expressions = { entries: /* @__PURE__ */ new Map(), reaction: active_reaction };
    var start = performance.now();
    var value = fn();
    var time = (performance.now() - start).toFixed(2);
    var prefix = untrack(label);
    if (!effect_tracking()) {
      console.log(`${prefix} %cran outside of an effect (${time}ms)`, "color: grey");
    } else if (tracing_expressions.entries.size === 0) {
      console.log(`${prefix} %cno reactive dependencies (${time}ms)`, "color: grey");
    } else {
      console.group(`${prefix} %c(${time}ms)`, "color: grey");
      var entries = tracing_expressions.entries;
      untrack(() => {
        for (const [signal, traces] of entries) {
          log_entry(signal, traces);
        }
      });
      tracing_expressions = null;
      console.groupEnd();
    }
    return value;
  } finally {
    tracing_expressions = previously_tracing_expressions;
  }
}
function tag(source2, label) {
  source2.label = label;
  tag_proxy(source2.v, label);
  return source2;
}
function tag_proxy(value, label) {
  value?.[PROXY_PATH_SYMBOL]?.(label);
  return value;
}
var tracing_expressions;
var init_tracing = __esm({
  "node_modules/svelte/src/internal/client/dev/tracing.js"() {
    init_constants();
    init_clone();
    init_constants2();
    init_effects();
    init_runtime();
    tracing_expressions = null;
  }
});

// node_modules/svelte/src/internal/shared/dev.js
function get_error(label) {
  const error = new Error();
  const stack2 = get_stack();
  if (stack2.length === 0) {
    return null;
  }
  stack2.unshift("\n");
  define_property(error, "stack", {
    value: stack2.join("\n")
  });
  define_property(error, "name", {
    value: label
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
function get_stack() {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  const stack2 = new Error().stack;
  Error.stackTraceLimit = limit;
  if (!stack2) return [];
  const lines = stack2.split("\n");
  const new_lines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const posixified = line.replaceAll("\\", "/");
    if (line.trim() === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return [];
    }
    if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) {
      continue;
    }
    new_lines.push(line);
  }
  return new_lines;
}
var init_dev = __esm({
  "node_modules/svelte/src/internal/shared/dev.js"() {
    init_utils();
  }
});

// node_modules/svelte/src/internal/client/context.js
function set_component_context(context2) {
  component_context = context2;
}
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
function add_svelte_meta(callback, type, component2, line, column, additional) {
  const parent = dev_stack;
  dev_stack = {
    type,
    file: component2[FILENAME],
    line,
    column,
    parent,
    ...additional
  };
  try {
    return callback();
  } finally {
    dev_stack = parent;
  }
}
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (true_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var context2 = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context2.e;
  if (effects !== null) {
    context2.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context2.x = component2;
  }
  context2.i = true;
  component_context = context2.p;
  if (true_default) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component2 ?? /** @type {T} */
  {};
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
var component_context, dev_stack, dev_current_component_function;
var init_context = __esm({
  "node_modules/svelte/src/internal/client/context.js"() {
    init_esm_env();
    init_errors2();
    init_runtime();
    init_effects();
    init_flags();
    init_constants();
    init_constants2();
    component_context = null;
    dev_stack = null;
    dev_current_component_function = null;
  }
});

// node_modules/svelte/src/internal/client/dom/task.js
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
var micro_tasks;
var init_task = __esm({
  "node_modules/svelte/src/internal/client/dom/task.js"() {
    init_utils();
    init_batch();
    micro_tasks = [];
  }
});

// node_modules/svelte/src/internal/client/error-handling.js
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (true_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (true_default && !effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e) {
        error = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (true_default && error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect2) {
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${effect2.fn?.name || "<unknown>"}`;
  var context2 = effect2.ctx;
  while (context2 !== null) {
    component_stack += `
${indent}in ${context2.function?.[FILENAME].split("/").pop()}`;
    context2 = context2.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: error.stack?.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}
var adjustments;
var init_error_handling = __esm({
  "node_modules/svelte/src/internal/client/error-handling.js"() {
    init_esm_env();
    init_constants();
    init_operations();
    init_constants2();
    init_utils();
    init_runtime();
    adjustments = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/svelte/src/internal/client/reactivity/batch.js
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  var source_stacks = true_default ? /* @__PURE__ */ new Set() : null;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (true_default) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of source2.updated ?? []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            if (update2.error) {
              console.error(update2.error);
            }
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
      if (true_default) {
        for (const source2 of batch.current.keys()) {
          source_stacks.add(source2);
        }
      }
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
    if (true_default) {
      for (
        const source2 of
        /** @type {Set<Source>} */
        source_stacks
      ) {
        source2.updated = null;
      }
    }
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (true_default) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          if ((e.f & (DESTROYED | INERT)) !== 0) continue;
          const ordered_effects = [e];
          let ancestor = e.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j = ordered_effects.length - 1; j >= 0; j--) {
            const e2 = ordered_effects[j];
            if ((e2.f & (DESTROYED | INERT)) !== 0) continue;
            update_effect(e2);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources, marked, checked) {
  if (marked.has(value)) return;
  marked.add(value);
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== void 0) return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked
      )) {
        checked.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0 && (flags2 & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
function eager_flush() {
  try {
    flushSync(() => {
      for (const version of eager_versions) {
        update(version);
      }
    });
  } finally {
    eager_versions = [];
  }
}
function eager(fn) {
  var version = source(0);
  var initial = true;
  var value = (
    /** @type {T} */
    void 0
  );
  get(version);
  eager_effect(() => {
    if (initial) {
      var previous_batch_values = batch_values;
      try {
        batch_values = null;
        value = fn();
      } finally {
        batch_values = previous_batch_values;
      }
      return;
    }
    if (eager_versions.length === 0) {
      queue_micro_task(eager_flush);
    }
    eager_versions.push(version);
  });
  initial = false;
  return value;
}
var batches, current_batch, previous_batch, batch_values, queued_root_effects, last_scheduled_effect, is_flushing, is_flushing_sync, Batch, eager_block_effects, eager_versions;
var init_batch = __esm({
  "node_modules/svelte/src/internal/client/reactivity/batch.js"() {
    init_constants2();
    init_flags();
    init_utils();
    init_runtime();
    init_errors2();
    init_task();
    init_esm_env();
    init_error_handling();
    init_sources();
    init_effects();
    batches = /* @__PURE__ */ new Set();
    current_batch = null;
    previous_batch = null;
    batch_values = null;
    queued_root_effects = [];
    last_scheduled_effect = null;
    is_flushing = false;
    is_flushing_sync = false;
    Batch = class _Batch {
      committed = false;
      /**
       * The current values of any sources that are updated in this batch
       * They keys of this map are identical to `this.#previous`
       * @type {Map<Source, any>}
       */
      current = /* @__PURE__ */ new Map();
      /**
       * The values of any sources that are updated in this batch _before_ those updates took place.
       * They keys of this map are identical to `this.#current`
       * @type {Map<Source, any>}
       */
      previous = /* @__PURE__ */ new Map();
      /**
       * When the batch is committed (and the DOM is updated), we need to remove old branches
       * and append new ones by calling the functions added inside (if/each/key/etc) blocks
       * @type {Set<() => void>}
       */
      #commit_callbacks = /* @__PURE__ */ new Set();
      /**
       * If a fork is discarded, we need to destroy any effects that are no longer needed
       * @type {Set<(batch: Batch) => void>}
       */
      #discard_callbacks = /* @__PURE__ */ new Set();
      /**
       * The number of async effects that are currently in flight
       */
      #pending = 0;
      /**
       * The number of async effects that are currently in flight, _not_ inside a pending boundary
       */
      #blocking_pending = 0;
      /**
       * A deferred that resolves when the batch is committed, used with `settled()`
       * TODO replace with Promise.withResolvers once supported widely enough
       * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
       */
      #deferred = null;
      /**
       * Deferred effects (which run after async work has completed) that are DIRTY
       * @type {Effect[]}
       */
      #dirty_effects = [];
      /**
       * Deferred effects that are MAYBE_DIRTY
       * @type {Effect[]}
       */
      #maybe_dirty_effects = [];
      /**
       * A set of branches that still exist, but will be destroyed when this batch
       * is committed  we skip over these during `process`
       * @type {Set<Effect>}
       */
      skipped_effects = /* @__PURE__ */ new Set();
      is_fork = false;
      is_deferred() {
        return this.is_fork || this.#blocking_pending > 0;
      }
      /**
       *
       * @param {Effect[]} root_effects
       */
      process(root_effects) {
        queued_root_effects = [];
        previous_batch = null;
        this.apply();
        var target = {
          parent: null,
          effect: null,
          effects: [],
          render_effects: [],
          block_effects: []
        };
        for (const root of root_effects) {
          this.#traverse_effect_tree(root, target);
        }
        if (!this.is_fork) {
          this.#resolve();
        }
        if (this.is_deferred()) {
          this.#defer_effects(target.effects);
          this.#defer_effects(target.render_effects);
          this.#defer_effects(target.block_effects);
        } else {
          previous_batch = this;
          current_batch = null;
          flush_queued_effects(target.render_effects);
          flush_queued_effects(target.effects);
          previous_batch = null;
          this.#deferred?.resolve();
        }
        batch_values = null;
      }
      /**
       * Traverse the effect tree, executing effects or stashing
       * them for later execution as appropriate
       * @param {Effect} root
       * @param {EffectTarget} target
       */
      #traverse_effect_tree(root, target) {
        root.f ^= CLEAN;
        var effect2 = root.first;
        while (effect2 !== null) {
          var flags2 = effect2.f;
          var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
          var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
          var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
          if ((effect2.f & BOUNDARY_EFFECT) !== 0 && effect2.b?.is_pending()) {
            target = {
              parent: target,
              effect: effect2,
              effects: [],
              render_effects: [],
              block_effects: []
            };
          }
          if (!skip && effect2.fn !== null) {
            if (is_branch) {
              effect2.f ^= CLEAN;
            } else if ((flags2 & EFFECT) !== 0) {
              target.effects.push(effect2);
            } else if (async_mode_flag && (flags2 & (RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
              target.render_effects.push(effect2);
            } else if (is_dirty(effect2)) {
              if ((effect2.f & BLOCK_EFFECT) !== 0) target.block_effects.push(effect2);
              update_effect(effect2);
            }
            var child2 = effect2.first;
            if (child2 !== null) {
              effect2 = child2;
              continue;
            }
          }
          var parent = effect2.parent;
          effect2 = effect2.next;
          while (effect2 === null && parent !== null) {
            if (parent === target.effect) {
              this.#defer_effects(target.effects);
              this.#defer_effects(target.render_effects);
              this.#defer_effects(target.block_effects);
              target = /** @type {EffectTarget} */
              target.parent;
            }
            effect2 = parent.next;
            parent = parent.parent;
          }
        }
      }
      /**
       * @param {Effect[]} effects
       */
      #defer_effects(effects) {
        for (const e of effects) {
          const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
          target.push(e);
          this.#clear_marked(e.deps);
          set_signal_status(e, CLEAN);
        }
      }
      /**
       * @param {Value[] | null} deps
       */
      #clear_marked(deps) {
        if (deps === null) return;
        for (const dep of deps) {
          if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
            continue;
          }
          dep.f ^= WAS_MARKED;
          this.#clear_marked(
            /** @type {Derived} */
            dep.deps
          );
        }
      }
      /**
       * Associate a change to a given source with the current
       * batch, noting its previous and current values
       * @param {Source} source
       * @param {any} value
       */
      capture(source2, value) {
        if (!this.previous.has(source2)) {
          this.previous.set(source2, value);
        }
        if ((source2.f & ERROR_VALUE) === 0) {
          this.current.set(source2, source2.v);
          batch_values?.set(source2, source2.v);
        }
      }
      activate() {
        current_batch = this;
        this.apply();
      }
      deactivate() {
        if (current_batch !== this) return;
        current_batch = null;
        batch_values = null;
      }
      flush() {
        this.activate();
        if (queued_root_effects.length > 0) {
          flush_effects();
          if (current_batch !== null && current_batch !== this) {
            return;
          }
        } else if (this.#pending === 0) {
          this.process([]);
        }
        this.deactivate();
      }
      discard() {
        for (const fn of this.#discard_callbacks) fn(this);
        this.#discard_callbacks.clear();
      }
      #resolve() {
        if (this.#blocking_pending === 0) {
          for (const fn of this.#commit_callbacks) fn();
          this.#commit_callbacks.clear();
        }
        if (this.#pending === 0) {
          this.#commit();
        }
      }
      #commit() {
        if (batches.size > 1) {
          this.previous.clear();
          var previous_batch_values = batch_values;
          var is_earlier = true;
          var dummy_target = {
            parent: null,
            effect: null,
            effects: [],
            render_effects: [],
            block_effects: []
          };
          for (const batch of batches) {
            if (batch === this) {
              is_earlier = false;
              continue;
            }
            const sources = [];
            for (const [source2, value] of this.current) {
              if (batch.current.has(source2)) {
                if (is_earlier && value !== batch.current.get(source2)) {
                  batch.current.set(source2, value);
                } else {
                  continue;
                }
              }
              sources.push(source2);
            }
            if (sources.length === 0) {
              continue;
            }
            const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
            if (others.length > 0) {
              var prev_queued_root_effects = queued_root_effects;
              queued_root_effects = [];
              const marked = /* @__PURE__ */ new Set();
              const checked = /* @__PURE__ */ new Map();
              for (const source2 of sources) {
                mark_effects(source2, others, marked, checked);
              }
              if (queued_root_effects.length > 0) {
                current_batch = batch;
                batch.apply();
                for (const root of queued_root_effects) {
                  batch.#traverse_effect_tree(root, dummy_target);
                }
                batch.deactivate();
              }
              queued_root_effects = prev_queued_root_effects;
            }
          }
          current_batch = null;
          batch_values = previous_batch_values;
        }
        this.committed = true;
        batches.delete(this);
      }
      /**
       *
       * @param {boolean} blocking
       */
      increment(blocking) {
        this.#pending += 1;
        if (blocking) this.#blocking_pending += 1;
      }
      /**
       *
       * @param {boolean} blocking
       */
      decrement(blocking) {
        this.#pending -= 1;
        if (blocking) this.#blocking_pending -= 1;
        this.revive();
      }
      revive() {
        for (const e of this.#dirty_effects) {
          set_signal_status(e, DIRTY);
          schedule_effect(e);
        }
        for (const e of this.#maybe_dirty_effects) {
          set_signal_status(e, MAYBE_DIRTY);
          schedule_effect(e);
        }
        this.#dirty_effects = [];
        this.#maybe_dirty_effects = [];
        this.flush();
      }
      /** @param {() => void} fn */
      oncommit(fn) {
        this.#commit_callbacks.add(fn);
      }
      /** @param {(batch: Batch) => void} fn */
      ondiscard(fn) {
        this.#discard_callbacks.add(fn);
      }
      settled() {
        return (this.#deferred ??= deferred()).promise;
      }
      static ensure() {
        if (current_batch === null) {
          const batch = current_batch = new _Batch();
          batches.add(current_batch);
          if (!is_flushing_sync) {
            _Batch.enqueue(() => {
              if (current_batch !== batch) {
                return;
              }
              batch.flush();
            });
          }
        }
        return current_batch;
      }
      /** @param {() => void} task */
      static enqueue(task) {
        queue_micro_task(task);
      }
      apply() {
        if (!async_mode_flag || !this.is_fork && batches.size === 1) return;
        batch_values = new Map(this.current);
        for (const batch of batches) {
          if (batch === this) continue;
          for (const [source2, previous] of batch.previous) {
            if (!batch_values.has(source2)) {
              batch_values.set(source2, previous);
            }
          }
        }
      }
    };
    eager_block_effects = null;
    eager_versions = [];
  }
});

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start) {
  let subscribers = 0;
  let version = source(0);
  let stop;
  if (true_default) {
    tag(version, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get(version);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start(() => increment(version)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}
var init_create_subscriber = __esm({
  "node_modules/svelte/src/reactivity/create-subscriber.js"() {
    init_runtime();
    init_effects();
    init_sources();
    init_tracing();
    init_esm_env();
    init_task();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
function get_boundary() {
  return (
    /** @type {Boundary} */
    /** @type {Effect} */
    active_effect.b
  );
}
function pending() {
  if (active_effect === null) {
    effect_pending_outside_reaction();
  }
  var boundary2 = active_effect.b;
  if (boundary2 === null) {
    return 0;
  }
  return boundary2.get_effect_pending();
}
var flags, Boundary;
var init_boundary = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/boundary.js"() {
    init_constants2();
    init_constants();
    init_context();
    init_error_handling();
    init_effects();
    init_runtime();
    init_hydration();
    init_task();
    init_errors2();
    init_warnings();
    init_esm_env();
    init_batch();
    init_sources();
    init_tracing();
    init_create_subscriber();
    init_operations();
    flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
    Boundary = class {
      /** @type {Boundary | null} */
      parent;
      #pending = false;
      /** @type {TemplateNode} */
      #anchor;
      /** @type {TemplateNode | null} */
      #hydrate_open = hydrating ? hydrate_node : null;
      /** @type {BoundaryProps} */
      #props;
      /** @type {((anchor: Node) => void)} */
      #children;
      /** @type {Effect} */
      #effect;
      /** @type {Effect | null} */
      #main_effect = null;
      /** @type {Effect | null} */
      #pending_effect = null;
      /** @type {Effect | null} */
      #failed_effect = null;
      /** @type {DocumentFragment | null} */
      #offscreen_fragment = null;
      /** @type {TemplateNode | null} */
      #pending_anchor = null;
      #local_pending_count = 0;
      #pending_count = 0;
      #is_creating_fallback = false;
      /**
       * A source containing the number of pending async deriveds/expressions.
       * Only created if `$effect.pending()` is used inside the boundary,
       * otherwise updating the source results in needless `Batch.ensure()`
       * calls followed by no-op flushes
       * @type {Source<number> | null}
       */
      #effect_pending = null;
      #effect_pending_subscriber = createSubscriber(() => {
        this.#effect_pending = source(this.#local_pending_count);
        if (true_default) {
          tag(this.#effect_pending, "$effect.pending()");
        }
        return () => {
          this.#effect_pending = null;
        };
      });
      /**
       * @param {TemplateNode} node
       * @param {BoundaryProps} props
       * @param {((anchor: Node) => void)} children
       */
      constructor(node, props, children) {
        this.#anchor = node;
        this.#props = props;
        this.#children = children;
        this.parent = /** @type {Effect} */
        active_effect.b;
        this.#pending = !!this.#props.pending;
        this.#effect = block(() => {
          active_effect.b = this;
          if (hydrating) {
            const comment2 = this.#hydrate_open;
            hydrate_next();
            const server_rendered_pending = (
              /** @type {Comment} */
              comment2.nodeType === COMMENT_NODE && /** @type {Comment} */
              comment2.data === HYDRATION_START_ELSE
            );
            if (server_rendered_pending) {
              this.#hydrate_pending_content();
            } else {
              this.#hydrate_resolved_content();
            }
          } else {
            var anchor = this.#get_anchor();
            try {
              this.#main_effect = branch(() => children(anchor));
            } catch (error) {
              this.error(error);
            }
            if (this.#pending_count > 0) {
              this.#show_pending_snippet();
            } else {
              this.#pending = false;
            }
          }
          return () => {
            this.#pending_anchor?.remove();
          };
        }, flags);
        if (hydrating) {
          this.#anchor = hydrate_node;
        }
      }
      #hydrate_resolved_content() {
        try {
          this.#main_effect = branch(() => this.#children(this.#anchor));
        } catch (error) {
          this.error(error);
        }
        this.#pending = false;
      }
      #hydrate_pending_content() {
        const pending3 = this.#props.pending;
        if (!pending3) {
          return;
        }
        this.#pending_effect = branch(() => pending3(this.#anchor));
        Batch.enqueue(() => {
          var anchor = this.#get_anchor();
          this.#main_effect = this.#run(() => {
            Batch.ensure();
            return branch(() => this.#children(anchor));
          });
          if (this.#pending_count > 0) {
            this.#show_pending_snippet();
          } else {
            pause_effect(
              /** @type {Effect} */
              this.#pending_effect,
              () => {
                this.#pending_effect = null;
              }
            );
            this.#pending = false;
          }
        });
      }
      #get_anchor() {
        var anchor = this.#anchor;
        if (this.#pending) {
          this.#pending_anchor = create_text();
          this.#anchor.before(this.#pending_anchor);
          anchor = this.#pending_anchor;
        }
        return anchor;
      }
      /**
       * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
       * @returns {boolean}
       */
      is_pending() {
        return this.#pending || !!this.parent && this.parent.is_pending();
      }
      has_pending_snippet() {
        return !!this.#props.pending;
      }
      /**
       * @param {() => Effect | null} fn
       */
      #run(fn) {
        var previous_effect = active_effect;
        var previous_reaction = active_reaction;
        var previous_ctx = component_context;
        set_active_effect(this.#effect);
        set_active_reaction(this.#effect);
        set_component_context(this.#effect.ctx);
        try {
          return fn();
        } catch (e) {
          handle_error(e);
          return null;
        } finally {
          set_active_effect(previous_effect);
          set_active_reaction(previous_reaction);
          set_component_context(previous_ctx);
        }
      }
      #show_pending_snippet() {
        const pending3 = (
          /** @type {(anchor: Node) => void} */
          this.#props.pending
        );
        if (this.#main_effect !== null) {
          this.#offscreen_fragment = document.createDocumentFragment();
          this.#offscreen_fragment.append(
            /** @type {TemplateNode} */
            this.#pending_anchor
          );
          move_effect(this.#main_effect, this.#offscreen_fragment);
        }
        if (this.#pending_effect === null) {
          this.#pending_effect = branch(() => pending3(this.#anchor));
        }
      }
      /**
       * Updates the pending count associated with the currently visible pending snippet,
       * if any, such that we can replace the snippet with content once work is done
       * @param {1 | -1} d
       */
      #update_pending_count(d) {
        if (!this.has_pending_snippet()) {
          if (this.parent) {
            this.parent.#update_pending_count(d);
          }
          return;
        }
        this.#pending_count += d;
        if (this.#pending_count === 0) {
          this.#pending = false;
          if (this.#pending_effect) {
            pause_effect(this.#pending_effect, () => {
              this.#pending_effect = null;
            });
          }
          if (this.#offscreen_fragment) {
            this.#anchor.before(this.#offscreen_fragment);
            this.#offscreen_fragment = null;
          }
        }
      }
      /**
       * Update the source that powers `$effect.pending()` inside this boundary,
       * and controls when the current `pending` snippet (if any) is removed.
       * Do not call from inside the class
       * @param {1 | -1} d
       */
      update_pending_count(d) {
        this.#update_pending_count(d);
        this.#local_pending_count += d;
        if (this.#effect_pending) {
          internal_set(this.#effect_pending, this.#local_pending_count);
        }
      }
      get_effect_pending() {
        this.#effect_pending_subscriber();
        return get(
          /** @type {Source<number>} */
          this.#effect_pending
        );
      }
      /** @param {unknown} error */
      error(error) {
        var onerror = this.#props.onerror;
        let failed = this.#props.failed;
        if (this.#is_creating_fallback || !onerror && !failed) {
          throw error;
        }
        if (this.#main_effect) {
          destroy_effect(this.#main_effect);
          this.#main_effect = null;
        }
        if (this.#pending_effect) {
          destroy_effect(this.#pending_effect);
          this.#pending_effect = null;
        }
        if (this.#failed_effect) {
          destroy_effect(this.#failed_effect);
          this.#failed_effect = null;
        }
        if (hydrating) {
          set_hydrate_node(
            /** @type {TemplateNode} */
            this.#hydrate_open
          );
          next();
          set_hydrate_node(skip_nodes());
        }
        var did_reset = false;
        var calling_on_error = false;
        const reset2 = () => {
          if (did_reset) {
            svelte_boundary_reset_noop();
            return;
          }
          did_reset = true;
          if (calling_on_error) {
            svelte_boundary_reset_onerror();
          }
          Batch.ensure();
          this.#local_pending_count = 0;
          if (this.#failed_effect !== null) {
            pause_effect(this.#failed_effect, () => {
              this.#failed_effect = null;
            });
          }
          this.#pending = this.has_pending_snippet();
          this.#main_effect = this.#run(() => {
            this.#is_creating_fallback = false;
            return branch(() => this.#children(this.#anchor));
          });
          if (this.#pending_count > 0) {
            this.#show_pending_snippet();
          } else {
            this.#pending = false;
          }
        };
        var previous_reaction = active_reaction;
        try {
          set_active_reaction(null);
          calling_on_error = true;
          onerror?.(error, reset2);
          calling_on_error = false;
        } catch (error2) {
          invoke_error_boundary(error2, this.#effect && this.#effect.parent);
        } finally {
          set_active_reaction(previous_reaction);
        }
        if (failed) {
          queue_micro_task(() => {
            this.#failed_effect = this.#run(() => {
              Batch.ensure();
              this.#is_creating_fallback = true;
              try {
                return branch(() => {
                  failed(
                    this.#anchor,
                    () => error,
                    () => reset2
                  );
                });
              } catch (error2) {
                invoke_error_boundary(
                  error2,
                  /** @type {Effect} */
                  this.#effect.parent
                );
                return null;
              } finally {
                this.#is_creating_fallback = false;
              }
            });
          });
        }
      }
    };
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/each.js
function set_current_each_item(item) {
  current_each_item = item;
}
function index(_, i) {
  return i;
}
function pause_effects(state2, to_destroy, controlled_anchor) {
  var transitions = [];
  var length = to_destroy.length;
  for (var i = 0; i < length; i++) {
    pause_children(to_destroy[i].e, transitions, true);
  }
  run_out_transitions(transitions, () => {
    var fast_path = transitions.length === 0 && controlled_anchor !== null;
    if (fast_path) {
      var anchor = (
        /** @type {Element} */
        controlled_anchor
      );
      var parent_node = (
        /** @type {Element} */
        anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(anchor);
      state2.items.clear();
      link(state2, to_destroy[0].prev, to_destroy[length - 1].next);
    }
    for (var i2 = 0; i2 < length; i2++) {
      var item = to_destroy[i2];
      if (!fast_path) {
        state2.items.delete(item.k);
        link(state2, item.prev, item.next);
      }
      destroy_effect(item.e, !fast_path);
    }
    if (state2.first === to_destroy[0]) {
      state2.first = to_destroy[0].prev;
    }
  });
}
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var items = /* @__PURE__ */ new Map();
  var first = null;
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  var is_reactive_value = (flags2 & EACH_ITEM_REACTIVE) !== 0;
  var is_reactive_index = (flags2 & EACH_INDEX_REACTIVE) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = hydrating ? set_hydrate_node(
      /** @type {Comment | Text} */
      get_first_child(parent_node)
    ) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback2 = null;
  var each_array = derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array;
  var first_run = true;
  function commit() {
    reconcile(state2, array, anchor, flags2, get_key);
    if (fallback2 !== null) {
      if (array.length === 0) {
        if (fallback2.fragment) {
          anchor.before(fallback2.fragment);
          fallback2.fragment = null;
        } else {
          resume_effect(fallback2.effect);
        }
        effect2.first = fallback2.effect;
      } else {
        pause_effect(fallback2.effect, () => {
          fallback2 = null;
        });
      }
    }
  }
  var effect2 = block(() => {
    array = /** @type {V[]} */
    get(each_array);
    var length = array.length;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length === 0)) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var keys = /* @__PURE__ */ new Set();
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var prev = null;
    var defer = should_defer_append();
    for (var i = 0; i < length; i += 1) {
      if (hydrating && hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */
      hydrate_node.data === HYDRATION_END) {
        anchor = /** @type {Comment} */
        hydrate_node;
        mismatch = true;
        set_hydrating(false);
      }
      var value = array[i];
      var key2 = get_key(value, i);
      var item = first_run ? null : items.get(key2);
      if (item) {
        if (is_reactive_value) {
          internal_set(item.v, value);
        }
        if (is_reactive_index) {
          internal_set(
            /** @type {Value<number>} */
            item.i,
            i
          );
        } else {
          item.i = i;
        }
        if (defer) {
          batch.skipped_effects.delete(item.e);
        }
      } else {
        item = create_item(
          first_run ? anchor : null,
          prev,
          value,
          key2,
          i,
          render_fn,
          flags2,
          get_collection
        );
        if (first_run) {
          item.o = true;
          if (prev === null) {
            first = item;
          } else {
            prev.next = item;
          }
          prev = item;
        }
        items.set(key2, item);
      }
      keys.add(key2);
    }
    if (length === 0 && fallback_fn && !fallback2) {
      if (first_run) {
        fallback2 = {
          fragment: null,
          effect: branch(() => fallback_fn(anchor))
        };
      } else {
        var fragment = document.createDocumentFragment();
        var target = create_text();
        fragment.append(target);
        fallback2 = {
          fragment,
          effect: branch(() => fallback_fn(target))
        };
      }
    }
    if (hydrating && length > 0) {
      set_hydrate_node(skip_nodes());
    }
    if (!first_run) {
      if (defer) {
        for (const [key3, item2] of items) {
          if (!keys.has(key3)) {
            batch.skipped_effects.add(item2.e);
          }
        }
        batch.oncommit(commit);
        batch.ondiscard(() => {
        });
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get(each_array);
  });
  var state2 = { effect: effect2, flags: flags2, items, first };
  first_run = false;
  if (hydrating) {
    anchor = hydrate_node;
  }
}
function reconcile(state2, array, anchor, flags2, get_key) {
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var length = array.length;
  var items = state2.items;
  var current = state2.first;
  var seen2;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value;
  var key2;
  var item;
  var i;
  if (is_animated) {
    for (i = 0; i < length; i += 1) {
      value = array[i];
      key2 = get_key(value, i);
      item = /** @type {EachItem} */
      items.get(key2);
      if (item.o) {
        item.a?.measure();
        (to_animate ??= /* @__PURE__ */ new Set()).add(item);
      }
    }
  }
  for (i = 0; i < length; i += 1) {
    value = array[i];
    key2 = get_key(value, i);
    item = /** @type {EachItem} */
    items.get(key2);
    state2.first ??= item;
    if (!item.o) {
      item.o = true;
      var next2 = prev ? prev.next : current;
      link(state2, prev, item);
      link(state2, item, next2);
      move(item, next2, anchor);
      prev = item;
      matched = [];
      stashed = [];
      current = prev.next;
      continue;
    }
    if ((item.e.f & INERT) !== 0) {
      resume_effect(item.e);
      if (is_animated) {
        item.a?.unfix();
        (to_animate ??= /* @__PURE__ */ new Set()).delete(item);
      }
    }
    if (item !== current) {
      if (seen2 !== void 0 && seen2.has(item)) {
        if (matched.length < stashed.length) {
          var start = stashed[0];
          var j;
          prev = start.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen2.delete(stashed[j]);
          }
          link(state2, a.prev, b.next);
          link(state2, prev, a);
          link(state2, b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen2.delete(item);
          move(item, current, anchor);
          link(state2, item.prev, item.next);
          link(state2, item, prev === null ? state2.first : prev.next);
          link(state2, prev, item);
          prev = item;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current.k !== key2) {
        if ((current.e.f & INERT) === 0) {
          (seen2 ??= /* @__PURE__ */ new Set()).add(current);
        }
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
      item = current;
    }
    matched.push(item);
    prev = item;
    current = item.next;
  }
  let has_offscreen_items = items.size > length;
  if (current !== null || seen2 !== void 0) {
    var to_destroy = seen2 === void 0 ? [] : array_from(seen2);
    while (current !== null) {
      if ((current.e.f & INERT) === 0) {
        to_destroy.push(current);
      }
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    has_offscreen_items = items.size - destroy_length > length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
      if (is_animated) {
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].a?.measure();
        }
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].a?.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (has_offscreen_items) {
    for (const item2 of items.values()) {
      if (!item2.o) {
        link(state2, prev, item2);
        prev = item2;
      }
    }
  }
  state2.effect.last = prev && prev.e;
  if (is_animated) {
    queue_micro_task(() => {
      if (to_animate === void 0) return;
      for (item of to_animate) {
        item.a?.apply();
      }
    });
  }
}
function create_item(anchor, prev, value, key2, index2, render_fn, flags2, get_collection) {
  var previous_each_item = current_each_item;
  var reactive = (flags2 & EACH_ITEM_REACTIVE) !== 0;
  var mutable = (flags2 & EACH_ITEM_IMMUTABLE) === 0;
  var v = reactive ? mutable ? mutable_source(value, false, false) : source(value) : value;
  var i = (flags2 & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);
  if (true_default && reactive) {
    v.trace = () => {
      var collection_index = typeof i === "number" ? index2 : i.v;
      get_collection()[collection_index];
    };
  }
  var item = {
    i,
    v,
    k: key2,
    a: null,
    // @ts-expect-error
    e: null,
    o: false,
    prev,
    next: null
  };
  current_each_item = item;
  try {
    if (anchor === null) {
      var fragment = document.createDocumentFragment();
      fragment.append(anchor = create_text());
    }
    item.e = branch(() => render_fn(
      /** @type {Node} */
      anchor,
      v,
      i,
      get_collection
    ));
    if (prev !== null) {
      prev.next = item;
    }
    return item;
  } finally {
    current_each_item = previous_each_item;
  }
}
function move(item, next2, anchor) {
  var end = item.next ? (
    /** @type {TemplateNode} */
    item.next.e.nodes_start
  ) : anchor;
  var dest = next2 ? (
    /** @type {TemplateNode} */
    next2.e.nodes_start
  ) : anchor;
  var node = (
    /** @type {TemplateNode} */
    item.e.nodes_start
  );
  while (node !== null && node !== end) {
    var next_node = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    dest.before(node);
    node = next_node;
  }
}
function link(state2, prev, next2) {
  if (prev === null) {
    state2.first = next2;
    state2.effect.first = next2 && next2.e;
  } else {
    if (prev.e.next) {
      prev.e.next.prev = null;
    }
    prev.next = next2;
    prev.e.next = next2 && next2.e;
  }
  if (next2 !== null) {
    if (next2.e.prev) {
      next2.e.prev.next = null;
    }
    next2.prev = prev;
    next2.e.prev = prev && prev.e;
  }
}
var current_each_item;
var init_each = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/each.js"() {
    init_constants();
    init_hydration();
    init_operations();
    init_effects();
    init_sources();
    init_utils();
    init_constants2();
    init_task();
    init_runtime();
    init_esm_env();
    init_deriveds();
    init_batch();
    current_each_item = null;
  }
});

// node_modules/svelte/src/internal/client/reactivity/async.js
function flatten(blockers, sync, async2, fn) {
  const d = is_runes() ? derived : derived_safe_equal;
  if (async2.length === 0 && blockers.length === 0) {
    fn(sync.map(d));
    return;
  }
  var batch = current_batch;
  var parent = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  function run3() {
    Promise.all(async2.map((expression) => async_derived(expression))).then((result) => {
      restore();
      try {
        fn([...sync.map(d), ...result]);
      } catch (error) {
        if ((parent.f & DESTROYED) === 0) {
          invoke_error_boundary(error, parent);
        }
      }
      batch?.deactivate();
      unset_context();
    }).catch((error) => {
      invoke_error_boundary(error, parent);
    });
  }
  if (blockers.length > 0) {
    Promise.all(blockers).then(() => {
      restore();
      try {
        return run3();
      } finally {
        batch?.deactivate();
        unset_context();
      }
    });
  } else {
    run3();
  }
}
function run_after_blockers(blockers, fn) {
  var each_item = current_each_item;
  flatten(blockers, [], [], (v) => {
    set_current_each_item(each_item);
    fn(v);
  });
}
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  if (true_default) {
    var previous_dev_stack = dev_stack;
  }
  return function restore(activate_batch = true) {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    if (activate_batch) previous_batch2?.activate();
    if (true_default) {
      set_from_async_derived(null);
      set_dev_stack(previous_dev_stack);
    }
  };
}
async function save(promise) {
  var restore = capture();
  var value = await promise;
  return () => {
    restore();
    return value;
  };
}
async function track_reactivity_loss(promise) {
  var previous_async_effect = current_async_effect;
  var value = await promise;
  return () => {
    set_from_async_derived(previous_async_effect);
    return value;
  };
}
async function* for_await_track_reactivity_loss(iterable) {
  const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
  if (iterator === void 0) {
    throw new TypeError("value is not async iterable");
  }
  let normal_completion = false;
  try {
    while (true) {
      const { done, value } = (await track_reactivity_loss(iterator.next()))();
      if (done) {
        normal_completion = true;
        break;
      }
      yield value;
    }
  } finally {
    if (normal_completion && iterator.return !== void 0) {
      return (
        /** @type {TReturn} */
        (await track_reactivity_loss(iterator.return()))().value
      );
    }
  }
}
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (true_default) {
    set_from_async_derived(null);
    set_dev_stack(null);
  }
}
async function async_body(anchor, fn) {
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var was_hydrating = hydrating;
  var next_hydrate_node = void 0;
  if (was_hydrating) {
    hydrate_next();
    next_hydrate_node = skip_nodes(false);
  }
  try {
    var promise = fn(anchor);
  } finally {
    if (next_hydrate_node) {
      set_hydrate_node(next_hydrate_node);
      hydrate_next();
    }
  }
  try {
    await promise;
  } catch (error) {
    if (!aborted(active)) {
      invoke_error_boundary(error, active);
    }
  } finally {
    boundary2.update_pending_count(-1);
    batch.decrement(blocking);
    unset_context();
  }
}
function run2(thunks) {
  const restore = capture();
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var errored = null;
  const handle_error2 = (error) => {
    errored = { error };
    if (!aborted(active)) {
      invoke_error_boundary(error, active);
    }
  };
  var promise = Promise.resolve(thunks[0]()).catch(handle_error2);
  var promises = [promise];
  for (const fn of thunks.slice(1)) {
    promise = promise.then(() => {
      if (errored) {
        throw errored.error;
      }
      if (aborted(active)) {
        throw STALE_REACTION;
      }
      try {
        restore();
        return fn();
      } finally {
        unset_context();
      }
    }).catch(handle_error2).finally(() => {
      unset_context();
    });
    promises.push(promise);
  }
  promise.then(() => Promise.resolve()).finally(() => {
    boundary2.update_pending_count(-1);
    batch.decrement(blocking);
  });
  return promises;
}
var init_async = __esm({
  "node_modules/svelte/src/internal/client/reactivity/async.js"() {
    init_constants2();
    init_esm_env();
    init_context();
    init_boundary();
    init_error_handling();
    init_runtime();
    init_batch();
    init_deriveds();
    init_effects();
    init_hydration();
    init_each();
  }
});

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
function set_from_async_derived(v) {
  current_async_effect = v;
}
// @__NO_SIDE_EFFECTS__
function derived(fn) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect !== null) {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived ?? active_effect,
    ac: null
  };
  if (true_default && tracing_mode_flag) {
    signal.created = get_error("created at");
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function async_derived(fn, location) {
  let parent = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent === null) {
    async_derived_orphan();
  }
  var boundary2 = (
    /** @type {Boundary} */
    parent.b
  );
  var promise = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  var should_suspend = !active_reaction;
  var deferreds = /* @__PURE__ */ new Map();
  async_effect(() => {
    if (true_default) current_async_effect = active_effect;
    var d = deferred();
    promise = d.promise;
    try {
      Promise.resolve(fn()).then(d.resolve, d.reject).then(() => {
        if (batch === current_batch && batch.committed) {
          batch.deactivate();
        }
        unset_context();
      });
    } catch (error) {
      d.reject(error);
      unset_context();
    }
    if (true_default) current_async_effect = null;
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    if (should_suspend) {
      var blocking = !boundary2.is_pending();
      boundary2.update_pending_count(1);
      batch.increment(blocking);
      deferreds.get(batch)?.reject(STALE_REACTION);
      deferreds.delete(batch);
      deferreds.set(batch, d);
    }
    const handler = (value, error = void 0) => {
      current_async_effect = null;
      batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value);
        for (const [b, d2] of deferreds) {
          deferreds.delete(b);
          if (b === batch) break;
          d2.reject(STALE_REACTION);
        }
        if (true_default && location !== void 0) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(
                /** @type {string} */
                signal.label,
                location
              );
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        batch.decrement(blocking);
      }
    };
    d.promise.then(handler, (e) => handler(null, e || "unknown"));
  });
  teardown(() => {
    for (const d of deferreds.values()) {
      d.reject(STALE_REACTION);
    }
  });
  if (true_default) {
    signal.f |= ASYNC;
  }
  return new Promise((fulfil) => {
    function next2(p) {
      function go() {
        if (p === promise) {
          fulfil(signal);
        } else {
          next2(promise);
        }
      }
      p.then(go, go);
    }
    next2(promise);
  });
}
// @__NO_SIDE_EFFECTS__
function user_derived(fn) {
  const d = /* @__PURE__ */ derived(fn);
  if (!async_mode_flag) push_reaction_value(d);
  return d;
}
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn) {
  const signal = /* @__PURE__ */ derived(fn);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
function get_derived_parent_effect(derived2) {
  var parent = derived2.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (parent.f & DESTROYED) === 0 ? (
        /** @type {Effect} */
        parent
      ) : null;
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived2) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  if (true_default) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived2)) {
        derived_references_self();
      }
      stack.push(derived2);
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else {
    try {
      derived2.f &= ~WAS_MARKED;
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived2) {
  var value = execute_derived(derived2);
  if (!derived2.equals(value)) {
    if (!current_batch?.is_fork) {
      derived2.v = value;
    }
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking() || current_batch?.is_fork) {
      batch_values.set(derived2, value);
    }
  } else {
    var status = (derived2.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}
var current_async_effect, recent_async_deriveds, stack;
var init_deriveds = __esm({
  "node_modules/svelte/src/internal/client/reactivity/deriveds.js"() {
    init_esm_env();
    init_constants2();
    init_runtime();
    init_equality();
    init_errors2();
    init_warnings();
    init_effects();
    init_sources();
    init_dev();
    init_flags();
    init_boundary();
    init_context();
    init_constants();
    init_batch();
    init_async();
    init_utils();
    current_async_effect = null;
    recent_async_deriveds = /* @__PURE__ */ new Set();
    stack = [];
  }
});

// node_modules/svelte/src/internal/client/reactivity/sources.js
function set_eager_effects(v) {
  eager_effects = v;
}
function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (true_default && tracing_mode_flag) {
    signal.created = stack2 ?? get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    (component_context.l.s ??= []).push(s);
  }
  return s;
}
function mutate(source2, value) {
  set(
    source2,
    untrack(() => get(source2))
  );
  return value;
}
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (true_default) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (true_default) {
      if (tracing_mode_flag || active_effect !== null) {
        source2.updated ??= /* @__PURE__ */ new Map();
        const count = (source2.updated.get("")?.count ?? 0) + 1;
        source2.updated.set("", { error: (
          /** @type {any} */
          null
        ), count });
        if (tracing_mode_flag || count > 5) {
          const error = get_error("updated at");
          if (error !== null) {
            let entry = source2.updated.get(error.stack);
            if (!entry) {
              entry = { error, count: 0 };
              source2.updated.set(error.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value;
}
function flush_eager_effects() {
  eager_effects_deferred = false;
  var prev_is_updating_effect = is_updating_effect;
  set_is_updating_effect(true);
  const inspects = Array.from(eager_effects);
  try {
    for (const effect2 of inspects) {
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
    }
  } finally {
    set_is_updating_effect(prev_is_updating_effect);
  }
  eager_effects.clear();
}
function update(source2, d = 1) {
  var value = get(source2);
  var result = d === 1 ? value++ : value--;
  set(source2, value);
  return result;
}
function update_pre(source2, d = 1) {
  var value = get(source2);
  return set(source2, d === 1 ? ++value : --value);
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (true_default && (flags2 & EAGER_EFFECT) !== 0) {
      eager_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived2 = (
        /** @type {Derived} */
        reaction
      );
      batch_values?.delete(derived2);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived2, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
        eager_block_effects.add(
          /** @type {Effect} */
          reaction
        );
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
var eager_effects, old_values, eager_effects_deferred;
var init_sources = __esm({
  "node_modules/svelte/src/internal/client/reactivity/sources.js"() {
    init_esm_env();
    init_runtime();
    init_equality();
    init_constants2();
    init_errors2();
    init_flags();
    init_tracing();
    init_dev();
    init_context();
    init_batch();
    init_proxy();
    init_deriveds();
    eager_effects = /* @__PURE__ */ new Set();
    old_values = /* @__PURE__ */ new Map();
    eager_effects_deferred = false;
  }
});

// node_modules/svelte/src/internal/client/proxy.js
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version = state(0);
  var stack2 = true_default && tracing_mode_flag ? get_error("created at") : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(
      /** @type {any[]} */
      value.length,
      stack2
    ));
    if (true_default) {
      value = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value
      );
    }
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path = new_path;
    tag(version, `${path} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path, prop2));
    }
    updating = false;
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          s = with_parent(() => {
            var s2 = state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (true_default && typeof prop2 === "string") {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
        } else {
          set(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version);
            if (true_default) {
              tag(s2, get_label(path, prop2));
            }
          }
        } else {
          set(s, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop2, receiver) {
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        if (true_default && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
          s = with_parent(() => {
            var p = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = state(p, stack2);
            if (true_default) {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
          if (s === void 0) {
            s = with_parent(() => {
              var p = has ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = state(p, stack2);
              if (true_default) {
                tag(s2, get_label(path, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value2 = get(s);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value2, receiver) {
        var s = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => state(UNINITIALIZED, stack2));
              sources.set(i + "", other_s);
              if (true_default) {
                tag(other_s, get_label(path, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has || get_descriptor(target, prop2)?.writable) {
            s = with_parent(() => state(void 0, stack2));
            if (true_default) {
              tag(s, get_label(path, prop2));
            }
            set(s, proxy(value2));
            sources.set(prop2, s);
          }
        } else {
          has = s.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set(s, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set(ls, n + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get(version);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function get_label(path, prop2) {
  if (typeof prop2 === "symbol") return `${path}[Symbol(${prop2.description ?? ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch {
  }
  return value;
}
function is(a, b) {
  return Object.is(get_proxied_value(a), get_proxied_value(b));
}
function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value;
      }
      return function(...args) {
        set_eager_effects_deferred();
        var result = value.apply(this, args);
        flush_eager_effects();
        return result;
      };
    }
  });
}
var regex_is_valid_identifier, ARRAY_MUTATING_METHODS;
var init_proxy = __esm({
  "node_modules/svelte/src/internal/client/proxy.js"() {
    init_esm_env();
    init_runtime();
    init_utils();
    init_sources();
    init_constants2();
    init_constants();
    init_errors2();
    init_tracing();
    init_dev();
    init_flags();
    regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
      "copyWithin",
      "fill",
      "pop",
      "push",
      "reverse",
      "shift",
      "sort",
      "splice",
      "unshift"
    ]);
  }
});

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index ?? 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}
function strict_equals(a, b, equal = true) {
  try {
    if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
      state_proxy_equality_mismatch(equal ? "===" : "!==");
    }
  } catch {
  }
  return a === b === equal;
}
function equals2(a, b, equal = true) {
  if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "==" : "!=");
  }
  return a == b === equal;
}
var init_equality2 = __esm({
  "node_modules/svelte/src/internal/client/dev/equality.js"() {
    init_warnings();
    init_proxy();
  }
});

// node_modules/svelte/src/internal/client/dom/operations.js
function init_operations2() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (true_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function child(node, is_text) {
  if (!hydrating) {
    return /* @__PURE__ */ get_first_child(node);
  }
  var child2 = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ get_first_child(hydrate_node)
  );
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    child2?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(child2);
  return child2;
}
function first_child(fragment, is_text = false) {
  if (!hydrating) {
    var first = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ get_first_child(
        /** @type {Node} */
        fragment
      )
    );
    if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
    return first;
  }
  if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    hydrate_node?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  return hydrate_node;
}
function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    if (next_sibling === null) {
      last_sibling?.after(text2);
    } else {
      next_sibling.before(text2);
    }
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(next_sibling);
  return (
    /** @type {TemplateNode} */
    next_sibling
  );
}
function clear_text_content(node) {
  node.textContent = "";
}
function should_defer_append() {
  if (!async_mode_flag) return false;
  if (eager_block_effects !== null) return false;
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  return (flags2 & EFFECT_RAN) !== 0;
}
function create_element(tag2, namespace, is2) {
  let options = is2 ? { is: is2 } : void 0;
  if (namespace) {
    return document.createElementNS(namespace, tag2, options);
  }
  return document.createElement(tag2, options);
}
function create_fragment() {
  return document.createDocumentFragment();
}
function create_comment(data = "") {
  return document.createComment(data);
}
function set_attribute(element2, key2, value = "") {
  if (key2.startsWith("xlink:")) {
    element2.setAttributeNS("http://www.w3.org/1999/xlink", key2, value);
    return;
  }
  return element2.setAttribute(key2, value);
}
var $window, $document, is_firefox, first_child_getter, next_sibling_getter;
var init_operations = __esm({
  "node_modules/svelte/src/internal/client/dom/operations.js"() {
    init_hydration();
    init_esm_env();
    init_equality2();
    init_utils();
    init_runtime();
    init_flags();
    init_constants2();
    init_batch();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/misc.js
function autofocus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    queue_micro_task(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
function remove_textarea_child(dom) {
  if (hydrating && get_first_child(dom) !== null) {
    clear_text_content(dom);
  }
}
function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          if (!evt.defaultPrevented) {
            for (
              const e of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              e.__on_r?.();
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
      { capture: true }
    );
  }
}
var listening_to_form_reset;
var init_misc = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/misc.js"() {
    init_hydration();
    init_operations();
    init_task();
    listening_to_form_reset = false;
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function listen(target, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (var name of events) {
    target.addEventListener(name, handler);
  }
  teardown(() => {
    for (var name2 of events) {
      target.removeEventListener(name2, handler);
    }
  });
}
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
  element2.addEventListener(event2, () => without_reactive_context(handler));
  const prev = element2.__on_r;
  if (prev) {
    element2.__on_r = () => {
      prev();
      on_reset(true);
    };
  } else {
    element2.__on_r = () => on_reset(true);
  }
  add_form_reset_listener();
}
var init_shared = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js"() {
    init_effects();
    init_runtime();
    init_misc();
  }
});

// node_modules/svelte/src/internal/client/reactivity/effects.js
function validate_effect(rune) {
  if (active_effect === null) {
    if (active_reaction === null) {
      effect_orphan(rune);
    }
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown(rune);
  }
}
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync) {
  var parent = active_effect;
  if (true_default) {
    while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (true_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e2) {
      destroy_effect(effect2);
      throw e2;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var e = effect2;
  if (sync && e.deps === null && e.teardown === null && e.nodes_start === null && e.first === e.last && // either `null`, or a singular child
  (e.f & EFFECT_PRESERVED) === 0) {
    e = e.first;
    if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e !== null) {
      e.f |= EFFECT_TRANSPARENT;
    }
  }
  if (e !== null) {
    e.parent = parent;
    if (parent !== null) {
      push_effect(e, parent);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
      var derived2 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived2.effects ??= []).push(e);
    }
  }
  return effect2;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}
function user_effect(fn) {
  validate_effect("$effect");
  if (true_default) {
    define_property(fn, "name", {
      value: "$effect"
    });
  }
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & EFFECT_RAN) === 0;
  if (defer) {
    var context2 = (
      /** @type {ComponentContext} */
      component_context
    );
    (context2.e ??= []).push(fn);
  } else {
    return create_user_effect(fn);
  }
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function user_pre_effect(fn) {
  validate_effect("$effect.pre");
  if (true_default) {
    define_property(fn, "name", {
      value: "$effect.pre"
    });
  }
  return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
}
function eager_effect(fn) {
  return create_effect(EAGER_EFFECT, fn, true);
}
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function legacy_pre_effect(deps, fn) {
  var context2 = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  var token = { effect: null, ran: false, deps };
  context2.l.$.push(token);
  token.effect = render_effect(() => {
    deps();
    if (token.ran) return;
    token.ran = true;
    untrack(fn);
  });
}
function legacy_pre_effect_reset() {
  var context2 = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  render_effect(() => {
    for (var token of context2.l.$) {
      token.deps();
      var effect2 = token.effect;
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
      token.ran = false;
    }
  });
}
function async_effect(fn) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function template_effect(fn, sync = [], async2 = [], blockers = []) {
  flatten(blockers, sync, async2, (values) => {
    create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
  });
}
function deferred_template_effect(fn, sync = [], async2 = [], blockers = []) {
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var is_async = async2.length > 0 || blockers.length > 0;
  if (is_async) batch.increment(true);
  flatten(blockers, sync, async2, (values) => {
    create_effect(EFFECT, () => fn(...values.map(get)), false);
    if (is_async) batch.decrement(true);
  });
}
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (true_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function managed(fn, flags2 = 0) {
  var effect2 = create_effect(MANAGED_EFFECT | flags2, fn, true);
  if (true_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function branch(fn) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller2 = effect2.ac;
    if (controller2 !== null) {
      without_reactive_context(() => {
        controller2.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null && effect2.nodes_end !== null) {
    remove_effect_dom(
      effect2.nodes_start,
      /** @type {TemplateNode} */
      effect2.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.transitions;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (true_default) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = effect2.ac = null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
function pause_effect(effect2, callback, destroy = true) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    if (destroy) destroy_effect(effect2);
    if (callback) callback();
  });
}
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) {
      transition2.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child2.f & BRANCH_EFFECT) !== 0 && (effect2.f & BLOCK_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function resume_effect(effect2) {
  resume_children(effect2, true);
}
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0) return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transition2.in();
      }
    }
  }
}
function aborted(effect2 = (
  /** @type {Effect} */
  active_effect
)) {
  return (effect2.f & DESTROYED) !== 0;
}
function move_effect(effect2, fragment) {
  var node = effect2.nodes_start;
  var end = effect2.nodes_end;
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    fragment.append(node);
    node = next2;
  }
}
var init_effects = __esm({
  "node_modules/svelte/src/internal/client/reactivity/effects.js"() {
    init_runtime();
    init_constants2();
    init_errors2();
    init_esm_env();
    init_utils();
    init_operations();
    init_context();
    init_batch();
    init_async();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/legacy.js
function capture_signals(fn) {
  var previous_captured_signals = captured_signals;
  try {
    captured_signals = /* @__PURE__ */ new Set();
    untrack(fn);
    if (previous_captured_signals !== null) {
      for (var signal of captured_signals) {
        previous_captured_signals.add(signal);
      }
    }
    return captured_signals;
  } finally {
    captured_signals = previous_captured_signals;
  }
}
function invalidate_inner_signals(fn) {
  for (var signal of capture_signals(fn)) {
    internal_set(signal, signal.v);
  }
}
var captured_signals;
var init_legacy = __esm({
  "node_modules/svelte/src/internal/client/legacy.js"() {
    init_sources();
    init_runtime();
    captured_signals = null;
  }
});

// node_modules/svelte/src/internal/client/runtime.js
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
function set_active_effect(effect2) {
  active_effect = effect2;
}
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
function set_untracked_writes(value) {
  untracked_writes = value;
}
function set_update_version(value) {
  update_version = value;
}
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length = dependencies.length;
      for (var i = 0; i < length; i++) {
        var dependency = dependencies[i];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if ((flags2 & CONNECTED) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (is_updating_effect && effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i = skipped_deps; i < deps.length; i++) {
          (deps[i].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & CONNECTED) !== 0) {
      dependency.f ^= CONNECTED;
      dependency.f &= ~WAS_MARKED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
function update_effect(effect2) {
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (true_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack(effect2.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (true_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (true_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
async function tick() {
  if (async_mode_flag) {
    return new Promise((f) => {
      requestAnimationFrame(() => f());
      setTimeout(() => f());
    });
  }
  await Promise.resolve();
  flushSync();
}
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (true_default) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        var trace2 = get_error("traced at");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== last?.stack) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      var derived2 = (
        /** @type {Derived} */
        signal
      );
      var value = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value = execute_derived(derived2);
      }
      old_values.set(derived2, value);
      return value;
    }
  } else if (is_derived && (!batch_values?.has(signal) || current_batch?.is_fork && !effect_tracking())) {
    derived2 = /** @type {Derived} */
    signal;
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
    if (is_updating_effect && effect_tracking() && (derived2.f & CONNECTED) === 0) {
      reconnect(derived2);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function reconnect(derived2) {
  if (derived2.deps === null) return;
  derived2.f ^= CONNECTED;
  for (const dep of derived2.deps) {
    (dep.reactions ??= []).push(derived2);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      reconnect(
        /** @type {Derived} */
        dep
      );
    }
  }
}
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED) return true;
  if (derived2.deps === null) return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function safe_get(signal) {
  return signal && get(signal);
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function exclude_from_object(obj, keys) {
  var result = {};
  for (var key2 in obj) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  for (var symbol of Object.getOwnPropertySymbols(obj)) {
    if (Object.propertyIsEnumerable.call(obj, symbol) && !keys.includes(symbol)) {
      result[symbol] = obj[symbol];
    }
  }
  return result;
}
function deep_read_state(value) {
  if (typeof value !== "object" || !value || value instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value) {
    deep_read(value);
  } else if (!Array.isArray(value)) {
    for (let key2 in value) {
      const prop2 = value[key2];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
  !(value instanceof EventTarget) && !visited.has(value)) {
    visited.add(value);
    if (value instanceof Date) {
      value.getTime();
    }
    for (let key2 in value) {
      try {
        deep_read(value[key2], visited);
      } catch (e) {
      }
    }
    const proto = get_prototype_of(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key2 in descriptors) {
        const get3 = descriptors[key2].get;
        if (get3) {
          try {
            get3.call(value);
          } catch (e) {
          }
        }
      }
    }
  }
}
var is_updating_effect, is_destroying_effect, active_reaction, untracking, active_effect, current_sources, new_deps, skipped_deps, untracked_writes, write_version, read_version, update_version, STATUS_MASK;
var init_runtime = __esm({
  "node_modules/svelte/src/internal/client/runtime.js"() {
    init_esm_env();
    init_utils();
    init_effects();
    init_constants2();
    init_sources();
    init_deriveds();
    init_flags();
    init_tracing();
    init_dev();
    init_context();
    init_warnings();
    init_batch();
    init_error_handling();
    init_constants();
    init_legacy();
    init_shared();
    is_updating_effect = false;
    is_destroying_effect = false;
    active_reaction = null;
    untracking = false;
    active_effect = null;
    current_sources = null;
    new_deps = null;
    skipped_deps = 0;
    untracked_writes = null;
    write_version = 1;
    read_version = 0;
    update_version = read_version;
    STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
  }
});

// node_modules/svelte/src/attachments/index.js
function createAttachmentKey() {
  return Symbol(ATTACHMENT_KEY);
}
var init_attachments = __esm({
  "node_modules/svelte/src/attachments/index.js"() {
    init_client();
    init_constants();
    init_index_client();
    init_effects();
  }
});

// node_modules/svelte/src/utils.js
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}
function is_void(name) {
  return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
function can_delegate_event(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
function normalize_attribute(name) {
  name = name.toLowerCase();
  return ATTRIBUTE_ALIASES[name] ?? name;
}
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
function is_raw_text_element(name) {
  return RAW_TEXT_ELEMENTS.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    name
  );
}
function sanitize_location(location) {
  return (
    /** @type {T} */
    location?.replace(/\//g, "/\u200B")
  );
}
var regex_return_characters, VOID_ELEMENT_NAMES, DELEGATED_EVENTS, DOM_BOOLEAN_ATTRIBUTES, ATTRIBUTE_ALIASES, DOM_PROPERTIES, PASSIVE_EVENTS, STATE_CREATION_RUNES, RUNES, RAW_TEXT_ELEMENTS;
var init_utils2 = __esm({
  "node_modules/svelte/src/utils.js"() {
    regex_return_characters = /\r/g;
    VOID_ELEMENT_NAMES = [
      "area",
      "base",
      "br",
      "col",
      "command",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    DELEGATED_EVENTS = [
      "beforeinput",
      "click",
      "change",
      "dblclick",
      "contextmenu",
      "focusin",
      "focusout",
      "input",
      "keydown",
      "keyup",
      "mousedown",
      "mousemove",
      "mouseout",
      "mouseover",
      "mouseup",
      "pointerdown",
      "pointermove",
      "pointerout",
      "pointerover",
      "pointerup",
      "touchend",
      "touchmove",
      "touchstart"
    ];
    DOM_BOOLEAN_ATTRIBUTES = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "indeterminate",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected",
      "webkitdirectory",
      "defer",
      "disablepictureinpicture",
      "disableremoteplayback"
    ];
    ATTRIBUTE_ALIASES = {
      // no `class: 'className'` because we handle that separately
      formnovalidate: "formNoValidate",
      ismap: "isMap",
      nomodule: "noModule",
      playsinline: "playsInline",
      readonly: "readOnly",
      defaultvalue: "defaultValue",
      defaultchecked: "defaultChecked",
      srcobject: "srcObject",
      novalidate: "noValidate",
      allowfullscreen: "allowFullscreen",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback"
    };
    DOM_PROPERTIES = [
      ...DOM_BOOLEAN_ATTRIBUTES,
      "formNoValidate",
      "isMap",
      "noModule",
      "playsInline",
      "readOnly",
      "value",
      "volume",
      "defaultValue",
      "defaultChecked",
      "srcObject",
      "noValidate",
      "allowFullscreen",
      "disablePictureInPicture",
      "disableRemotePlayback"
    ];
    PASSIVE_EVENTS = ["touchstart", "touchmove"];
    STATE_CREATION_RUNES = /** @type {const} */
    [
      "$state",
      "$state.raw",
      "$derived",
      "$derived.by"
    ];
    RUNES = /** @type {const} */
    [
      ...STATE_CREATION_RUNES,
      "$state.eager",
      "$state.snapshot",
      "$props",
      "$props.id",
      "$bindable",
      "$effect",
      "$effect.pre",
      "$effect.tracking",
      "$effect.root",
      "$effect.pending",
      "$inspect",
      "$inspect().with",
      "$inspect.trace",
      "$host"
    ];
    RAW_TEXT_ELEMENTS = /** @type {const} */
    ["textarea", "script", "style", "title"];
  }
});

// node_modules/svelte/src/internal/client/dev/assign.js
function compare(a, b, property, location) {
  if (a !== b) {
    assignment_value_stale(
      property,
      /** @type {string} */
      sanitize_location(location)
    );
  }
  return a;
}
function assign(object, property, value, location) {
  return compare(
    object[property] = value,
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_and(object, property, value, location) {
  return compare(
    object[property] &&= value,
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_or(object, property, value, location) {
  return compare(
    object[property] ||= value,
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_nullish(object, property, value, location) {
  return compare(
    object[property] ??= value,
    untrack(() => object[property]),
    property,
    location
  );
}
var init_assign = __esm({
  "node_modules/svelte/src/internal/client/dev/assign.js"() {
    init_utils2();
    init_runtime();
    init_warnings();
  }
});

// node_modules/svelte/src/internal/client/dev/css.js
function register_style(hash2, style) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = /* @__PURE__ */ new Set();
    all_styles.set(hash2, styles);
  }
  styles.add(style);
}
function cleanup_styles(hash2) {
  var styles = all_styles.get(hash2);
  if (!styles) return;
  for (const style of styles) {
    style.remove();
  }
  all_styles.delete(hash2);
}
var all_styles;
var init_css = __esm({
  "node_modules/svelte/src/internal/client/dev/css.js"() {
    all_styles = /* @__PURE__ */ new Map();
  }
});

// node_modules/svelte/src/internal/client/dev/elements.js
function add_locations(fn, filename, locations) {
  return (...args) => {
    const dom = fn(...args);
    var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
    assign_locations(node, filename, locations);
    return dom;
  };
}
function assign_location(element2, filename, location) {
  element2.__svelte_meta = {
    parent: dev_stack,
    loc: { file: filename, line: location[0], column: location[1] }
  };
  if (location[2]) {
    assign_locations(element2.firstChild, filename, location[2]);
  }
}
function assign_locations(node, filename, locations) {
  var i = 0;
  var depth = 0;
  while (node && i < locations.length) {
    if (hydrating && node.nodeType === COMMENT_NODE) {
      var comment2 = (
        /** @type {Comment} */
        node
      );
      if (comment2.data === HYDRATION_START || comment2.data === HYDRATION_START_ELSE) depth += 1;
      else if (comment2.data[0] === HYDRATION_END) depth -= 1;
    }
    if (depth === 0 && node.nodeType === ELEMENT_NODE) {
      assign_location(
        /** @type {Element} */
        node,
        filename,
        locations[i++]
      );
    }
    node = node.nextSibling;
  }
}
var init_elements = __esm({
  "node_modules/svelte/src/internal/client/dev/elements.js"() {
    init_constants2();
    init_constants();
    init_hydration();
    init_context();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/events.js
function replay_events(dom) {
  if (!hydrating) return;
  dom.removeAttribute("onload");
  dom.removeAttribute("onerror");
  const event2 = dom.__e;
  if (event2 !== void 0) {
    dom.__e = void 0;
    queueMicrotask(() => {
      if (dom.isConnected) {
        dom.dispatchEvent(event2);
      }
    });
  }
}
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event2);
    }
    if (!event2.cancelBubble) {
      return without_reactive_context(() => {
        return handler?.call(this, event2);
      });
    }
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function event(event_name, dom, handler, capture2, passive2) {
  var options = { capture: capture2, passive: passive2 };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || // @ts-ignore
  dom === window || // @ts-ignore
  dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = event2.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          delegated.call(current_target, event2);
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function apply(thunk, element2, args, component2, loc, has_side_effects = false, remove_parens = false) {
  let handler;
  let error;
  try {
    handler = thunk();
  } catch (e) {
    error = e;
  }
  if (typeof handler !== "function" && (has_side_effects || handler != null || error)) {
    const filename = component2?.[FILENAME];
    const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
    const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? "capture" : "";
    const event_name = args[0]?.type + phase;
    const description = `\`${event_name}\` handler${location}`;
    const suggestion = remove_parens ? "remove the trailing `()`" : "add a leading `() =>`";
    event_handler_invalid(description, suggestion);
    if (error) {
      throw error;
    }
  }
  handler?.apply(element2, args);
}
var all_registered_events, root_event_handles, last_propagated_event;
var init_events = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/events.js"() {
    init_effects();
    init_utils();
    init_hydration();
    init_task();
    init_constants();
    init_warnings();
    init_runtime();
    init_shared();
    all_registered_events = /* @__PURE__ */ new Set();
    root_event_handles = /* @__PURE__ */ new Set();
    last_propagated_event = null;
  }
});

// node_modules/svelte/src/internal/client/dom/reconciler.js
function create_fragment_from_html(html3) {
  var elem = document.createElement("template");
  elem.innerHTML = html3.replaceAll("<!>", "<!---->");
  return elem.content;
}
var init_reconciler = __esm({
  "node_modules/svelte/src/internal/client/dom/reconciler.js"() {
  }
});

// node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes_start === null) {
    effect2.nodes_start = start;
    effect2.nodes_end = end;
  }
}
// @__NO_SIDE_EFFECTS__
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment) node = /** @type {Node} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_namespace(content, flags2, ns = "svg") {
  var has_start = !content.startsWith("<!>");
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (!node) {
      var fragment = (
        /** @type {DocumentFragment} */
        create_fragment_from_html(wrapped)
      );
      var root = (
        /** @type {Element} */
        get_first_child(fragment)
      );
      if (is_fragment) {
        node = document.createDocumentFragment();
        while (get_first_child(root)) {
          node.appendChild(
            /** @type {Node} */
            get_first_child(root)
          );
        }
      } else {
        node = /** @type {Element} */
        get_first_child(root);
      }
    }
    var clone2 = (
      /** @type {TemplateNode} */
      node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_svg(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "svg");
}
// @__NO_SIDE_EFFECTS__
function from_mathml(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "math");
}
function fragment_from_tree(structure, ns) {
  var fragment = create_fragment();
  for (var item of structure) {
    if (typeof item === "string") {
      fragment.append(create_text(item));
      continue;
    }
    if (item === void 0 || item[0][0] === "/") {
      fragment.append(create_comment(item ? item[0].slice(3) : ""));
      continue;
    }
    const [name, attributes2, ...children] = item;
    const namespace = name === "svg" ? NAMESPACE_SVG : name === "math" ? NAMESPACE_MATHML : ns;
    var element2 = create_element(name, namespace, attributes2?.is);
    for (var key2 in attributes2) {
      set_attribute(element2, key2, attributes2[key2]);
    }
    if (children.length > 0) {
      var target = element2.tagName === "TEMPLATE" ? (
        /** @type {HTMLTemplateElement} */
        element2.content
      ) : element2;
      target.append(
        fragment_from_tree(children, element2.tagName === "foreignObject" ? void 0 : namespace)
      );
    }
    fragment.append(element2);
  }
  return fragment;
}
// @__NO_SIDE_EFFECTS__
function from_tree(structure, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      const ns = (flags2 & TEMPLATE_USE_SVG) !== 0 ? NAMESPACE_SVG : (flags2 & TEMPLATE_USE_MATHML) !== 0 ? NAMESPACE_MATHML : void 0;
      node = fragment_from_tree(structure, ns);
      if (!is_fragment) node = /** @type {Node} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
function with_script(fn) {
  return () => run_scripts(fn());
}
function run_scripts(node) {
  if (hydrating) return node;
  const is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE;
  const scripts = (
    /** @type {HTMLElement} */
    node.tagName === "SCRIPT" ? [
      /** @type {HTMLScriptElement} */
      node
    ] : node.querySelectorAll("script")
  );
  const effect2 = (
    /** @type {Effect} */
    active_effect
  );
  for (const script of scripts) {
    const clone2 = document.createElement("script");
    for (var attribute of script.attributes) {
      clone2.setAttribute(attribute.name, attribute.value);
    }
    clone2.textContent = script.textContent;
    if (is_fragment ? node.firstChild === script : node === script) {
      effect2.nodes_start = clone2;
    }
    if (is_fragment ? node.lastChild === script : node === script) {
      effect2.nodes_end = clone2;
    }
    script.replaceWith(clone2);
  }
  return node;
}
function text(value = "") {
  if (!hydrating) {
    var t = create_text(value + "");
    assign_nodes(t, t);
    return t;
  }
  var node = hydrate_node;
  if (node.nodeType !== TEXT_NODE) {
    node.before(node = create_text());
    set_hydrate_node(node);
  }
  assign_nodes(node, node);
  return node;
}
function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment();
  var start = document.createComment("");
  var anchor = create_text();
  frag.append(start, anchor);
  assign_nodes(start, anchor);
  return frag;
}
function append(anchor, dom) {
  if (hydrating) {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if ((effect2.f & EFFECT_RAN) === 0 || effect2.nodes_end === null) {
      effect2.nodes_end = hydrate_node;
    }
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
function props_id() {
  if (hydrating && hydrate_node && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.textContent?.startsWith(`$`)) {
    const id = hydrate_node.textContent.substring(1);
    hydrate_next();
    return id;
  }
  (window.__svelte ??= {}).uid ??= 1;
  return `c${window.__svelte.uid++}`;
}
var init_template = __esm({
  "node_modules/svelte/src/internal/client/dom/template.js"() {
    init_hydration();
    init_operations();
    init_reconciler();
    init_runtime();
    init_constants();
    init_constants2();
  }
});

// node_modules/svelte/src/internal/client/render.js
function set_should_intro(value) {
  should_intro = value;
}
function set_text(text2, value) {
  var str = value == null ? "" : typeof value === "object" ? value + "" : value;
  if (str !== (text2.__t ??= text2.nodeValue)) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  init_operations2();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component2, { ...options, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations2();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
function _mount(Component, { target, anchor, props = {}, events, context: context2, intro = true }) {
  init_operations2();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n = document_listeners.get(event_name);
      if (n === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount3 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: () => {
        }
      },
      (anchor_node2) => {
        if (context2) {
          push({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context2;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context2) {
          pop();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount3);
  return component2;
}
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (true_default) {
    if (STATE_SYMBOL in component2) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}
var should_intro, document_listeners, mounted_components;
var init_render = __esm({
  "node_modules/svelte/src/internal/client/render.js"() {
    init_esm_env();
    init_operations();
    init_constants();
    init_runtime();
    init_context();
    init_effects();
    init_hydration();
    init_utils();
    init_events();
    init_warnings();
    init_errors2();
    init_template();
    init_utils2();
    init_constants2();
    init_boundary();
    should_intro = true;
    document_listeners = /* @__PURE__ */ new Map();
    mounted_components = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/svelte/src/internal/client/dev/hmr.js
function hmr(original, get_source) {
  function wrapper(anchor, props) {
    let instance = {};
    let effect2;
    let ran = false;
    block(() => {
      const source2 = get_source();
      const component2 = get(source2);
      if (effect2) {
        for (var k in instance) delete instance[k];
        destroy_effect(effect2);
      }
      effect2 = branch(() => {
        if (ran) set_should_intro(false);
        Object.defineProperties(
          instance,
          Object.getOwnPropertyDescriptors(
            // @ts-expect-error
            new.target ? new component2(anchor, props) : component2(anchor, props)
          )
        );
        if (ran) set_should_intro(true);
      });
    }, EFFECT_TRANSPARENT);
    ran = true;
    if (hydrating) {
      anchor = hydrate_node;
    }
    return instance;
  }
  wrapper[FILENAME] = original[FILENAME];
  wrapper[HMR] = {
    // When we accept an update, we set the original source to the new component
    original,
    // The `get_source` parameter reads `wrapper[HMR].source`, but in the `accept`
    // function we always replace it with `previous[HMR].source`, which in practice
    // means we only ever update the original
    source: source(original)
  };
  return wrapper;
}
var init_hmr = __esm({
  "node_modules/svelte/src/internal/client/dev/hmr.js"() {
    init_constants();
    init_constants2();
    init_hydration();
    init_effects();
    init_sources();
    init_render();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dev/ownership.js
function create_ownership_validator(props) {
  const component2 = component_context?.function;
  const parent = component_context?.p?.function;
  return {
    /**
     * @param {string} prop
     * @param {any[]} path
     * @param {any} result
     * @param {number} line
     * @param {number} column
     */
    mutation: (prop2, path, result, line, column) => {
      const name = path[0];
      if (is_bound_or_unset(props, name) || !parent) {
        return result;
      }
      let value = props;
      for (let i = 0; i < path.length - 1; i++) {
        value = value[path[i]];
        if (!value?.[STATE_SYMBOL]) {
          return result;
        }
      }
      const location = sanitize_location(`${component2[FILENAME]}:${line}:${column}`);
      ownership_invalid_mutation(name, location, prop2, parent[FILENAME]);
      return result;
    },
    /**
     * @param {any} key
     * @param {any} child_component
     * @param {() => any} value
     */
    binding: (key2, child_component, value) => {
      if (!is_bound_or_unset(props, key2) && parent && value()?.[STATE_SYMBOL]) {
        ownership_invalid_binding(
          component2[FILENAME],
          key2,
          child_component[FILENAME],
          parent[FILENAME]
        );
      }
    }
  };
}
function is_bound_or_unset(props, prop_name) {
  const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
  return !!get_descriptor(props, prop_name)?.set || is_entry_props && prop_name in props || !(prop_name in props);
}
var init_ownership = __esm({
  "node_modules/svelte/src/internal/client/dev/ownership.js"() {
    init_utils();
    init_constants2();
    init_constants();
    init_context();
    init_warnings();
    init_utils2();
  }
});

// node_modules/svelte/src/internal/client/dev/legacy.js
function check_target(target) {
  if (target) {
    component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
  }
}
function legacy_api() {
  const component2 = component_context?.function;
  function error(method) {
    component_api_changed(method, component2[FILENAME]);
  }
  return {
    $destroy: () => error("$destroy()"),
    $on: () => error("$on(...)"),
    $set: () => error("$set(...)")
  };
}
var init_legacy2 = __esm({
  "node_modules/svelte/src/internal/client/dev/legacy.js"() {
    init_errors2();
    init_context();
    init_constants();
  }
});

// node_modules/svelte/src/internal/client/dev/inspect.js
function inspect(get_value, inspector, show_stack = false) {
  validate_effect("$inspect");
  let initial = true;
  let error = (
    /** @type {any} */
    UNINITIALIZED
  );
  eager_effect(() => {
    try {
      var value = get_value();
    } catch (e) {
      error = e;
      return;
    }
    var snap = snapshot(value, true, true);
    untrack(() => {
      if (show_stack) {
        inspector(...snap);
        if (!initial) {
          const stack2 = get_error("$inspect(...)");
          if (stack2) {
            console.groupCollapsed("stack trace");
            console.log(stack2);
            console.groupEnd();
          }
        }
      } else {
        inspector(initial ? "init" : "update", ...snap);
      }
    });
    initial = false;
  });
  render_effect(() => {
    try {
      get_value();
    } catch {
    }
    if (error !== UNINITIALIZED) {
      console.error(error);
      error = UNINITIALIZED;
    }
  });
}
var init_inspect = __esm({
  "node_modules/svelte/src/internal/client/dev/inspect.js"() {
    init_constants();
    init_clone();
    init_effects();
    init_runtime();
    init_dev();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/async.js
function async(node, blockers = [], expressions = [], fn) {
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = !boundary2.is_pending();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var was_hydrating = hydrating;
  if (was_hydrating) {
    hydrate_next();
    var previous_hydrate_node = hydrate_node;
    var end = skip_nodes(false);
    set_hydrate_node(end);
  }
  flatten(blockers, [], expressions, (values) => {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(previous_hydrate_node);
    }
    try {
      for (const d of values) get(d);
      fn(node, ...values);
    } finally {
      if (was_hydrating) {
        set_hydrating(false);
      }
      boundary2.update_pending_count(-1);
      batch.decrement(blocking);
    }
  });
}
var init_async2 = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/async.js"() {
    init_async();
    init_batch();
    init_runtime();
    init_hydration();
    init_boundary();
  }
});

// node_modules/svelte/src/internal/client/dev/validation.js
function validate_snippet_args(anchor, ...args) {
  if (typeof anchor !== "object" || !(anchor instanceof Node)) {
    invalid_snippet_arguments();
  }
  for (let arg of args) {
    if (typeof arg !== "function") {
      invalid_snippet_arguments();
    }
  }
}
var init_validation = __esm({
  "node_modules/svelte/src/internal/client/dev/validation.js"() {
    init_errors2();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/branches.js
var BranchManager;
var init_branches = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/branches.js"() {
    init_batch();
    init_effects();
    init_hydration();
    init_operations();
    BranchManager = class {
      /** @type {TemplateNode} */
      anchor;
      /** @type {Map<Batch, Key>} */
      #batches = /* @__PURE__ */ new Map();
      /**
       * Map of keys to effects that are currently rendered in the DOM.
       * These effects are visible and actively part of the document tree.
       * Example:
       * ```
       * {#if condition}
       * 	foo
       * {:else}
       * 	bar
       * {/if}
       * ```
       * Can result in the entries `true->Effect` and `false->Effect`
       * @type {Map<Key, Effect>}
       */
      #onscreen = /* @__PURE__ */ new Map();
      /**
       * Similar to #onscreen with respect to the keys, but contains branches that are not yet
       * in the DOM, because their insertion is deferred.
       * @type {Map<Key, Branch>}
       */
      #offscreen = /* @__PURE__ */ new Map();
      /**
       * Keys of effects that are currently outroing
       * @type {Set<Key>}
       */
      #outroing = /* @__PURE__ */ new Set();
      /**
       * Whether to pause (i.e. outro) on change, or destroy immediately.
       * This is necessary for `<svelte:element>`
       */
      #transition = true;
      /**
       * @param {TemplateNode} anchor
       * @param {boolean} transition
       */
      constructor(anchor, transition2 = true) {
        this.anchor = anchor;
        this.#transition = transition2;
      }
      #commit = () => {
        var batch = (
          /** @type {Batch} */
          current_batch
        );
        if (!this.#batches.has(batch)) return;
        var key2 = (
          /** @type {Key} */
          this.#batches.get(batch)
        );
        var onscreen = this.#onscreen.get(key2);
        if (onscreen) {
          resume_effect(onscreen);
          this.#outroing.delete(key2);
        } else {
          var offscreen = this.#offscreen.get(key2);
          if (offscreen) {
            this.#onscreen.set(key2, offscreen.effect);
            this.#offscreen.delete(key2);
            offscreen.fragment.lastChild.remove();
            this.anchor.before(offscreen.fragment);
            onscreen = offscreen.effect;
          }
        }
        for (const [b, k] of this.#batches) {
          this.#batches.delete(b);
          if (b === batch) {
            break;
          }
          const offscreen2 = this.#offscreen.get(k);
          if (offscreen2) {
            destroy_effect(offscreen2.effect);
            this.#offscreen.delete(k);
          }
        }
        for (const [k, effect2] of this.#onscreen) {
          if (k === key2 || this.#outroing.has(k)) continue;
          const on_destroy = () => {
            const keys = Array.from(this.#batches.values());
            if (keys.includes(k)) {
              var fragment = document.createDocumentFragment();
              move_effect(effect2, fragment);
              fragment.append(create_text());
              this.#offscreen.set(k, { effect: effect2, fragment });
            } else {
              destroy_effect(effect2);
            }
            this.#outroing.delete(k);
            this.#onscreen.delete(k);
          };
          if (this.#transition || !onscreen) {
            this.#outroing.add(k);
            pause_effect(effect2, on_destroy, false);
          } else {
            on_destroy();
          }
        }
      };
      /**
       * @param {Batch} batch
       */
      #discard = (batch) => {
        this.#batches.delete(batch);
        const keys = Array.from(this.#batches.values());
        for (const [k, branch2] of this.#offscreen) {
          if (!keys.includes(k)) {
            destroy_effect(branch2.effect);
            this.#offscreen.delete(k);
          }
        }
      };
      /**
       *
       * @param {any} key
       * @param {null | ((target: TemplateNode) => void)} fn
       */
      ensure(key2, fn) {
        var batch = (
          /** @type {Batch} */
          current_batch
        );
        var defer = should_defer_append();
        if (fn && !this.#onscreen.has(key2) && !this.#offscreen.has(key2)) {
          if (defer) {
            var fragment = document.createDocumentFragment();
            var target = create_text();
            fragment.append(target);
            this.#offscreen.set(key2, {
              effect: branch(() => fn(target)),
              fragment
            });
          } else {
            this.#onscreen.set(
              key2,
              branch(() => fn(this.anchor))
            );
          }
        }
        this.#batches.set(batch, key2);
        if (defer) {
          for (const [k, effect2] of this.#onscreen) {
            if (k === key2) {
              batch.skipped_effects.delete(effect2);
            } else {
              batch.skipped_effects.add(effect2);
            }
          }
          for (const [k, branch2] of this.#offscreen) {
            if (k === key2) {
              batch.skipped_effects.delete(branch2.effect);
            } else {
              batch.skipped_effects.add(branch2.effect);
            }
          }
          batch.oncommit(this.#commit);
          batch.ondiscard(this.#discard);
        } else {
          if (hydrating) {
            this.anchor = hydrate_node;
          }
          this.#commit();
        }
      }
    };
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/await.js
function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var runes = is_runes();
  var v = (
    /** @type {V} */
    UNINITIALIZED
  );
  var value = runes ? source(v) : mutable_source(v, false, false);
  var error = runes ? source(v) : mutable_source(v, false, false);
  var branches = new BranchManager(node);
  block(() => {
    var input = get_input();
    var destroyed = false;
    let mismatch = hydrating && is_promise(input) === (node.data === HYDRATION_START_ELSE);
    if (mismatch) {
      set_hydrate_node(skip_nodes());
      set_hydrating(false);
    }
    if (is_promise(input)) {
      var restore = capture();
      var resolved = false;
      const resolve = (fn) => {
        if (destroyed) return;
        resolved = true;
        restore(false);
        Batch.ensure();
        if (hydrating) {
          set_hydrating(false);
        }
        try {
          fn();
        } finally {
          unset_context();
          if (!is_flushing_sync) flushSync();
        }
      };
      input.then(
        (v2) => {
          resolve(() => {
            internal_set(value, v2);
            branches.ensure(THEN, then_fn && ((target) => then_fn(target, value)));
          });
        },
        (e) => {
          resolve(() => {
            internal_set(error, e);
            branches.ensure(THEN, catch_fn && ((target) => catch_fn(target, error)));
            if (!catch_fn) {
              throw error.v;
            }
          });
        }
      );
      if (hydrating) {
        branches.ensure(PENDING, pending_fn);
      } else {
        queue_micro_task(() => {
          if (!resolved) {
            resolve(() => {
              branches.ensure(PENDING, pending_fn);
            });
          }
        });
      }
    } else {
      internal_set(value, input);
      branches.ensure(THEN, then_fn && ((target) => then_fn(target, value)));
    }
    if (mismatch) {
      set_hydrating(true);
    }
    return () => {
      destroyed = true;
    };
  });
}
var PENDING, THEN;
var init_await = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/await.js"() {
    init_utils();
    init_effects();
    init_sources();
    init_hydration();
    init_task();
    init_constants();
    init_context();
    init_batch();
    init_branches();
    init_async();
    PENDING = 0;
    THEN = 1;
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function if_block(node, fn, elseif = false) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var flags2 = elseif ? EFFECT_TRANSPARENT : 0;
  function update_branch(condition, fn2) {
    if (hydrating) {
      const is_else = read_hydration_instruction(node) === HYDRATION_START_ELSE;
      if (condition === is_else) {
        var anchor = skip_nodes();
        set_hydrate_node(anchor);
        branches.anchor = anchor;
        set_hydrating(false);
        branches.ensure(condition, fn2);
        set_hydrating(true);
        return;
      }
    }
    branches.ensure(condition, fn2);
  }
  block(() => {
    var has_branch = false;
    fn((fn2, flag = true) => {
      has_branch = true;
      update_branch(flag, fn2);
    });
    if (!has_branch) {
      update_branch(false, null);
    }
  }, flags2);
}
var init_if = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/if.js"() {
    init_constants2();
    init_hydration();
    init_effects();
    init_constants();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/key.js
function key(node, get_key, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var legacy = !is_runes();
  block(() => {
    var key2 = get_key();
    if (legacy && key2 !== null && typeof key2 === "object") {
      key2 = /** @type {V} */
      {};
    }
    branches.ensure(key2, render_fn);
  });
}
var init_key = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/key.js"() {
    init_context();
    init_effects();
    init_hydration();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/css-props.js
function css_props(element2, get_styles) {
  if (hydrating) {
    set_hydrate_node(
      /** @type {TemplateNode} */
      get_first_child(element2)
    );
  }
  render_effect(() => {
    var styles = get_styles();
    for (var key2 in styles) {
      var value = styles[key2];
      if (value) {
        element2.style.setProperty(key2, value);
      } else {
        element2.style.removeProperty(key2);
      }
    }
  });
}
var init_css_props = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/css-props.js"() {
    init_effects();
    init_hydration();
    init_operations();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/html.js
function check_hash(element2, server_hash, value) {
  if (!server_hash || server_hash === hash(String(value ?? ""))) return;
  let location;
  const loc = element2.__svelte_meta?.loc;
  if (loc) {
    location = `near ${loc.file}:${loc.line}:${loc.column}`;
  } else if (dev_current_component_function?.[FILENAME]) {
    location = `in ${dev_current_component_function[FILENAME]}`;
  }
  hydration_html_changed(sanitize_location(location));
}
function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
  var anchor = node;
  var value = "";
  template_effect(() => {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (value === (value = get_value() ?? "")) {
      if (hydrating) hydrate_next();
      return;
    }
    if (effect2.nodes_start !== null) {
      remove_effect_dom(
        effect2.nodes_start,
        /** @type {TemplateNode} */
        effect2.nodes_end
      );
      effect2.nodes_start = effect2.nodes_end = null;
    }
    if (value === "") return;
    if (hydrating) {
      var hash2 = (
        /** @type {Comment} */
        hydrate_node.data
      );
      var next2 = hydrate_next();
      var last = next2;
      while (next2 !== null && (next2.nodeType !== COMMENT_NODE || /** @type {Comment} */
      next2.data !== "")) {
        last = next2;
        next2 = /** @type {TemplateNode} */
        get_next_sibling(next2);
      }
      if (next2 === null) {
        hydration_mismatch();
        throw HYDRATION_ERROR;
      }
      if (true_default && !skip_warning) {
        check_hash(
          /** @type {Element} */
          next2.parentNode,
          hash2,
          value
        );
      }
      assign_nodes(hydrate_node, last);
      anchor = set_hydrate_node(next2);
      return;
    }
    var html3 = value + "";
    if (svg) html3 = `<svg>${html3}</svg>`;
    else if (mathml) html3 = `<math>${html3}</math>`;
    var node2 = create_fragment_from_html(html3);
    if (svg || mathml) {
      node2 = /** @type {Element} */
      get_first_child(node2);
    }
    assign_nodes(
      /** @type {TemplateNode} */
      get_first_child(node2),
      /** @type {TemplateNode} */
      node2.lastChild
    );
    if (svg || mathml) {
      while (get_first_child(node2)) {
        anchor.before(
          /** @type {Node} */
          get_first_child(node2)
        );
      }
    } else {
      anchor.before(node2);
    }
  });
}
var init_html = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/html.js"() {
    init_constants();
    init_effects();
    init_hydration();
    init_reconciler();
    init_template();
    init_warnings();
    init_utils2();
    init_esm_env();
    init_context();
    init_operations();
    init_runtime();
    init_constants2();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/slot.js
function slot(anchor, $$props, name, slot_props, fallback_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var slot_fn = $$props.$$slots?.[name];
  var is_interop = false;
  if (slot_fn === true) {
    slot_fn = $$props[name === "default" ? "children" : name];
    is_interop = true;
  }
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, is_interop ? () => slot_props : slot_props);
  }
}
function sanitize_slots(props) {
  const sanitized = {};
  if (props.children) sanitized.default = true;
  for (const key2 in props.$$slots) {
    sanitized[key2] = true;
  }
  return sanitized;
}
var init_slot = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/slot.js"() {
    init_hydration();
  }
});

// node_modules/svelte/src/internal/shared/validate.js
function validate_void_dynamic_element(tag_fn) {
  const tag2 = tag_fn();
  if (tag2 && is_void(tag2)) {
    dynamic_void_element_content(tag2);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag2 = tag_fn();
  const is_string = typeof tag2 === "string";
  if (tag2 && !is_string) {
    svelte_element_invalid_this_value();
  }
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    store_invalid_shape(name);
  }
}
function prevent_snippet_stringification(fn) {
  fn.toString = () => {
    snippet_without_render_tag();
    return "";
  };
  return fn;
}
var init_validate = __esm({
  "node_modules/svelte/src/internal/shared/validate.js"() {
    init_utils2();
    init_warnings2();
    init_errors();
    init_errors();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/snippet.js
function snippet(node, get_snippet, ...args) {
  var branches = new BranchManager(node);
  block(() => {
    const snippet2 = get_snippet() ?? null;
    if (true_default && snippet2 == null) {
      invalid_snippet();
    }
    branches.ensure(snippet2, snippet2 && ((anchor) => snippet2(anchor, ...args)));
  }, EFFECT_TRANSPARENT);
}
function wrap_snippet(component2, fn) {
  const snippet2 = (node, ...args) => {
    var previous_component_function = dev_current_component_function;
    set_dev_current_component_function(component2);
    try {
      return fn(node, ...args);
    } finally {
      set_dev_current_component_function(previous_component_function);
    }
  };
  prevent_snippet_stringification(snippet2);
  return snippet2;
}
var init_snippet = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/snippet.js"() {
    init_constants2();
    init_effects();
    init_context();
    init_hydration();
    init_reconciler();
    init_template();
    init_warnings();
    init_errors2();
    init_esm_env();
    init_operations();
    init_validate();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js
function component(node, get_component, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  block(() => {
    var component2 = get_component() ?? null;
    branches.ensure(component2, component2 && ((target) => render_fn(target, component2)));
  }, EFFECT_TRANSPARENT);
}
var init_svelte_component = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js"() {
    init_constants2();
    init_effects();
    init_hydration();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
  let was_hydrating = hydrating;
  if (hydrating) {
    hydrate_next();
  }
  var filename = true_default && location && component_context?.function[FILENAME];
  var element2 = null;
  if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
    element2 = /** @type {Element} */
    hydrate_node;
    hydrate_next();
  }
  var anchor = (
    /** @type {TemplateNode} */
    hydrating ? hydrate_node : node
  );
  var each_item_block = current_each_item;
  var branches = new BranchManager(anchor, false);
  block(() => {
    const next_tag = get_tag() || null;
    var ns = get_namespace ? get_namespace() : is_svg || next_tag === "svg" ? NAMESPACE_SVG : null;
    if (next_tag === null) {
      branches.ensure(null, null);
      set_should_intro(true);
      return;
    }
    branches.ensure(next_tag, (anchor2) => {
      var previous_each_item = current_each_item;
      set_current_each_item(each_item_block);
      if (next_tag) {
        element2 = hydrating ? (
          /** @type {Element} */
          element2
        ) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag);
        if (true_default && location) {
          element2.__svelte_meta = {
            parent: dev_stack,
            loc: {
              file: filename,
              line: location[0],
              column: location[1]
            }
          };
        }
        assign_nodes(element2, element2);
        if (render_fn) {
          if (hydrating && is_raw_text_element(next_tag)) {
            element2.append(document.createComment(""));
          }
          var child_anchor = (
            /** @type {TemplateNode} */
            hydrating ? get_first_child(element2) : element2.appendChild(create_text())
          );
          if (hydrating) {
            if (child_anchor === null) {
              set_hydrating(false);
            } else {
              set_hydrate_node(child_anchor);
            }
          }
          render_fn(element2, child_anchor);
        }
        active_effect.nodes_end = element2;
        anchor2.before(element2);
      }
      set_current_each_item(previous_each_item);
      if (hydrating) {
        set_hydrate_node(anchor2);
      }
    });
    set_should_intro(true);
    return () => {
      if (next_tag) {
        set_should_intro(false);
      }
    };
  }, EFFECT_TRANSPARENT);
  teardown(() => {
    set_should_intro(true);
  });
  if (was_hydrating) {
    set_hydrating(true);
    set_hydrate_node(anchor);
  }
}
var init_svelte_element = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js"() {
    init_constants();
    init_hydration();
    init_operations();
    init_effects();
    init_render();
    init_each();
    init_runtime();
    init_context();
    init_esm_env();
    init_constants2();
    init_template();
    init_utils2();
    init_branches();
  }
});

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
function head(hash2, render_fn) {
  let previous_hydrate_node = null;
  let was_hydrating = hydrating;
  var anchor;
  if (hydrating) {
    previous_hydrate_node = hydrate_node;
    var head_anchor = (
      /** @type {TemplateNode} */
      get_first_child(document.head)
    );
    while (head_anchor !== null && (head_anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    head_anchor.data !== hash2)) {
      head_anchor = /** @type {TemplateNode} */
      get_next_sibling(head_anchor);
    }
    if (head_anchor === null) {
      set_hydrating(false);
    } else {
      var start = (
        /** @type {TemplateNode} */
        get_next_sibling(head_anchor)
      );
      head_anchor.remove();
      set_hydrate_node(start);
    }
  }
  if (!hydrating) {
    anchor = document.head.appendChild(create_text());
  }
  try {
    block(() => render_fn(anchor), HEAD_EFFECT);
  } finally {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(
        /** @type {TemplateNode} */
        previous_hydrate_node
      );
    }
  }
}
var init_svelte_head = __esm({
  "node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js"() {
    init_hydration();
    init_operations();
    init_effects();
    init_constants2();
  }
});

// node_modules/svelte/src/internal/client/dom/css.js
function append_styles2(anchor, css) {
  effect(() => {
    var root = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root.host ? (
        /** @type {ShadowRoot} */
        root
      ) : (
        /** @type {Document} */
        root.head ?? /** @type {Document} */
        root.ownerDocument.head
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style = document.createElement("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
      if (true_default) {
        register_style(css.hash, style);
      }
    }
  });
}
var init_css2 = __esm({
  "node_modules/svelte/src/internal/client/dom/css.js"() {
    init_esm_env();
    init_css();
    init_effects();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/actions.js
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value?.()) || {});
    if (get_value && payload?.update) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value = get_value();
        deep_read_state(value);
        if (inited && safe_not_equal(prev, value)) {
          prev = value;
          payload.update(value);
        }
      });
      inited = true;
    }
    if (payload?.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}
var init_actions = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/actions.js"() {
    init_effects();
    init_equality();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/attachments.js
function attach(node, get_fn) {
  var fn = void 0;
  var e;
  managed(() => {
    if (fn !== (fn = get_fn())) {
      if (e) {
        destroy_effect(e);
        e = null;
      }
      if (fn) {
        e = branch(() => {
          effect(() => (
            /** @type {(node: Element) => void} */
            fn(node)
          ));
        });
      }
    }
  });
}
var init_attachments2 = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/attachments.js"() {
    init_effects();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/class.js
function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value || prev === void 0) {
    var next_class_name = to_class(value, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key2 in next_classes) {
      var is_present = !!next_classes[key2];
      if (prev_classes == null || is_present !== !!prev_classes[key2]) {
        dom.classList.toggle(key2, is_present);
      }
    }
  }
  return next_classes;
}
var init_class = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/class.js"() {
    init_attributes();
    init_hydration();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/style.js
function update_styles(dom, prev = {}, next2, priority) {
  for (var key2 in next2) {
    var value = next2[key2];
    if (prev[key2] !== value) {
      if (next2[key2] == null) {
        dom.style.removeProperty(key2);
      } else {
        dom.style.setProperty(key2, value, priority);
      }
    }
  }
}
function set_style(dom, value, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value) {
    var next_style_attr = to_style(value, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles?.[0], next_styles[0]);
      update_styles(dom, prev_styles?.[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}
var init_style = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/style.js"() {
    init_attributes();
    init_hydration();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
function select_option(select, value, mounting = false) {
  if (select.multiple) {
    if (value == void 0) {
      return;
    }
    if (!is_array(value)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function init_select2(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
function bind_select_value(select, get3, set2 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  var mounting = true;
  listen_to_event_and_reset_event(select, "change", (is_reset) => {
    var query = is_reset ? "[selected]" : ":checked";
    var value;
    if (select.multiple) {
      value = [].map.call(select.querySelectorAll(query), get_option_value);
    } else {
      var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected
      select.querySelector("option:not([disabled])");
      value = selected_option && get_option_value(selected_option);
    }
    set2(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  });
  effect(() => {
    var value = get3();
    if (select === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    select_option(select, value, mounting);
    if (mounting && value === void 0) {
      var selected_option = select.querySelector(":checked");
      if (selected_option !== null) {
        value = get_option_value(selected_option);
        set2(value);
      }
    }
    select.__value = value;
    mounting = false;
  });
  init_select2(select);
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}
var init_select = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/select.js"() {
    init_effects();
    init_shared();
    init_proxy();
    init_utils();
    init_warnings();
    init_batch();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
function remove_input_defaults(input) {
  if (!hydrating) return;
  var already_removed = false;
  var remove_defaults = () => {
    if (already_removed) return;
    already_removed = true;
    if (input.hasAttribute("value")) {
      var value = input.value;
      set_attribute2(input, "value", null);
      input.value = value;
    }
    if (input.hasAttribute("checked")) {
      var checked = input.checked;
      set_attribute2(input, "checked", null);
      input.checked = checked;
    }
  };
  input.__on_r = remove_defaults;
  queue_micro_task(remove_defaults);
  add_form_reset_listener();
}
function set_value(element2, value) {
  var attributes2 = get_attributes(element2);
  if (attributes2.value === (attributes2.value = // treat null and undefined the same for the initial value
  value ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  element2.value === value && (value !== 0 || element2.nodeName !== "PROGRESS")) {
    return;
  }
  element2.value = value ?? "";
}
function set_checked(element2, checked) {
  var attributes2 = get_attributes(element2);
  if (attributes2.checked === (attributes2.checked = // treat null and undefined the same for the initial value
  checked ?? void 0)) {
    return;
  }
  element2.checked = checked;
}
function set_selected(element2, selected) {
  if (selected) {
    if (!element2.hasAttribute("selected")) {
      element2.setAttribute("selected", "");
    }
  } else {
    element2.removeAttribute("selected");
  }
}
function set_default_checked(element2, checked) {
  const existing_value = element2.checked;
  element2.defaultChecked = checked;
  element2.checked = existing_value;
}
function set_default_value(element2, value) {
  const existing_value = element2.value;
  element2.defaultValue = value;
  element2.value = existing_value;
}
function set_attribute2(element2, attribute, value, skip_warning) {
  var attributes2 = get_attributes(element2);
  if (hydrating) {
    attributes2[attribute] = element2.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element2.nodeName === "LINK") {
      if (!skip_warning) {
        check_src_in_dev_hydration(element2, attribute, value ?? "");
      }
      return;
    }
  }
  if (attributes2[attribute] === (attributes2[attribute] = value)) return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value;
  }
  if (value == null) {
    element2.removeAttribute(attribute);
  } else if (typeof value !== "string" && get_setters(element2).includes(attribute)) {
    element2[attribute] = value;
  } else {
    element2.setAttribute(attribute, value);
  }
}
function set_xlink_attribute(dom, attribute, value) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
}
function set_custom_element_data(node, prop2, value) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  let was_hydrating = hydrating;
  if (hydrating) {
    set_hydrating(false);
  }
  set_active_reaction(null);
  set_active_effect(null);
  try {
    if (
      // `style` should use `set_attribute` rather than the setter
      prop2 !== "style" && // Don't compute setters for custom elements while they aren't registered yet,
      // because during their upgrade/instantiation they might add more setters.
      // Instead, fall back to a simple "an object, then set as property" heuristic.
      (setters_cache.has(node.getAttribute("is") || node.nodeName) || // customElements may not be available in browser extension contexts
      !customElements || customElements.get(node.getAttribute("is") || node.tagName.toLowerCase()) ? get_setters(node).includes(prop2) : value && typeof value === "object")
    ) {
      node[prop2] = value;
    } else {
      set_attribute2(node, prop2, value == null ? value : String(value));
    }
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
    if (was_hydrating) {
      set_hydrating(true);
    }
  }
}
function set_attributes(element2, prev, next2, css_hash, should_remove_defaults = false, skip_warning = false) {
  if (hydrating && should_remove_defaults && element2.tagName === "INPUT") {
    var input = (
      /** @type {HTMLInputElement} */
      element2
    );
    var attribute = input.type === "checkbox" ? "defaultChecked" : "defaultValue";
    if (!(attribute in next2)) {
      remove_input_defaults(input);
    }
  }
  var attributes2 = get_attributes(element2);
  var is_custom_element = attributes2[IS_CUSTOM_ELEMENT];
  var preserve_attribute_case = !attributes2[IS_HTML];
  let is_hydrating_custom_element = hydrating && is_custom_element;
  if (is_hydrating_custom_element) {
    set_hydrating(false);
  }
  var current = prev || {};
  var is_option_element = element2.tagName === "OPTION";
  for (var key2 in prev) {
    if (!(key2 in next2)) {
      next2[key2] = null;
    }
  }
  if (next2.class) {
    next2.class = clsx2(next2.class);
  } else if (css_hash || next2[CLASS]) {
    next2.class = null;
  }
  if (next2[STYLE]) {
    next2.style ??= null;
  }
  var setters = get_setters(element2);
  for (const key3 in next2) {
    let value = next2[key3];
    if (is_option_element && key3 === "value" && value == null) {
      element2.value = element2.__value = "";
      current[key3] = value;
      continue;
    }
    if (key3 === "class") {
      var is_html = element2.namespaceURI === "http://www.w3.org/1999/xhtml";
      set_class(element2, is_html, value, css_hash, prev?.[CLASS], next2[CLASS]);
      current[key3] = value;
      current[CLASS] = next2[CLASS];
      continue;
    }
    if (key3 === "style") {
      set_style(element2, value, prev?.[STYLE], next2[STYLE]);
      current[key3] = value;
      current[STYLE] = next2[STYLE];
      continue;
    }
    var prev_value = current[key3];
    if (value === prev_value && !(value === void 0 && element2.hasAttribute(key3))) {
      continue;
    }
    current[key3] = value;
    var prefix = key3[0] + key3[1];
    if (prefix === "$$") continue;
    if (prefix === "on") {
      const opts = {};
      const event_handle_key = "$$" + key3;
      let event_name = key3.slice(2);
      var delegated = can_delegate_event(event_name);
      if (is_capture_event(event_name)) {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && prev_value) {
        if (value != null) continue;
        element2.removeEventListener(event_name, current[event_handle_key], opts);
        current[event_handle_key] = null;
      }
      if (value != null) {
        if (!delegated) {
          let handle = function(evt) {
            current[key3].call(this, evt);
          };
          current[event_handle_key] = create_event(event_name, element2, handle, opts);
        } else {
          element2[`__${event_name}`] = value;
          delegate([event_name]);
        }
      } else if (delegated) {
        element2[`__${event_name}`] = void 0;
      }
    } else if (key3 === "style") {
      set_attribute2(element2, key3, value);
    } else if (key3 === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element2,
        Boolean(value)
      );
    } else if (!is_custom_element && (key3 === "__value" || key3 === "value" && value != null)) {
      element2.value = element2.__value = value;
    } else if (key3 === "selected" && is_option_element) {
      set_selected(
        /** @type {HTMLOptionElement} */
        element2,
        value
      );
    } else {
      var name = key3;
      if (!preserve_attribute_case) {
        name = normalize_attribute(name);
      }
      var is_default = name === "defaultValue" || name === "defaultChecked";
      if (value == null && !is_custom_element && !is_default) {
        attributes2[key3] = null;
        if (name === "value" || name === "checked") {
          let input2 = (
            /** @type {HTMLInputElement} */
            element2
          );
          const use_default = prev === void 0;
          if (name === "value") {
            let previous = input2.defaultValue;
            input2.removeAttribute(name);
            input2.defaultValue = previous;
            input2.value = input2.__value = use_default ? previous : null;
          } else {
            let previous = input2.defaultChecked;
            input2.removeAttribute(name);
            input2.defaultChecked = previous;
            input2.checked = use_default ? previous : false;
          }
        } else {
          element2.removeAttribute(key3);
        }
      } else if (is_default || setters.includes(name) && (is_custom_element || typeof value !== "string")) {
        element2[name] = value;
        if (name in attributes2) attributes2[name] = UNINITIALIZED;
      } else if (typeof value !== "function") {
        set_attribute2(element2, name, value, skip_warning);
      }
    }
  }
  if (is_hydrating_custom_element) {
    set_hydrating(true);
  }
  return current;
}
function attribute_effect(element2, fn, sync = [], async2 = [], blockers = [], css_hash, should_remove_defaults = false, skip_warning = false) {
  flatten(blockers, sync, async2, (values) => {
    var prev = void 0;
    var effects = {};
    var is_select = element2.nodeName === "SELECT";
    var inited = false;
    managed(() => {
      var next2 = fn(...values.map(get));
      var current = set_attributes(
        element2,
        prev,
        next2,
        css_hash,
        should_remove_defaults,
        skip_warning
      );
      if (inited && is_select && "value" in next2) {
        select_option(
          /** @type {HTMLSelectElement} */
          element2,
          next2.value
        );
      }
      for (let symbol of Object.getOwnPropertySymbols(effects)) {
        if (!next2[symbol]) destroy_effect(effects[symbol]);
      }
      for (let symbol of Object.getOwnPropertySymbols(next2)) {
        var n = next2[symbol];
        if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {
          if (effects[symbol]) destroy_effect(effects[symbol]);
          effects[symbol] = branch(() => attach(element2, () => n));
        }
        current[symbol] = n;
      }
      prev = current;
    });
    if (is_select) {
      var select = (
        /** @type {HTMLSelectElement} */
        element2
      );
      effect(() => {
        select_option(
          select,
          /** @type {Record<string | symbol, any>} */
          prev.value,
          true
        );
        init_select2(select);
      });
    }
    inited = true;
  });
}
function get_attributes(element2) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    element2.__attributes ??= {
      [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
      [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
    }
  );
}
function get_setters(element2) {
  var cache_key = element2.getAttribute("is") || element2.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters) return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element2;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) {
      if (descriptors[key2].set) {
        setters.push(key2);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function check_src_in_dev_hydration(element2, attribute, value) {
  if (!true_default) return;
  if (attribute === "srcset" && srcset_url_equal(element2, value)) return;
  if (src_url_equal(element2.getAttribute(attribute) ?? "", value)) return;
  hydration_attribute_changed(
    attribute,
    element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."),
    String(value)
  );
}
function src_url_equal(element_src, url) {
  if (element_src === url) return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}
var CLASS, STYLE, IS_CUSTOM_ELEMENT, IS_HTML, setters_cache;
var init_attributes2 = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/attributes.js"() {
    init_esm_env();
    init_hydration();
    init_utils();
    init_events();
    init_misc();
    init_warnings();
    init_constants2();
    init_task();
    init_utils2();
    init_runtime();
    init_attachments2();
    init_attributes();
    init_class();
    init_style();
    init_constants();
    init_effects();
    init_select();
    init_async();
    CLASS = Symbol("class");
    STYLE = Symbol("style");
    IS_CUSTOM_ELEMENT = Symbol("is custom element");
    IS_HTML = Symbol("is html");
    setters_cache = /* @__PURE__ */ new Map();
  }
});

// node_modules/svelte/src/internal/client/timing.js
var now, raf;
var init_timing = __esm({
  "node_modules/svelte/src/internal/client/timing.js"() {
    init_utils();
    init_esm_env();
    now = false_default ? () => performance.now() : () => Date.now();
    raf = {
      // don't access requestAnimationFrame eagerly outside method
      // this allows basic testing of user code without JSDOM
      // bunder will eval and remove ternary when the user's app is built
      tick: (
        /** @param {any} _ */
        (_) => (false_default ? requestAnimationFrame : noop)(_)
      ),
      now: () => now(),
      tasks: /* @__PURE__ */ new Set()
    };
  }
});

// node_modules/svelte/src/internal/client/loop.js
function run_tasks() {
  const now2 = raf.now();
  raf.tasks.forEach((task) => {
    if (!task.c(now2)) {
      raf.tasks.delete(task);
      task.f();
    }
  });
  if (raf.tasks.size !== 0) {
    raf.tick(run_tasks);
  }
}
function loop(callback) {
  let task;
  if (raf.tasks.size === 0) {
    raf.tick(run_tasks);
  }
  return {
    promise: new Promise((fulfill) => {
      raf.tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      raf.tasks.delete(task);
    }
  };
}
var init_loop = __esm({
  "node_modules/svelte/src/internal/client/loop.js"() {
    init_timing();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/transitions.js
function dispatch_event(element2, type) {
  without_reactive_context(() => {
    element2.dispatchEvent(new CustomEvent(type));
  });
}
function css_property_to_camelcase(style) {
  if (style === "float") return "cssFloat";
  if (style === "offset") return "cssOffset";
  if (style.startsWith("--")) return style;
  const parts = style.split("-");
  if (parts.length === 1) return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value] = part.split(":");
    if (!property || value === void 0) break;
    const formatted_property = css_property_to_camelcase(property.trim());
    keyframe[formatted_property] = value.trim();
  }
  return keyframe;
}
function animation(element2, get_fn, get_params) {
  var item = (
    /** @type {EachItem} */
    current_each_item
  );
  var from;
  var to;
  var animation2;
  var original_styles = null;
  item.a ??= {
    element: element2,
    measure() {
      from = this.element.getBoundingClientRect();
    },
    apply() {
      animation2?.abort();
      to = this.element.getBoundingClientRect();
      if (from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom) {
        const options = get_fn()(this.element, { from, to }, get_params?.());
        animation2 = animate(this.element, options, void 0, 1, () => {
          animation2?.abort();
          animation2 = void 0;
        });
      }
    },
    fix() {
      if (element2.getAnimations().length) return;
      var { position, width, height } = getComputedStyle(element2);
      if (position !== "absolute" && position !== "fixed") {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        original_styles = {
          position: style.position,
          width: style.width,
          height: style.height,
          transform: style.transform
        };
        style.position = "absolute";
        style.width = width;
        style.height = height;
        var to2 = element2.getBoundingClientRect();
        if (from.left !== to2.left || from.top !== to2.top) {
          var transform = `translate(${from.left - to2.left}px, ${from.top - to2.top}px)`;
          style.transform = style.transform ? `${style.transform} ${transform}` : transform;
        }
      }
    },
    unfix() {
      if (original_styles) {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        style.position = original_styles.position;
        style.width = original_styles.width;
        style.height = original_styles.height;
        style.transform = original_styles.transform;
      }
    }
  };
  item.a.element = element2;
}
function transition(flags2, element2, get_fn, get_params) {
  var is_intro = (flags2 & TRANSITION_IN) !== 0;
  var is_outro = (flags2 & TRANSITION_OUT) !== 0;
  var is_both = is_intro && is_outro;
  var is_global = (flags2 & TRANSITION_GLOBAL) !== 0;
  var direction = is_both ? "both" : is_intro ? "in" : "out";
  var current_options;
  var inert = element2.inert;
  var overflow = element2.style.overflow;
  var intro;
  var outro;
  function get_options() {
    return without_reactive_context(() => {
      return current_options ??= get_fn()(element2, get_params?.() ?? /** @type {P} */
      {}, {
        direction
      });
    });
  }
  var transition2 = {
    is_global,
    in() {
      element2.inert = inert;
      if (!is_intro) {
        outro?.abort();
        outro?.reset?.();
        return;
      }
      if (!is_outro) {
        intro?.abort();
      }
      dispatch_event(element2, "introstart");
      intro = animate(element2, get_options(), outro, 1, () => {
        dispatch_event(element2, "introend");
        intro?.abort();
        intro = current_options = void 0;
        element2.style.overflow = overflow;
      });
    },
    out(fn) {
      if (!is_outro) {
        fn?.();
        current_options = void 0;
        return;
      }
      element2.inert = true;
      dispatch_event(element2, "outrostart");
      outro = animate(element2, get_options(), intro, 0, () => {
        dispatch_event(element2, "outroend");
        fn?.();
      });
    },
    stop: () => {
      intro?.abort();
      outro?.abort();
    }
  };
  var e = (
    /** @type {Effect} */
    active_effect
  );
  (e.transitions ??= []).push(transition2);
  if (is_intro && should_intro) {
    var run3 = is_global;
    if (!run3) {
      var block2 = (
        /** @type {Effect | null} */
        e.parent
      );
      while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
        while (block2 = block2.parent) {
          if ((block2.f & BLOCK_EFFECT) !== 0) break;
        }
      }
      run3 = !block2 || (block2.f & EFFECT_RAN) !== 0;
    }
    if (run3) {
      effect(() => {
        untrack(() => transition2.in());
      });
    }
  }
}
function animate(element2, options, counterpart, t2, on_finish) {
  var is_intro = t2 === 1;
  if (is_function(options)) {
    var a;
    var aborted2 = false;
    queue_micro_task(() => {
      if (aborted2) return;
      var o = options({ direction: is_intro ? "in" : "out" });
      a = animate(element2, o, counterpart, t2, on_finish);
    });
    return {
      abort: () => {
        aborted2 = true;
        a?.abort();
      },
      deactivate: () => a.deactivate(),
      reset: () => a.reset(),
      t: () => a.t()
    };
  }
  counterpart?.deactivate();
  if (!options?.duration) {
    on_finish();
    return {
      abort: noop,
      deactivate: noop,
      reset: noop,
      t: () => t2
    };
  }
  const { delay = 0, css, tick: tick3, easing = linear } = options;
  var keyframes = [];
  if (is_intro && counterpart === void 0) {
    if (tick3) {
      tick3(0, 1);
    }
    if (css) {
      var styles = css_to_keyframe(css(0, 1));
      keyframes.push(styles, styles);
    }
  }
  var get_t = () => 1 - t2;
  var animation2 = element2.animate(keyframes, { duration: delay, fill: "forwards" });
  animation2.onfinish = () => {
    animation2.cancel();
    var t1 = counterpart?.t() ?? 1 - t2;
    counterpart?.abort();
    var delta = t2 - t1;
    var duration = (
      /** @type {number} */
      options.duration * Math.abs(delta)
    );
    var keyframes2 = [];
    if (duration > 0) {
      var needs_overflow_hidden = false;
      if (css) {
        var n = Math.ceil(duration / (1e3 / 60));
        for (var i = 0; i <= n; i += 1) {
          var t = t1 + delta * easing(i / n);
          var styles2 = css_to_keyframe(css(t, 1 - t));
          keyframes2.push(styles2);
          needs_overflow_hidden ||= styles2.overflow === "hidden";
        }
      }
      if (needs_overflow_hidden) {
        element2.style.overflow = "hidden";
      }
      get_t = () => {
        var time = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          animation2.currentTime
        );
        return t1 + delta * easing(time / duration);
      };
      if (tick3) {
        loop(() => {
          if (animation2.playState !== "running") return false;
          var t3 = get_t();
          tick3(t3, 1 - t3);
          return true;
        });
      }
    }
    animation2 = element2.animate(keyframes2, { duration, fill: "forwards" });
    animation2.onfinish = () => {
      get_t = () => t2;
      tick3?.(t2, 1 - t2);
      on_finish();
    };
  };
  return {
    abort: () => {
      if (animation2) {
        animation2.cancel();
        animation2.effect = null;
        animation2.onfinish = noop;
      }
    },
    deactivate: () => {
      on_finish = noop;
    },
    reset: () => {
      if (t2 === 0) {
        tick3?.(1, 0);
      }
    },
    t: () => get_t()
  };
}
var linear;
var init_transitions = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/transitions.js"() {
    init_utils();
    init_effects();
    init_runtime();
    init_loop();
    init_render();
    init_each();
    init_constants();
    init_constants2();
    init_task();
    init_shared();
    linear = (t) => t;
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/document.js
function bind_active_element(update2) {
  listen(document, ["focusin", "focusout"], (event2) => {
    if (event2 && event2.type === "focusout" && /** @type {FocusEvent} */
    event2.relatedTarget) {
      return;
    }
    update2(document.activeElement);
  });
}
var init_document = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/document.js"() {
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
function bind_value(input, get3, set2 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  listen_to_event_and_reset_event(input, "input", async (is_reset) => {
    if (true_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = is_reset ? input.defaultValue : input.value;
    value = is_numberlike_input(input) ? to_number(value) : value;
    set2(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
    await tick();
    if (value !== (value = get3())) {
      var start = input.selectionStart;
      var end = input.selectionEnd;
      var length = input.value.length;
      input.value = value ?? "";
      if (end !== null) {
        var new_length = input.value.length;
        if (start === end && end === length && new_length > length) {
          input.selectionStart = new_length;
          input.selectionEnd = new_length;
        } else {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, new_length);
        }
      }
    }
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
    // TODO Svelte 6: remove input.value check and set to empty string?
    untrack(get3) == null && input.value
  ) {
    set2(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  }
  render_effect(() => {
    if (true_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = get3();
    if (input === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    if (is_numberlike_input(input) && value === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value && !input.value) {
      return;
    }
    if (value !== input.value) {
      input.value = value ?? "";
    }
  });
}
function bind_group(inputs, group_index, input, get3, set2 = get3) {
  var is_checkbox = input.getAttribute("type") === "checkbox";
  var binding_group = inputs;
  let hydration_mismatch2 = false;
  if (group_index !== null) {
    for (var index2 of group_index) {
      binding_group = binding_group[index2] ??= [];
    }
  }
  binding_group.push(input);
  listen_to_event_and_reset_event(
    input,
    "change",
    () => {
      var value = input.__value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      }
      set2(value);
    },
    // TODO better default value handling
    () => set2(is_checkbox ? [] : null)
  );
  render_effect(() => {
    var value = get3();
    if (hydrating && input.defaultChecked !== input.checked) {
      hydration_mismatch2 = true;
      return;
    }
    if (is_checkbox) {
      value = value || [];
      input.checked = value.includes(input.__value);
    } else {
      input.checked = is(input.__value, value);
    }
  });
  teardown(() => {
    var index3 = binding_group.indexOf(input);
    if (index3 !== -1) {
      binding_group.splice(index3, 1);
    }
  });
  if (!pending2.has(binding_group)) {
    pending2.add(binding_group);
    queue_micro_task(() => {
      binding_group.sort((a, b) => a.compareDocumentPosition(b) === 4 ? -1 : 1);
      pending2.delete(binding_group);
    });
  }
  queue_micro_task(() => {
    if (hydration_mismatch2) {
      var value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      } else {
        var hydration_input = binding_group.find((input2) => input2.checked);
        value = hydration_input?.__value;
      }
      set2(value);
    }
  });
}
function bind_checked(input, get3, set2 = get3) {
  listen_to_event_and_reset_event(input, "change", (is_reset) => {
    var value = is_reset ? input.defaultChecked : input.checked;
    set2(value);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the update value from the input instead.
    hydrating && input.defaultChecked !== input.checked || // If defaultChecked is set, then checked == defaultChecked
    untrack(get3) == null
  ) {
    set2(input.checked);
  }
  render_effect(() => {
    var value = get3();
    input.checked = Boolean(value);
  });
}
function get_binding_group_value(group, __value, checked) {
  var value = /* @__PURE__ */ new Set();
  for (var i = 0; i < group.length; i += 1) {
    if (group[i].checked) {
      value.add(group[i].__value);
    }
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
function to_number(value) {
  return value === "" ? null : +value;
}
function bind_files(input, get3, set2 = get3) {
  listen_to_event_and_reset_event(input, "change", () => {
    set2(input.files);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.files
  ) {
    set2(input.files);
  }
  render_effect(() => {
    input.files = get3();
  });
}
var pending2;
var init_input = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/input.js"() {
    init_esm_env();
    init_effects();
    init_shared();
    init_errors2();
    init_proxy();
    init_task();
    init_hydration();
    init_runtime();
    init_context();
    init_batch();
    pending2 = /* @__PURE__ */ new Set();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/media.js
function time_ranges_to_array(ranges) {
  var array = [];
  for (var i = 0; i < ranges.length; i += 1) {
    array.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array;
}
function bind_current_time(media, get3, set2 = get3) {
  var raf_id;
  var value;
  var callback = () => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    var next_value = media.currentTime;
    if (value !== next_value) {
      set2(value = next_value);
    }
  };
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    var next_value = Number(get3());
    if (value !== next_value && !isNaN(
      /** @type {any} */
      next_value
    )) {
      media.currentTime = value = next_value;
    }
  });
  teardown(() => {
    cancelAnimationFrame(raf_id);
    media.removeEventListener("timeupdate", callback);
  });
}
function bind_buffered(media, set2) {
  var current;
  listen(media, ["loadedmetadata", "progress", "timeupdate", "seeking"], () => {
    var ranges = media.buffered;
    if (!current || current.length !== ranges.length || current.some((range, i) => ranges.start(i) !== range.start || ranges.end(i) !== range.end)) {
      current = time_ranges_to_array(ranges);
      set2(current);
    }
  });
}
function bind_seekable(media, set2) {
  listen(media, ["loadedmetadata"], () => set2(time_ranges_to_array(media.seekable)));
}
function bind_played(media, set2) {
  listen(media, ["timeupdate"], () => set2(time_ranges_to_array(media.played)));
}
function bind_seeking(media, set2) {
  listen(media, ["seeking", "seeked"], () => set2(media.seeking));
}
function bind_ended(media, set2) {
  listen(media, ["timeupdate", "ended"], () => set2(media.ended));
}
function bind_ready_state(media, set2) {
  listen(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    () => set2(media.readyState)
  );
}
function bind_playback_rate(media, get3, set2 = get3) {
  effect(() => {
    var value = Number(get3());
    if (value !== media.playbackRate && !isNaN(value)) {
      media.playbackRate = value;
    }
  });
  effect(() => {
    listen(media, ["ratechange"], () => {
      set2(media.playbackRate);
    });
  });
}
function bind_paused(media, get3, set2 = get3) {
  var paused = get3();
  var update2 = () => {
    if (paused !== media.paused) {
      set2(paused = media.paused);
    }
  };
  listen(media, ["play", "pause", "canplay"], update2, paused == null);
  effect(() => {
    if ((paused = !!get3()) !== media.paused) {
      if (paused) {
        media.pause();
      } else {
        media.play().catch(() => {
          set2(paused = true);
        });
      }
    }
  });
}
function bind_volume(media, get3, set2 = get3) {
  var callback = () => {
    set2(media.volume);
  };
  if (get3() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = Number(get3());
    if (value !== media.volume && !isNaN(value)) {
      media.volume = value;
    }
  });
}
function bind_muted(media, get3, set2 = get3) {
  var callback = () => {
    set2(media.muted);
  };
  if (get3() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = !!get3();
    if (media.muted !== value) media.muted = value;
  });
}
var init_media = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/media.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js
function bind_online(update2) {
  listen(window, ["online", "offline"], () => {
    update2(navigator.onLine);
  });
}
var init_navigator = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js"() {
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/props.js
function bind_prop(props, prop2, value) {
  var desc = get_descriptor(props, prop2);
  if (desc && desc.set) {
    props[prop2] = value;
    teardown(() => {
      props[prop2] = null;
    });
  }
}
var init_props = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/props.js"() {
    init_effects();
    init_utils();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
function bind_resize_observer(element2, type, set2) {
  var observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  var unsub = observer.observe(
    element2,
    /** @param {any} entry */
    (entry) => set2(entry[type])
  );
  teardown(unsub);
}
function bind_element_size(element2, type, set2) {
  var unsub = resize_observer_border_box.observe(element2, () => set2(element2[type]));
  effect(() => {
    untrack(() => set2(element2[type]));
    return unsub;
  });
}
var ResizeObserverSingleton, resize_observer_content_box, resize_observer_border_box, resize_observer_device_pixel_content_box;
var init_size = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/size.js"() {
    init_effects();
    init_runtime();
    ResizeObserverSingleton = class _ResizeObserverSingleton {
      /** */
      #listeners = /* @__PURE__ */ new WeakMap();
      /** @type {ResizeObserver | undefined} */
      #observer;
      /** @type {ResizeObserverOptions} */
      #options;
      /** @static */
      static entries = /* @__PURE__ */ new WeakMap();
      /** @param {ResizeObserverOptions} options */
      constructor(options) {
        this.#options = options;
      }
      /**
       * @param {Element} element
       * @param {(entry: ResizeObserverEntry) => any} listener
       */
      observe(element2, listener) {
        var listeners = this.#listeners.get(element2) || /* @__PURE__ */ new Set();
        listeners.add(listener);
        this.#listeners.set(element2, listeners);
        this.#getObserver().observe(element2, this.#options);
        return () => {
          var listeners2 = this.#listeners.get(element2);
          listeners2.delete(listener);
          if (listeners2.size === 0) {
            this.#listeners.delete(element2);
            this.#observer.unobserve(element2);
          }
        };
      }
      #getObserver() {
        return this.#observer ?? (this.#observer = new ResizeObserver(
          /** @param {any} entries */
          (entries) => {
            for (var entry of entries) {
              _ResizeObserverSingleton.entries.set(entry.target, entry);
              for (var listener of this.#listeners.get(entry.target) || []) {
                listener(entry);
              }
            }
          }
        ));
      }
    };
    resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
      box: "content-box"
    });
    resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
      box: "border-box"
    });
    resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
      box: "device-pixel-content-box"
    });
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component;
}
function bind_this(element_or_component = {}, update2, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = get_parts?.() || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update2(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update2(null, ...parts);
        }
      });
    };
  });
  return element_or_component;
}
var init_this = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/this.js"() {
    init_constants2();
    init_effects();
    init_runtime();
    init_task();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js
function bind_content_editable(property, element2, get3, set2 = get3) {
  element2.addEventListener("input", () => {
    set2(element2[property]);
  });
  render_effect(() => {
    var value = get3();
    if (element2[property] !== value) {
      if (value == null) {
        var non_null_value = element2[property];
        set2(non_null_value);
      } else {
        element2[property] = value + "";
      }
    }
  });
}
function bind_property(property, event_name, element2, set2, get3) {
  var handler = () => {
    set2(element2[property]);
  };
  element2.addEventListener(event_name, handler);
  if (get3) {
    render_effect(() => {
      element2[property] = get3();
    });
  } else {
    handler();
  }
  if (element2 === document.body || element2 === window || element2 === document) {
    teardown(() => {
      element2.removeEventListener(event_name, handler);
    });
  }
}
function bind_focused(element2, set2) {
  listen(element2, ["focus", "blur"], () => {
    set2(element2 === document.activeElement);
  });
}
var init_universal = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/elements/bindings/window.js
function bind_window_scroll(type, get3, set2 = get3) {
  var is_scrolling_x = type === "x";
  var target_handler = () => without_reactive_context(() => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear, 100);
    set2(window[is_scrolling_x ? "scrollX" : "scrollY"]);
  });
  addEventListener("scroll", target_handler, {
    passive: true
  });
  var scrolling = false;
  var timeout;
  var clear = () => {
    scrolling = false;
  };
  var first = true;
  render_effect(() => {
    var latest_value = get3();
    if (first) {
      first = false;
    } else if (!scrolling && latest_value != null) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear, 100);
    }
  });
  effect(target_handler);
  teardown(() => {
    removeEventListener("scroll", target_handler);
  });
}
function bind_window_size(type, set2) {
  listen(window, ["resize"], () => without_reactive_context(() => set2(window[type])));
}
var init_window = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/bindings/window.js"() {
    init_effects();
    init_shared();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
function trusted(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.isTrusted) {
      fn?.apply(this, args);
    }
  };
}
function self(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.target === this) {
      fn?.apply(this, args);
    }
  };
}
function stopPropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopPropagation();
    return fn?.apply(this, args);
  };
}
function once(fn) {
  var ran = false;
  return function(...args) {
    if (ran) return;
    ran = true;
    return fn?.apply(this, args);
  };
}
function stopImmediatePropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopImmediatePropagation();
    return fn?.apply(this, args);
  };
}
function preventDefault(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.preventDefault();
    return fn?.apply(this, args);
  };
}
var init_event_modifiers = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js"() {
    init_utils();
    init_effects();
    init_events();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
function init(immutable = false) {
  const context2 = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  const callbacks = context2.l.u;
  if (!callbacks) return;
  let props = () => deep_read_state(context2.s);
  if (immutable) {
    let version = 0;
    let prev = (
      /** @type {Record<string, any>} */
      {}
    );
    const d = derived(() => {
      let changed = false;
      const props2 = context2.s;
      for (const key2 in props2) {
        if (props2[key2] !== prev[key2]) {
          prev[key2] = props2[key2];
          changed = true;
        }
      }
      if (changed) version++;
      return version;
    });
    props = () => get(d);
  }
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context2, props);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run));
    return () => {
      for (const fn of fns) {
        if (typeof fn === "function") {
          fn();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context2, props);
      run_all(callbacks.a);
    });
  }
}
function observe_all(context2, props) {
  if (context2.l.s) {
    for (const signal of context2.l.s) get(signal);
  }
  props();
}
var init_lifecycle = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js"() {
    init_utils();
    init_context();
    init_deriveds();
    init_effects();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/dom/legacy/misc.js
function reactive_import(fn) {
  var s = source(0);
  return function() {
    if (arguments.length === 1) {
      set(s, get(s) + 1);
      return arguments[0];
    } else {
      get(s);
      return fn();
    }
  };
}
function bubble_event($$props, event2) {
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    $$props.$$events?.[event2.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn of callbacks) {
    fn.call(this, event2);
  }
}
function add_legacy_event_listener($$props, event_name, event_callback) {
  $$props.$$events ||= {};
  $$props.$$events[event_name] ||= [];
  $$props.$$events[event_name].push(event_callback);
}
function update_legacy_props($$new_props) {
  for (var key2 in $$new_props) {
    if (key2 in this) {
      this[key2] = $$new_props[key2];
    }
  }
}
var init_misc2 = __esm({
  "node_modules/svelte/src/internal/client/dom/legacy/misc.js"() {
    init_sources();
    init_runtime();
    init_utils();
  }
});

// node_modules/svelte/src/store/shared/index.js
function get2(store) {
  let value;
  subscribe_to_store(store, (_) => value = _)();
  return value;
}
var init_shared2 = __esm({
  "node_modules/svelte/src/store/shared/index.js"() {
    init_utils();
    init_equality();
    init_utils3();
  }
});

// node_modules/svelte/src/internal/client/reactivity/store.js
function store_get(store, store_name, stores) {
  const entry = stores[store_name] ??= {
    store: null,
    source: mutable_source(void 0),
    unsubscribe: noop
  };
  if (true_default) {
    entry.source.label = store_name;
  }
  if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = store ?? null;
    if (store == null) {
      entry.source.v = void 0;
      entry.unsubscribe = noop;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store, (v) => {
        if (is_synchronous_callback) {
          entry.source.v = v;
        } else {
          set(entry.source, v);
        }
      });
      is_synchronous_callback = false;
    }
  }
  if (store && IS_UNMOUNTED in stores) {
    return get2(store);
  }
  return get(entry.source);
}
function store_unsub(store, store_name, stores) {
  let entry = stores[store_name];
  if (entry && entry.store !== store) {
    entry.unsubscribe();
    entry.unsubscribe = noop;
  }
  return store;
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function invalidate_store(stores, store_name) {
  var entry = stores[store_name];
  if (entry.store !== null) {
    store_set(entry.store, entry.source.v);
  }
}
function setup_stores() {
  const stores = {};
  function cleanup() {
    teardown(() => {
      for (var store_name in stores) {
        const ref = stores[store_name];
        ref.unsubscribe();
      }
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  }
  return [stores, cleanup];
}
function store_mutate(store, expression, new_value) {
  store.set(new_value);
  return expression;
}
function update_store(store, store_value, d = 1) {
  store.set(store_value + d);
  return store_value;
}
function update_pre_store(store, store_value, d = 1) {
  const value = store_value + d;
  store.set(value);
  return value;
}
function mark_store_binding() {
  is_store_binding = true;
}
function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}
var is_store_binding, IS_UNMOUNTED;
var init_store = __esm({
  "node_modules/svelte/src/internal/client/reactivity/store.js"() {
    init_utils3();
    init_shared2();
    init_utils();
    init_runtime();
    init_effects();
    init_sources();
    init_esm_env();
    is_store_binding = false;
    IS_UNMOUNTED = Symbol();
  }
});

// node_modules/svelte/src/internal/client/reactivity/props.js
function update_prop(fn, d = 1) {
  const value = fn();
  fn(value + d);
  return value;
}
function update_pre_prop(fn, d = 1) {
  const value = fn() + d;
  fn(value);
  return value;
}
// @__NO_SIDE_EFFECTS__
function rest_props(props, exclude, name) {
  return new Proxy(
    true_default ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
    rest_props_handler
  );
}
function legacy_rest_props(props, exclude) {
  return new Proxy(
    {
      props,
      exclude,
      special: {},
      version: source(0),
      // TODO this is only necessary because we need to track component
      // destruction inside `prop`, because of `bind:this`, but it
      // seems likely that we can simplify `bind:this` instead
      parent_effect: (
        /** @type {Effect} */
        active_effect
      )
    },
    legacy_rest_props_handler
  );
}
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function prop(props, key2, flags2, fallback2) {
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback2
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy ? untrack(
        /** @type {() => V} */
        fallback2
      ) : (
        /** @type {V} */
        fallback2
      );
    }
    return fallback_value;
  };
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = get_descriptor(props, key2)?.set ?? (is_entry_props && key2 in props ? (v) => props[key2] = v : void 0);
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key2]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key2];
  }
  if (initial_value === void 0 && fallback2 !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value(key2);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value === void 0) return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value === void 0 ? fallback_value : value;
    };
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return (
      /** @type {() => V} */
      (function(value, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value);
          }
          return value;
        }
        return getter();
      })
    );
  }
  var overridden = false;
  var d = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (true_default) {
    d.label = key2;
  }
  if (bindable) get(d);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return (
    /** @type {() => V} */
    (function(value, mutation) {
      if (arguments.length > 0) {
        const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;
        set(d, new_value);
        overridden = true;
        if (fallback_value !== void 0) {
          fallback_value = new_value;
        }
        return value;
      }
      if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
        return d.v;
      }
      return get(d);
    })
  );
}
var rest_props_handler, legacy_rest_props_handler, spread_props_handler;
var init_props2 = __esm({
  "node_modules/svelte/src/internal/client/reactivity/props.js"() {
    init_esm_env();
    init_constants();
    init_utils();
    init_sources();
    init_deriveds();
    init_runtime();
    init_errors2();
    init_constants2();
    init_proxy();
    init_store();
    init_flags();
    rest_props_handler = {
      get(target, key2) {
        if (target.exclude.includes(key2)) return;
        return target.props[key2];
      },
      set(target, key2) {
        if (true_default) {
          props_rest_readonly(`${target.name}.${String(key2)}`);
        }
        return false;
      },
      getOwnPropertyDescriptor(target, key2) {
        if (target.exclude.includes(key2)) return;
        if (key2 in target.props) {
          return {
            enumerable: true,
            configurable: true,
            value: target.props[key2]
          };
        }
      },
      has(target, key2) {
        if (target.exclude.includes(key2)) return false;
        return key2 in target.props;
      },
      ownKeys(target) {
        return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
      }
    };
    legacy_rest_props_handler = {
      get(target, key2) {
        if (target.exclude.includes(key2)) return;
        get(target.version);
        return key2 in target.special ? target.special[key2]() : target.props[key2];
      },
      set(target, key2, value) {
        if (!(key2 in target.special)) {
          var previous_effect = active_effect;
          try {
            set_active_effect(target.parent_effect);
            target.special[key2] = prop(
              {
                get [key2]() {
                  return target.props[key2];
                }
              },
              /** @type {string} */
              key2,
              PROPS_IS_UPDATED
            );
          } finally {
            set_active_effect(previous_effect);
          }
        }
        target.special[key2](value);
        update(target.version);
        return true;
      },
      getOwnPropertyDescriptor(target, key2) {
        if (target.exclude.includes(key2)) return;
        if (key2 in target.props) {
          return {
            enumerable: true,
            configurable: true,
            value: target.props[key2]
          };
        }
      },
      deleteProperty(target, key2) {
        if (target.exclude.includes(key2)) return true;
        target.exclude.push(key2);
        update(target.version);
        return true;
      },
      has(target, key2) {
        if (target.exclude.includes(key2)) return false;
        return key2 in target.props;
      },
      ownKeys(target) {
        return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
      }
    };
    spread_props_handler = {
      get(target, key2) {
        let i = target.props.length;
        while (i--) {
          let p = target.props[i];
          if (is_function(p)) p = p();
          if (typeof p === "object" && p !== null && key2 in p) return p[key2];
        }
      },
      set(target, key2, value) {
        let i = target.props.length;
        while (i--) {
          let p = target.props[i];
          if (is_function(p)) p = p();
          const desc = get_descriptor(p, key2);
          if (desc && desc.set) {
            desc.set(value);
            return true;
          }
        }
        return false;
      },
      getOwnPropertyDescriptor(target, key2) {
        let i = target.props.length;
        while (i--) {
          let p = target.props[i];
          if (is_function(p)) p = p();
          if (typeof p === "object" && p !== null && key2 in p) {
            const descriptor = get_descriptor(p, key2);
            if (descriptor && !descriptor.configurable) {
              descriptor.configurable = true;
            }
            return descriptor;
          }
        }
      },
      has(target, key2) {
        if (key2 === STATE_SYMBOL || key2 === LEGACY_PROPS) return false;
        for (let p of target.props) {
          if (is_function(p)) p = p();
          if (p != null && key2 in p) return true;
        }
        return false;
      },
      ownKeys(target) {
        const keys = [];
        for (let p of target.props) {
          if (is_function(p)) p = p();
          if (!p) continue;
          for (const key2 in p) {
            if (!keys.includes(key2)) keys.push(key2);
          }
          for (const key2 of Object.getOwnPropertySymbols(p)) {
            if (!keys.includes(key2)) keys.push(key2);
          }
        }
        return keys;
      }
    };
  }
});

// node_modules/svelte/src/internal/client/validate.js
function validate_each_keys(collection, key_fn) {
  render_effect(() => {
    const keys = /* @__PURE__ */ new Map();
    const maybe_array = collection();
    const array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
    const length = array.length;
    for (let i = 0; i < length; i++) {
      const key2 = key_fn(array[i], i);
      if (keys.has(key2)) {
        const a = String(keys.get(key2));
        const b = String(i);
        let k = String(key2);
        if (k.startsWith("[object ")) k = null;
        each_key_duplicate(a, b, k);
      }
      keys.set(key2, i);
    }
  });
}
function validate_binding(binding, blockers, get_object, get_property, line, column) {
  run_after_blockers(blockers, () => {
    var warned = false;
    var filename = dev_current_component_function?.[FILENAME];
    render_effect(() => {
      if (warned) return;
      var [object, is_store_sub] = capture_store_binding(get_object);
      if (is_store_sub) return;
      var property = get_property();
      var ran = false;
      var effect2 = render_effect(() => {
        if (ran) return;
        object[property];
      });
      ran = true;
      if (effect2.deps === null) {
        var location = `${filename}:${line}:${column}`;
        binding_property_non_reactive(binding, location);
        warned = true;
      }
    });
  });
}
var init_validate2 = __esm({
  "node_modules/svelte/src/internal/client/validate.js"() {
    init_context();
    init_utils();
    init_errors2();
    init_constants();
    init_effects();
    init_warnings();
    init_store();
    init_async();
  }
});

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var Svelte4Component;
var init_legacy_client = __esm({
  "node_modules/svelte/src/legacy/legacy-client.js"() {
    init_constants2();
    init_effects();
    init_sources();
    init_render();
    init_runtime();
    init_batch();
    init_utils();
    init_errors2();
    init_warnings();
    init_esm_env();
    init_constants();
    init_context();
    init_flags();
    init_event_modifiers();
    Svelte4Component = class {
      /** @type {any} */
      #events;
      /** @type {Record<string, any>} */
      #instance;
      /**
       * @param {ComponentConstructorOptions & {
       *  component: any;
       * }} options
       */
      constructor(options) {
        var sources = /* @__PURE__ */ new Map();
        var add_source = (key2, value) => {
          var s = mutable_source(value, false, false);
          sources.set(key2, s);
          return s;
        };
        const props = new Proxy(
          { ...options.props || {}, $$events: {} },
          {
            get(target, prop2) {
              return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
            },
            has(target, prop2) {
              if (prop2 === LEGACY_PROPS) return true;
              get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
              return Reflect.has(target, prop2);
            },
            set(target, prop2, value) {
              set(sources.get(prop2) ?? add_source(prop2, value), value);
              return Reflect.set(target, prop2, value);
            }
          }
        );
        this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
          target: options.target,
          anchor: options.anchor,
          props,
          context: options.context,
          intro: options.intro ?? false,
          recover: options.recover
        });
        if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {
          flushSync();
        }
        this.#events = props.$$events;
        for (const key2 of Object.keys(this.#instance)) {
          if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
          define_property(this, key2, {
            get() {
              return this.#instance[key2];
            },
            /** @param {any} value */
            set(value) {
              this.#instance[key2] = value;
            },
            enumerable: true
          });
        }
        this.#instance.$set = /** @param {Record<string, any>} next */
        (next2) => {
          Object.assign(props, next2);
        };
        this.#instance.$destroy = () => {
          unmount(this.#instance);
        };
      }
      /** @param {Record<string, any>} props */
      $set(props) {
        this.#instance.$set(props);
      }
      /**
       * @param {string} event
       * @param {(...args: any[]) => any} callback
       * @returns {any}
       */
      $on(event2, callback) {
        this.#events[event2] = this.#events[event2] || [];
        const cb = (...args) => callback.call(this, ...args);
        this.#events[event2].push(cb);
        return () => {
          this.#events[event2] = this.#events[event2].filter(
            /** @param {any} fn */
            (fn) => fn !== cb
          );
        };
      }
      $destroy() {
        this.#instance.$destroy();
      }
    };
  }
});

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
function get_custom_element_value(prop2, value, props_definition, transform) {
  const type = props_definition[prop2]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
function create_custom_element(Component, props_definition, slots, exports2, use_shadow_dom, extend) {
  let Class = class extends SvelteElement {
    constructor() {
      super(Component, slots, use_shadow_dom);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return object_keys(props_definition).map(
        (key2) => (props_definition[key2].attribute || key2).toLowerCase()
      );
    }
  };
  object_keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value) {
        value = get_custom_element_value(prop2, value, props_definition);
        this.$$d[prop2] = value;
        var component2 = this.$$c;
        if (component2) {
          var setter = get_descriptor(component2, prop2)?.get;
          if (setter) {
            component2[prop2] = value;
          } else {
            component2.$set({ [prop2]: value });
          }
        }
      }
    });
  });
  exports2.forEach((property) => {
    define_property(Class.prototype, property, {
      get() {
        return this.$$c?.[property];
      }
    });
  });
  if (extend) {
    Class = extend(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}
var SvelteElement;
var init_custom_element = __esm({
  "node_modules/svelte/src/internal/client/dom/elements/custom-element.js"() {
    init_legacy_client();
    init_effects();
    init_template();
    init_utils();
    if (typeof HTMLElement === "function") {
      SvelteElement = class extends HTMLElement {
        /** The Svelte component constructor */
        $$ctor;
        /** Slots */
        $$s;
        /** @type {any} The Svelte component instance */
        $$c;
        /** Whether or not the custom element is connected */
        $$cn = false;
        /** @type {Record<string, any>} Component props data */
        $$d = {};
        /** `true` if currently in the process of reflecting component props back to attributes */
        $$r = false;
        /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
        $$p_d = {};
        /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
        $$l = {};
        /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
        $$l_u = /* @__PURE__ */ new Map();
        /** @type {any} The managed render effect for reflecting attributes */
        $$me;
        /**
         * @param {*} $$componentCtor
         * @param {*} $$slots
         * @param {*} use_shadow_dom
         */
        constructor($$componentCtor, $$slots, use_shadow_dom) {
          super();
          this.$$ctor = $$componentCtor;
          this.$$s = $$slots;
          if (use_shadow_dom) {
            this.attachShadow({ mode: "open" });
          }
        }
        /**
         * @param {string} type
         * @param {EventListenerOrEventListenerObject} listener
         * @param {boolean | AddEventListenerOptions} [options]
         */
        addEventListener(type, listener, options) {
          this.$$l[type] = this.$$l[type] || [];
          this.$$l[type].push(listener);
          if (this.$$c) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
          super.addEventListener(type, listener, options);
        }
        /**
         * @param {string} type
         * @param {EventListenerOrEventListenerObject} listener
         * @param {boolean | AddEventListenerOptions} [options]
         */
        removeEventListener(type, listener, options) {
          super.removeEventListener(type, listener, options);
          if (this.$$c) {
            const unsub = this.$$l_u.get(listener);
            if (unsub) {
              unsub();
              this.$$l_u.delete(listener);
            }
          }
        }
        async connectedCallback() {
          this.$$cn = true;
          if (!this.$$c) {
            let create_slot = function(name) {
              return (anchor) => {
                const slot2 = document.createElement("slot");
                if (name !== "default") slot2.name = name;
                append(anchor, slot2);
              };
            };
            await Promise.resolve();
            if (!this.$$cn || this.$$c) {
              return;
            }
            const $$slots = {};
            const existing_slots = get_custom_elements_slots(this);
            for (const name of this.$$s) {
              if (name in existing_slots) {
                if (name === "default" && !this.$$d.children) {
                  this.$$d.children = create_slot(name);
                  $$slots.default = true;
                } else {
                  $$slots[name] = create_slot(name);
                }
              }
            }
            for (const attribute of this.attributes) {
              const name = this.$$g_p(attribute.name);
              if (!(name in this.$$d)) {
                this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
              }
            }
            for (const key2 in this.$$p_d) {
              if (!(key2 in this.$$d) && this[key2] !== void 0) {
                this.$$d[key2] = this[key2];
                delete this[key2];
              }
            }
            this.$$c = createClassComponent({
              component: this.$$ctor,
              target: this.shadowRoot || this,
              props: {
                ...this.$$d,
                $$slots,
                $$host: this
              }
            });
            this.$$me = effect_root(() => {
              render_effect(() => {
                this.$$r = true;
                for (const key2 of object_keys(this.$$c)) {
                  if (!this.$$p_d[key2]?.reflect) continue;
                  this.$$d[key2] = this.$$c[key2];
                  const attribute_value = get_custom_element_value(
                    key2,
                    this.$$d[key2],
                    this.$$p_d,
                    "toAttribute"
                  );
                  if (attribute_value == null) {
                    this.removeAttribute(this.$$p_d[key2].attribute || key2);
                  } else {
                    this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
                  }
                }
                this.$$r = false;
              });
            });
            for (const type in this.$$l) {
              for (const listener of this.$$l[type]) {
                const unsub = this.$$c.$on(type, listener);
                this.$$l_u.set(listener, unsub);
              }
            }
            this.$$l = {};
          }
        }
        // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
        // and setting attributes through setAttribute etc, this is helpful
        /**
         * @param {string} attr
         * @param {string} _oldValue
         * @param {string} newValue
         */
        attributeChangedCallback(attr2, _oldValue, newValue) {
          if (this.$$r) return;
          attr2 = this.$$g_p(attr2);
          this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
          this.$$c?.$set({ [attr2]: this.$$d[attr2] });
        }
        disconnectedCallback() {
          this.$$cn = false;
          Promise.resolve().then(() => {
            if (!this.$$cn && this.$$c) {
              this.$$c.$destroy();
              this.$$me();
              this.$$c = void 0;
            }
          });
        }
        /**
         * @param {string} attribute_name
         */
        $$g_p(attribute_name) {
          return object_keys(this.$$p_d).find(
            (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
          ) || attribute_name;
        }
      };
    }
  }
});

// node_modules/svelte/src/internal/client/dev/console-log.js
function log_if_contains_state(method, ...objects) {
  untrack(() => {
    try {
      let has_state = false;
      const transformed = [];
      for (const obj of objects) {
        if (obj && typeof obj === "object" && STATE_SYMBOL in obj) {
          transformed.push(snapshot(obj, true));
          has_state = true;
        } else {
          transformed.push(obj);
        }
      }
      if (has_state) {
        console_log_state(method);
        console.log("%c[snapshot]", "color: grey", ...transformed);
      }
    } catch {
    }
  });
  return objects;
}
var init_console_log = __esm({
  "node_modules/svelte/src/internal/client/dev/console-log.js"() {
    init_constants2();
    init_clone();
    init_warnings();
    init_runtime();
  }
});

// node_modules/svelte/src/internal/client/index.js
var client_exports = {};
__export(client_exports, {
  CLASS: () => CLASS,
  FILENAME: () => FILENAME,
  HMR: () => HMR,
  NAMESPACE_SVG: () => NAMESPACE_SVG,
  STYLE: () => STYLE,
  aborted: () => aborted,
  action: () => action,
  active_effect: () => active_effect,
  add_legacy_event_listener: () => add_legacy_event_listener,
  add_locations: () => add_locations,
  add_svelte_meta: () => add_svelte_meta,
  animation: () => animation,
  append: () => append,
  append_styles: () => append_styles2,
  apply: () => apply,
  assign: () => assign,
  assign_and: () => assign_and,
  assign_nullish: () => assign_nullish,
  assign_or: () => assign_or,
  async: () => async,
  async_body: () => async_body,
  async_derived: () => async_derived,
  attach: () => attach,
  attachment: () => createAttachmentKey,
  attr: () => attr,
  attribute_effect: () => attribute_effect,
  autofocus: () => autofocus,
  await: () => await_block,
  bind_active_element: () => bind_active_element,
  bind_buffered: () => bind_buffered,
  bind_checked: () => bind_checked,
  bind_content_editable: () => bind_content_editable,
  bind_current_time: () => bind_current_time,
  bind_element_size: () => bind_element_size,
  bind_ended: () => bind_ended,
  bind_files: () => bind_files,
  bind_focused: () => bind_focused,
  bind_group: () => bind_group,
  bind_muted: () => bind_muted,
  bind_online: () => bind_online,
  bind_paused: () => bind_paused,
  bind_playback_rate: () => bind_playback_rate,
  bind_played: () => bind_played,
  bind_prop: () => bind_prop,
  bind_property: () => bind_property,
  bind_ready_state: () => bind_ready_state,
  bind_resize_observer: () => bind_resize_observer,
  bind_seekable: () => bind_seekable,
  bind_seeking: () => bind_seeking,
  bind_select_value: () => bind_select_value,
  bind_this: () => bind_this,
  bind_value: () => bind_value,
  bind_volume: () => bind_volume,
  bind_window_scroll: () => bind_window_scroll,
  bind_window_size: () => bind_window_size,
  boundary: () => boundary,
  bubble_event: () => bubble_event,
  check_target: () => check_target,
  child: () => child,
  cleanup_styles: () => cleanup_styles,
  clsx: () => clsx2,
  comment: () => comment,
  component: () => component,
  create_custom_element: () => create_custom_element,
  create_ownership_validator: () => create_ownership_validator,
  css_props: () => css_props,
  deep_read: () => deep_read,
  deep_read_state: () => deep_read_state,
  deferred_template_effect: () => deferred_template_effect,
  delegate: () => delegate,
  derived: () => user_derived,
  derived_safe_equal: () => derived_safe_equal,
  document: () => $document,
  each: () => each,
  eager: () => eager,
  effect: () => effect,
  effect_root: () => effect_root,
  effect_tracking: () => effect_tracking,
  element: () => element,
  equals: () => equals2,
  event: () => event,
  exclude_from_object: () => exclude_from_object,
  fallback: () => fallback,
  first_child: () => first_child,
  flush: () => flushSync,
  for_await_track_reactivity_loss: () => for_await_track_reactivity_loss,
  from_html: () => from_html,
  from_mathml: () => from_mathml,
  from_svg: () => from_svg,
  from_tree: () => from_tree,
  get: () => get,
  head: () => head,
  hmr: () => hmr,
  html: () => html,
  hydrate_template: () => hydrate_template,
  if: () => if_block,
  index: () => index,
  init: () => init,
  init_select: () => init_select2,
  inspect: () => inspect,
  invalid_default_snippet: () => invalid_default_snippet,
  invalidate_inner_signals: () => invalidate_inner_signals,
  invalidate_store: () => invalidate_store,
  invoke_error_boundary: () => invoke_error_boundary,
  key: () => key,
  legacy_api: () => legacy_api,
  legacy_pre_effect: () => legacy_pre_effect,
  legacy_pre_effect_reset: () => legacy_pre_effect_reset,
  legacy_rest_props: () => legacy_rest_props,
  log_if_contains_state: () => log_if_contains_state,
  mark_store_binding: () => mark_store_binding,
  mutable_source: () => mutable_source,
  mutate: () => mutate,
  next: () => next,
  noop: () => noop,
  once: () => once,
  pending: () => pending,
  pop: () => pop,
  preventDefault: () => preventDefault,
  prevent_snippet_stringification: () => prevent_snippet_stringification,
  prop: () => prop,
  props_id: () => props_id,
  proxy: () => proxy,
  push: () => push,
  raf: () => raf,
  reactive_import: () => reactive_import,
  remove_input_defaults: () => remove_input_defaults,
  remove_textarea_child: () => remove_textarea_child,
  render_effect: () => render_effect,
  replay_events: () => replay_events,
  reset: () => reset,
  rest_props: () => rest_props,
  run: () => run2,
  run_after_blockers: () => run_after_blockers,
  safe_get: () => safe_get,
  sanitize_slots: () => sanitize_slots,
  save: () => save,
  select_option: () => select_option,
  self: () => self,
  set: () => set,
  set_attribute: () => set_attribute2,
  set_checked: () => set_checked,
  set_class: () => set_class,
  set_custom_element_data: () => set_custom_element_data,
  set_default_checked: () => set_default_checked,
  set_default_value: () => set_default_value,
  set_selected: () => set_selected,
  set_style: () => set_style,
  set_text: () => set_text,
  set_value: () => set_value,
  set_xlink_attribute: () => set_xlink_attribute,
  setup_stores: () => setup_stores,
  sibling: () => sibling,
  slot: () => slot,
  snapshot: () => snapshot,
  snippet: () => snippet,
  spread_props: () => spread_props,
  state: () => state,
  stopImmediatePropagation: () => stopImmediatePropagation,
  stopPropagation: () => stopPropagation,
  store_get: () => store_get,
  store_mutate: () => store_mutate,
  store_set: () => store_set,
  store_unsub: () => store_unsub,
  strict_equals: () => strict_equals,
  tag: () => tag,
  tag_proxy: () => tag_proxy,
  template_effect: () => template_effect,
  text: () => text,
  tick: () => tick,
  to_array: () => to_array,
  trace: () => trace,
  track_reactivity_loss: () => track_reactivity_loss,
  transition: () => transition,
  trusted: () => trusted,
  untrack: () => untrack,
  update: () => update,
  update_legacy_props: () => update_legacy_props,
  update_pre: () => update_pre,
  update_pre_prop: () => update_pre_prop,
  update_pre_store: () => update_pre_store,
  update_prop: () => update_prop,
  update_store: () => update_store,
  user_effect: () => user_effect,
  user_pre_effect: () => user_pre_effect,
  validate_binding: () => validate_binding,
  validate_dynamic_element_tag: () => validate_dynamic_element_tag,
  validate_each_keys: () => validate_each_keys,
  validate_snippet_args: () => validate_snippet_args,
  validate_store: () => validate_store,
  validate_void_dynamic_element: () => validate_void_dynamic_element,
  window: () => $window,
  with_script: () => with_script,
  wrap_snippet: () => wrap_snippet
});
var init_client = __esm({
  "node_modules/svelte/src/internal/client/index.js"() {
    init_attachments();
    init_constants();
    init_context();
    init_assign();
    init_css();
    init_elements();
    init_hmr();
    init_ownership();
    init_legacy2();
    init_tracing();
    init_inspect();
    init_async2();
    init_validation();
    init_await();
    init_if();
    init_key();
    init_css_props();
    init_each();
    init_html();
    init_slot();
    init_snippet();
    init_svelte_component();
    init_svelte_element();
    init_svelte_head();
    init_css2();
    init_actions();
    init_attachments2();
    init_attributes2();
    init_class();
    init_events();
    init_misc();
    init_style();
    init_transitions();
    init_document();
    init_input();
    init_media();
    init_navigator();
    init_props();
    init_select();
    init_size();
    init_this();
    init_universal();
    init_window();
    init_hydration();
    init_event_modifiers();
    init_lifecycle();
    init_misc2();
    init_template();
    init_async();
    init_batch();
    init_deriveds();
    init_effects();
    init_sources();
    init_props2();
    init_store();
    init_boundary();
    init_legacy();
    init_render();
    init_runtime();
    init_validate2();
    init_timing();
    init_proxy();
    init_custom_element();
    init_operations();
    init_attributes();
    init_clone();
    init_utils();
    init_validate();
    init_equality2();
    init_console_log();
    init_error_handling();
  }
});

// node_modules/svelte/src/internal/client/hydratable.js
var init_hydratable = __esm({
  "node_modules/svelte/src/internal/client/hydratable.js"() {
    init_flags();
    init_hydration();
    init_warnings();
    init_errors2();
    init_esm_env();
  }
});

// node_modules/svelte/src/index-client.js
var init_index_client = __esm({
  "node_modules/svelte/src/index-client.js"() {
    init_runtime();
    init_utils();
    init_client();
    init_errors2();
    init_flags();
    init_context();
    init_esm_env();
    init_batch();
    init_context();
    init_hydratable();
    init_render();
    init_runtime();
    init_snippet();
    if (true_default) {
      let throw_rune_error = function(rune) {
        if (!(rune in globalThis)) {
          let value;
          Object.defineProperty(globalThis, rune, {
            configurable: true,
            // eslint-disable-next-line getter-return
            get: () => {
              if (value !== void 0) {
                return value;
              }
              rune_outside_svelte(rune);
            },
            set: (v) => {
              value = v;
            }
          });
        }
      };
      throw_rune_error("$state");
      throw_rune_error("$effect");
      throw_rune_error("$derived");
      throw_rune_error("$inspect");
      throw_rune_error("$props");
      throw_rune_error("$bindable");
    }
  }
});

// node_modules/svelte/src/store/utils.js
function subscribe_to_store(store, run3, invalidate) {
  if (store == null) {
    run3(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store.subscribe(
      run3,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var init_utils3 = __esm({
  "node_modules/svelte/src/store/utils.js"() {
    init_index_client();
    init_utils();
  }
});

// node_modules/svelte/src/internal/server/hydration.js
var BLOCK_OPEN, BLOCK_OPEN_ELSE, BLOCK_CLOSE;
var init_hydration2 = __esm({
  "node_modules/svelte/src/internal/server/hydration.js"() {
    init_constants();
    BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
    BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
    BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
  }
});

// node_modules/svelte/src/internal/server/abort-signal.js
function abort() {
  controller?.abort(STALE_REACTION);
  controller = null;
}
function getAbortSignal() {
  return (controller ??= new AbortController()).signal;
}
var controller;
var init_abort_signal = __esm({
  "node_modules/svelte/src/internal/server/abort-signal.js"() {
    init_constants2();
    controller = null;
  }
});

// node_modules/svelte/src/internal/server/errors.js
function async_local_storage_unavailable() {
  const error = new Error(`async_local_storage_unavailable
The node API \`AsyncLocalStorage\` is not available, but is required to use async server rendering.
https://svelte.dev/e/async_local_storage_unavailable`);
  error.name = "Svelte error";
  throw error;
}
function await_invalid() {
  const error = new Error(`await_invalid
Encountered asynchronous work while rendering synchronously.
https://svelte.dev/e/await_invalid`);
  error.name = "Svelte error";
  throw error;
}
function html_deprecated() {
  const error = new Error(`html_deprecated
The \`html\` property of server render results has been deprecated. Use \`body\` instead.
https://svelte.dev/e/html_deprecated`);
  error.name = "Svelte error";
  throw error;
}
function hydratable_clobbering(key2, stack2) {
  const error = new Error(`hydratable_clobbering
Attempted to set \`hydratable\` with key \`${key2}\` twice with different values.

${stack2}
https://svelte.dev/e/hydratable_clobbering`);
  error.name = "Svelte error";
  throw error;
}
function hydratable_serialization_failed(key2, stack2) {
  const error = new Error(`hydratable_serialization_failed
Failed to serialize \`hydratable\` data for key \`${key2}\`.

\`hydratable\` can serialize anything [\`uneval\` from \`devalue\`](https://npmjs.com/package/uneval) can, plus Promises.

Cause:
${stack2}
https://svelte.dev/e/hydratable_serialization_failed`);
  error.name = "Svelte error";
  throw error;
}
function lifecycle_function_unavailable(name) {
  const error = new Error(`lifecycle_function_unavailable
\`${name}(...)\` is not available on the server
https://svelte.dev/e/lifecycle_function_unavailable`);
  error.name = "Svelte error";
  throw error;
}
function server_context_required() {
  const error = new Error(`server_context_required
Could not resolve \`render\` context.
https://svelte.dev/e/server_context_required`);
  error.name = "Svelte error";
  throw error;
}
var init_errors3 = __esm({
  "node_modules/svelte/src/internal/server/errors.js"() {
    init_errors();
  }
});

// node_modules/svelte/src/internal/server/context.js
function set_ssr_context(v) {
  ssr_context = v;
}
function createContext2() {
  const key2 = {};
  return [() => getContext2(key2), (context2) => setContext2(key2, context2)];
}
function getContext2(key2) {
  const context_map = get_or_init_context_map("getContext");
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
function setContext2(key2, context2) {
  get_or_init_context_map("setContext").set(key2, context2);
  return context2;
}
function hasContext2(key2) {
  return get_or_init_context_map("hasContext").has(key2);
}
function getAllContexts2() {
  return get_or_init_context_map("getAllContexts");
}
function get_or_init_context_map(name) {
  if (ssr_context === null) {
    lifecycle_outside_component(name);
  }
  return ssr_context.c ??= new Map(get_parent_context(ssr_context) || void 0);
}
function push2(fn) {
  ssr_context = { p: ssr_context, c: null, r: null };
  if (true_default) {
    ssr_context.function = fn;
    ssr_context.element = ssr_context.p?.element;
  }
}
function pop2() {
  ssr_context = /** @type {SSRContext} */
  ssr_context.p;
}
function get_parent_context(ssr_context2) {
  let parent = ssr_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
var ssr_context;
var init_context2 = __esm({
  "node_modules/svelte/src/internal/server/context.js"() {
    init_esm_env();
    init_errors3();
    ssr_context = null;
  }
});

// node_modules/svelte/src/internal/server/warnings.js
function unresolved_hydratable(key2, stack2) {
  if (true_default) {
    console.warn(
      `%c[svelte] unresolved_hydratable
%cA \`hydratable\` value with key \`${key2}\` was created, but at least part of it was not used during the render.

The \`hydratable\` was initialized in:
${stack2}
https://svelte.dev/e/unresolved_hydratable`,
      bold3,
      normal3
    );
  } else {
    console.warn(`https://svelte.dev/e/unresolved_hydratable`);
  }
}
var bold3, normal3;
var init_warnings3 = __esm({
  "node_modules/svelte/src/internal/server/warnings.js"() {
    init_esm_env();
    bold3 = "font-weight: bold";
    normal3 = "font-weight: normal";
  }
});

// node_modules/svelte/src/internal/server/render-context.js
function get_render_context() {
  const store = context ?? als?.getStore();
  if (!store) {
    server_context_required();
  }
  return store;
}
async function with_render_context(fn) {
  context = {
    hydratable: {
      lookup: /* @__PURE__ */ new Map(),
      comparisons: [],
      unresolved_promises: /* @__PURE__ */ new Map()
    }
  };
  if (in_webcontainer()) {
    const { promise, resolve } = deferred();
    const previous_render = current_render;
    current_render = promise;
    await previous_render;
    return fn().finally(resolve);
  }
  try {
    if (als === null) {
      async_local_storage_unavailable();
    }
    return als.run(context, fn);
  } finally {
    context = null;
  }
}
async function init_render_context2() {
  if (als !== null) return;
  try {
    const { AsyncLocalStorage } = await import("node:async_hooks");
    als = new AsyncLocalStorage();
  } catch {
  }
}
function in_webcontainer() {
  return !!globalThis.process?.versions?.webcontainer;
}
var current_render, context, als;
var init_render_context = __esm({
  "node_modules/svelte/src/internal/server/render-context.js"() {
    init_utils();
    init_errors3();
    current_render = null;
    context = null;
    als = null;
  }
});

// node_modules/svelte/src/internal/server/renderer.js
var Renderer, SSRState;
var init_renderer = __esm({
  "node_modules/svelte/src/internal/server/renderer.js"() {
    init_flags();
    init_abort_signal();
    init_context2();
    init_errors3();
    init_warnings3();
    init_hydration2();
    init_server();
    init_render_context();
    init_esm_env();
    Renderer = class _Renderer {
      /**
       * The contents of the renderer.
       * @type {RendererItem[]}
       */
      #out = [];
      /**
       * Any `onDestroy` callbacks registered during execution of this renderer.
       * @type {(() => void)[] | undefined}
       */
      #on_destroy = void 0;
      /**
       * Whether this renderer is a component body.
       * @type {boolean}
       */
      #is_component_body = false;
      /**
       * The type of string content that this renderer is accumulating.
       * @type {RendererType}
       */
      type;
      /** @type {Renderer | undefined} */
      #parent;
      /**
       * Asynchronous work associated with this renderer
       * @type {Promise<void> | undefined}
       */
      promise = void 0;
      /**
       * State which is associated with the content tree as a whole.
       * It will be re-exposed, uncopied, on all children.
       * @type {SSRState}
       * @readonly
       */
      global;
      /**
       * State that is local to the branch it is declared in.
       * It will be shallow-copied to all children.
       *
       * @type {{ select_value: string | undefined }}
       */
      local;
      /**
       * @param {SSRState} global
       * @param {Renderer | undefined} [parent]
       */
      constructor(global, parent) {
        this.#parent = parent;
        this.global = global;
        this.local = parent ? { ...parent.local } : { select_value: void 0 };
        this.type = parent ? parent.type : "body";
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      head(fn) {
        const head2 = new _Renderer(this.global, this);
        head2.type = "head";
        this.#out.push(head2);
        head2.child(fn);
      }
      /**
       * @param {Array<Promise<void>>} blockers
       * @param {(renderer: Renderer) => void} fn
       */
      async_block(blockers, fn) {
        this.#out.push(BLOCK_OPEN);
        this.async(blockers, fn);
        this.#out.push(BLOCK_CLOSE);
      }
      /**
       * @param {Array<Promise<void>>} blockers
       * @param {(renderer: Renderer) => void} fn
       */
      async(blockers, fn) {
        let callback = fn;
        if (blockers.length > 0) {
          const context2 = ssr_context;
          callback = (renderer) => {
            return Promise.all(blockers).then(() => {
              const previous_context = ssr_context;
              try {
                set_ssr_context(context2);
                return fn(renderer);
              } finally {
                set_ssr_context(previous_context);
              }
            });
          };
        }
        this.child(callback);
      }
      /**
       * @param {Array<() => void>} thunks
       */
      run(thunks) {
        const context2 = ssr_context;
        let promise = Promise.resolve(thunks[0]());
        const promises = [promise];
        for (const fn of thunks.slice(1)) {
          promise = promise.then(() => {
            const previous_context = ssr_context;
            set_ssr_context(context2);
            try {
              return fn();
            } finally {
              set_ssr_context(previous_context);
            }
          });
          promises.push(promise);
        }
        return promises;
      }
      /**
       * Create a child renderer. The child renderer inherits the state from the parent,
       * but has its own content.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       */
      child(fn) {
        const child2 = new _Renderer(this.global, this);
        this.#out.push(child2);
        const parent = ssr_context;
        set_ssr_context({
          ...ssr_context,
          p: parent,
          c: null,
          r: child2
        });
        const result = fn(child2);
        set_ssr_context(parent);
        if (result instanceof Promise) {
          if (child2.global.mode === "sync") {
            await_invalid();
          }
          result.catch(() => {
          });
          child2.promise = result;
        }
        return child2;
      }
      /**
       * Create a component renderer. The component renderer inherits the state from the parent,
       * but has its own content. It is treated as an ordering boundary for ondestroy callbacks.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       * @param {Function} [component_fn]
       * @returns {void}
       */
      component(fn, component_fn) {
        push2(component_fn);
        const child2 = this.child(fn);
        child2.#is_component_body = true;
        pop2();
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {(renderer: Renderer) => void} fn
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       * @returns {void}
       */
      select(attrs, fn, css_hash, classes, styles, flags2) {
        const { value, ...select_attrs } = attrs;
        this.push(`<select${attributes(select_attrs, css_hash, classes, styles, flags2)}>`);
        this.child((renderer) => {
          renderer.local.select_value = value;
          fn(renderer);
        });
        this.push("</select>");
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {string | number | boolean | ((renderer: Renderer) => void)} body
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       */
      option(attrs, body, css_hash, classes, styles, flags2) {
        this.#out.push(`<option${attributes(attrs, css_hash, classes, styles, flags2)}`);
        const close = (renderer, value, { head: head2, body: body2 }) => {
          if ("value" in attrs) {
            value = attrs.value;
          }
          if (value === this.local.select_value) {
            renderer.#out.push(" selected");
          }
          renderer.#out.push(`>${body2}</option>`);
          if (head2) {
            renderer.head((child2) => child2.push(head2));
          }
        };
        if (typeof body === "function") {
          this.child((renderer) => {
            const r2 = new _Renderer(this.global, this);
            body(r2);
            if (this.global.mode === "async") {
              return r2.#collect_content_async().then((content) => {
                close(renderer, content.body.replaceAll("<!---->", ""), content);
              });
            } else {
              const content = r2.#collect_content();
              close(renderer, content.body.replaceAll("<!---->", ""), content);
            }
          });
        } else {
          close(this, body, { body });
        }
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      title(fn) {
        const path = this.get_path();
        const close = (head2) => {
          this.global.set_title(head2, path);
        };
        this.child((renderer) => {
          const r2 = new _Renderer(renderer.global, renderer);
          fn(r2);
          if (renderer.global.mode === "async") {
            return r2.#collect_content_async().then((content) => {
              close(content.head);
            });
          } else {
            const content = r2.#collect_content();
            close(content.head);
          }
        });
      }
      /**
       * @param {string | (() => Promise<string>)} content
       */
      push(content) {
        if (typeof content === "function") {
          this.child(async (renderer) => renderer.push(await content()));
        } else {
          this.#out.push(content);
        }
      }
      /**
       * @param {() => void} fn
       */
      on_destroy(fn) {
        (this.#on_destroy ??= []).push(fn);
      }
      /**
       * @returns {number[]}
       */
      get_path() {
        return this.#parent ? [...this.#parent.get_path(), this.#parent.#out.indexOf(this)] : [];
      }
      /**
       * @deprecated this is needed for legacy component bindings
       */
      copy() {
        const copy = new _Renderer(this.global, this.#parent);
        copy.#out = this.#out.map((item) => item instanceof _Renderer ? item.copy() : item);
        copy.promise = this.promise;
        return copy;
      }
      /**
       * @param {Renderer} other
       * @deprecated this is needed for legacy component bindings
       */
      subsume(other) {
        if (this.global.mode !== other.global.mode) {
          throw new Error(
            "invariant: A renderer cannot switch modes. If you're seeing this, there's a compiler bug. File an issue!"
          );
        }
        this.local = other.local;
        this.#out = other.#out.map((item) => {
          if (item instanceof _Renderer) {
            item.subsume(item);
          }
          return item;
        });
        this.promise = other.promise;
        this.type = other.type;
      }
      get length() {
        return this.#out.length;
      }
      /**
       * Only available on the server and when compiling with the `server` option.
       * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} [options]
       * @returns {RenderOutput}
       */
      static render(component2, options = {}) {
        let sync;
        let async2;
        const result = (
          /** @type {RenderOutput} */
          {}
        );
        Object.defineProperties(result, {
          html: {
            get: () => {
              return (sync ??= _Renderer.#render(component2, options)).body;
            }
          },
          head: {
            get: () => {
              return (sync ??= _Renderer.#render(component2, options)).head;
            }
          },
          body: {
            get: () => {
              return (sync ??= _Renderer.#render(component2, options)).body;
            }
          },
          then: {
            value: (
              /**
               * this is not type-safe, but honestly it's the best I can do right now, and it's a straightforward function.
               *
               * @template TResult1
               * @template [TResult2=never]
               * @param { (value: SyncRenderOutput) => TResult1 } onfulfilled
               * @param { (reason: unknown) => TResult2 } onrejected
               */
              (onfulfilled, onrejected) => {
                if (!async_mode_flag) {
                  const result2 = sync ??= _Renderer.#render(component2, options);
                  const user_result = onfulfilled({
                    head: result2.head,
                    body: result2.body,
                    html: result2.body
                  });
                  return Promise.resolve(user_result);
                }
                async2 ??= init_render_context2().then(
                  () => with_render_context(() => _Renderer.#render_async(component2, options))
                );
                return async2.then((result2) => {
                  Object.defineProperty(result2, "html", {
                    // eslint-disable-next-line getter-return
                    get: () => {
                      html_deprecated();
                    }
                  });
                  return onfulfilled(
                    /** @type {SyncRenderOutput} */
                    result2
                  );
                }, onrejected);
              }
            )
          }
        });
        return result;
      }
      /**
       * Collect all of the `onDestroy` callbacks registered during rendering. In an async context, this is only safe to call
       * after awaiting `collect_async`.
       *
       * Child renderers are "porous" and don't affect execution order, but component body renderers
       * create ordering boundaries. Within a renderer, callbacks run in order until hitting a component boundary.
       * @returns {Iterable<() => void>}
       */
      *#collect_on_destroy() {
        for (const component2 of this.#traverse_components()) {
          yield* component2.#collect_ondestroy();
        }
      }
      /**
       * Performs a depth-first search of renderers, yielding the deepest components first, then additional components as we backtrack up the tree.
       * @returns {Iterable<Renderer>}
       */
      *#traverse_components() {
        for (const child2 of this.#out) {
          if (typeof child2 !== "string") {
            yield* child2.#traverse_components();
          }
        }
        if (this.#is_component_body) {
          yield this;
        }
      }
      /**
       * @returns {Iterable<() => void>}
       */
      *#collect_ondestroy() {
        if (this.#on_destroy) {
          for (const fn of this.#on_destroy) {
            yield fn;
          }
        }
        for (const child2 of this.#out) {
          if (child2 instanceof _Renderer && !child2.#is_component_body) {
            yield* child2.#collect_ondestroy();
          }
        }
      }
      /**
       * Render a component. Throws if any of the children are performing asynchronous work.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {AccumulatedContent}
       */
      static #render(component2, options) {
        var previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("sync", component2, options);
          const content = renderer.#collect_content();
          return _Renderer.#close_render(content, renderer);
        } finally {
          abort();
          set_ssr_context(previous_context);
        }
      }
      /**
       * Render a component.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Promise<AccumulatedContent>}
       */
      static async #render_async(component2, options) {
        const previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("async", component2, options);
          const content = await renderer.#collect_content_async();
          const hydratables = await renderer.#collect_hydratables();
          if (hydratables !== null) {
            content.head = hydratables + content.head;
          }
          return _Renderer.#close_render(content, renderer);
        } finally {
          set_ssr_context(previous_context);
          abort();
        }
      }
      /**
       * Collect all of the code from the `out` array and return it as a string, or a promise resolving to a string.
       * @param {AccumulatedContent} content
       * @returns {AccumulatedContent}
       */
      #collect_content(content = { head: "", body: "" }) {
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            item.#collect_content(content);
          }
        }
        return content;
      }
      /**
       * Collect all of the code from the `out` array and return it as a string.
       * @param {AccumulatedContent} content
       * @returns {Promise<AccumulatedContent>}
       */
      async #collect_content_async(content = { head: "", body: "" }) {
        await this.promise;
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            await item.#collect_content_async(content);
          }
        }
        return content;
      }
      async #collect_hydratables() {
        const ctx = get_render_context().hydratable;
        for (const [_, key2] of ctx.unresolved_promises) {
          unresolved_hydratable(key2, ctx.lookup.get(key2)?.stack ?? "<missing stack trace>");
        }
        for (const comparison of ctx.comparisons) {
          await comparison;
        }
        return await _Renderer.#hydratable_block(ctx);
      }
      /**
       * @template {Record<string, any>} Props
       * @param {'sync' | 'async'} mode
       * @param {import('svelte').Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Renderer}
       */
      static #open_render(mode, component2, options) {
        const renderer = new _Renderer(
          new SSRState(mode, options.idPrefix ? options.idPrefix + "-" : "")
        );
        renderer.push(BLOCK_OPEN);
        if (options.context) {
          push2();
          ssr_context.c = options.context;
          ssr_context.r = renderer;
        }
        component2(renderer, options.props ?? {});
        if (options.context) {
          pop2();
        }
        renderer.push(BLOCK_CLOSE);
        return renderer;
      }
      /**
       * @param {AccumulatedContent} content
       * @param {Renderer} renderer
       */
      static #close_render(content, renderer) {
        for (const cleanup of renderer.#collect_on_destroy()) {
          cleanup();
        }
        let head2 = content.head + renderer.global.get_title();
        let body = content.body;
        for (const { hash: hash2, code } of renderer.global.css) {
          head2 += `<style id="${hash2}">${code}</style>`;
        }
        return {
          head: head2,
          body
        };
      }
      /**
       * @param {HydratableContext} ctx
       */
      static async #hydratable_block(ctx) {
        if (ctx.lookup.size === 0) {
          return null;
        }
        let entries = [];
        let has_promises = false;
        for (const [k, v] of ctx.lookup) {
          if (v.promises) {
            has_promises = true;
            for (const p of v.promises) await p;
          }
          entries.push(`[${JSON.stringify(k)},${v.serialized}]`);
        }
        let prelude = `const h = (window.__svelte ??= {}).h ??= new Map();`;
        if (has_promises) {
          prelude = `const r = (v) => Promise.resolve(v);
				${prelude}`;
        }
        return `
		<script>
			{
				${prelude}

				for (const [k, v] of [
					${entries.join(",\n					")}
				]) {
					h.set(k, v);
				}
			}
		</script>`;
      }
    };
    SSRState = class {
      /** @readonly @type {'sync' | 'async'} */
      mode;
      /** @readonly @type {() => string} */
      uid;
      /** @readonly @type {Set<{ hash: string; code: string }>} */
      css = /* @__PURE__ */ new Set();
      /** @type {{ path: number[], value: string }} */
      #title = { path: [], value: "" };
      /**
       * @param {'sync' | 'async'} mode
       * @param {string} [id_prefix]
       */
      constructor(mode, id_prefix = "") {
        this.mode = mode;
        let uid = 1;
        this.uid = () => `${id_prefix}s${uid++}`;
      }
      get_title() {
        return this.#title.value;
      }
      /**
       * Performs a depth-first (lexicographic) comparison using the path. Rejects sets
       * from earlier than or equal to the current value.
       * @param {string} value
       * @param {number[]} path
       */
      set_title(value, path) {
        const current = this.#title.path;
        let i = 0;
        let l = Math.min(path.length, current.length);
        while (i < l && path[i] === current[i]) i += 1;
        if (path[i] === void 0) return;
        if (current[i] === void 0 || path[i] > current[i]) {
          this.#title.path = path;
          this.#title.value = value;
        }
      }
    };
  }
});

// node_modules/svelte/src/internal/server/blocks/html.js
var init_html2 = __esm({
  "node_modules/svelte/src/internal/server/blocks/html.js"() {
    init_esm_env();
    init_utils2();
  }
});

// node_modules/svelte/src/html-tree-validation.js
function is_tag_valid_with_ancestor(child_tag, ancestors, child_loc, ancestor_loc) {
  if (child_tag.includes("-")) return null;
  const ancestor_tag = ancestors[ancestors.length - 1];
  const disallowed = disallowed_children[ancestor_tag];
  if (!disallowed) return null;
  if ("reset_by" in disallowed && disallowed.reset_by) {
    for (let i = ancestors.length - 2; i >= 0; i--) {
      const ancestor = ancestors[i];
      if (ancestor.includes("-")) return null;
      if (disallowed.reset_by.includes(ancestors[i])) {
        return null;
      }
    }
  }
  if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
    const child2 = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
    const ancestor = ancestor_loc ? `\`<${ancestor_tag}>\` (${ancestor_loc})` : `\`<${ancestor_tag}>\``;
    return `${child2} cannot be a descendant of ${ancestor}`;
  }
  return null;
}
function is_tag_valid_with_parent(child_tag, parent_tag, child_loc, parent_loc) {
  if (child_tag.includes("-") || parent_tag?.includes("-")) return null;
  if (parent_tag === "template") return null;
  const disallowed = disallowed_children[parent_tag];
  const child2 = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
  const parent = parent_loc ? `\`<${parent_tag}>\` (${parent_loc})` : `\`<${parent_tag}>\``;
  if (disallowed) {
    if ("direct" in disallowed && disallowed.direct.includes(child_tag)) {
      return `${child2} cannot be a direct child of ${parent}`;
    }
    if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
      return `${child2} cannot be a child of ${parent}`;
    }
    if ("only" in disallowed && disallowed.only) {
      if (disallowed.only.includes(child_tag)) {
        return null;
      } else {
        return `${child2} cannot be a child of ${parent}. \`<${parent_tag}>\` only allows these children: ${disallowed.only.map((d) => `\`<${d}>\``).join(", ")}`;
      }
    }
  }
  switch (child_tag) {
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
      return `${child2} cannot be a child of ${parent}`;
    case "thead":
    case "tbody":
    case "tfoot":
      return `${child2} must be the child of a \`<table>\`, not a ${parent}`;
    case "td":
    case "th":
      return `${child2} must be the child of a \`<tr>\`, not a ${parent}`;
    case "tr":
      return `\`<tr>\` must be the child of a \`<thead>\`, \`<tbody>\`, or \`<tfoot>\`, not a ${parent}`;
  }
  return null;
}
var autoclosing_children, disallowed_children;
var init_html_tree_validation = __esm({
  "node_modules/svelte/src/html-tree-validation.js"() {
    autoclosing_children = {
      // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
      li: { direct: ["li"] },
      // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
      dt: { descendant: ["dt", "dd"], reset_by: ["dl"] },
      dd: { descendant: ["dt", "dd"], reset_by: ["dl"] },
      p: {
        descendant: [
          "address",
          "article",
          "aside",
          "blockquote",
          "div",
          "dl",
          "fieldset",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "header",
          "hgroup",
          "hr",
          "main",
          "menu",
          "nav",
          "ol",
          "p",
          "pre",
          "section",
          "table",
          "ul"
        ]
      },
      rt: { descendant: ["rt", "rp"] },
      rp: { descendant: ["rt", "rp"] },
      optgroup: { descendant: ["optgroup"] },
      option: { descendant: ["option", "optgroup"] },
      thead: { direct: ["tbody", "tfoot"] },
      tbody: { direct: ["tbody", "tfoot"] },
      tfoot: { direct: ["tbody"] },
      tr: { direct: ["tr", "tbody"] },
      td: { direct: ["td", "th", "tr"] },
      th: { direct: ["td", "th", "tr"] }
    };
    disallowed_children = {
      ...autoclosing_children,
      optgroup: { only: ["option", "#text"] },
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
      option: { only: ["#text"] },
      form: { descendant: ["form"] },
      a: { descendant: ["a"] },
      button: { descendant: ["button"] },
      h1: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h2: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h3: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h4: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h5: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      h6: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      select: { only: ["option", "optgroup", "#text", "hr", "script", "template"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      tr: { only: ["th", "td", "style", "script", "template"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      tbody: { only: ["tr", "style", "script", "template"] },
      thead: { only: ["tr", "style", "script", "template"] },
      tfoot: { only: ["tr", "style", "script", "template"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      colgroup: { only: ["col", "template"] },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      table: {
        only: ["caption", "colgroup", "tbody", "thead", "tfoot", "style", "script", "template"]
      },
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      head: {
        only: [
          "base",
          "basefont",
          "bgsound",
          "link",
          "meta",
          "title",
          "noscript",
          "noframes",
          "style",
          "script",
          "template"
        ]
      },
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      html: { only: ["head", "body", "frameset"] },
      frameset: { only: ["frame"] },
      "#document": { only: ["html"] }
    };
  }
});

// node_modules/svelte/src/internal/server/dev.js
function print_error(renderer, message) {
  message = `node_invalid_placement_ssr: ${message}

This can cause content to shift around as the browser repairs the HTML, and will likely result in a \`hydration_mismatch\` warning.`;
  if ((seen ??= /* @__PURE__ */ new Set()).has(message)) return;
  seen.add(message);
  console.error(message);
  renderer.head((r2) => r2.push(`<script>console.error(${JSON.stringify(message)})</script>`));
}
function push_element(renderer, tag2, line, column) {
  var context2 = (
    /** @type {SSRContext} */
    ssr_context
  );
  var filename = context2.function[FILENAME];
  var parent = context2.element;
  var element2 = { tag: tag2, parent, filename, line, column };
  if (parent !== void 0) {
    var ancestor = parent.parent;
    var ancestors = [parent.tag];
    const child_loc = filename ? `${filename}:${line}:${column}` : void 0;
    const parent_loc = parent.filename ? `${parent.filename}:${parent.line}:${parent.column}` : void 0;
    const message = is_tag_valid_with_parent(tag2, parent.tag, child_loc, parent_loc);
    if (message) print_error(renderer, message);
    while (ancestor != null) {
      ancestors.push(ancestor.tag);
      const ancestor_loc = ancestor.filename ? `${ancestor.filename}:${ancestor.line}:${ancestor.column}` : void 0;
      const message2 = is_tag_valid_with_ancestor(tag2, ancestors, child_loc, ancestor_loc);
      if (message2) print_error(renderer, message2);
      ancestor = ancestor.parent;
    }
  }
  set_ssr_context({ ...context2, p: context2, element: element2 });
}
function pop_element() {
  set_ssr_context(
    /** @type {SSRContext} */
    ssr_context.p
  );
}
function get_user_code_location() {
  const stack2 = get_stack();
  return stack2.filter((line) => line.trim().startsWith("at ")).map((line) => line.replace(/\((.*):\d+:\d+\)$/, (_, file) => `(${file})`)).join("\n");
}
var seen;
var init_dev2 = __esm({
  "node_modules/svelte/src/internal/server/dev.js"() {
    init_constants();
    init_html_tree_validation();
    init_dev();
    init_context2();
    init_errors3();
    init_renderer();
  }
});

// node_modules/svelte/src/internal/server/index.js
function render(component2, options = {}) {
  return Renderer.render(
    /** @type {Component<Props>} */
    component2,
    options
  );
}
function attributes(attrs, css_hash, classes, styles, flags2 = 0) {
  if (styles) {
    attrs.style = to_style(attrs.style, styles);
  }
  if (attrs.class) {
    attrs.class = clsx2(attrs.class);
  }
  if (css_hash || classes) {
    attrs.class = to_class(attrs.class, css_hash, classes);
  }
  let attr_str = "";
  let name;
  const is_html = (flags2 & ELEMENT_IS_NAMESPACED) === 0;
  const lowercase = (flags2 & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;
  const is_input = (flags2 & ELEMENT_IS_INPUT) !== 0;
  for (name in attrs) {
    if (typeof attrs[name] === "function") continue;
    if (name[0] === "$" && name[1] === "$") continue;
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue;
    var value = attrs[name];
    if (lowercase) {
      name = name.toLowerCase();
    }
    if (is_input) {
      if (name === "defaultvalue" || name === "defaultchecked") {
        name = name === "defaultvalue" ? "value" : "checked";
        if (attrs[name]) continue;
      }
    }
    attr_str += attr(name, value, is_html && is_boolean_attribute(name));
  }
  return attr_str;
}
function stringify(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
function attr_class(value, hash2, directives) {
  var result = to_class(value, hash2, directives);
  return result ? ` class="${escape_html(result, true)}"` : "";
}
function attr_style(value, directives) {
  var result = to_style(value, directives);
  return result ? ` style="${escape_html(result, true)}"` : "";
}
function bind_props(props_parent, props_now) {
  for (const key2 in props_now) {
    const initial_value = props_parent[key2];
    const value = props_now[key2];
    if (initial_value === void 0 && value !== void 0 && Object.getOwnPropertyDescriptor(props_parent, key2)?.set) {
      props_parent[key2] = value;
    }
  }
}
function ensure_array_like(array_like_or_iterator) {
  if (array_like_or_iterator) {
    return array_like_or_iterator.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }
  return [];
}
var INVALID_ATTR_NAME_CHAR_REGEX;
var init_server = __esm({
  "node_modules/svelte/src/internal/server/index.js"() {
    init_constants();
    init_attributes();
    init_utils();
    init_utils3();
    init_constants();
    init_escaping();
    init_esm_env();
    init_hydration2();
    init_validate();
    init_utils2();
    init_renderer();
    init_html2();
    init_context2();
    init_dev2();
    init_clone();
    init_utils();
    init_validate();
    INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
  }
});

// node_modules/svelte/src/server/index.js
var server_exports2 = {};
__export(server_exports2, {
  render: () => render
});
var init_server2 = __esm({
  "node_modules/svelte/src/server/index.js"() {
    init_server();
  }
});

// node_modules/devalue/src/utils.js
function is_primitive(thing) {
  return Object(thing) !== thing;
}
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type2(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char = str[i];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
function stringify_key(key2) {
  return is_identifier.test(key2) ? "." + key2 : "[" + JSON.stringify(key2) + "]";
}
var escaped, DevalueError, object_proto_names, is_identifier;
var init_utils4 = __esm({
  "node_modules/devalue/src/utils.js"() {
    escaped = {
      "<": "\\u003C",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    DevalueError = class extends Error {
      /**
       * @param {string} message
       * @param {string[]} keys
       */
      constructor(message, keys) {
        super(message);
        this.name = "DevalueError";
        this.path = keys.join("");
      }
    };
    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
      Object.prototype
    ).sort().join("\0");
    is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  }
});

// node_modules/devalue/src/uneval.js
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing, (value2) => uneval(value2, replacer));
        if (typeof str2 === "string") {
          custom.set(thing, str2);
          return;
        }
      }
      if (typeof thing === "function") {
        throw new DevalueError(`Cannot stringify a function`, keys);
      }
      const type = get_type2(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
        case "URL":
        case "URLSearchParams":
          return;
        case "Array":
          thing.forEach((value2, i) => {
            keys.push(`[${i}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          walk(thing.buffer);
          return;
        case "ArrayBuffer":
          return;
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(stringify_key(key2));
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a, b) => b[1] - a[1]).forEach((entry, i) => {
    names.set(entry[0], get_name(i));
  });
  function stringify2(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom.has(thing)) {
      return custom.get(thing);
    }
    const type = get_type2(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify2(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "URL":
        return `new URL(${stringify_string(thing.toString())})`;
      case "URLSearchParams":
        return `new URLSearchParams(${stringify_string(thing.toString())})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v, i) => i in thing ? stringify2(v) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify2).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        let str2 = `new ${type}`;
        if (counts.get(thing.buffer) === 1) {
          const array = new thing.constructor(thing.buffer);
          str2 += `([${array}])`;
        } else {
          str2 += `([${stringify2(thing.buffer)}])`;
        }
        const a = thing.byteOffset;
        const b = a + thing.byteLength;
        if (a > 0 || b !== thing.buffer.byteLength) {
          const m = +/(\d+)/.exec(type)[1] / 8;
          str2 += `.subarray(${a / m},${b / m})`;
        }
        return str2;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      case "Temporal.Duration":
      case "Temporal.Instant":
      case "Temporal.PlainDate":
      case "Temporal.PlainTime":
      case "Temporal.PlainDateTime":
      case "Temporal.PlainMonthDay":
      case "Temporal.PlainYearMonth":
      case "Temporal.ZonedDateTime":
        return `${type}.from(${stringify_string(thing.toString())})`;
      default:
        const keys2 = Object.keys(thing);
        const obj = keys2.map((key2) => `${safe_key(key2)}:${stringify2(thing[key2])}`).join(",");
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return keys2.length > 0 ? `{${obj},__proto__:null}` : `{__proto__:null}`;
        }
        return `{${obj}}`;
    }
  }
  const str = stringify2(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name, thing) => {
      params.push(name);
      if (custom.has(thing)) {
        values.push(
          /** @type {string} */
          custom.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type2(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify2(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v, i) => {
            statements.push(`${name}[${i}]=${stringify2(v)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v) => `add(${stringify2(v)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k, v]) => `set(${stringify2(k)}, ${stringify2(v)})`).join(".")}`
          );
          break;
        case "ArrayBuffer":
          values.push(
            `new Uint8Array([${new Uint8Array(thing).join(",")}]).buffer`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name}${safe_prop(key2)}=${stringify2(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
function escape_unsafe_char(c) {
  return escaped[c] || c;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
function stringify_primitive(thing) {
  if (typeof thing === "string") return stringify_string(thing);
  if (thing === void 0) return "void 0";
  if (thing === 0 && 1 / thing < 0) return "-0";
  const str = String(thing);
  if (typeof thing === "number") return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint") return thing + "n";
  return str;
}
var chars, unsafe_chars, reserved;
var init_uneval = __esm({
  "node_modules/devalue/src/uneval.js"() {
    init_utils4();
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
  }
});

// node_modules/devalue/index.js
var init_devalue = __esm({
  "node_modules/devalue/index.js"() {
    init_uneval();
  }
});

// node_modules/svelte/src/internal/server/hydratable.js
function hydratable2(key2, fn) {
  if (!async_mode_flag) {
    experimental_async_required("hydratable");
  }
  const { hydratable: hydratable3 } = get_render_context();
  let entry = hydratable3.lookup.get(key2);
  if (entry !== void 0) {
    if (true_default) {
      const comparison = compare2(key2, entry, encode(key2, fn()));
      comparison.catch(() => {
      });
      hydratable3.comparisons.push(comparison);
    }
    return (
      /** @type {T} */
      entry.value
    );
  }
  const value = fn();
  entry = encode(key2, value, hydratable3.unresolved_promises);
  hydratable3.lookup.set(key2, entry);
  return value;
}
function encode(key2, value, unresolved) {
  const entry = { value, serialized: "" };
  if (true_default) {
    entry.stack = get_user_code_location();
  }
  let uid = 1;
  entry.serialized = uneval(entry.value, (value2, uneval2) => {
    if (is_promise2(value2)) {
      const p = value2.then((v) => `r(${uneval2(v)})`).catch(
        (devalue_error) => hydratable_serialization_failed(
          key2,
          serialization_stack(entry.stack, devalue_error?.stack)
        )
      );
      p.catch(() => {
      });
      unresolved?.set(p, key2);
      p.finally(() => unresolved?.delete(p));
      const placeholder = `"${uid++}"`;
      (entry.promises ??= []).push(
        p.then((s) => {
          entry.serialized = entry.serialized.replace(placeholder, s);
        })
      );
      return placeholder;
    }
  });
  return entry;
}
function is_promise2(value) {
  return Object.prototype.toString.call(value) === "[object Promise]";
}
async function compare2(key2, a, b) {
  for (const p of a?.promises ?? []) {
    await p;
  }
  for (const p of b?.promises ?? []) {
    await p;
  }
  if (a.serialized !== b.serialized) {
    const a_stack = (
      /** @type {string} */
      a.stack
    );
    const b_stack = (
      /** @type {string} */
      b.stack
    );
    const stack2 = a_stack === b_stack ? `Occurred at:
${a_stack}` : `First occurrence at:
${a_stack}

Second occurrence at:
${b_stack}`;
    hydratable_clobbering(key2, stack2);
  }
}
function serialization_stack(root_stack, uneval_stack) {
  let out = "";
  if (root_stack) {
    out += root_stack + "\n";
  }
  if (uneval_stack) {
    out += "Caused by:\n" + uneval_stack + "\n";
  }
  return out || "<missing stack trace>";
}
var init_hydratable2 = __esm({
  "node_modules/svelte/src/internal/server/hydratable.js"() {
    init_flags();
    init_render_context();
    init_errors3();
    init_devalue();
    init_dev();
    init_esm_env();
    init_dev2();
  }
});

// node_modules/svelte/src/internal/server/blocks/snippet.js
function createRawSnippet2(fn) {
  return (renderer, ...args) => {
    var getters = (
      /** @type {Getters<Params>} */
      args.map((value) => () => value)
    );
    renderer.push(
      fn(...getters).render().trim()
    );
  };
}
var init_snippet2 = __esm({
  "node_modules/svelte/src/internal/server/blocks/snippet.js"() {
  }
});

// node_modules/svelte/src/index-server.js
var index_server_exports = {};
__export(index_server_exports, {
  afterUpdate: () => noop,
  beforeUpdate: () => noop,
  createContext: () => createContext2,
  createEventDispatcher: () => createEventDispatcher,
  createRawSnippet: () => createRawSnippet2,
  flushSync: () => noop,
  fork: () => fork2,
  getAbortSignal: () => getAbortSignal,
  getAllContexts: () => getAllContexts2,
  getContext: () => getContext2,
  hasContext: () => hasContext2,
  hydratable: () => hydratable2,
  hydrate: () => hydrate2,
  mount: () => mount2,
  onDestroy: () => onDestroy,
  onMount: () => noop,
  setContext: () => setContext2,
  settled: () => settled2,
  tick: () => tick2,
  unmount: () => unmount2,
  untrack: () => run
});
function onDestroy(fn) {
  /** @type {SSRContext} */
  ssr_context.r.on_destroy(fn);
}
function createEventDispatcher() {
  return noop;
}
function mount2() {
  lifecycle_function_unavailable("mount");
}
function hydrate2() {
  lifecycle_function_unavailable("hydrate");
}
function unmount2() {
  lifecycle_function_unavailable("unmount");
}
function fork2() {
  lifecycle_function_unavailable("fork");
}
async function tick2() {
}
async function settled2() {
}
var init_index_server = __esm({
  "node_modules/svelte/src/index-server.js"() {
    init_context2();
    init_utils();
    init_errors3();
    init_utils();
    init_abort_signal();
    init_context2();
    init_hydratable2();
    init_snippet2();
  }
});

// ../deps/live_svelte/priv/static/live_svelte.cjs.js
var require_live_svelte_cjs = __commonJS({
  "../deps/live_svelte/priv/static/live_svelte.cjs.js"(exports2, module2) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var live_svelte_exports = {};
    __export2(live_svelte_exports, {
      getHooks: () => getHooks,
      getRender: () => getRender2
    });
    module2.exports = __toCommonJS2(live_svelte_exports);
    function normalizeComponents(components) {
      if (!Array.isArray(components.default) || !Array.isArray(components.filenames)) return components;
      const normalized = {};
      for (const [index2, module22] of components.default.entries()) {
        const Component = module22.default;
        const name = components.filenames[index2].replace("../svelte/", "").replace(".svelte", "");
        normalized[name] = Component;
      }
      return normalized;
    }
    var import_server2 = (init_server2(), __toCommonJS(server_exports2));
    var import_svelte = (init_index_server(), __toCommonJS(index_server_exports));
    function getRender2(components) {
      components = normalizeComponents(components);
      return function r2(name, props, slots) {
        const snippets = Object.fromEntries(
          Object.entries(slots).map(([slotName, v]) => {
            const snippet2 = (0, import_svelte.createRawSnippet)((name2) => {
              return {
                render: () => v
              };
            });
            if (slotName === "default") return ["children", snippet2];
            else return [slotName, snippet2];
          })
        );
        return (0, import_server2.render)(components[name], { props: { ...props, ...snippets } });
      };
    }
    var $ = __toESM2((init_client(), __toCommonJS(client_exports)));
    var import_svelte2 = (init_index_server(), __toCommonJS(index_server_exports));
    function getAttributeJson(ref, attributeName) {
      const data = ref.el.getAttribute(attributeName);
      return data ? JSON.parse(data) : {};
    }
    function getSlots(ref) {
      let snippets = {};
      for (const slotName in getAttributeJson(ref, "data-slots")) {
        const base64 = getAttributeJson(ref, "data-slots")[slotName];
        const element2 = document.createElement("div");
        element2.innerHTML = atob(base64).trim();
        const snippet2 = (0, import_svelte2.createRawSnippet)((name) => {
          return { render: () => element2.outerHTML };
        });
        if (slotName === "default") snippets["children"] = snippet2;
        else snippets[slotName] = snippet2;
      }
      return snippets;
    }
    function getLiveJsonProps(ref) {
      const json = getAttributeJson(ref, "data-live-json");
      if (!Array.isArray(json)) return json;
      const liveJsonData = {};
      for (const liveJsonVariable of json) {
        const data = window[liveJsonVariable];
        if (data) liveJsonData[liveJsonVariable] = data;
      }
      return liveJsonData;
    }
    function getProps(ref) {
      return {
        ...getAttributeJson(ref, "data-props"),
        ...getLiveJsonProps(ref),
        ...getSlots(ref),
        live: ref
      };
    }
    function update_state(ref) {
      const newProps = getProps(ref);
      for (const key2 in newProps) {
        ref._instance.state[key2] = newProps[key2];
      }
    }
    function getHooks(components) {
      components = normalizeComponents(components);
      const SvelteHook = {
        mounted() {
          let state2 = $.proxy(getProps(this));
          const componentName = this.el.getAttribute("data-name");
          if (!componentName) throw new Error("Component name must be provided");
          const Component = components[componentName];
          if (!Component) throw new Error(`Unable to find ${componentName} component.`);
          for (const liveJsonElement of Object.keys(getAttributeJson(this, "data-live-json"))) {
            window.addEventListener(`${liveJsonElement}_initialized`, (_event) => update_state(this), false);
            window.addEventListener(`${liveJsonElement}_patched`, (_event) => update_state(this), false);
          }
          if (!this.el.hasAttribute("data-ssr")) {
            this.el.innerHTML = "";
          }
          const hydrateOrMount = this.el.hasAttribute("data-ssr") ? import_svelte2.hydrate : import_svelte2.mount;
          this._instance = hydrateOrMount(Component, { target: this.el, props: state2 });
          this._instance.state = state2;
        },
        updated() {
          update_state(this);
        },
        destroyed() {
          if (this._instance) window.addEventListener("phx:page-loading-stop", () => (0, import_svelte2.unmount)(this._instance), { once: true });
        }
      };
      return { SvelteHook };
    }
  }
});

// js/server.js
var server_exports3 = {};
__export(server_exports3, {
  render: () => render2
});
module.exports = __toCommonJS(server_exports3);

// import-glob:../svelte/**/*.svelte
var __exports = {};
__export(__exports, {
  default: () => __default,
  filenames: () => filenames
});

// svelte/AuthModal.svelte
var AuthModal_exports = {};
__export(AuthModal_exports, {
  default: () => AuthModal_default
});
init_server();
AuthModal[FILENAME] = "svelte/AuthModal.svelte";
function AuthModal($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { isOpen = false } = $$props;
      const providers = [
        {
          name: "Google",
          icon: "\u{1F50D}",
          path: "/auth/google",
          colorClass: "btn-neutral"
        },
        {
          name: "Twitter",
          icon: "\u{1D54F}",
          path: "/auth/twitter",
          colorClass: "btn-info"
        },
        {
          name: "Facebook",
          icon: "f",
          path: "/auth/facebook",
          colorClass: "btn-primary"
        }
      ];
      function handleOAuthLogin(providerPath) {
        window.location.href = providerPath;
      }
      function closeModal() {
        isOpen = false;
      }
      $$renderer2.push(`<dialog${attr_class("modal", void 0, { "modal-open": isOpen })}>`);
      push_element($$renderer2, "dialog", 34, 0);
      $$renderer2.push(`<div class="modal-box bg-base-200 max-w-md">`);
      push_element($$renderer2, "div", 35, 2);
      $$renderer2.push(`<form method="dialog">`);
      push_element($$renderer2, "form", 36, 4);
      $$renderer2.push(`<button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2" aria-label="Close">`);
      push_element($$renderer2, "button", 37, 6);
      $$renderer2.push(`\u2715</button>`);
      pop_element();
      $$renderer2.push(`</form>`);
      pop_element();
      $$renderer2.push(` <h3 class="font-bold text-2xl mb-2">`);
      push_element($$renderer2, "h3", 46, 4);
      $$renderer2.push(`Welcome Back</h3>`);
      pop_element();
      $$renderer2.push(` <p class="text-base-content/70 mb-6">`);
      push_element($$renderer2, "p", 47, 4);
      $$renderer2.push(`Sign in to save prompts, leave comments, and more</p>`);
      pop_element();
      $$renderer2.push(` <div class="flex flex-col gap-3">`);
      push_element($$renderer2, "div", 49, 4);
      $$renderer2.push(`<!--[-->`);
      const each_array = ensure_array_like(providers);
      for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
        let provider = each_array[$$index];
        $$renderer2.push(`<button${attr_class(`btn ${stringify(provider.colorClass)} btn-lg w-full justify-start gap-4`)}>`);
        push_element($$renderer2, "button", 51, 8);
        $$renderer2.push(`<span class="text-2xl">`);
        push_element($$renderer2, "span", 55, 10);
        $$renderer2.push(`${escape_html(provider.icon)}</span>`);
        pop_element();
        $$renderer2.push(` <span class="flex-1 text-left">`);
        push_element($$renderer2, "span", 56, 10);
        $$renderer2.push(`Continue with ${escape_html(provider.name)}</span>`);
        pop_element();
        $$renderer2.push(` <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
        push_element($$renderer2, "svg", 57, 10);
        $$renderer2.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7">`);
        push_element($$renderer2, "path", 64, 12);
        $$renderer2.push(`</path>`);
        pop_element();
        $$renderer2.push(`</svg>`);
        pop_element();
        $$renderer2.push(`</button>`);
        pop_element();
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
      $$renderer2.push(` <div class="mt-6 text-xs text-base-content/50 text-center">`);
      push_element($$renderer2, "div", 70, 4);
      $$renderer2.push(`By continuing, you agree to our Terms of Service and Privacy Policy</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <form method="dialog" class="modal-backdrop">`);
      push_element($$renderer2, "form", 74, 2);
      $$renderer2.push(`<button>`);
      push_element($$renderer2, "button", 75, 4);
      $$renderer2.push(`close</button>`);
      pop_element();
      $$renderer2.push(`</form>`);
      pop_element();
      $$renderer2.push(`</dialog>`);
      pop_element();
      bind_props($$props, { isOpen });
    },
    AuthModal
  );
}
AuthModal.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var AuthModal_default = AuthModal;

// svelte/CodeSnippetCard.svelte
var CodeSnippetCard_exports = {};
__export(CodeSnippetCard_exports, {
  default: () => CodeSnippetCard_default
});
init_server();
CodeSnippetCard[FILENAME] = "svelte/CodeSnippetCard.svelte";
function CodeSnippetCard($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { delay = 0 } = $$props;
      $$renderer2.push(`<div class="absolute hidden lg:block top-1/4 left-10 xl:left-32 w-64 bg-base-200/90 backdrop-blur-xl border border-base-300 shadow-[0_20px_40px_-15px_rgba(0,0,0,0.1)] rounded-2xl p-4 animate-float rotate-[-3deg]"${attr_style(`animation-delay: ${stringify(delay)}s`)}>`);
      push_element($$renderer2, "div", 5, 0);
      $$renderer2.push(`<div class="font-mono text-[10px] text-base-content/70 leading-relaxed">`);
      push_element($$renderer2, "div", 9, 2);
      $$renderer2.push(`<div class="flex gap-2 mb-2 border-b border-base-300 pb-2">`);
      push_element($$renderer2, "div", 10, 4);
      $$renderer2.push(`<div class="w-2 h-2 rounded-full bg-red-500">`);
      push_element($$renderer2, "div", 11, 6);
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="w-2 h-2 rounded-full bg-yellow-500">`);
      push_element($$renderer2, "div", 12, 6);
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="w-2 h-2 rounded-full bg-green-500">`);
      push_element($$renderer2, "div", 13, 6);
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="text-blue-400">`);
      push_element($$renderer2, "div", 15, 4);
      $$renderer2.push(`const <span class="text-yellow-200">`);
      push_element($$renderer2, "span", 16, 12);
      $$renderer2.push(`automate</span>`);
      pop_element();
      $$renderer2.push(` = <span class="text-purple-400">`);
      push_element($$renderer2, "span", 16, 60);
      $$renderer2.push(`async</span>`);
      pop_element();
      $$renderer2.push(` () => {</div>`);
      pop_element();
      $$renderer2.push(` <div class="pl-4">`);
      push_element($$renderer2, "div", 18, 4);
      $$renderer2.push(`await <span class="text-green-300">`);
      push_element($$renderer2, "span", 19, 12);
      $$renderer2.push(`n8n</span>`);
      pop_element();
      $$renderer2.push(`.trigger();</div>`);
      pop_element();
      $$renderer2.push(` <div class="pl-4">`);
      push_element($$renderer2, "div", 21, 4);
      $$renderer2.push(`return <span class="text-orange-300">`);
      push_element($$renderer2, "span", 22, 13);
      $$renderer2.push(`"Freedom"</span>`);
      pop_element();
      $$renderer2.push(`;</div>`);
      pop_element();
      $$renderer2.push(` <div>`);
      push_element($$renderer2, "div", 24, 4);
      $$renderer2.push(`}</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    CodeSnippetCard
  );
}
CodeSnippetCard.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var CodeSnippetCard_default = CodeSnippetCard;

// svelte/Counter.svelte
var Counter_exports = {};
__export(Counter_exports, {
  default: () => Counter_default
});
init_server();
Counter[FILENAME] = "svelte/Counter.svelte";
function Counter($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { count = 0, live } = $$props;
      function increment2() {
        live.pushEvent("increment", {});
      }
      function decrement() {
        live.pushEvent("decrement", {});
      }
      $$renderer2.push(`<div class="flex flex-col items-center gap-4 p-8">`);
      push_element($$renderer2, "div", 13, 0);
      $$renderer2.push(`<h2 class="text-3xl font-bold">`);
      push_element($$renderer2, "h2", 14, 2);
      $$renderer2.push(`Counter: ${escape_html(count)}</h2>`);
      pop_element();
      $$renderer2.push(` <div class="flex gap-2">`);
      push_element($$renderer2, "div", 16, 2);
      $$renderer2.push(`<button class="btn btn-error">`);
      push_element($$renderer2, "button", 17, 4);
      $$renderer2.push(`Decrement</button>`);
      pop_element();
      $$renderer2.push(` <button class="btn btn-primary">`);
      push_element($$renderer2, "button", 24, 4);
      $$renderer2.push(`Increment</button>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    Counter
  );
}
Counter.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var Counter_default = Counter;

// svelte/Navbar.svelte
var Navbar_exports = {};
__export(Navbar_exports, {
  default: () => Navbar_default
});
init_server();

// svelte/UserMenu.svelte
var UserMenu_exports = {};
__export(UserMenu_exports, {
  default: () => UserMenu_default
});
init_server();
UserMenu[FILENAME] = "svelte/UserMenu.svelte";
function UserMenu($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { currentUser } = $$props;
      let isOpen = false;
      function toggleMenu() {
        isOpen = !isOpen;
      }
      function closeMenu() {
        isOpen = false;
      }
      function handleClickOutside(event2) {
        if (!event2.target.closest(".dropdown")) {
          closeMenu();
        }
      }
      function handleLogout() {
        const form = document.createElement("form");
        form.method = "POST";
        form.action = "/auth/logout";
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
        if (csrfToken) {
          const csrfInput = document.createElement("input");
          csrfInput.type = "hidden";
          csrfInput.name = "_csrf_token";
          csrfInput.value = csrfToken;
          form.appendChild(csrfInput);
        }
        const methodInput = document.createElement("input");
        methodInput.type = "hidden";
        methodInput.name = "_method";
        methodInput.value = "DELETE";
        form.appendChild(methodInput);
        document.body.appendChild(form);
        form.submit();
      }
      $$renderer2.push(`<div${attr_class("dropdown dropdown-end", void 0, { "dropdown-open": isOpen })}>`);
      push_element($$renderer2, "div", 53, 0);
      $$renderer2.push(`<button class="btn btn-ghost btn-circle avatar online" aria-label="User menu">`);
      push_element($$renderer2, "button", 54, 2);
      if (currentUser.avatarUrl) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="w-10 rounded-full ring ring-primary ring-offset-base-100 ring-offset-2">`);
        push_element($$renderer2, "div", 60, 6);
        $$renderer2.push(`<img${attr("src", currentUser.avatarUrl)}${attr("alt", currentUser.name || currentUser.email)}/>`);
        push_element($$renderer2, "img", 61, 8);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
        $$renderer2.push(`<div class="w-10 h-10 rounded-full bg-primary flex items-center justify-center text-primary-content font-bold ring ring-primary ring-offset-base-100 ring-offset-2">`);
        push_element($$renderer2, "div", 67, 6);
        $$renderer2.push(`${escape_html(currentUser.name?.charAt(0).toUpperCase() || currentUser.email?.charAt(0).toUpperCase() || "U")}</div>`);
        pop_element();
      }
      $$renderer2.push(`<!--]--></button>`);
      pop_element();
      $$renderer2.push(` `);
      if (isOpen) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<ul class="menu dropdown-content bg-base-200 rounded-box z-[1] w-52 p-2 shadow-xl border border-base-300 mt-3">`);
        push_element($$renderer2, "ul", 74, 4);
        $$renderer2.push(`<li class="menu-title px-4 py-2">`);
        push_element($$renderer2, "li", 75, 6);
        $$renderer2.push(`<div class="flex flex-col">`);
        push_element($$renderer2, "div", 76, 8);
        $$renderer2.push(`<span class="font-semibold text-base-content">`);
        push_element($$renderer2, "span", 77, 10);
        $$renderer2.push(`${escape_html(currentUser.name || "User")}</span>`);
        pop_element();
        $$renderer2.push(` <span class="text-xs text-base-content/60">`);
        push_element($$renderer2, "span", 78, 10);
        $$renderer2.push(`${escape_html(currentUser.email)}</span>`);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
        $$renderer2.push(`</li>`);
        pop_element();
        $$renderer2.push(` <li>`);
        push_element($$renderer2, "li", 81, 6);
        $$renderer2.push(`<a href="/saved">`);
        push_element($$renderer2, "a", 82, 8);
        $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
        push_element($$renderer2, "svg", 83, 10);
        $$renderer2.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z">`);
        push_element($$renderer2, "path", 84, 12);
        $$renderer2.push(`</path>`);
        pop_element();
        $$renderer2.push(`</svg>`);
        pop_element();
        $$renderer2.push(` My Saved</a>`);
        pop_element();
        $$renderer2.push(`</li>`);
        pop_element();
        $$renderer2.push(` <li>`);
        push_element($$renderer2, "li", 89, 6);
        $$renderer2.push(`<button>`);
        push_element($$renderer2, "button", 90, 8);
        $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
        push_element($$renderer2, "svg", 91, 10);
        $$renderer2.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1">`);
        push_element($$renderer2, "path", 92, 12);
        $$renderer2.push(`</path>`);
        pop_element();
        $$renderer2.push(`</svg>`);
        pop_element();
        $$renderer2.push(` Sign Out</button>`);
        pop_element();
        $$renderer2.push(`</li>`);
        pop_element();
        $$renderer2.push(`</ul>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
    },
    UserMenu
  );
}
UserMenu.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var UserMenu_default = UserMenu;

// svelte/Navbar.svelte
Navbar[FILENAME] = "svelte/Navbar.svelte";
function Navbar($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { currentPage = "", currentUser = null } = $$props;
      let isScrolled = false;
      let isMenuOpen = false;
      let showAuthModal = false;
      let dropdownRef;
      function handleScroll() {
        isScrolled = window.scrollY > 20;
      }
      function toggleMenu() {
        isMenuOpen = !isMenuOpen;
      }
      function closeMenu() {
        isMenuOpen = false;
      }
      function openAuthModal() {
        showAuthModal = true;
      }
      function handleClickOutside(event2) {
        if (dropdownRef && !dropdownRef.contains(event2.target)) {
          closeMenu();
        }
      }
      let $$settled = true;
      let $$inner_renderer;
      function $$render_inner($$renderer3) {
        $$renderer3.push(`<div${attr_class(`navbar fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${isScrolled ? "bg-base-100/80 backdrop-blur-md border-b border-base-300" : "bg-transparent"}`)}>`);
        push_element($$renderer3, "div", 46, 0);
        $$renderer3.push(`<div class="navbar-start">`);
        push_element($$renderer3, "div", 51, 2);
        $$renderer3.push(`<div${attr_class("dropdown lg:hidden", void 0, { "dropdown-open": isMenuOpen })}>`);
        push_element($$renderer3, "div", 53, 4);
        $$renderer3.push(`<button aria-label="Toggle navigation menu"${attr("aria-expanded", isMenuOpen)} aria-controls="mobile-nav" class="btn btn-ghost">`);
        push_element($$renderer3, "button", 54, 6);
        $$renderer3.push(`<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
        push_element($$renderer3, "svg", 61, 8);
        $$renderer3.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16">`);
        push_element($$renderer3, "path", 62, 10);
        $$renderer3.push(`</path>`);
        pop_element();
        $$renderer3.push(`</svg>`);
        pop_element();
        $$renderer3.push(`</button>`);
        pop_element();
        $$renderer3.push(` `);
        if (isMenuOpen) {
          $$renderer3.push("<!--[-->");
          $$renderer3.push(`<ul id="mobile-nav" class="menu menu-sm dropdown-content bg-base-100 rounded-box z-[1] mt-3 w-52 p-2 shadow">`);
          push_element($$renderer3, "ul", 66, 8);
          $$renderer3.push(`<li>`);
          push_element($$renderer3, "li", 67, 10);
          $$renderer3.push(`<a href="/"${attr_class("", void 0, { "active": currentPage === "home" })}>`);
          push_element($$renderer3, "a", 67, 14);
          $$renderer3.push(`Home</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 68, 10);
          $$renderer3.push(`<a href="/references?category=coding">`);
          push_element($$renderer3, "a", 68, 14);
          $$renderer3.push(`Coding</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 69, 10);
          $$renderer3.push(`<a href="/references?category=ai">`);
          push_element($$renderer3, "a", 69, 14);
          $$renderer3.push(`AI</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 70, 10);
          $$renderer3.push(`<a href="/references?category=n8n">`);
          push_element($$renderer3, "a", 70, 14);
          $$renderer3.push(`n8n</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 71, 10);
          $$renderer3.push(`<a href="/references?category=tools">`);
          push_element($$renderer3, "a", 71, 14);
          $$renderer3.push(`Tools</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(` <li>`);
          push_element($$renderer3, "li", 72, 10);
          $$renderer3.push(`<a href="/references"${attr_class("", void 0, { "active": currentPage === "references" })}>`);
          push_element($$renderer3, "a", 72, 14);
          $$renderer3.push(`Prompts</a>`);
          pop_element();
          $$renderer3.push(`</li>`);
          pop_element();
          $$renderer3.push(`</ul>`);
          pop_element();
        } else {
          $$renderer3.push("<!--[!-->");
        }
        $$renderer3.push(`<!--]--></div>`);
        pop_element();
        $$renderer3.push(` <a href="/" class="btn btn-ghost text-xl font-semibold tracking-tight">`);
        push_element($$renderer3, "a", 78, 4);
        $$renderer3.push(`UrielM<span class="text-base-content/50">`);
        push_element($$renderer3, "span", 79, 12);
        $$renderer3.push(`.dev</span>`);
        pop_element();
        $$renderer3.push(`</a>`);
        pop_element();
        $$renderer3.push(`</div>`);
        pop_element();
        $$renderer3.push(` <div class="navbar-center hidden lg:flex">`);
        push_element($$renderer3, "div", 84, 2);
        $$renderer3.push(`<div class="flex items-center gap-8">`);
        push_element($$renderer3, "div", 85, 4);
        $$renderer3.push(`<a href="/"${attr_class(`font-medium transition-colors ${currentPage === "home" ? "text-primary font-bold" : "text-base-content hover:text-primary"}`)}>`);
        push_element($$renderer3, "a", 86, 6);
        $$renderer3.push(`Home</a>`);
        pop_element();
        $$renderer3.push(` <a href="/references?category=coding" class="font-medium text-base-content hover:text-primary transition-colors">`);
        push_element($$renderer3, "a", 92, 6);
        $$renderer3.push(`Coding</a>`);
        pop_element();
        $$renderer3.push(` <a href="/references?category=ai" class="font-medium text-base-content hover:text-primary transition-colors">`);
        push_element($$renderer3, "a", 98, 6);
        $$renderer3.push(`AI</a>`);
        pop_element();
        $$renderer3.push(` <a href="/references?category=n8n" class="font-medium text-base-content hover:text-primary transition-colors">`);
        push_element($$renderer3, "a", 104, 6);
        $$renderer3.push(`n8n</a>`);
        pop_element();
        $$renderer3.push(` <a href="/references?category=tools" class="font-medium text-base-content hover:text-primary transition-colors">`);
        push_element($$renderer3, "a", 110, 6);
        $$renderer3.push(`Tools</a>`);
        pop_element();
        $$renderer3.push(` <a href="/references"${attr_class(`font-medium transition-colors ${currentPage === "references" ? "text-primary font-bold" : "text-base-content hover:text-primary"}`)}>`);
        push_element($$renderer3, "a", 116, 6);
        $$renderer3.push(`Prompts</a>`);
        pop_element();
        $$renderer3.push(`</div>`);
        pop_element();
        $$renderer3.push(`</div>`);
        pop_element();
        $$renderer3.push(` <div class="navbar-end gap-2">`);
        push_element($$renderer3, "div", 126, 2);
        if (currentUser) {
          $$renderer3.push("<!--[-->");
          UserMenu_default($$renderer3, { currentUser });
        } else {
          $$renderer3.push("<!--[!-->");
          $$renderer3.push(`<button class="btn btn-sm btn-primary rounded-full px-6">`);
          push_element($$renderer3, "button", 130, 6);
          $$renderer3.push(`Sign In</button>`);
          pop_element();
        }
        $$renderer3.push(`<!--]--></div>`);
        pop_element();
        $$renderer3.push(`</div>`);
        pop_element();
        $$renderer3.push(` `);
        AuthModal_default($$renderer3, {
          get isOpen() {
            return showAuthModal;
          },
          set isOpen($$value) {
            showAuthModal = $$value;
            $$settled = false;
          }
        });
        $$renderer3.push(`<!---->`);
      }
      do {
        $$settled = true;
        $$inner_renderer = $$renderer2.copy();
        $$render_inner($$inner_renderer);
      } while (!$$settled);
      $$renderer2.subsume($$inner_renderer);
    },
    Navbar
  );
}
Navbar.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var Navbar_default = Navbar;

// svelte/SubNav.svelte
var SubNav_exports = {};
__export(SubNav_exports, {
  default: () => SubNav_default
});
init_server();
SubNav[FILENAME] = "svelte/SubNav.svelte";
function SubNav($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { activeFilter = "all", categories = [], live } = $$props;
      function selectFilter(filter) {
        live.pushEvent("filter_changed", { category: filter });
      }
      $$renderer2.push(`<div class="bg-base-100 border-b border-base-300">`);
      push_element($$renderer2, "div", 9, 0);
      $$renderer2.push(`<div class="container mx-auto px-4">`);
      push_element($$renderer2, "div", 10, 2);
      $$renderer2.push(`<div class="tabs tabs-bordered overflow-x-auto scrollbar-hide" aria-label="Reference filters" role="tablist">`);
      push_element($$renderer2, "div", 11, 4);
      $$renderer2.push(`<button type="button" role="tab"${attr("aria-selected", activeFilter === "all")}${attr_class(`tab tab-sm sm:tab-md whitespace-nowrap transition-colors duration-200 hover:text-primary ${activeFilter === "all" ? "tab-active" : ""}`)}>`);
      push_element($$renderer2, "button", 12, 6);
      $$renderer2.push(`All</button>`);
      pop_element();
      $$renderer2.push(` <!--[-->`);
      const each_array = ensure_array_like(categories);
      for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
        let category = each_array[$$index];
        $$renderer2.push(`<button type="button" role="tab"${attr("aria-selected", activeFilter === category)}${attr_class(`tab tab-sm sm:tab-md whitespace-nowrap capitalize transition-colors duration-200 hover:text-primary ${activeFilter === category ? "tab-active" : ""}`)}>`);
        push_element($$renderer2, "button", 22, 8);
        $$renderer2.push(`${escape_html(category)}</button>`);
        pop_element();
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    SubNav
  );
}
SubNav.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var SubNav_default = SubNav;

// svelte/ThemeSelector.svelte
var ThemeSelector_exports = {};
__export(ThemeSelector_exports, {
  default: () => ThemeSelector_default
});
init_server();
ThemeSelector[FILENAME] = "svelte/ThemeSelector.svelte";
var $$css = {
  hash: "svelte-k618ps",
  code: "\n  .theme-selector.svelte-k618ps {\n    user-select: none;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGhlbWVTZWxlY3Rvci5zdmVsdGUiLCJzb3VyY2VzIjpbIlRoZW1lU2VsZWN0b3Iuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGNvbnN0IHRoZW1lcyA9IFtcbiAgICB7IHZhbHVlOiAnbGlnaHQnLCBsYWJlbDogJ0xpZ2h0JywgaWNvbjogJ+KYgO+4jycgfSxcbiAgICB7IHZhbHVlOiAnZGFyaycsIGxhYmVsOiAnRGFyaycsIGljb246ICfwn4yZJyB9LFxuICAgIHsgdmFsdWU6ICdkcmFjdWxhJywgbGFiZWw6ICdEcmFjdWxhJywgaWNvbjogJ/Cfp5snIH0sXG4gICAgeyB2YWx1ZTogJ3N5bnRod2F2ZScsIGxhYmVsOiAnU3ludGh3YXZlJywgaWNvbjogJ/CfjIYnIH0sXG4gICAgeyB2YWx1ZTogJ2J1c2luZXNzJywgbGFiZWw6ICdCdXNpbmVzcycsIGljb246ICfwn5K8JyB9LFxuICAgIHsgdmFsdWU6ICdkaW0nLCBsYWJlbDogJ0RpbScsIGljb246ICfwn4yRJyB9XG4gIF1cblxuICBsZXQgY3VycmVudFRoZW1lID0gJHN0YXRlKCdkYXJrJylcbiAgbGV0IGlzT3BlbiA9ICRzdGF0ZShmYWxzZSlcblxuICBmdW5jdGlvbiBhcHBseVRoZW1lKHRoZW1lKSB7XG4gICAgY3VycmVudFRoZW1lID0gdGhlbWVcbiAgICBpZiAodGhlbWUgPT09ICdzeXN0ZW0nKSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRoZW1lJylcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwaHg6dGhlbWUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJywgdGhlbWUpXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgc3RvcmFnZSBrZXkgYXMgUGhvZW5peCArIG90aGVyIHRvZ2dsZXNcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwaHg6dGhlbWUnLCB0aGVtZSlcbiAgICB9XG4gICAgLy8gTm90aWZ5IGxpc3RlbmVycyAoZS5nLiwgUGhvZW5peCBoZWFkIHNjcmlwdClcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3BoeDpzZXQtdGhlbWUnLCB7IGRldGFpbDogeyB0aGVtZSB9IH0pKVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0VGhlbWUodGhlbWUpIHtcbiAgICBhcHBseVRoZW1lKHRoZW1lKVxuICAgIGlzT3BlbiA9IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVEcm9wZG93bigpIHtcbiAgICBpc09wZW4gPSAhaXNPcGVuXG4gIH1cblxuICAvLyBDbG9zZSBkcm9wZG93biB3aGVuIGNsaWNraW5nIG91dHNpZGVcbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQuY2xvc2VzdCgnLnRoZW1lLXNlbGVjdG9yJykpIHtcbiAgICAgIGlzT3BlbiA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3luYyBmcm9tIHBhZ2UvaGVhZCBpbml0aWFsaXphdGlvblxuICAgIGNvbnN0IHNhdmVkVGhlbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGh4OnRoZW1lJykgfHwgJ3N5c3RlbSdcbiAgICBpZiAoc2F2ZWRUaGVtZSA9PT0gJ3N5c3RlbScpIHtcbiAgICAgIGN1cnJlbnRUaGVtZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKSB8fCAnbGlnaHQnXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRUaGVtZSA9IHNhdmVkVGhlbWVcbiAgICB9XG5cbiAgICAvLyBLZWVwIGluIHN5bmMgd2l0aCBvdGhlciBjb250cm9scyAoTGF5b3V0cy50aGVtZV90b2dnbGUsIG90aGVyIHRhYnMpXG4gICAgY29uc3Qgc3RvcmFnZUhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSAncGh4OnRoZW1lJykge1xuICAgICAgICBjb25zdCBuZXh0ID0gZS5uZXdWYWx1ZSB8fCAnc3lzdGVtJ1xuICAgICAgICBjdXJyZW50VGhlbWUgPSBuZXh0ID09PSAnc3lzdGVtJyA/IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJykgfHwgJ2xpZ2h0JykgOiBuZXh0XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRoZW1lRXZlbnRIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLmRldGFpbD8udGhlbWUgPz8gZS50YXJnZXQ/LmRhdGFzZXQ/LnBoeFRoZW1lID8/ICdzeXN0ZW0nXG4gICAgICBjdXJyZW50VGhlbWUgPSBuZXh0ID09PSAnc3lzdGVtJyA/IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJykgfHwgJ2xpZ2h0JykgOiBuZXh0XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGlja091dHNpZGUpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBzdG9yYWdlSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGh4OnNldC10aGVtZScsIHRoZW1lRXZlbnRIYW5kbGVyKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrT3V0c2lkZSlcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgc3RvcmFnZUhhbmRsZXIpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGh4OnNldC10aGVtZScsIHRoZW1lRXZlbnRIYW5kbGVyKVxuICAgIH1cbiAgfSlcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwidGhlbWUtc2VsZWN0b3IgcmVsYXRpdmVcIj5cbiAgPGJ1dHRvblxuICAgIG9uY2xpY2s9e3RvZ2dsZURyb3Bkb3dufVxuICAgIGNsYXNzPVwiYnRuIGJ0bi1naG9zdCBidG4tc20gZ2FwLTJcIlxuICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgdGhlbWVcIlxuICA+XG4gICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LWxnXCI+e3RoZW1lcy5maW5kKHQgPT4gdC52YWx1ZSA9PT0gY3VycmVudFRoZW1lKT8uaWNvbiB8fCAn8J+MmSd9PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiaGlkZGVuIG1kOmlubGluZVwiPlRoZW1lPC9zcGFuPlxuICAgIDxzdmdcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgY2xhc3M9XCJoLTQgdy00IHRyYW5zaXRpb24tdHJhbnNmb3JtIHtpc09wZW4gPyAncm90YXRlLTE4MCcgOiAnJ31cIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgID5cbiAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE5IDlsLTcgNy03LTdcIiAvPlxuICAgIDwvc3ZnPlxuICA8L2J1dHRvbj5cblxuICB7I2lmIGlzT3Blbn1cbiAgICA8ZGl2IGNsYXNzPVwiYWJzb2x1dGUgcmlnaHQtMCBtdC0yIHctNDggYmctYmFzZS0yMDAgcm91bmRlZC1sZyBzaGFkb3cteGwgYm9yZGVyIGJvcmRlci1iYXNlLTMwMCB6LTUwXCI+XG4gICAgICA8dWwgY2xhc3M9XCJtZW51IHAtMlwiPlxuICAgICAgICB7I2VhY2ggdGhlbWVzIGFzIHRoZW1lfVxuICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgb25jbGljaz17KCkgPT4gc2VsZWN0VGhlbWUodGhlbWUudmFsdWUpfVxuICAgICAgICAgICAgICBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zIHtjdXJyZW50VGhlbWUgPT09IHRoZW1lLnZhbHVlID8gJ2FjdGl2ZSBiZy1wcmltYXJ5IHRleHQtcHJpbWFyeS1jb250ZW50JyA6ICcnfVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC1sZ1wiPnt0aGVtZS5pY29ufTwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4+e3RoZW1lLmxhYmVsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgeyNpZiBjdXJyZW50VGhlbWUgPT09IHRoZW1lLnZhbHVlfVxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoLTQgdy00IG1sLWF1dG9cIlxuICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUgMTNsNCA0TDE5IDdcIiAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgey9lYWNofVxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgey9pZn1cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC50aGVtZS1zZWxlY3RvciB7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQTZIQSxFQUFFLDZCQUFlLENBQUM7QUFDbEIsSUFBSSxpQkFBaUI7QUFDckIiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function ThemeSelector($$renderer, $$props) {
  $$renderer.global.css.add($$css);
  $$renderer.component(
    ($$renderer2) => {
      const themes = [
        { value: "light", label: "Light", icon: "\u2600\uFE0F" },
        { value: "dark", label: "Dark", icon: "\u{1F319}" },
        { value: "dracula", label: "Dracula", icon: "\u{1F9DB}" },
        { value: "synthwave", label: "Synthwave", icon: "\u{1F306}" },
        { value: "business", label: "Business", icon: "\u{1F4BC}" },
        { value: "dim", label: "Dim", icon: "\u{1F311}" }
      ];
      let currentTheme = "dark";
      let isOpen = false;
      function applyTheme(theme) {
        currentTheme = theme;
        if (theme === "system") {
          document.documentElement.removeAttribute("data-theme");
          localStorage.removeItem("phx:theme");
        } else {
          document.documentElement.setAttribute("data-theme", theme);
          localStorage.setItem("phx:theme", theme);
        }
        window.dispatchEvent(new CustomEvent("phx:set-theme", { detail: { theme } }));
      }
      function selectTheme(theme) {
        applyTheme(theme);
        isOpen = false;
      }
      function toggleDropdown() {
        isOpen = !isOpen;
      }
      function handleClickOutside(event2) {
        if (!event2.target.closest(".theme-selector")) {
          isOpen = false;
        }
      }
      $$renderer2.push(`<div class="theme-selector relative svelte-k618ps">`);
      push_element($$renderer2, "div", 76, 0);
      $$renderer2.push(`<button class="btn btn-ghost btn-sm gap-2" aria-label="Select theme">`);
      push_element($$renderer2, "button", 77, 2);
      $$renderer2.push(`<span class="text-lg">`);
      push_element($$renderer2, "span", 82, 4);
      $$renderer2.push(`${escape_html(
        // Sync from page/head initialization
        // Keep in sync with other controls (Layouts.theme_toggle, other tabs)
        themes.find((t) => t.value === currentTheme)?.icon || "\u{1F319}"
      )}</span>`);
      pop_element();
      $$renderer2.push(` <span class="hidden md:inline">`);
      push_element($$renderer2, "span", 83, 4);
      $$renderer2.push(`Theme</span>`);
      pop_element();
      $$renderer2.push(` <svg xmlns="http://www.w3.org/2000/svg"${attr_class(`h-4 w-4 transition-transform ${stringify(isOpen ? "rotate-180" : "")}`)} fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
      push_element($$renderer2, "svg", 84, 4);
      $$renderer2.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">`);
      push_element($$renderer2, "path", 91, 6);
      $$renderer2.push(`</path>`);
      pop_element();
      $$renderer2.push(`</svg>`);
      pop_element();
      $$renderer2.push(`</button>`);
      pop_element();
      $$renderer2.push(` `);
      if (isOpen) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<div class="absolute right-0 mt-2 w-48 bg-base-200 rounded-lg shadow-xl border border-base-300 z-50">`);
        push_element($$renderer2, "div", 96, 4);
        $$renderer2.push(`<ul class="menu p-2">`);
        push_element($$renderer2, "ul", 97, 6);
        $$renderer2.push(`<!--[-->`);
        const each_array = ensure_array_like(themes);
        for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
          let theme = each_array[$$index];
          $$renderer2.push(`<li>`);
          push_element($$renderer2, "li", 99, 10);
          $$renderer2.push(`<button${attr_class(`flex items-center gap-3 ${stringify(currentTheme === theme.value ? "active bg-primary text-primary-content" : "")}`)}>`);
          push_element($$renderer2, "button", 100, 12);
          $$renderer2.push(`<span class="text-lg">`);
          push_element($$renderer2, "span", 104, 14);
          $$renderer2.push(`${escape_html(theme.icon)}</span>`);
          pop_element();
          $$renderer2.push(` <span>`);
          push_element($$renderer2, "span", 105, 14);
          $$renderer2.push(`${escape_html(theme.label)}</span>`);
          pop_element();
          $$renderer2.push(` `);
          if (currentTheme === theme.value) {
            $$renderer2.push("<!--[-->");
            $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">`);
            push_element($$renderer2, "svg", 107, 16);
            $$renderer2.push(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7">`);
            push_element($$renderer2, "path", 114, 18);
            $$renderer2.push(`</path>`);
            pop_element();
            $$renderer2.push(`</svg>`);
            pop_element();
          } else {
            $$renderer2.push("<!--[!-->");
          }
          $$renderer2.push(`<!--]--></button>`);
          pop_element();
          $$renderer2.push(`</li>`);
          pop_element();
        }
        $$renderer2.push(`<!--]--></ul>`);
        pop_element();
        $$renderer2.push(`</div>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
      }
      $$renderer2.push(`<!--]--></div>`);
      pop_element();
    },
    ThemeSelector
  );
}
ThemeSelector.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var ThemeSelector_default = ThemeSelector;

// svelte/ThemeToggle.svelte
var ThemeToggle_exports = {};
__export(ThemeToggle_exports, {
  default: () => ThemeToggle_default
});
init_server();
ThemeToggle[FILENAME] = "svelte/ThemeToggle.svelte";
function ThemeToggle($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let currentTheme = "light";
      function toggleTheme() {
        const newTheme = currentTheme === "light" ? "dark" : "light";
        currentTheme = newTheme;
        document.documentElement.setAttribute("data-theme", newTheme);
        localStorage.setItem("phx:theme", newTheme);
        window.dispatchEvent(new CustomEvent("phx:set-theme", { detail: { theme: newTheme } }));
      }
      $$renderer2.push(`<button class="btn btn-ghost btn-circle btn-sm" aria-label="Toggle theme">`);
      push_element($$renderer2, "button", 28, 0);
      if (
        // Get initial theme
        currentTheme === "light"
      ) {
        $$renderer2.push("<!--[-->");
        $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">`);
        push_element($$renderer2, "svg", 35, 4);
        $$renderer2.push(`<path fill-rule="evenodd" d="M7.455 2.004a.75.75 0 01.26.77 7 7 0 009.958 7.967.75.75 0 011.067.853A8.5 8.5 0 116.647 1.921a.75.75 0 01.808.083z" clip-rule="evenodd">`);
        push_element($$renderer2, "path", 36, 6);
        $$renderer2.push(`</path>`);
        pop_element();
        $$renderer2.push(`</svg>`);
        pop_element();
      } else {
        $$renderer2.push("<!--[!-->");
        $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">`);
        push_element($$renderer2, "svg", 40, 4);
        $$renderer2.push(`<path d="M10 2a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 2zM10 15a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 0110 15zM10 7a3 3 0 100 6 3 3 0 000-6zM15.657 5.404a.75.75 0 10-1.06-1.06l-1.061 1.06a.75.75 0 001.06 1.06l1.06-1.06zM6.464 14.596a.75.75 0 10-1.06-1.06l-1.06 1.06a.75.75 0 001.06 1.06l1.06-1.06zM18 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0118 10zM5 10a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 015 10zM14.596 15.657a.75.75 0 001.06-1.06l-1.06-1.061a.75.75 0 10-1.06 1.06l1.06 1.06zM5.404 6.464a.75.75 0 001.06-1.06l-1.06-1.06a.75.75 0 10-1.061 1.06l1.06 1.06z">`);
        push_element($$renderer2, "path", 41, 6);
        $$renderer2.push(`</path>`);
        pop_element();
        $$renderer2.push(`</svg>`);
        pop_element();
      }
      $$renderer2.push(`<!--]--></button>`);
      pop_element();
    },
    ThemeToggle
  );
}
ThemeToggle.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var ThemeToggle_default = ThemeToggle;

// svelte/WorkflowStatusCard.svelte
var WorkflowStatusCard_exports = {};
__export(WorkflowStatusCard_exports, {
  default: () => WorkflowStatusCard_default
});
init_server();
WorkflowStatusCard[FILENAME] = "svelte/WorkflowStatusCard.svelte";
function WorkflowStatusCard($$renderer, $$props) {
  $$renderer.component(
    ($$renderer2) => {
      let { delay = 0 } = $$props;
      $$renderer2.push(`<div class="absolute hidden lg:block bottom-20 right-10 xl:right-32 w-auto bg-base-100/40 backdrop-blur-xl border border-base-300/50 shadow-[0_20px_40px_-15px_rgba(0,0,0,0.1)] rounded-2xl p-4 animate-float rotate-[3deg]"${attr_style(`animation-delay: ${stringify(delay)}s`)}>`);
      push_element($$renderer2, "div", 5, 0);
      $$renderer2.push(`<div class="flex items-center space-x-3 pr-2">`);
      push_element($$renderer2, "div", 9, 2);
      $$renderer2.push(`<div class="w-10 h-10 rounded-xl bg-[#EA4B71] flex items-center justify-center text-white shadow-lg shadow-pink-500/20">`);
      push_element($$renderer2, "div", 10, 4);
      $$renderer2.push(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">`);
      push_element($$renderer2, "svg", 11, 6);
      $$renderer2.push(`<path fill-rule="evenodd" d="M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm1.23-3.723a.75.75 0 00.219-.53V2.929a.75.75 0 00-1.5 0V5.36l-.31-.31A7 7 0 003.239 8.188a.75.75 0 101.448.389A5.5 5.5 0 0113.89 6.11l.311.31h-2.432a.75.75 0 000 1.5h4.243a.75.75 0 00.53-.219z" clip-rule="evenodd">`);
      push_element($$renderer2, "path", 12, 8);
      $$renderer2.push(`</path>`);
      pop_element();
      $$renderer2.push(`</svg>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(` <div class="text-left">`);
      push_element($$renderer2, "div", 15, 4);
      $$renderer2.push(`<div class="text-xs text-base-content/60 font-medium">`);
      push_element($$renderer2, "div", 16, 6);
      $$renderer2.push(`Active Workflow</div>`);
      pop_element();
      $$renderer2.push(` <div class="text-sm font-bold text-base-content">`);
      push_element($$renderer2, "div", 17, 6);
      $$renderer2.push(`Lead Gen Bot \xB7 Running</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
      $$renderer2.push(`</div>`);
      pop_element();
    },
    WorkflowStatusCard
  );
}
WorkflowStatusCard.render = function() {
  throw new Error("Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information");
};
var WorkflowStatusCard_default = WorkflowStatusCard;

// import-glob:../svelte/**/*.svelte
var modules = [AuthModal_exports, CodeSnippetCard_exports, Counter_exports, Navbar_exports, SubNav_exports, ThemeSelector_exports, ThemeToggle_exports, UserMenu_exports, WorkflowStatusCard_exports];
var __default = modules;
var filenames = ["../svelte/AuthModal.svelte", "../svelte/CodeSnippetCard.svelte", "../svelte/Counter.svelte", "../svelte/Navbar.svelte", "../svelte/SubNav.svelte", "../svelte/ThemeSelector.svelte", "../svelte/ThemeToggle.svelte", "../svelte/UserMenu.svelte", "../svelte/WorkflowStatusCard.svelte"];

// js/server.js
var import_live_svelte = __toESM(require_live_svelte_cjs());
var render2 = (0, import_live_svelte.getRender)(__exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  render
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2NvbnN0YW50cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvZXNjYXBpbmcuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9hdHRyaWJ1dGVzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9lc20tZW52L2ZhbHNlLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZXNtLWVudi90cnVlLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZXNtLWVudi9pbmRleC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2NvbnN0YW50cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvc2hhcmVkL2Vycm9ycy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Vycm9ycy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3dhcm5pbmdzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2h5ZHJhdGlvbi5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZXF1YWxpdHkuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2ZsYWdzL2luZGV4LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvd2FybmluZ3MuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9jbG9uZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi90cmFjaW5nLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvZGV2LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS90YXNrLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZXJyb3ItaGFuZGxpbmcuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2JhdGNoLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9yZWFjdGl2aXR5L2NyZWF0ZS1zdWJzY3JpYmVyLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvZWFjaC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvYXN5bmMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zb3VyY2VzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcHJveHkuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvZXF1YWxpdHkuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vb3BlcmF0aW9ucy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9taXNjLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NoYXJlZC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZWZmZWN0cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2xlZ2FjeS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2F0dGFjaG1lbnRzL2luZGV4LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy91dGlscy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi9hc3NpZ24uanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvY3NzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2VsZW1lbnRzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2V2ZW50cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9yZWNvbmNpbGVyLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL3RlbXBsYXRlLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVuZGVyLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2htci5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi9vd25lcnNoaXAuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvbGVnYWN5LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2luc3BlY3QuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2FzeW5jLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L3ZhbGlkYXRpb24uanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2JyYW5jaGVzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9hd2FpdC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvaWYuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2tleS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvY3NzLXByb3BzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9odG1sLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbG90LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdmFsaWRhdGUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3NuaXBwZXQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1jb21wb25lbnQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1lbGVtZW50LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zdmVsdGUtaGVhZC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9jc3MuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYWN0aW9ucy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9hdHRhY2htZW50cy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9jbGFzcy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9zdHlsZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zZWxlY3QuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYXR0cmlidXRlcy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3RpbWluZy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2xvb3AuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvdHJhbnNpdGlvbnMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvZG9jdW1lbnQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvaW5wdXQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvbWVkaWEuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvbmF2aWdhdG9yLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3Byb3BzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NpemUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvdGhpcy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy91bml2ZXJzYWwuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3Mvd2luZG93LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2xlZ2FjeS9ldmVudC1tb2RpZmllcnMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vbGVnYWN5L2xpZmVjeWNsZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbWlzYy5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvc2hhcmVkL2luZGV4LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zdG9yZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvcHJvcHMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC92YWxpZGF0ZS5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvbGVnYWN5L2xlZ2FjeS1jbGllbnQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvY3VzdG9tLWVsZW1lbnQuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvY29uc29sZS1sb2cuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2h5ZHJhdGFibGUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2luZGV4LWNsaWVudC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvdXRpbHMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9oeWRyYXRpb24uanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9hYm9ydC1zaWduYWwuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9lcnJvcnMuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9jb250ZXh0LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvd2FybmluZ3MuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9yZW5kZXItY29udGV4dC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvc2VydmVyL3JlbmRlcmVyLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvYmxvY2tzL2h0bWwuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2h0bWwtdHJlZS12YWxpZGF0aW9uLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvZGV2LmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zZXJ2ZXIvaW5kZXguanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NlcnZlci9pbmRleC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2RldmFsdWUvc3JjL3V0aWxzLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGV2YWx1ZS9zcmMvdW5ldmFsLmpzIiwgIi4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvZGV2YWx1ZS9pbmRleC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvc2VydmVyL2h5ZHJhdGFibGUuanMiLCAiLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NlcnZlci9ibG9ja3Mvc25pcHBldC5qcyIsICIuLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW5kZXgtc2VydmVyLmpzIiwgIi4uLy4uL2RlcHMvbGl2ZV9zdmVsdGUvYXNzZXRzL2pzL2xpdmVfc3ZlbHRlL2luZGV4LmpzIiwgIi4uLy4uL2RlcHMvbGl2ZV9zdmVsdGUvYXNzZXRzL2pzL2xpdmVfc3ZlbHRlL3V0aWxzLmpzIiwgIi4uLy4uL2RlcHMvbGl2ZV9zdmVsdGUvYXNzZXRzL2pzL2xpdmVfc3ZlbHRlL3JlbmRlci5qcyIsICIuLi8uLi9kZXBzL2xpdmVfc3ZlbHRlL2Fzc2V0cy9qcy9saXZlX3N2ZWx0ZS9ob29rcy5zdmVsdGUuanMiLCAiLi4vLi4vYXNzZXRzL2pzL3NlcnZlci5qcyIsICJpbXBvcnQtZ2xvYjouLi9zdmVsdGUvKiovKi5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL3N2ZWx0ZS9BdXRoTW9kYWwuc3ZlbHRlIiwgIi4uLy4uL2Fzc2V0cy9zdmVsdGUvQ29kZVNuaXBwZXRDYXJkLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL0NvdW50ZXIuc3ZlbHRlIiwgIi4uLy4uL2Fzc2V0cy9zdmVsdGUvVXNlck1lbnUuc3ZlbHRlIiwgIi4uLy4uL2Fzc2V0cy9zdmVsdGUvTmF2YmFyLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL1N1Yk5hdi5zdmVsdGUiLCAiLi4vLi4vYXNzZXRzL3N2ZWx0ZS9UaGVtZVNlbGVjdG9yLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL1RoZW1lVG9nZ2xlLnN2ZWx0ZSIsICIuLi8uLi9hc3NldHMvc3ZlbHRlL1dvcmtmbG93U3RhdHVzQ2FyZC5zdmVsdGUiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCBjb25zdCBFQUNIX0lURU1fUkVBQ1RJVkUgPSAxO1xuZXhwb3J0IGNvbnN0IEVBQ0hfSU5ERVhfUkVBQ1RJVkUgPSAxIDw8IDE7XG4vKiogU2VlIEVhY2hCbG9jayBpbnRlcmZhY2UgbWV0YWRhdGEuaXNfY29udHJvbGxlZCBmb3IgYW4gZXhwbGFuYXRpb24gd2hhdCB0aGlzIGlzICovXG5leHBvcnQgY29uc3QgRUFDSF9JU19DT05UUk9MTEVEID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IEVBQ0hfSVNfQU5JTUFURUQgPSAxIDw8IDM7XG5leHBvcnQgY29uc3QgRUFDSF9JVEVNX0lNTVVUQUJMRSA9IDEgPDwgNDtcblxuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0lNTVVUQUJMRSA9IDE7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfUlVORVMgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfVVBEQVRFRCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19CSU5EQUJMRSA9IDEgPDwgMztcbmV4cG9ydCBjb25zdCBQUk9QU19JU19MQVpZX0lOSVRJQUwgPSAxIDw8IDQ7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX0lOID0gMTtcbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX09VVCA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX0dMT0JBTCA9IDEgPDwgMjtcblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX0ZSQUdNRU5UID0gMTtcbmV4cG9ydCBjb25zdCBURU1QTEFURV9VU0VfSU1QT1JUX05PREUgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgVEVNUExBVEVfVVNFX1NWRyA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBURU1QTEFURV9VU0VfTUFUSE1MID0gMSA8PCAzO1xuXG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX1NUQVJUID0gJ1snO1xuLyoqIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhbiBgezplbHNlfS4uLmAgYmxvY2sgd2FzIHJlbmRlcmVkICovXG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX1NUQVJUX0VMU0UgPSAnWyEnO1xuZXhwb3J0IGNvbnN0IEhZRFJBVElPTl9FTkQgPSAnXSc7XG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX0VSUk9SID0ge307XG5cbmV4cG9ydCBjb25zdCBFTEVNRU5UX0lTX05BTUVTUEFDRUQgPSAxO1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRfUFJFU0VSVkVfQVRUUklCVVRFX0NBU0UgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgRUxFTUVOVF9JU19JTlBVVCA9IDEgPDwgMjtcblxuZXhwb3J0IGNvbnN0IFVOSU5JVElBTElaRUQgPSBTeW1ib2woKTtcblxuLy8gRGV2LXRpbWUgY29tcG9uZW50IHByb3BlcnRpZXNcbmV4cG9ydCBjb25zdCBGSUxFTkFNRSA9IFN5bWJvbCgnZmlsZW5hbWUnKTtcbmV4cG9ydCBjb25zdCBITVIgPSBTeW1ib2woJ2htcicpO1xuXG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX0hUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX1NWRyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX01BVEhNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcblxuLy8gd2UgdXNlIGEgbGlzdCBvZiBpZ25vcmFibGUgcnVudGltZSB3YXJuaW5ncyBiZWNhdXNlIG5vdCBldmVyeSBydW50aW1lIHdhcm5pbmdcbi8vIGNhbiBiZSBpZ25vcmVkIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIHZhbGlkYXRpb24gZm9yIHN2ZWx0ZS1pZ25vcmUgaW4gcGxhY2VcbmV4cG9ydCBjb25zdCBJR05PUkFCTEVfUlVOVElNRV9XQVJOSU5HUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCdhd2FpdF93YXRlcmZhbGwnLFxuXHQnYXdhaXRfcmVhY3Rpdml0eV9sb3NzJyxcblx0J3N0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlJyxcblx0J2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlJyxcblx0J2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZCcsXG5cdCdoeWRyYXRpb25faHRtbF9jaGFuZ2VkJyxcblx0J293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcnLFxuXHQnb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24nXG5dKTtcblxuLyoqXG4gKiBXaGl0ZXNwYWNlIGluc2lkZSBvbmUgb2YgdGhlc2UgZWxlbWVudHMgd2lsbCBub3QgcmVzdWx0IGluXG4gKiBhIHdoaXRlc3BhY2Ugbm9kZSBiZWluZyBjcmVhdGVkIGluIGFueSBjaXJjdW1zdGFuY2VzLiAoVGhpc1xuICogbGlzdCBpcyBhbG1vc3QgY2VydGFpbmx5IHZlcnkgaW5jb21wbGV0ZSlcbiAqIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgdW51c2VkXG4gKi9cbmV4cG9ydCBjb25zdCBFTEVNRU5UU19XSVRIT1VUX1RFWFQgPSBbJ2F1ZGlvJywgJ2RhdGFsaXN0JywgJ2RsJywgJ29wdGdyb3VwJywgJ3NlbGVjdCcsICd2aWRlbyddO1xuXG5leHBvcnQgY29uc3QgQVRUQUNITUVOVF9LRVkgPSAnQGF0dGFjaCc7XG4iLCAiY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiPF0vZztcbmNvbnN0IENPTlRFTlRfUkVHRVggPSAvWyY8XS9nO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc19hdHRyXVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlX2h0bWwodmFsdWUsIGlzX2F0dHIpIHtcblx0Y29uc3Qgc3RyID0gU3RyaW5nKHZhbHVlID8/ICcnKTtcblxuXHRjb25zdCBwYXR0ZXJuID0gaXNfYXR0ciA/IEFUVFJfUkVHRVggOiBDT05URU5UX1JFR0VYO1xuXHRwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG5cblx0bGV0IGVzY2FwZWQgPSAnJztcblx0bGV0IGxhc3QgPSAwO1xuXG5cdHdoaWxlIChwYXR0ZXJuLnRlc3Qoc3RyKSkge1xuXHRcdGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG5cdFx0Y29uc3QgY2ggPSBzdHJbaV07XG5cdFx0ZXNjYXBlZCArPSBzdHIuc3Vic3RyaW5nKGxhc3QsIGkpICsgKGNoID09PSAnJicgPyAnJmFtcDsnIDogY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7Jyk7XG5cdFx0bGFzdCA9IGkgKyAxO1xuXHR9XG5cblx0cmV0dXJuIGVzY2FwZWQgKyBzdHIuc3Vic3RyaW5nKGxhc3QpO1xufVxuIiwgImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwgImltcG9ydCB7IGVzY2FwZV9odG1sIH0gZnJvbSAnLi4vLi4vZXNjYXBpbmcuanMnO1xuaW1wb3J0IHsgY2xzeCBhcyBfY2xzeCB9IGZyb20gJ2Nsc3gnO1xuXG4vKipcbiAqIGA8ZGl2IHRyYW5zbGF0ZT17ZmFsc2V9PmAgc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGA8ZGl2IHRyYW5zbGF0ZT1cIm5vXCI+YCBhbmQgX25vdF9cbiAqIGA8ZGl2IHRyYW5zbGF0ZT1cImZhbHNlXCI+YCwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byBgPGRpdiB0cmFuc2xhdGU9XCJ5ZXNcIj5gLiBUaGVyZVxuICogbWF5IGJlIG90aGVyIG9kZCBjYXNlcyB0aGF0IG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhpcyBsaXN0IGluIGZ1dHVyZVxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIE1hcDxhbnksIHN0cmluZz4+fVxuICovXG5jb25zdCByZXBsYWNlbWVudHMgPSB7XG5cdHRyYW5zbGF0ZTogbmV3IE1hcChbXG5cdFx0W3RydWUsICd5ZXMnXSxcblx0XHRbZmFsc2UsICdubyddXG5cdF0pXG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbaXNfYm9vbGVhbl1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKG5hbWUsIHZhbHVlLCBpc19ib29sZWFuID0gZmFsc2UpIHtcblx0Ly8gYXR0cmlidXRlIGhpZGRlbiBmb3IgdmFsdWVzIG90aGVyIHRoYW4gXCJ1bnRpbC1mb3VuZFwiIGJlaGF2ZXMgbGlrZSBhIGJvb2xlYW4gYXR0cmlidXRlXG5cdGlmIChuYW1lID09PSAnaGlkZGVuJyAmJiB2YWx1ZSAhPT0gJ3VudGlsLWZvdW5kJykge1xuXHRcdGlzX2Jvb2xlYW4gPSB0cnVlO1xuXHR9XG5cdGlmICh2YWx1ZSA9PSBudWxsIHx8ICghdmFsdWUgJiYgaXNfYm9vbGVhbikpIHJldHVybiAnJztcblx0Y29uc3Qgbm9ybWFsaXplZCA9IChuYW1lIGluIHJlcGxhY2VtZW50cyAmJiByZXBsYWNlbWVudHNbbmFtZV0uZ2V0KHZhbHVlKSkgfHwgdmFsdWU7XG5cdGNvbnN0IGFzc2lnbm1lbnQgPSBpc19ib29sZWFuID8gJycgOiBgPVwiJHtlc2NhcGVfaHRtbChub3JtYWxpemVkLCB0cnVlKX1cImA7XG5cdHJldHVybiBgICR7bmFtZX0ke2Fzc2lnbm1lbnR9YDtcbn1cblxuLyoqXG4gKiBTbWFsbCB3cmFwcGVyIGFyb3VuZCBjbHN4IHRvIHByZXNlcnZlIFN2ZWx0ZSdzICh3ZWlyZCkgaGFuZGxpbmcgb2YgZmFsc3kgdmFsdWVzLlxuICogVE9ETyBTdmVsdGUgNiByZXZpc2l0IHRoaXMsIGFuZCBsaWtlbHkgdHVybiBhbGwgZmFsc3kgdmFsdWVzIGludG8gdGhlIGVtcHR5IHN0cmluZyAod2hhdCBjbHN4IGFsc28gZG9lcylcbiAqIEBwYXJhbSAge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsc3godmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gX2Nsc3godmFsdWUpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB2YWx1ZSA/PyAnJztcblx0fVxufVxuXG5jb25zdCB3aGl0ZXNwYWNlID0gWy4uLicgXFx0XFxuXFxyXFxmXFx1MDBhMFxcdTAwMGJcXHVmZWZmJ107XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFtoYXNoXVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn0gW2RpcmVjdGl2ZXNdXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX2NsYXNzKHZhbHVlLCBoYXNoLCBkaXJlY3RpdmVzKSB7XG5cdHZhciBjbGFzc25hbWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiAnJyArIHZhbHVlO1xuXG5cdGlmIChoYXNoKSB7XG5cdFx0Y2xhc3NuYW1lID0gY2xhc3NuYW1lID8gY2xhc3NuYW1lICsgJyAnICsgaGFzaCA6IGhhc2g7XG5cdH1cblxuXHRpZiAoZGlyZWN0aXZlcykge1xuXHRcdGZvciAodmFyIGtleSBpbiBkaXJlY3RpdmVzKSB7XG5cdFx0XHRpZiAoZGlyZWN0aXZlc1trZXldKSB7XG5cdFx0XHRcdGNsYXNzbmFtZSA9IGNsYXNzbmFtZSA/IGNsYXNzbmFtZSArICcgJyArIGtleSA6IGtleTtcblx0XHRcdH0gZWxzZSBpZiAoY2xhc3NuYW1lLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgbGVuID0ga2V5Lmxlbmd0aDtcblx0XHRcdFx0dmFyIGEgPSAwO1xuXG5cdFx0XHRcdHdoaWxlICgoYSA9IGNsYXNzbmFtZS5pbmRleE9mKGtleSwgYSkpID49IDApIHtcblx0XHRcdFx0XHR2YXIgYiA9IGEgKyBsZW47XG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHQoYSA9PT0gMCB8fCB3aGl0ZXNwYWNlLmluY2x1ZGVzKGNsYXNzbmFtZVthIC0gMV0pKSAmJlxuXHRcdFx0XHRcdFx0KGIgPT09IGNsYXNzbmFtZS5sZW5ndGggfHwgd2hpdGVzcGFjZS5pbmNsdWRlcyhjbGFzc25hbWVbYl0pKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Y2xhc3NuYW1lID0gKGEgPT09IDAgPyAnJyA6IGNsYXNzbmFtZS5zdWJzdHJpbmcoMCwgYSkpICsgY2xhc3NuYW1lLnN1YnN0cmluZyhiICsgMSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGEgPSBiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjbGFzc25hbWUgPT09ICcnID8gbnVsbCA6IGNsYXNzbmFtZTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLGFueT59IHN0eWxlc1xuICogQHBhcmFtIHtib29sZWFufSBpbXBvcnRhbnRcbiAqL1xuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyhzdHlsZXMsIGltcG9ydGFudCA9IGZhbHNlKSB7XG5cdHZhciBzZXBhcmF0b3IgPSBpbXBvcnRhbnQgPyAnICFpbXBvcnRhbnQ7JyA6ICc7Jztcblx0dmFyIGNzcyA9ICcnO1xuXG5cdGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHlsZXNba2V5XTtcblx0XHRpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycpIHtcblx0XHRcdGNzcyArPSAnICcgKyBrZXkgKyAnOiAnICsgdmFsdWUgKyBzZXBhcmF0b3I7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNzcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9fY3NzX25hbWUobmFtZSkge1xuXHRpZiAobmFtZVswXSAhPT0gJy0nIHx8IG5hbWVbMV0gIT09ICctJykge1xuXHRcdHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH1cblx0cmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT4gfCBbUmVjb3JkPHN0cmluZywgYW55PiwgUmVjb3JkPHN0cmluZywgYW55Pl19IFtzdHlsZXNdXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX3N0eWxlKHZhbHVlLCBzdHlsZXMpIHtcblx0aWYgKHN0eWxlcykge1xuXHRcdHZhciBuZXdfc3R5bGUgPSAnJztcblxuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZyxhbnk+IHwgdW5kZWZpbmVkfSAqL1xuXHRcdHZhciBub3JtYWxfc3R5bGVzO1xuXG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLGFueT4gfCB1bmRlZmluZWR9ICovXG5cdFx0dmFyIGltcG9ydGFudF9zdHlsZXM7XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XG5cdFx0XHRub3JtYWxfc3R5bGVzID0gc3R5bGVzWzBdO1xuXHRcdFx0aW1wb3J0YW50X3N0eWxlcyA9IHN0eWxlc1sxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9ybWFsX3N0eWxlcyA9IHN0eWxlcztcblx0XHR9XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuXHRcdFx0XHQucmVwbGFjZUFsbCgvXFxzKlxcL1xcKi4qP1xcKlxcL1xccyovZywgJycpXG5cdFx0XHRcdC50cmltKCk7XG5cblx0XHRcdC8qKiBAdHlwZSB7Ym9vbGVhbiB8ICdcIicgfCBcIidcIn0gKi9cblx0XHRcdHZhciBpbl9zdHIgPSBmYWxzZTtcblx0XHRcdHZhciBpbl9hcG8gPSAwO1xuXHRcdFx0dmFyIGluX2NvbW1lbnQgPSBmYWxzZTtcblxuXHRcdFx0dmFyIHJlc2VydmVkX25hbWVzID0gW107XG5cblx0XHRcdGlmIChub3JtYWxfc3R5bGVzKSB7XG5cdFx0XHRcdHJlc2VydmVkX25hbWVzLnB1c2goLi4uT2JqZWN0LmtleXMobm9ybWFsX3N0eWxlcykubWFwKHRvX2Nzc19uYW1lKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW1wb3J0YW50X3N0eWxlcykge1xuXHRcdFx0XHRyZXNlcnZlZF9uYW1lcy5wdXNoKC4uLk9iamVjdC5rZXlzKGltcG9ydGFudF9zdHlsZXMpLm1hcCh0b19jc3NfbmFtZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc3RhcnRfaW5kZXggPSAwO1xuXHRcdFx0dmFyIG5hbWVfaW5kZXggPSAtMTtcblxuXHRcdFx0Y29uc3QgbGVuID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR2YXIgYyA9IHZhbHVlW2ldO1xuXG5cdFx0XHRcdGlmIChpbl9jb21tZW50KSB7XG5cdFx0XHRcdFx0aWYgKGMgPT09ICcvJyAmJiB2YWx1ZVtpIC0gMV0gPT09ICcqJykge1xuXHRcdFx0XHRcdFx0aW5fY29tbWVudCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChpbl9zdHIpIHtcblx0XHRcdFx0XHRpZiAoaW5fc3RyID09PSBjKSB7XG5cdFx0XHRcdFx0XHRpbl9zdHIgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJy8nICYmIHZhbHVlW2kgKyAxXSA9PT0gJyonKSB7XG5cdFx0XHRcdFx0aW5fY29tbWVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJ1wiJyB8fCBjID09PSBcIidcIikge1xuXHRcdFx0XHRcdGluX3N0ciA9IGM7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJygnKSB7XG5cdFx0XHRcdFx0aW5fYXBvKys7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJyknKSB7XG5cdFx0XHRcdFx0aW5fYXBvLS07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWluX2NvbW1lbnQgJiYgaW5fc3RyID09PSBmYWxzZSAmJiBpbl9hcG8gPT09IDApIHtcblx0XHRcdFx0XHRpZiAoYyA9PT0gJzonICYmIG5hbWVfaW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRuYW1lX2luZGV4ID0gaTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09ICc7JyB8fCBpID09PSBsZW4gLSAxKSB7XG5cdFx0XHRcdFx0XHRpZiAobmFtZV9pbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5hbWUgPSB0b19jc3NfbmFtZSh2YWx1ZS5zdWJzdHJpbmcoc3RhcnRfaW5kZXgsIG5hbWVfaW5kZXgpLnRyaW0oKSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFyZXNlcnZlZF9uYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjICE9PSAnOycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgcHJvcGVydHkgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnRfaW5kZXgsIGkpLnRyaW0oKTtcblx0XHRcdFx0XHRcdFx0XHRuZXdfc3R5bGUgKz0gJyAnICsgcHJvcGVydHkgKyAnOyc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnRfaW5kZXggPSBpICsgMTtcblx0XHRcdFx0XHRcdG5hbWVfaW5kZXggPSAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobm9ybWFsX3N0eWxlcykge1xuXHRcdFx0bmV3X3N0eWxlICs9IGFwcGVuZF9zdHlsZXMobm9ybWFsX3N0eWxlcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGltcG9ydGFudF9zdHlsZXMpIHtcblx0XHRcdG5ld19zdHlsZSArPSBhcHBlbmRfc3R5bGVzKGltcG9ydGFudF9zdHlsZXMsIHRydWUpO1xuXHRcdH1cblxuXHRcdG5ld19zdHlsZSA9IG5ld19zdHlsZS50cmltKCk7XG5cdFx0cmV0dXJuIG5ld19zdHlsZSA9PT0gJycgPyBudWxsIDogbmV3X3N0eWxlO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogU3RyaW5nKHZhbHVlKTtcbn1cbiIsICIvLyBTdG9yZSB0aGUgcmVmZXJlbmNlcyB0byBnbG9iYWxzIGluIGNhc2Ugc29tZW9uZSB0cmllcyB0byBtb25rZXkgcGF0Y2ggdGhlc2UsIGNhdXNpbmcgdGhlIGJlbG93XG4vLyB0byBkZS1vcHQgKHRoaXMgb2NjdXJzIG9mdGVuIHdoZW4gdXNpbmcgcG9wdWxhciBleHRlbnNpb25zKS5cbmV4cG9ydCB2YXIgaXNfYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuZXhwb3J0IHZhciBpbmRleF9vZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuZXhwb3J0IHZhciBhcnJheV9mcm9tID0gQXJyYXkuZnJvbTtcbmV4cG9ydCB2YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cztcbmV4cG9ydCB2YXIgZGVmaW5lX3Byb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuZXhwb3J0IHZhciBnZXRfZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5leHBvcnQgdmFyIGdldF9kZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xuZXhwb3J0IHZhciBvYmplY3RfcHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmV4cG9ydCB2YXIgYXJyYXlfcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuZXhwb3J0IHZhciBnZXRfcHJvdG90eXBlX29mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuZXhwb3J0IHZhciBpc19leHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBjb25zdCBub29wID0gKCkgPT4ge307XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuLyoqXG4gKiBAdGVtcGxhdGUgW1Q9YW55XVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgUHJvbWlzZUxpa2U8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWU/LnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuLyoqIEBwYXJhbSB7QXJyYXk8KCkgPT4gdm9pZD59IGFyciAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hbGwoYXJyKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJyW2ldKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUT0RPIHJlcGxhY2Ugd2l0aCBQcm9taXNlLndpdGhSZXNvbHZlcnMgb25jZSBzdXBwb3J0ZWQgd2lkZWx5IGVub3VnaFxuICogQHRlbXBsYXRlIFtUPXZvaWRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZlcnJlZCgpIHtcblx0LyoqIEB0eXBlIHsodmFsdWU6IFQpID0+IHZvaWR9ICovXG5cdHZhciByZXNvbHZlO1xuXG5cdC8qKiBAdHlwZSB7KHJlYXNvbjogYW55KSA9PiB2b2lkfSAqL1xuXHR2YXIgcmVqZWN0O1xuXG5cdC8qKiBAdHlwZSB7UHJvbWlzZTxUPn0gKi9cblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRyZXNvbHZlID0gcmVzO1xuXHRcdHJlamVjdCA9IHJlajtcblx0fSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtWIHwgKCgpID0+IFYpfSBmYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFufSBbbGF6eV1cbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFsbGJhY2sodmFsdWUsIGZhbGxiYWNrLCBsYXp5ID0gZmFsc2UpIHtcblx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcblx0XHQ/IGxhenlcblx0XHRcdD8gLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoZmFsbGJhY2spKClcblx0XHRcdDogLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spXG5cdFx0OiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBXaGVuIGVuY291bnRlcmluZyBhIHNpdHVhdGlvbiBsaWtlIGBsZXQgW2EsIGIsIGNdID0gJGRlcml2ZWQoYmxhaCgpKWAsXG4gKiB3ZSBuZWVkIHRvIHN0YXNoIGFuIGludGVybWVkaWF0ZSB2YWx1ZSB0aGF0IGBhYCwgYGJgLCBhbmQgYGNgIGRlcml2ZVxuICogZnJvbSwgaW4gY2FzZSBpdCdzIGFuIGl0ZXJhYmxlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheUxpa2U8VD4gfCBJdGVyYWJsZTxUPn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbl1cbiAqIEByZXR1cm5zIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX2FycmF5KHZhbHVlLCBuKSB7XG5cdC8vIHJldHVybiBhcnJheXMgdW5jaGFuZ2VkXG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8vIGlmIHZhbHVlIGlzIG5vdCBpdGVyYWJsZSwgb3IgYG5gIGlzIHVuc3BlY2lmaWVkIChpbmRpY2F0ZXMgYSByZXN0XG5cdC8vIGVsZW1lbnQsIHdoaWNoIG1lYW5zIHdlJ3JlIG5vdCBjb25jZXJuZWQgYWJvdXQgdW5ib3VuZGVkIGl0ZXJhYmxlcylcblx0Ly8gY29udmVydCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tYFxuXHRpZiAobiA9PT0gdW5kZWZpbmVkIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSkge1xuXHRcdHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcblx0fVxuXG5cdC8vIG90aGVyd2lzZSwgcG9wdWxhdGUgYW4gYXJyYXkgd2l0aCBgbmAgdmFsdWVzXG5cblx0LyoqIEB0eXBlIHtUW119ICovXG5cdGNvbnN0IGFycmF5ID0gW107XG5cblx0Zm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlKSB7XG5cdFx0YXJyYXkucHVzaChlbGVtZW50KTtcblx0XHRpZiAoYXJyYXkubGVuZ3RoID09PSBuKSBicmVhaztcblx0fVxuXG5cdHJldHVybiBhcnJheTtcbn1cbiIsICJleHBvcnQgZGVmYXVsdCBmYWxzZTtcbiIsICJleHBvcnQgZGVmYXVsdCB0cnVlO1xuIiwgImV4cG9ydCB7IGRlZmF1bHQgYXMgQlJPV1NFUiB9IGZyb20gJ2VzbS1lbnYvYnJvd3Nlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERFViB9IGZyb20gJ2VzbS1lbnYvZGV2ZWxvcG1lbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOT0RFIH0gZnJvbSAnZXNtLWVudi9ub2RlJztcbiIsICIvLyBHZW5lcmFsIGZsYWdzXG5leHBvcnQgY29uc3QgREVSSVZFRCA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBFRkZFQ1QgPSAxIDw8IDI7XG5leHBvcnQgY29uc3QgUkVOREVSX0VGRkVDVCA9IDEgPDwgMztcbi8qKlxuICogQW4gZWZmZWN0IHRoYXQgZG9lcyBub3QgZGVzdHJveSBpdHMgY2hpbGQgZWZmZWN0cyB3aGVuIGl0IHJlcnVucy5cbiAqIFJ1bnMgYXMgcGFydCBvZiByZW5kZXIgZWZmZWN0cywgaS5lLiBub3QgZWFnZXJseSBhcyBwYXJ0IG9mIHRyZWUgdHJhdmVyc2FsIG9yIGVmZmVjdCBmbHVzaGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IE1BTkFHRURfRUZGRUNUID0gMSA8PCAyNDtcbi8qKlxuICogQW4gZWZmZWN0IHRoYXQgZG9lcyBub3QgZGVzdHJveSBpdHMgY2hpbGQgZWZmZWN0cyB3aGVuIGl0IHJlcnVucyAobGlrZSBNQU5BR0VEX0VGRkVDVCkuXG4gKiBSdW5zIGVhZ2VybHkgYXMgcGFydCBvZiB0cmVlIHRyYXZlcnNhbCBvciBlZmZlY3QgZmx1c2hpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBCTE9DS19FRkZFQ1QgPSAxIDw8IDQ7XG5leHBvcnQgY29uc3QgQlJBTkNIX0VGRkVDVCA9IDEgPDwgNTtcbmV4cG9ydCBjb25zdCBST09UX0VGRkVDVCA9IDEgPDwgNjtcbmV4cG9ydCBjb25zdCBCT1VOREFSWV9FRkZFQ1QgPSAxIDw8IDc7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IGEgcmVhY3Rpb24gaXMgY29ubmVjdGVkIHRvIGFuIGVmZmVjdCByb290IFx1MjAxNCBlaXRoZXIgaXQgaXMgYW4gZWZmZWN0LFxuICogb3IgaXQgaXMgYSBkZXJpdmVkIHRoYXQgaXMgZGVwZW5kZWQgb24gYnkgYXQgbGVhc3Qgb25lIGVmZmVjdC4gSWYgYSBkZXJpdmVkIGhhc1xuICogbm8gZGVwZW5kZW50cywgd2UgY2FuIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgZ3JhcGgsIGFsbG93aW5nIGl0IHRvIGVpdGhlciBiZVxuICogR0MnZCBvciByZWNvbm5lY3RlZCBsYXRlciBpZiBhbiBlZmZlY3QgY29tZXMgdG8gZGVwZW5kIG9uIGl0IGFnYWluXG4gKi9cbmV4cG9ydCBjb25zdCBDT05ORUNURUQgPSAxIDw8IDk7XG5leHBvcnQgY29uc3QgQ0xFQU4gPSAxIDw8IDEwO1xuZXhwb3J0IGNvbnN0IERJUlRZID0gMSA8PCAxMTtcbmV4cG9ydCBjb25zdCBNQVlCRV9ESVJUWSA9IDEgPDwgMTI7XG5leHBvcnQgY29uc3QgSU5FUlQgPSAxIDw8IDEzO1xuZXhwb3J0IGNvbnN0IERFU1RST1lFRCA9IDEgPDwgMTQ7XG5cbi8vIEZsYWdzIGV4Y2x1c2l2ZSB0byBlZmZlY3RzXG4vKiogU2V0IG9uY2UgYW4gZWZmZWN0IHRoYXQgc2hvdWxkIHJ1biBzeW5jaHJvbm91c2x5IGhhcyBydW4gKi9cbmV4cG9ydCBjb25zdCBFRkZFQ1RfUkFOID0gMSA8PCAxNTtcbi8qKlxuICogJ1RyYW5zcGFyZW50JyBlZmZlY3RzIGRvIG5vdCBjcmVhdGUgYSB0cmFuc2l0aW9uIGJvdW5kYXJ5LlxuICogVGhpcyBpcyBvbiBhIGJsb2NrIGVmZmVjdCA5OSUgb2YgdGhlIHRpbWUgYnV0IG1heSBhbHNvIGJlIG9uIGEgYnJhbmNoIGVmZmVjdCBpZiBpdHMgcGFyZW50IGJsb2NrIGVmZmVjdCB3YXMgcHJ1bmVkXG4gKi9cbmV4cG9ydCBjb25zdCBFRkZFQ1RfVFJBTlNQQVJFTlQgPSAxIDw8IDE2O1xuZXhwb3J0IGNvbnN0IEVBR0VSX0VGRkVDVCA9IDEgPDwgMTc7XG5leHBvcnQgY29uc3QgSEVBRF9FRkZFQ1QgPSAxIDw8IDE4O1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9QUkVTRVJWRUQgPSAxIDw8IDE5O1xuZXhwb3J0IGNvbnN0IFVTRVJfRUZGRUNUID0gMSA8PCAyMDtcblxuLy8gRmxhZ3MgZXhjbHVzaXZlIHRvIGRlcml2ZWRzXG4vKipcbiAqIFRlbGxzIHRoYXQgd2UgbWFya2VkIHRoaXMgZGVyaXZlZCBhbmQgaXRzIHJlYWN0aW9ucyBhcyB2aXNpdGVkIGR1cmluZyB0aGUgXCJtYXJrIGFzIChtYXliZSkgZGlydHlcIi1waGFzZS5cbiAqIFdpbGwgYmUgbGlmdGVkIGR1cmluZyBleGVjdXRpb24gb2YgdGhlIGRlcml2ZWQgYW5kIGR1cmluZyBjaGVja2luZyBpdHMgZGlydHkgc3RhdGUgKGJvdGggYXJlIG5lY2Vzc2FyeVxuICogYmVjYXVzZSBhIGRlcml2ZWQgbWlnaHQgYmUgY2hlY2tlZCBidXQgbm90IGV4ZWN1dGVkKS5cbiAqL1xuZXhwb3J0IGNvbnN0IFdBU19NQVJLRUQgPSAxIDw8IDE1O1xuXG4vLyBGbGFncyB1c2VkIGZvciBhc3luY1xuZXhwb3J0IGNvbnN0IFJFQUNUSU9OX0lTX1VQREFUSU5HID0gMSA8PCAyMTtcbmV4cG9ydCBjb25zdCBBU1lOQyA9IDEgPDwgMjI7XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9WQUxVRSA9IDEgPDwgMjM7XG5cbmV4cG9ydCBjb25zdCBTVEFURV9TWU1CT0wgPSBTeW1ib2woJyRzdGF0ZScpO1xuZXhwb3J0IGNvbnN0IExFR0FDWV9QUk9QUyA9IFN5bWJvbCgnbGVnYWN5IHByb3BzJyk7XG5leHBvcnQgY29uc3QgTE9BRElOR19BVFRSX1NZTUJPTCA9IFN5bWJvbCgnJyk7XG5leHBvcnQgY29uc3QgUFJPWFlfUEFUSF9TWU1CT0wgPSBTeW1ib2woJ3Byb3h5IHBhdGgnKTtcblxuLyoqIGFsbG93IHVzZXJzIHRvIGlnbm9yZSBhYm9ydGVkIHNpZ25hbCBlcnJvcnMgaWYgYHJlYXNvbi5uYW1lID09PSAnU3RhbGVSZWFjdGlvbkVycm9yYCAqL1xuZXhwb3J0IGNvbnN0IFNUQUxFX1JFQUNUSU9OID0gbmV3IChjbGFzcyBTdGFsZVJlYWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdG5hbWUgPSAnU3RhbGVSZWFjdGlvbkVycm9yJztcblx0bWVzc2FnZSA9ICdUaGUgcmVhY3Rpb24gdGhhdCBjYWxsZWQgYGdldEFib3J0U2lnbmFsKClgIHdhcyByZS1ydW4gb3IgZGVzdHJveWVkJztcbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBFTEVNRU5UX05PREUgPSAxO1xuZXhwb3J0IGNvbnN0IFRFWFRfTk9ERSA9IDM7XG5leHBvcnQgY29uc3QgQ09NTUVOVF9OT0RFID0gODtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG4iLCAiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuLyoqXG4gKiBDYW5ub3QgdXNlIGAlbmFtZSUoLi4uKWAgdW5sZXNzIHRoZSBgZXhwZXJpbWVudGFsLmFzeW5jYCBjb21waWxlciBvcHRpb24gaXMgYHRydWVgXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwZXJpbWVudGFsX2FzeW5jX3JlcXVpcmVkKG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBleHBlcmltZW50YWxfYXN5bmNfcmVxdWlyZWRcXG5DYW5ub3QgdXNlIFxcYCR7bmFtZX0oLi4uKVxcYCB1bmxlc3MgdGhlIFxcYGV4cGVyaW1lbnRhbC5hc3luY1xcYCBjb21waWxlciBvcHRpb24gaXMgXFxgdHJ1ZVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2V4cGVyaW1lbnRhbF9hc3luY19yZXF1aXJlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9leHBlcmltZW50YWxfYXN5bmNfcmVxdWlyZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCB1c2UgYHtAcmVuZGVyIGNoaWxkcmVuKC4uLil9YCBpZiB0aGUgcGFyZW50IGNvbXBvbmVudCB1c2VzIGBsZXQ6YCBkaXJlY3RpdmVzLiBDb25zaWRlciB1c2luZyBhIG5hbWVkIHNuaXBwZXQgaW5zdGVhZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9kZWZhdWx0X3NuaXBwZXQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRcXG5DYW5ub3QgdXNlIFxcYHtAcmVuZGVyIGNoaWxkcmVuKC4uLil9XFxgIGlmIHRoZSBwYXJlbnQgY29tcG9uZW50IHVzZXMgXFxgbGV0OlxcYCBkaXJlY3RpdmVzLiBDb25zaWRlciB1c2luZyBhIG5hbWVkIHNuaXBwZXQgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfZGVmYXVsdF9zbmlwcGV0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfZGVmYXVsdF9zbmlwcGV0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIHNuaXBwZXQgZnVuY3Rpb24gd2FzIHBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cy4gU25pcHBldHMgc2hvdWxkIG9ubHkgYmUgaW5zdGFudGlhdGVkIHZpYSBge0ByZW5kZXIgLi4ufWBcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRfc25pcHBldF9hcmd1bWVudHMoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50c1xcbkEgc25pcHBldCBmdW5jdGlvbiB3YXMgcGFzc2VkIGludmFsaWQgYXJndW1lbnRzLiBTbmlwcGV0cyBzaG91bGQgb25seSBiZSBpbnN0YW50aWF0ZWQgdmlhIFxcYHtAcmVuZGVyIC4uLn1cXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3NuaXBwZXRfYXJndW1lbnRzYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldF9hcmd1bWVudHNgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSUoLi4uKWAgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnRcXG5cXGAke25hbWV9KC4uLilcXGAgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudGApO1xuXHR9XG59XG5cbi8qKlxuICogQ29udGV4dCB3YXMgbm90IHNldCBpbiBhIHBhcmVudCBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pc3NpbmdfY29udGV4dCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBtaXNzaW5nX2NvbnRleHRcXG5Db250ZXh0IHdhcyBub3Qgc2V0IGluIGEgcGFyZW50IGNvbXBvbmVudFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL21pc3NpbmdfY29udGV4dGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9taXNzaW5nX2NvbnRleHRgKTtcblx0fVxufVxuXG4vKipcbiAqIEF0dGVtcHRlZCB0byByZW5kZXIgYSBzbmlwcGV0IHdpdGhvdXQgYSBge0ByZW5kZXJ9YCBibG9jay4gVGhpcyB3b3VsZCBjYXVzZSB0aGUgc25pcHBldCBjb2RlIHRvIGJlIHN0cmluZ2lmaWVkIGluc3RlYWQgb2YgaXRzIGNvbnRlbnQgYmVpbmcgcmVuZGVyZWQgdG8gdGhlIERPTS4gVG8gZml4IHRoaXMsIGNoYW5nZSBge3NuaXBwZXR9YCB0byBge0ByZW5kZXIgc25pcHBldCgpfWAuXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmlwcGV0X3dpdGhvdXRfcmVuZGVyX3RhZygpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzbmlwcGV0X3dpdGhvdXRfcmVuZGVyX3RhZ1xcbkF0dGVtcHRlZCB0byByZW5kZXIgYSBzbmlwcGV0IHdpdGhvdXQgYSBcXGB7QHJlbmRlcn1cXGAgYmxvY2suIFRoaXMgd291bGQgY2F1c2UgdGhlIHNuaXBwZXQgY29kZSB0byBiZSBzdHJpbmdpZmllZCBpbnN0ZWFkIG9mIGl0cyBjb250ZW50IGJlaW5nIHJlbmRlcmVkIHRvIHRoZSBET00uIFRvIGZpeCB0aGlzLCBjaGFuZ2UgXFxge3NuaXBwZXR9XFxgIHRvIFxcYHtAcmVuZGVyIHNuaXBwZXQoKX1cXGAuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc25pcHBldF93aXRob3V0X3JlbmRlcl90YWdgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc25pcHBldF93aXRob3V0X3JlbmRlcl90YWdgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSVgIGlzIG5vdCBhIHN0b3JlIHdpdGggYSBgc3Vic2NyaWJlYCBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9pbnZhbGlkX3NoYXBlKG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdG9yZV9pbnZhbGlkX3NoYXBlXFxuXFxgJHtuYW1lfVxcYCBpcyBub3QgYSBzdG9yZSB3aXRoIGEgXFxgc3Vic2NyaWJlXFxgIG1ldGhvZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0b3JlX2ludmFsaWRfc2hhcGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RvcmVfaW52YWxpZF9zaGFwZWApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGB0aGlzYCBwcm9wIG9uIGA8c3ZlbHRlOmVsZW1lbnQ+YCBtdXN0IGJlIGEgc3RyaW5nLCBpZiBkZWZpbmVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWUoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3ZlbHRlX2VsZW1lbnRfaW52YWxpZF90aGlzX3ZhbHVlXFxuVGhlIFxcYHRoaXNcXGAgcHJvcCBvbiBcXGA8c3ZlbHRlOmVsZW1lbnQ+XFxgIG11c3QgYmUgYSBzdHJpbmcsIGlmIGRlZmluZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3ZlbHRlX2VsZW1lbnRfaW52YWxpZF90aGlzX3ZhbHVlYCk7XG5cdH1cbn0iLCAiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuZXhwb3J0ICogIGZyb20gJy4uL3NoYXJlZC9lcnJvcnMuanMnO1xuXG4vKipcbiAqIENhbm5vdCBjcmVhdGUgYSBgJGRlcml2ZWQoLi4uKWAgd2l0aCBhbiBgYXdhaXRgIGV4cHJlc3Npb24gb3V0c2lkZSBvZiBhbiBlZmZlY3QgdHJlZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNfZGVyaXZlZF9vcnBoYW4oKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYXN5bmNfZGVyaXZlZF9vcnBoYW5cXG5DYW5ub3QgY3JlYXRlIGEgXFxgJGRlcml2ZWQoLi4uKVxcYCB3aXRoIGFuIFxcYGF3YWl0XFxgIGV4cHJlc3Npb24gb3V0c2lkZSBvZiBhbiBlZmZlY3QgdHJlZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2FzeW5jX2Rlcml2ZWRfb3JwaGFuYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2FzeW5jX2Rlcml2ZWRfb3JwaGFuYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBVc2luZyBgYmluZDp2YWx1ZWAgdG9nZXRoZXIgd2l0aCBhIGNoZWNrYm94IGlucHV0IGlzIG5vdCBhbGxvd2VkLiBVc2UgYGJpbmQ6Y2hlY2tlZGAgaW5zdGVhZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZVxcblVzaW5nIFxcYGJpbmQ6dmFsdWVcXGAgdG9nZXRoZXIgd2l0aCBhIGNoZWNrYm94IGlucHV0IGlzIG5vdCBhbGxvd2VkLiBVc2UgXFxgYmluZDpjaGVja2VkXFxgIGluc3RlYWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb21wb25lbnQgJWNvbXBvbmVudCUgaGFzIGFuIGV4cG9ydCBuYW1lZCBgJWtleSVgIHRoYXQgYSBjb25zdW1lciBjb21wb25lbnQgaXMgdHJ5aW5nIHRvIGFjY2VzcyB1c2luZyBgYmluZDola2V5JWAsIHdoaWNoIGlzIGRpc2FsbG93ZWQuIEluc3RlYWQsIHVzZSBgYmluZDp0aGlzYCAoZS5nLiBgPCVuYW1lJSBiaW5kOnRoaXM9e2NvbXBvbmVudH0gLz5gKSBhbmQgdGhlbiBhY2Nlc3MgdGhlIHByb3BlcnR5IG9uIHRoZSBib3VuZCBjb21wb25lbnQgaW5zdGFuY2UgKGUuZy4gYGNvbXBvbmVudC4la2V5JWApXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9pbnZhbGlkX2V4cG9ydChjb21wb25lbnQsIGtleSwgbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGJpbmRfaW52YWxpZF9leHBvcnRcXG5Db21wb25lbnQgJHtjb21wb25lbnR9IGhhcyBhbiBleHBvcnQgbmFtZWQgXFxgJHtrZXl9XFxgIHRoYXQgYSBjb25zdW1lciBjb21wb25lbnQgaXMgdHJ5aW5nIHRvIGFjY2VzcyB1c2luZyBcXGBiaW5kOiR7a2V5fVxcYCwgd2hpY2ggaXMgZGlzYWxsb3dlZC4gSW5zdGVhZCwgdXNlIFxcYGJpbmQ6dGhpc1xcYCAoZS5nLiBcXGA8JHtuYW1lfSBiaW5kOnRoaXM9e2NvbXBvbmVudH0gLz5cXGApIGFuZCB0aGVuIGFjY2VzcyB0aGUgcHJvcGVydHkgb24gdGhlIGJvdW5kIGNvbXBvbmVudCBpbnN0YW5jZSAoZS5nLiBcXGBjb21wb25lbnQuJHtrZXl9XFxgKVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfaW52YWxpZF9leHBvcnRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2V4cG9ydGApO1xuXHR9XG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgaXMgYXR0ZW1wdGluZyB0byBiaW5kIHRvIGEgbm9uLWJpbmRhYmxlIHByb3BlcnR5IGAla2V5JWAgYmVsb25naW5nIHRvICVjb21wb25lbnQlIChpLmUuIGA8JW5hbWUlIGJpbmQ6JWtleSU9ey4uLn0+YCkuIFRvIG1hcmsgYSBwcm9wZXJ0eSBhcyBiaW5kYWJsZTogYGxldCB7ICVrZXklID0gJGJpbmRhYmxlKCkgfSA9ICRwcm9wcygpYFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfbm90X2JpbmRhYmxlKGtleSwgY29tcG9uZW50LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9ub3RfYmluZGFibGVcXG5BIGNvbXBvbmVudCBpcyBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYSBub24tYmluZGFibGUgcHJvcGVydHkgXFxgJHtrZXl9XFxgIGJlbG9uZ2luZyB0byAke2NvbXBvbmVudH0gKGkuZS4gXFxgPCR7bmFtZX0gYmluZDoke2tleX09ey4uLn0+XFxgKS4gVG8gbWFyayBhIHByb3BlcnR5IGFzIGJpbmRhYmxlOiBcXGBsZXQgeyAke2tleX0gPSAkYmluZGFibGUoKSB9ID0gJHByb3BzKClcXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX25vdF9iaW5kYWJsZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX25vdF9iaW5kYWJsZWApO1xuXHR9XG59XG5cbi8qKlxuICogQ2FsbGluZyBgJW1ldGhvZCVgIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIChvZiAlY29tcG9uZW50JSkgaXMgbm8gbG9uZ2VyIHZhbGlkIGluIFN2ZWx0ZSA1XG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfYXBpX2NoYW5nZWQobWV0aG9kLCBjb21wb25lbnQpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBjb21wb25lbnRfYXBpX2NoYW5nZWRcXG5DYWxsaW5nIFxcYCR7bWV0aG9kfVxcYCBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZSAob2YgJHtjb21wb25lbnR9KSBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2NoYW5nZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9jaGFuZ2VkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0ZWQgdG8gaW5zdGFudGlhdGUgJWNvbXBvbmVudCUgd2l0aCBgbmV3ICVuYW1lJWAsIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNS4gSWYgdGhpcyBjb21wb25lbnQgaXMgbm90IHVuZGVyIHlvdXIgY29udHJvbCwgc2V0IHRoZSBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGlgIGNvbXBpbGVyIG9wdGlvbiB0byBgNGAgdG8ga2VlcCBpdCB3b3JraW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9hcGlfaW52YWxpZF9uZXcoY29tcG9uZW50LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld1xcbkF0dGVtcHRlZCB0byBpbnN0YW50aWF0ZSAke2NvbXBvbmVudH0gd2l0aCBcXGBuZXcgJHtuYW1lfVxcYCwgd2hpY2ggaXMgbm8gbG9uZ2VyIHZhbGlkIGluIFN2ZWx0ZSA1LiBJZiB0aGlzIGNvbXBvbmVudCBpcyBub3QgdW5kZXIgeW91ciBjb250cm9sLCBzZXQgdGhlIFxcYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpXFxgIGNvbXBpbGVyIG9wdGlvbiB0byBcXGA0XFxgIHRvIGtlZXAgaXQgd29ya2luZy5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2ludmFsaWRfbmV3YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfaW52YWxpZF9uZXdgKTtcblx0fVxufVxuXG4vKipcbiAqIEEgZGVyaXZlZCB2YWx1ZSBjYW5ub3QgcmVmZXJlbmNlIGl0c2VsZiByZWN1cnNpdmVseVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZF9yZWZlcmVuY2VzX3NlbGYoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZGVyaXZlZF9yZWZlcmVuY2VzX3NlbGZcXG5BIGRlcml2ZWQgdmFsdWUgY2Fubm90IHJlZmVyZW5jZSBpdHNlbGYgcmVjdXJzaXZlbHlcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZmApO1xuXHR9XG59XG5cbi8qKlxuICogS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBgJXZhbHVlJWAgYXQgaW5kZXhlcyAlYSUgYW5kICViJVxuICogQHBhcmFtIHtzdHJpbmd9IGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2hfa2V5X2R1cGxpY2F0ZShhLCBiLCB2YWx1ZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVhY2hfa2V5X2R1cGxpY2F0ZVxcbiR7dmFsdWVcblx0XHRcdD8gYEtleWVkIGVhY2ggYmxvY2sgaGFzIGR1cGxpY2F0ZSBrZXkgXFxgJHt2YWx1ZX1cXGAgYXQgaW5kZXhlcyAke2F9IGFuZCAke2J9YFxuXHRcdFx0OiBgS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBhdCBpbmRleGVzICR7YX0gYW5kICR7Yn1gfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VhY2hfa2V5X2R1cGxpY2F0ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lYWNoX2tleV9kdXBsaWNhdGVgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlcnVuZSVgIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgY2xlYW51cCBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF9pbl90ZWFyZG93bihydW5lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X2luX3RlYXJkb3duXFxuXFxgJHtydW5lfVxcYCBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IGNsZWFudXAgZnVuY3Rpb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdGVhcmRvd25gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3RlYXJkb3duYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBFZmZlY3QgY2Fubm90IGJlIGNyZWF0ZWQgaW5zaWRlIGEgYCRkZXJpdmVkYCB2YWx1ZSB0aGF0IHdhcyBub3QgaXRzZWxmIGNyZWF0ZWQgaW5zaWRlIGFuIGVmZmVjdFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkXFxuRWZmZWN0IGNhbm5vdCBiZSBjcmVhdGVkIGluc2lkZSBhIFxcYCRkZXJpdmVkXFxgIHZhbHVlIHRoYXQgd2FzIG5vdCBpdHNlbGYgY3JlYXRlZCBpbnNpZGUgYW4gZWZmZWN0XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJXJ1bmUlYCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgKGUuZy4gZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbilcbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3Rfb3JwaGFuKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3Rfb3JwaGFuXFxuXFxgJHtydW5lfVxcYCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgKGUuZy4gZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbilcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3Rfb3JwaGFuYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9vcnBoYW5gKTtcblx0fVxufVxuXG4vKipcbiAqIGAkZWZmZWN0LnBlbmRpbmcoKWAgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBhbiBlZmZlY3Qgb3IgZGVyaXZlZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3BlbmRpbmdfb3V0c2lkZV9yZWFjdGlvbigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uXFxuXFxgJGVmZmVjdC5wZW5kaW5nKClcXGAgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBhbiBlZmZlY3Qgb3IgZGVyaXZlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9wZW5kaW5nX291dHNpZGVfcmVhY3Rpb25gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3BlbmRpbmdfb3V0c2lkZV9yZWFjdGlvbmApO1xuXHR9XG59XG5cbi8qKlxuICogTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgdHlwaWNhbGx5IGluZGljYXRlcyB0aGF0IGFuIGVmZmVjdCByZWFkcyBhbmQgd3JpdGVzIHRoZSBzYW1lIHBpZWNlIG9mIHN0YXRlXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWRcXG5NYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoYXQgYW4gZWZmZWN0IHJlYWRzIGFuZCB3cml0ZXMgdGhlIHNhbWUgcGllY2Ugb2Ygc3RhdGVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCB1c2UgYGZsdXNoU3luY2AgaW5zaWRlIGFuIGVmZmVjdFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfc3luY19pbl9lZmZlY3QoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZmx1c2hfc3luY19pbl9lZmZlY3RcXG5DYW5ub3QgdXNlIFxcYGZsdXNoU3luY1xcYCBpbnNpZGUgYW4gZWZmZWN0XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZmx1c2hfc3luY19pbl9lZmZlY3RgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZmx1c2hfc3luY19pbl9lZmZlY3RgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBjb21taXQgYSBmb3JrIHRoYXQgd2FzIGFscmVhZHkgZGlzY2FyZGVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JrX2Rpc2NhcmRlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBmb3JrX2Rpc2NhcmRlZFxcbkNhbm5vdCBjb21taXQgYSBmb3JrIHRoYXQgd2FzIGFscmVhZHkgZGlzY2FyZGVkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZm9ya19kaXNjYXJkZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZm9ya19kaXNjYXJkZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBjcmVhdGUgYSBmb3JrIGluc2lkZSBhbiBlZmZlY3Qgb3Igd2hlbiBzdGF0ZSBjaGFuZ2VzIGFyZSBwZW5kaW5nXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JrX3RpbWluZygpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBmb3JrX3RpbWluZ1xcbkNhbm5vdCBjcmVhdGUgYSBmb3JrIGluc2lkZSBhbiBlZmZlY3Qgb3Igd2hlbiBzdGF0ZSBjaGFuZ2VzIGFyZSBwZW5kaW5nXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZm9ya190aW1pbmdgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZm9ya190aW1pbmdgKTtcblx0fVxufVxuXG4vKipcbiAqIGBnZXRBYm9ydFNpZ25hbCgpYCBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGFuIGVmZmVjdCBvciBkZXJpdmVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYWJvcnRfc2lnbmFsX291dHNpZGVfcmVhY3Rpb24oKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZ2V0X2Fib3J0X3NpZ25hbF9vdXRzaWRlX3JlYWN0aW9uXFxuXFxgZ2V0QWJvcnRTaWduYWwoKVxcYCBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGFuIGVmZmVjdCBvciBkZXJpdmVkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZ2V0X2Fib3J0X3NpZ25hbF9vdXRzaWRlX3JlYWN0aW9uYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2dldF9hYm9ydF9zaWduYWxfb3V0c2lkZV9yZWFjdGlvbmApO1xuXHR9XG59XG5cbi8qKlxuICogRXhwZWN0ZWQgdG8gZmluZCBhIGh5ZHJhdGFibGUgd2l0aCBrZXkgYCVrZXklYCBkdXJpbmcgaHlkcmF0aW9uLCBidXQgZGlkIG5vdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGFibGVfbWlzc2luZ19idXRfcmVxdWlyZWQoa2V5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaHlkcmF0YWJsZV9taXNzaW5nX2J1dF9yZXF1aXJlZFxcbkV4cGVjdGVkIHRvIGZpbmQgYSBoeWRyYXRhYmxlIHdpdGgga2V5IFxcYCR7a2V5fVxcYCBkdXJpbmcgaHlkcmF0aW9uLCBidXQgZGlkIG5vdC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRhYmxlX21pc3NpbmdfYnV0X3JlcXVpcmVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGFibGVfbWlzc2luZ19idXRfcmVxdWlyZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIEZhaWxlZCB0byBoeWRyYXRlIHRoZSBhcHBsaWNhdGlvblxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX2ZhaWxlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBoeWRyYXRpb25fZmFpbGVkXFxuRmFpbGVkIHRvIGh5ZHJhdGUgdGhlIGFwcGxpY2F0aW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2ZhaWxlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fZmFpbGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb3VsZCBub3QgYHtAcmVuZGVyfWAgc25pcHBldCBkdWUgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgYG51bGxgIG9yIGB1bmRlZmluZWRgLiBDb25zaWRlciB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBge0ByZW5kZXIgc25pcHBldD8uKCl9YFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9zbmlwcGV0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWRfc25pcHBldFxcbkNvdWxkIG5vdCBcXGB7QHJlbmRlcn1cXGAgc25pcHBldCBkdWUgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgXFxgbnVsbFxcYCBvciBcXGB1bmRlZmluZWRcXGAuIENvbnNpZGVyIHVzaW5nIG9wdGlvbmFsIGNoYWluaW5nIFxcYHtAcmVuZGVyIHNuaXBwZXQ/LigpfVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3NuaXBwZXRgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSUoLi4uKWAgY2Fubm90IGJlIHVzZWQgaW4gcnVuZXMgbW9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9sZWdhY3lfb25seShuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5XFxuXFxgJHtuYW1lfSguLi4pXFxgIGNhbm5vdCBiZSB1c2VkIGluIHJ1bmVzIG1vZGVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfbGVnYWN5X29ubHlgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3QgZG8gYGJpbmQ6JWtleSU9e3VuZGVmaW5lZH1gIHdoZW4gYCVrZXklYCBoYXMgYSBmYWxsYmFjayB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcHNfaW52YWxpZF92YWx1ZShrZXkpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBwcm9wc19pbnZhbGlkX3ZhbHVlXFxuQ2Fubm90IGRvIFxcYGJpbmQ6JHtrZXl9PXt1bmRlZmluZWR9XFxgIHdoZW4gXFxgJHtrZXl9XFxgIGhhcyBhIGZhbGxiYWNrIHZhbHVlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfaW52YWxpZF92YWx1ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19pbnZhbGlkX3ZhbHVlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXN0IGVsZW1lbnQgcHJvcGVydGllcyBvZiBgJHByb3BzKClgIHN1Y2ggYXMgYCVwcm9wZXJ0eSVgIGFyZSByZWFkb25seVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19yZXN0X3JlYWRvbmx5KHByb3BlcnR5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcHJvcHNfcmVzdF9yZWFkb25seVxcblJlc3QgZWxlbWVudCBwcm9wZXJ0aWVzIG9mIFxcYCRwcm9wcygpXFxgIHN1Y2ggYXMgXFxgJHtwcm9wZXJ0eX1cXGAgYXJlIHJlYWRvbmx5XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfcmVzdF9yZWFkb25seWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19yZXN0X3JlYWRvbmx5YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYCVydW5lJWAgcnVuZSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgYC5zdmVsdGVgIGFuZCBgLnN2ZWx0ZS5qcy90c2AgZmlsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBydW5lX291dHNpZGVfc3ZlbHRlXFxuVGhlIFxcYCR7cnVuZX1cXGAgcnVuZSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgXFxgLnN2ZWx0ZVxcYCBhbmQgXFxgLnN2ZWx0ZS5qcy90c1xcYCBmaWxlc1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3J1bmVfb3V0c2lkZV9zdmVsdGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcnVuZV9vdXRzaWRlX3N2ZWx0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogYHNldENvbnRleHRgIG11c3QgYmUgY2FsbGVkIHdoZW4gYSBjb21wb25lbnQgZmlyc3QgaW5pdGlhbGl6ZXMsIG5vdCBpbiBhIHN1YnNlcXVlbnQgZWZmZWN0IG9yIGFmdGVyIGFuIGBhd2FpdGAgZXhwcmVzc2lvblxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzZXRfY29udGV4dF9hZnRlcl9pbml0XFxuXFxgc2V0Q29udGV4dFxcYCBtdXN0IGJlIGNhbGxlZCB3aGVuIGEgY29tcG9uZW50IGZpcnN0IGluaXRpYWxpemVzLCBub3QgaW4gYSBzdWJzZXF1ZW50IGVmZmVjdCBvciBhZnRlciBhbiBcXGBhd2FpdFxcYCBleHByZXNzaW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zZXRfY29udGV4dF9hZnRlcl9pbml0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBQcm9wZXJ0eSBkZXNjcmlwdG9ycyBkZWZpbmVkIG9uIGAkc3RhdGVgIG9iamVjdHMgbXVzdCBjb250YWluIGB2YWx1ZWAgYW5kIGFsd2F5cyBiZSBgZW51bWVyYWJsZWAsIGBjb25maWd1cmFibGVgIGFuZCBgd3JpdGFibGVgLlxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRcXG5Qcm9wZXJ0eSBkZXNjcmlwdG9ycyBkZWZpbmVkIG9uIFxcYCRzdGF0ZVxcYCBvYmplY3RzIG11c3QgY29udGFpbiBcXGB2YWx1ZVxcYCBhbmQgYWx3YXlzIGJlIFxcYGVudW1lcmFibGVcXGAsIFxcYGNvbmZpZ3VyYWJsZVxcYCBhbmQgXFxgd3JpdGFibGVcXGAuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBzZXQgcHJvdG90eXBlIG9mIGAkc3RhdGVgIG9iamVjdFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX3Byb3RvdHlwZV9maXhlZFxcbkNhbm5vdCBzZXQgcHJvdG90eXBlIG9mIFxcYCRzdGF0ZVxcYCBvYmplY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm90b3R5cGVfZml4ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJvdG90eXBlX2ZpeGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBVcGRhdGluZyBzdGF0ZSBpbnNpZGUgYCRkZXJpdmVkKC4uLilgLCBgJGluc3BlY3QoLi4uKWAgb3IgYSB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIGZvcmJpZGRlbi4gSWYgdGhlIHZhbHVlIHNob3VsZCBub3QgYmUgcmVhY3RpdmUsIGRlY2xhcmUgaXQgd2l0aG91dCBgJHN0YXRlYFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfdW5zYWZlX211dGF0aW9uKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX3Vuc2FmZV9tdXRhdGlvblxcblVwZGF0aW5nIHN0YXRlIGluc2lkZSBcXGAkZGVyaXZlZCguLi4pXFxgLCBcXGAkaW5zcGVjdCguLi4pXFxgIG9yIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiBpcyBmb3JiaWRkZW4uIElmIHRoZSB2YWx1ZSBzaG91bGQgbm90IGJlIHJlYWN0aXZlLCBkZWNsYXJlIGl0IHdpdGhvdXQgXFxgJHN0YXRlXFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX211dGF0aW9uYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Vuc2FmZV9tdXRhdGlvbmApO1xuXHR9XG59XG5cbi8qKlxuICogQSBgPHN2ZWx0ZTpib3VuZGFyeT5gIGByZXNldGAgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCB3aGlsZSBhbiBlcnJvciBpcyBzdGlsbCBiZWluZyBoYW5kbGVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdmVsdGVfYm91bmRhcnlfcmVzZXRfb25lcnJvcigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdmVsdGVfYm91bmRhcnlfcmVzZXRfb25lcnJvclxcbkEgXFxgPHN2ZWx0ZTpib3VuZGFyeT5cXGAgXFxgcmVzZXRcXGAgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCB3aGlsZSBhbiBlcnJvciBpcyBzdGlsbCBiZWluZyBoYW5kbGVkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X29uZXJyb3JgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X29uZXJyb3JgKTtcblx0fVxufSIsICIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG52YXIgYm9sZCA9ICdmb250LXdlaWdodDogYm9sZCc7XG52YXIgbm9ybWFsID0gJ2ZvbnQtd2VpZ2h0OiBub3JtYWwnO1xuXG4vKipcbiAqIEFzc2lnbm1lbnQgdG8gYCVwcm9wZXJ0eSVgIHByb3BlcnR5ICglbG9jYXRpb24lKSB3aWxsIGV2YWx1YXRlIHRvIHRoZSByaWdodC1oYW5kIHNpZGUsIG5vdCB0aGUgdmFsdWUgb2YgYCVwcm9wZXJ0eSVgIGZvbGxvd2luZyB0aGUgYXNzaWdubWVudC4gVGhpcyBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbm1lbnRfdmFsdWVfc3RhbGUocHJvcGVydHksIGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gYXNzaWdubWVudF92YWx1ZV9zdGFsZVxcbiVjQXNzaWdubWVudCB0byBcXGAke3Byb3BlcnR5fVxcYCBwcm9wZXJ0eSAoJHtsb2NhdGlvbn0pIHdpbGwgZXZhbHVhdGUgdG8gdGhlIHJpZ2h0LWhhbmQgc2lkZSwgbm90IHRoZSB2YWx1ZSBvZiBcXGAke3Byb3BlcnR5fVxcYCBmb2xsb3dpbmcgdGhlIGFzc2lnbm1lbnQuIFRoaXMgbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hc3NpZ25tZW50X3ZhbHVlX3N0YWxlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2Fzc2lnbm1lbnRfdmFsdWVfc3RhbGVgKTtcblx0fVxufVxuXG4vKipcbiAqIERldGVjdGVkIHJlYWN0aXZpdHkgbG9zcyB3aGVuIHJlYWRpbmcgYCVuYW1lJWAuIFRoaXMgaGFwcGVucyB3aGVuIHN0YXRlIGlzIHJlYWQgaW4gYW4gYXN5bmMgZnVuY3Rpb24gYWZ0ZXIgYW4gZWFybGllciBgYXdhaXRgXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRfcmVhY3Rpdml0eV9sb3NzKG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBhd2FpdF9yZWFjdGl2aXR5X2xvc3NcXG4lY0RldGVjdGVkIHJlYWN0aXZpdHkgbG9zcyB3aGVuIHJlYWRpbmcgXFxgJHtuYW1lfVxcYC4gVGhpcyBoYXBwZW5zIHdoZW4gc3RhdGUgaXMgcmVhZCBpbiBhbiBhc3luYyBmdW5jdGlvbiBhZnRlciBhbiBlYXJsaWVyIFxcYGF3YWl0XFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXdhaXRfcmVhY3Rpdml0eV9sb3NzYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2F3YWl0X3JlYWN0aXZpdHlfbG9zc2ApO1xuXHR9XG59XG5cbi8qKlxuICogQW4gYXN5bmMgZGVyaXZlZCwgYCVuYW1lJWAgKCVsb2NhdGlvbiUpIHdhcyBub3QgcmVhZCBpbW1lZGlhdGVseSBhZnRlciBpdCByZXNvbHZlZC4gVGhpcyBvZnRlbiBpbmRpY2F0ZXMgYW4gdW5uZWNlc3Nhcnkgd2F0ZXJmYWxsLCB3aGljaCBjYW4gc2xvdyBkb3duIHlvdXIgYXBwXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdF93YXRlcmZhbGwobmFtZSwgbG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBhd2FpdF93YXRlcmZhbGxcXG4lY0FuIGFzeW5jIGRlcml2ZWQsIFxcYCR7bmFtZX1cXGAgKCR7bG9jYXRpb259KSB3YXMgbm90IHJlYWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFRoaXMgb2Z0ZW4gaW5kaWNhdGVzIGFuIHVubmVjZXNzYXJ5IHdhdGVyZmFsbCwgd2hpY2ggY2FuIHNsb3cgZG93biB5b3VyIGFwcFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2F3YWl0X3dhdGVyZmFsbGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9hd2FpdF93YXRlcmZhbGxgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlYmluZGluZyVgICglbG9jYXRpb24lKSBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gYmluZGluZ1xuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZShiaW5kaW5nLCBsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YCVjW3N2ZWx0ZV0gYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVcXG4lYyR7bG9jYXRpb25cblx0XHRcdFx0PyBgXFxgJHtiaW5kaW5nfVxcYCAoJHtsb2NhdGlvbn0pIGlzIGJpbmRpbmcgdG8gYSBub24tcmVhY3RpdmUgcHJvcGVydHlgXG5cdFx0XHRcdDogYFxcYCR7YmluZGluZ31cXGAgaXMgYmluZGluZyB0byBhIG5vbi1yZWFjdGl2ZSBwcm9wZXJ0eWB9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgLFxuXHRcdFx0Ym9sZCxcblx0XHRcdG5vcm1hbFxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWApO1xuXHR9XG59XG5cbi8qKlxuICogWW91ciBgY29uc29sZS4lbWV0aG9kJWAgY29udGFpbmVkIGAkc3RhdGVgIHByb3hpZXMuIENvbnNpZGVyIHVzaW5nIGAkaW5zcGVjdCguLi4pYCBvciBgJHN0YXRlLnNuYXBzaG90KC4uLilgIGluc3RlYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnNvbGVfbG9nX3N0YXRlKG1ldGhvZCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGNvbnNvbGVfbG9nX3N0YXRlXFxuJWNZb3VyIFxcYGNvbnNvbGUuJHttZXRob2R9XFxgIGNvbnRhaW5lZCBcXGAkc3RhdGVcXGAgcHJveGllcy4gQ29uc2lkZXIgdXNpbmcgXFxgJGluc3BlY3QoLi4uKVxcYCBvciBcXGAkc3RhdGUuc25hcHNob3QoLi4uKVxcYCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29uc29sZV9sb2dfc3RhdGVgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29uc29sZV9sb2dfc3RhdGVgKTtcblx0fVxufVxuXG4vKipcbiAqICVoYW5kbGVyJSBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBtZWFuIHRvICVzdWdnZXN0aW9uJT9cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3VnZ2VzdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRfaGFuZGxlcl9pbnZhbGlkKGhhbmRsZXIsIHN1Z2dlc3Rpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBldmVudF9oYW5kbGVyX2ludmFsaWRcXG4lYyR7aGFuZGxlcn0gc2hvdWxkIGJlIGEgZnVuY3Rpb24uIERpZCB5b3UgbWVhbiB0byAke3N1Z2dlc3Rpb259P1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2V2ZW50X2hhbmRsZXJfaW52YWxpZGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9ldmVudF9oYW5kbGVyX2ludmFsaWRgKTtcblx0fVxufVxuXG4vKipcbiAqIEV4cGVjdGVkIHRvIGZpbmQgYSBoeWRyYXRhYmxlIHdpdGgga2V5IGAla2V5JWAgZHVyaW5nIGh5ZHJhdGlvbiwgYnV0IGRpZCBub3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRhYmxlX21pc3NpbmdfYnV0X2V4cGVjdGVkKGtleSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGh5ZHJhdGFibGVfbWlzc2luZ19idXRfZXhwZWN0ZWRcXG4lY0V4cGVjdGVkIHRvIGZpbmQgYSBoeWRyYXRhYmxlIHdpdGgga2V5IFxcYCR7a2V5fVxcYCBkdXJpbmcgaHlkcmF0aW9uLCBidXQgZGlkIG5vdC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRhYmxlX21pc3NpbmdfYnV0X2V4cGVjdGVkYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGFibGVfbWlzc2luZ19idXRfZXhwZWN0ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgJWF0dHJpYnV0ZSVgIGF0dHJpYnV0ZSBvbiBgJWh0bWwlYCBjaGFuZ2VkIGl0cyB2YWx1ZSBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUsIGAldmFsdWUlYCwgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWQoYXR0cmlidXRlLCBodG1sLCB2YWx1ZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZFxcbiVjVGhlIFxcYCR7YXR0cmlidXRlfVxcYCBhdHRyaWJ1dGUgb24gXFxgJHtodG1sfVxcYCBjaGFuZ2VkIGl0cyB2YWx1ZSBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUsIFxcYCR7dmFsdWV9XFxgLCB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgdmFsdWUgb2YgYW4gYHtAaHRtbCAuLi59YCBibG9jayAlbG9jYXRpb24lIGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25faHRtbF9jaGFuZ2VkKGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRgJWNbc3ZlbHRlXSBoeWRyYXRpb25faHRtbF9jaGFuZ2VkXFxuJWMke2xvY2F0aW9uXG5cdFx0XHRcdD8gYFRoZSB2YWx1ZSBvZiBhbiBcXGB7QGh0bWwgLi4ufVxcYCBibG9jayAke2xvY2F0aW9ufSBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVgXG5cdFx0XHRcdDogJ1RoZSB2YWx1ZSBvZiBhbiBge0BodG1sIC4uLn1gIGJsb2NrIGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZSd9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2h0bWxfY2hhbmdlZGAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9odG1sX2NoYW5nZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIEh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgZXJyb3Igb2NjdXJyZWQgbmVhciAlbG9jYXRpb24lXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtsb2NhdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9taXNtYXRjaChsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX21pc21hdGNoXFxuJWMke2xvY2F0aW9uXG5cdFx0XHRcdD8gYEh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgZXJyb3Igb2NjdXJyZWQgbmVhciAke2xvY2F0aW9ufWBcblx0XHRcdFx0OiAnSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXInfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9taXNtYXRjaGAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9taXNtYXRjaGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGByZW5kZXJgIGZ1bmN0aW9uIHBhc3NlZCB0byBgY3JlYXRlUmF3U25pcHBldGAgc2hvdWxkIHJldHVybiBIVE1MIGZvciBhIHNpbmdsZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBpbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlclxcbiVjVGhlIFxcYHJlbmRlclxcYCBmdW5jdGlvbiBwYXNzZWQgdG8gXFxgY3JlYXRlUmF3U25pcHBldFxcYCBzaG91bGQgcmV0dXJuIEhUTUwgZm9yIGEgc2luZ2xlIGVsZW1lbnRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcmAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcmApO1xuXHR9XG59XG5cbi8qKlxuICogRGV0ZWN0ZWQgYSBtaWdyYXRlZCBgJDpgIHJlYWN0aXZlIGJsb2NrIGluIGAlZmlsZW5hbWUlYCB0aGF0IGJvdGggYWNjZXNzZXMgYW5kIHVwZGF0ZXMgdGhlIHNhbWUgcmVhY3RpdmUgdmFsdWUuIFRoaXMgbWF5IGNhdXNlIHJlY3Vyc2l2ZSB1cGRhdGVzIHdoZW4gY29udmVydGVkIHRvIGFuIGAkZWZmZWN0YC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9jayhmaWxlbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tcXG4lY0RldGVjdGVkIGEgbWlncmF0ZWQgXFxgJDpcXGAgcmVhY3RpdmUgYmxvY2sgaW4gXFxgJHtmaWxlbmFtZX1cXGAgdGhhdCBib3RoIGFjY2Vzc2VzIGFuZCB1cGRhdGVzIHRoZSBzYW1lIHJlYWN0aXZlIHZhbHVlLiBUaGlzIG1heSBjYXVzZSByZWN1cnNpdmUgdXBkYXRlcyB3aGVuIGNvbnZlcnRlZCB0byBhbiBcXGAkZWZmZWN0XFxgLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9ja2ApO1xuXHR9XG59XG5cbi8qKlxuICogVHJpZWQgdG8gdW5tb3VudCBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgbW91bnRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGxpZmVjeWNsZV9kb3VibGVfdW5tb3VudFxcbiVjVHJpZWQgdG8gdW5tb3VudCBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgbW91bnRlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9kb3VibGVfdW5tb3VudGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfZG91YmxlX3VubW91bnRgKTtcblx0fVxufVxuXG4vKipcbiAqICVwYXJlbnQlIHBhc3NlZCBwcm9wZXJ0eSBgJXByb3AlYCB0byAlY2hpbGQlIHdpdGggYGJpbmQ6YCwgYnV0IGl0cyBwYXJlbnQgY29tcG9uZW50ICVvd25lciUgZGlkIG5vdCBkZWNsYXJlIGAlcHJvcCVgIGFzIGEgYmluZGluZy4gQ29uc2lkZXIgY3JlYXRpbmcgYSBiaW5kaW5nIGJldHdlZW4gJW93bmVyJSBhbmQgJXBhcmVudCUgKGUuZy4gYGJpbmQ6JXByb3AlPXsuLi59YCBpbnN0ZWFkIG9mIGAlcHJvcCU9ey4uLn1gKVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZFxuICogQHBhcmFtIHtzdHJpbmd9IG93bmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nKHBhcmVudCwgcHJvcCwgY2hpbGQsIG93bmVyKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gb3duZXJzaGlwX2ludmFsaWRfYmluZGluZ1xcbiVjJHtwYXJlbnR9IHBhc3NlZCBwcm9wZXJ0eSBcXGAke3Byb3B9XFxgIHRvICR7Y2hpbGR9IHdpdGggXFxgYmluZDpcXGAsIGJ1dCBpdHMgcGFyZW50IGNvbXBvbmVudCAke293bmVyfSBkaWQgbm90IGRlY2xhcmUgXFxgJHtwcm9wfVxcYCBhcyBhIGJpbmRpbmcuIENvbnNpZGVyIGNyZWF0aW5nIGEgYmluZGluZyBiZXR3ZWVuICR7b3duZXJ9IGFuZCAke3BhcmVudH0gKGUuZy4gXFxgYmluZDoke3Byb3B9PXsuLi59XFxgIGluc3RlYWQgb2YgXFxgJHtwcm9wfT17Li4ufVxcYClcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmdgKTtcblx0fVxufVxuXG4vKipcbiAqIE11dGF0aW5nIHVuYm91bmQgcHJvcHMgKGAlbmFtZSVgLCBhdCAlbG9jYXRpb24lKSBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gQ29uc2lkZXIgdXNpbmcgYGJpbmQ6JXByb3AlPXsuLi59YCBpbiAlcGFyZW50JSAob3IgdXNpbmcgYSBjYWxsYmFjaykgaW5zdGVhZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uKG5hbWUsIGxvY2F0aW9uLCBwcm9wLCBwYXJlbnQpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBvd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvblxcbiVjTXV0YXRpbmcgdW5ib3VuZCBwcm9wcyAoXFxgJHtuYW1lfVxcYCwgYXQgJHtsb2NhdGlvbn0pIGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkLiBDb25zaWRlciB1c2luZyBcXGBiaW5kOiR7cHJvcH09ey4uLn1cXGAgaW4gJHtwYXJlbnR9IChvciB1c2luZyBhIGNhbGxiYWNrKSBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb25gLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb25gKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIGEgYDxzZWxlY3QgbXVsdGlwbGU+YCBlbGVtZW50IHNob3VsZCBiZSBhbiBhcnJheSwgYnV0IGl0IHJlY2VpdmVkIGEgbm9uLWFycmF5IHZhbHVlLiBUaGUgc2VsZWN0aW9uIHdpbGwgYmUga2VwdCBhcyBpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV9pbnZhbGlkX3ZhbHVlKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHNlbGVjdF9tdWx0aXBsZV9pbnZhbGlkX3ZhbHVlXFxuJWNUaGUgXFxgdmFsdWVcXGAgcHJvcGVydHkgb2YgYSBcXGA8c2VsZWN0IG11bHRpcGxlPlxcYCBlbGVtZW50IHNob3VsZCBiZSBhbiBhcnJheSwgYnV0IGl0IHJlY2VpdmVkIGEgbm9uLWFycmF5IHZhbHVlLiBUaGUgc2VsZWN0aW9uIHdpbGwgYmUga2VwdCBhcyBpcy5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zZWxlY3RfbXVsdGlwbGVfaW52YWxpZF92YWx1ZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zZWxlY3RfbXVsdGlwbGVfaW52YWxpZF92YWx1ZWApO1xuXHR9XG59XG5cbi8qKlxuICogUmVhY3RpdmUgYCRzdGF0ZSguLi4pYCBwcm94aWVzIGFuZCB0aGUgdmFsdWVzIHRoZXkgcHJveHkgaGF2ZSBkaWZmZXJlbnQgaWRlbnRpdGllcy4gQmVjYXVzZSBvZiB0aGlzLCBjb21wYXJpc29ucyB3aXRoIGAlb3BlcmF0b3IlYCB3aWxsIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKG9wZXJhdG9yKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hcXG4lY1JlYWN0aXZlIFxcYCRzdGF0ZSguLi4pXFxgIHByb3hpZXMgYW5kIHRoZSB2YWx1ZXMgdGhleSBwcm94eSBoYXZlIGRpZmZlcmVudCBpZGVudGl0aWVzLiBCZWNhdXNlIG9mIHRoaXMsIGNvbXBhcmlzb25zIHdpdGggXFxgJHtvcGVyYXRvcn1cXGAgd2lsbCBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0c1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUcmllZCB0byB1bm1vdW50IGEgc3RhdGUgcHJveHksIHJhdGhlciB0aGFuIGEgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9wcm94eV91bm1vdW50KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHN0YXRlX3Byb3h5X3VubW91bnRcXG4lY1RyaWVkIHRvIHVubW91bnQgYSBzdGF0ZSBwcm94eSwgcmF0aGVyIHRoYW4gYSBjb21wb25lbnRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm94eV91bm1vdW50YCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X3VubW91bnRgKTtcblx0fVxufVxuXG4vKipcbiAqIEEgYDxzdmVsdGU6Ym91bmRhcnk+YCBgcmVzZXRgIGZ1bmN0aW9uIG9ubHkgcmVzZXRzIHRoZSBib3VuZGFyeSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wXFxuJWNBIFxcYDxzdmVsdGU6Ym91bmRhcnk+XFxgIFxcYHJlc2V0XFxgIGZ1bmN0aW9uIG9ubHkgcmVzZXRzIHRoZSBib3VuZGFyeSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfYm91bmRhcnlfcmVzZXRfbm9vcGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfYm91bmRhcnlfcmVzZXRfbm9vcGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGBzbGlkZWAgdHJhbnNpdGlvbiBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSBmb3IgZWxlbWVudHMgd2l0aCBgZGlzcGxheTogJXZhbHVlJWBcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5KHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gdHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5XFxuJWNUaGUgXFxgc2xpZGVcXGAgdHJhbnNpdGlvbiBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSBmb3IgZWxlbWVudHMgd2l0aCBcXGBkaXNwbGF5OiAke3ZhbHVlfVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3RyYW5zaXRpb25fc2xpZGVfZGlzcGxheWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS90cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXlgKTtcblx0fVxufSIsICIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5cbmltcG9ydCB7IENPTU1FTlRfTk9ERSB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7XG5cdEhZRFJBVElPTl9FTkQsXG5cdEhZRFJBVElPTl9FUlJPUixcblx0SFlEUkFUSU9OX1NUQVJULFxuXHRIWURSQVRJT05fU1RBUlRfRUxTRVxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi9vcGVyYXRpb25zLmpzJztcblxuLyoqXG4gKiBVc2UgdGhpcyB2YXJpYWJsZSB0byBndWFyZCBldmVyeXRoaW5nIHJlbGF0ZWQgdG8gaHlkcmF0aW9uIGNvZGUgc28gaXQgY2FuIGJlIHRyZWVzaGFrZW4gb3V0XG4gKiBpZiB0aGUgdXNlciBkb2Vzbid0IHVzZSB0aGUgYGh5ZHJhdGVgIG1ldGhvZCBhbmQgdGhlc2UgY29kZSBwYXRocyBhcmUgdGhlcmVmb3JlIG5vdCBuZWVkZWQuXG4gKi9cbmV4cG9ydCBsZXQgaHlkcmF0aW5nID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2h5ZHJhdGluZyh2YWx1ZSkge1xuXHRoeWRyYXRpbmcgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgbm9kZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBoeWRyYXRlZC4gVGhpcyBzdGFydHMgb3V0IGFzIHRoZSBmaXJzdCBub2RlIGluc2lkZSB0aGUgb3BlbmluZ1xuICogPCEtLVstLT4gY29tbWVudCwgYW5kIHVwZGF0ZXMgZWFjaCB0aW1lIGEgY29tcG9uZW50IGNhbGxzIGAkLmNoaWxkKC4uLilgIG9yIGAkLnNpYmxpbmcoLi4uKWAuXG4gKiBXaGVuIGVudGVyaW5nIGEgYmxvY2sgKGUuZy4gYHsjaWYgLi4ufWApLCBgaHlkcmF0ZV9ub2RlYCBpcyB0aGUgYmxvY2sgb3BlbmluZyBjb21tZW50OyBieSB0aGVcbiAqIHRpbWUgd2UgbGVhdmUgdGhlIGJsb2NrIGl0IGlzIHRoZSBjbG9zaW5nIGNvbW1lbnQsIHdoaWNoIHNlcnZlcyBhcyB0aGUgYmxvY2sncyBhbmNob3IuXG4gKiBAdHlwZSB7VGVtcGxhdGVOb2RlfVxuICovXG5leHBvcnQgbGV0IGh5ZHJhdGVfbm9kZTtcblxuLyoqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2h5ZHJhdGVfbm9kZShub2RlKSB7XG5cdGlmIChub2RlID09PSBudWxsKSB7XG5cdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHR0aHJvdyBIWURSQVRJT05fRVJST1I7XG5cdH1cblxuXHRyZXR1cm4gKGh5ZHJhdGVfbm9kZSA9IG5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZV9uZXh0KCkge1xuXHRyZXR1cm4gc2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoaHlkcmF0ZV9ub2RlKSkpO1xufVxuXG4vKiogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGUgKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldChub2RlKSB7XG5cdGlmICghaHlkcmF0aW5nKSByZXR1cm47XG5cblx0Ly8gSWYgdGhlIG5vZGUgaGFzIHJlbWFpbmluZyBzaWJsaW5ncywgc29tZXRoaW5nIGhhcyBnb25lIHdyb25nXG5cdGlmIChnZXRfbmV4dF9zaWJsaW5nKGh5ZHJhdGVfbm9kZSkgIT09IG51bGwpIHtcblx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0fVxuXG5cdGh5ZHJhdGVfbm9kZSA9IG5vZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZV90ZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUZW1wbGF0ZU5vZGUgZG9lc24ndCBpbmNsdWRlIERvY3VtZW50RnJhZ21lbnQsIGJ1dCBpdCdzIGFjdHVhbGx5IGZpbmVcblx0XHRoeWRyYXRlX25vZGUgPSB0ZW1wbGF0ZS5jb250ZW50O1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXh0KGNvdW50ID0gMSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0dmFyIGkgPSBjb3VudDtcblx0XHR2YXIgbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdG5vZGUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXHRcdH1cblxuXHRcdGh5ZHJhdGVfbm9kZSA9IG5vZGU7XG5cdH1cbn1cblxuLyoqXG4gKiBTa2lwcyBvciByZW1vdmVzIChkZXBlbmRpbmcgb24ge0BsaW5rIHJlbW92ZX0pIGFsbCBub2RlcyBzdGFydGluZyBhdCBgaHlkcmF0ZV9ub2RlYCB1cCB1bnRpbCB0aGUgbmV4dCBoeWRyYXRpb24gZW5kIGNvbW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBza2lwX25vZGVzKHJlbW92ZSA9IHRydWUpIHtcblx0dmFyIGRlcHRoID0gMDtcblx0dmFyIG5vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0d2hpbGUgKHRydWUpIHtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG5cdFx0XHR2YXIgZGF0YSA9IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5vZGUpLmRhdGE7XG5cblx0XHRcdGlmIChkYXRhID09PSBIWURSQVRJT05fRU5EKSB7XG5cdFx0XHRcdGlmIChkZXB0aCA9PT0gMCkgcmV0dXJuIG5vZGU7XG5cdFx0XHRcdGRlcHRoIC09IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGEgPT09IEhZRFJBVElPTl9TVEFSVCB8fCBkYXRhID09PSBIWURSQVRJT05fU1RBUlRfRUxTRSkge1xuXHRcdFx0XHRkZXB0aCArPSAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBuZXh0ID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblx0XHRpZiAocmVtb3ZlKSBub2RlLnJlbW92ZSgpO1xuXHRcdG5vZGUgPSBuZXh0O1xuXHR9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkX2h5ZHJhdGlvbl9pbnN0cnVjdGlvbihub2RlKSB7XG5cdGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcblx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0fVxuXG5cdHJldHVybiAvKiogQHR5cGUge0NvbW1lbnR9ICovIChub2RlKS5kYXRhO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRXF1YWxzIH0gZnJvbSAnI2NsaWVudCcgKi9cblxuLyoqIEB0eXBlIHtFcXVhbHN9ICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gdGhpcy52O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gYVxuICogQHBhcmFtIHt1bmtub3dufSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVfbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT0gYVxuXHRcdD8gYiA9PSBiXG5cdFx0OiBhICE9PSBiIHx8IChhICE9PSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBhXG4gKiBAcGFyYW0ge3Vua25vd259IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT09IGI7XG59XG5cbi8qKiBAdHlwZSB7RXF1YWxzfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVfZXF1YWxzKHZhbHVlKSB7XG5cdHJldHVybiAhc2FmZV9ub3RfZXF1YWwodmFsdWUsIHRoaXMudik7XG59XG4iLCAiLyoqIFRydWUgaWYgZXhwZXJpbWVudGFsLmFzeW5jPXRydWUgKi9cbmV4cG9ydCBsZXQgYXN5bmNfbW9kZV9mbGFnID0gZmFsc2U7XG4vKiogVHJ1ZSBpZiB3ZSdyZSBub3QgY2VydGFpbiB0aGF0IHdlIG9ubHkgaGF2ZSBTdmVsdGUgNSBjb2RlIGluIHRoZSBjb21waWxhdGlvbiAqL1xuZXhwb3J0IGxldCBsZWdhY3lfbW9kZV9mbGFnID0gZmFsc2U7XG4vKiogVHJ1ZSBpZiAkaW5zcGVjdC50cmFjZSBpcyB1c2VkICovXG5leHBvcnQgbGV0IHRyYWNpbmdfbW9kZV9mbGFnID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVfYXN5bmNfbW9kZV9mbGFnKCkge1xuXHRhc3luY19tb2RlX2ZsYWcgPSB0cnVlO1xufVxuXG4vKiogT05MWSBVU0UgVEhJUyBEVVJJTkcgVEVTVElORyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVfYXN5bmNfbW9kZV9mbGFnKCkge1xuXHRhc3luY19tb2RlX2ZsYWcgPSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZV9sZWdhY3lfbW9kZV9mbGFnKCkge1xuXHRsZWdhY3lfbW9kZV9mbGFnID0gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZV90cmFjaW5nX21vZGVfZmxhZygpIHtcblx0dHJhY2luZ19tb2RlX2ZsYWcgPSB0cnVlO1xufVxuIiwgIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbnZhciBib2xkID0gJ2ZvbnQtd2VpZ2h0OiBib2xkJztcbnZhciBub3JtYWwgPSAnZm9udC13ZWlnaHQ6IG5vcm1hbCc7XG5cbi8qKlxuICogYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJXRhZyVcIj5gIGlzIGEgdm9pZCBlbGVtZW50IFx1MjAxNCBpdCBjYW5ub3QgaGF2ZSBjb250ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50KHRhZykge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGR5bmFtaWNfdm9pZF9lbGVtZW50X2NvbnRlbnRcXG4lY1xcYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJHt0YWd9XCI+XFxgIGlzIGEgdm9pZCBlbGVtZW50IFx1MjAxNCBpdCBjYW5ub3QgaGF2ZSBjb250ZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9keW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIGNsb25lZCB3aXRoIGAkc3RhdGUuc25hcHNob3RgIFx1MjAxNCB0aGUgcmV0dXJuIHZhbHVlIGNvbnRhaW5zIHRoZSBvcmlnaW5hbHM6XG4gKiBcbiAqICVwcm9wZXJ0aWVzJVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbcHJvcGVydGllc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKHByb3BlcnRpZXMpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGAlY1tzdmVsdGVdIHN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlXFxuJWMke3Byb3BlcnRpZXNcblx0XHRcdFx0PyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBjbG9uZWQgd2l0aCBcXGAkc3RhdGUuc25hcHNob3RcXGAgXHUyMDE0IHRoZSByZXR1cm4gdmFsdWUgY29udGFpbnMgdGhlIG9yaWdpbmFsczpcblxuJHtwcm9wZXJ0aWVzfWBcblx0XHRcdFx0OiAnVmFsdWUgY2Fubm90IGJlIGNsb25lZCB3aXRoIGAkc3RhdGUuc25hcHNob3RgIFx1MjAxNCB0aGUgb3JpZ2luYWwgdmFsdWUgd2FzIHJldHVybmVkJ31cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZWAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlYCk7XG5cdH1cbn0iLCAiLyoqIEBpbXBvcnQgeyBTbmFwc2hvdCB9IGZyb20gJy4vdHlwZXMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBnZXRfcHJvdG90eXBlX29mLCBpc19hcnJheSwgb2JqZWN0X3Byb3RvdHlwZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEluIGRldiwgd2Uga2VlcCB0cmFjayBvZiB3aGljaCBwcm9wZXJ0aWVzIGNvdWxkIG5vdCBiZSBjbG9uZWQuIEluIHByb2RcbiAqIHdlIGRvbid0IGJvdGhlciwgYnV0IHdlIGtlZXAgYSBkdW1teSBhcnJheSBhcm91bmQgc28gdGhhdCB0aGVcbiAqIHNpZ25hdHVyZSBzdGF5cyB0aGUgc2FtZVxuICogQHR5cGUge3N0cmluZ1tdfVxuICovXG5jb25zdCBlbXB0eSA9IFtdO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtub190b2pzb25dXG4gKiBAcmV0dXJucyB7U25hcHNob3Q8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmFwc2hvdCh2YWx1ZSwgc2tpcF93YXJuaW5nID0gZmFsc2UsIG5vX3RvanNvbiA9IGZhbHNlKSB7XG5cdGlmIChERVYgJiYgIXNraXBfd2FybmluZykge1xuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgcGF0aHMgPSBbXTtcblxuXHRcdGNvbnN0IGNvcHkgPSBjbG9uZSh2YWx1ZSwgbmV3IE1hcCgpLCAnJywgcGF0aHMsIG51bGwsIG5vX3RvanNvbik7XG5cdFx0aWYgKHBhdGhzLmxlbmd0aCA9PT0gMSAmJiBwYXRoc1swXSA9PT0gJycpIHtcblx0XHRcdC8vIHZhbHVlIGNvdWxkIG5vdCBiZSBjbG9uZWRcblx0XHRcdHcuc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUoKTtcblx0XHR9IGVsc2UgaWYgKHBhdGhzLmxlbmd0aCA+IDApIHtcblx0XHRcdC8vIHNvbWUgcHJvcGVydGllcyBjb3VsZCBub3QgYmUgY2xvbmVkXG5cdFx0XHRjb25zdCBzbGljZSA9IHBhdGhzLmxlbmd0aCA+IDEwID8gcGF0aHMuc2xpY2UoMCwgNykgOiBwYXRocy5zbGljZSgwLCAxMCk7XG5cdFx0XHRjb25zdCBleGNlc3MgPSBwYXRocy5sZW5ndGggLSBzbGljZS5sZW5ndGg7XG5cblx0XHRcdGxldCB1bmNsb25lZCA9IHNsaWNlLm1hcCgocGF0aCkgPT4gYC0gPHZhbHVlPiR7cGF0aH1gKS5qb2luKCdcXG4nKTtcblx0XHRcdGlmIChleGNlc3MgPiAwKSB1bmNsb25lZCArPSBgXFxuLSAuLi5hbmQgJHtleGNlc3N9IG1vcmVgO1xuXG5cdFx0XHR3LnN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKHVuY2xvbmVkKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29weTtcblx0fVxuXG5cdHJldHVybiBjbG9uZSh2YWx1ZSwgbmV3IE1hcCgpLCAnJywgZW1wdHksIG51bGwsIG5vX3RvanNvbik7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7TWFwPFQsIFNuYXBzaG90PFQ+Pn0gY2xvbmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHNcbiAqIEBwYXJhbSB7bnVsbCB8IFR9IFtvcmlnaW5hbF0gVGhlIG9yaWdpbmFsIHZhbHVlLCBpZiBgdmFsdWVgIHdhcyBwcm9kdWNlZCBmcm9tIGEgYHRvSlNPTmAgY2FsbFxuICogQHBhcmFtIHtib29sZWFufSBbbm9fdG9qc29uXVxuICogQHJldHVybnMge1NuYXBzaG90PFQ+fVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSwgY2xvbmVkLCBwYXRoLCBwYXRocywgb3JpZ2luYWwgPSBudWxsLCBub190b2pzb24gPSBmYWxzZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHZhciB1bndyYXBwZWQgPSBjbG9uZWQuZ2V0KHZhbHVlKTtcblx0XHRpZiAodW53cmFwcGVkICE9PSB1bmRlZmluZWQpIHJldHVybiB1bndyYXBwZWQ7XG5cblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAobmV3IE1hcCh2YWx1ZSkpO1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkgcmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovIChuZXcgU2V0KHZhbHVlKSk7XG5cblx0XHRpZiAoaXNfYXJyYXkodmFsdWUpKSB7XG5cdFx0XHR2YXIgY29weSA9IC8qKiBAdHlwZSB7U25hcHNob3Q8YW55Pn0gKi8gKEFycmF5KHZhbHVlLmxlbmd0aCkpO1xuXHRcdFx0Y2xvbmVkLnNldCh2YWx1ZSwgY29weSk7XG5cblx0XHRcdGlmIChvcmlnaW5hbCAhPT0gbnVsbCkge1xuXHRcdFx0XHRjbG9uZWQuc2V0KG9yaWdpbmFsLCBjb3B5KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHZhbHVlW2ldO1xuXHRcdFx0XHRpZiAoaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGNvcHlbaV0gPSBjbG9uZShlbGVtZW50LCBjbG9uZWQsIERFViA/IGAke3BhdGh9WyR7aX1dYCA6IHBhdGgsIHBhdGhzLCBudWxsLCBub190b2pzb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH1cblxuXHRcdGlmIChnZXRfcHJvdG90eXBlX29mKHZhbHVlKSA9PT0gb2JqZWN0X3Byb3RvdHlwZSkge1xuXHRcdFx0LyoqIEB0eXBlIHtTbmFwc2hvdDxhbnk+fSAqL1xuXHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0Y2xvbmVkLnNldCh2YWx1ZSwgY29weSk7XG5cblx0XHRcdGlmIChvcmlnaW5hbCAhPT0gbnVsbCkge1xuXHRcdFx0XHRjbG9uZWQuc2V0KG9yaWdpbmFsLCBjb3B5KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRcdGNvcHlba2V5XSA9IGNsb25lKFxuXHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHR2YWx1ZVtrZXldLFxuXHRcdFx0XHRcdGNsb25lZCxcblx0XHRcdFx0XHRERVYgPyBgJHtwYXRofS4ke2tleX1gIDogcGF0aCxcblx0XHRcdFx0XHRwYXRocyxcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdG5vX3RvanNvblxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29weTtcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSkpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgKC8qKiBAdHlwZSB7VCAmIHsgdG9KU09OPzogYW55IH0gfSAqLyAodmFsdWUpLnRvSlNPTikgPT09ICdmdW5jdGlvbicgJiYgIW5vX3RvanNvbikge1xuXHRcdFx0cmV0dXJuIGNsb25lKFxuXHRcdFx0XHQvKiogQHR5cGUge1QgJiB7IHRvSlNPTigpOiBhbnkgfSB9ICovICh2YWx1ZSkudG9KU09OKCksXG5cdFx0XHRcdGNsb25lZCxcblx0XHRcdFx0REVWID8gYCR7cGF0aH0udG9KU09OKClgIDogcGF0aCxcblx0XHRcdFx0cGF0aHMsXG5cdFx0XHRcdC8vIEFzc29jaWF0ZSB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgdG9KU09OIGNsb25lXG5cdFx0XHRcdHZhbHVlXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG5cdFx0Ly8gY2FuJ3QgYmUgY2xvbmVkXG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovICh2YWx1ZSk7XG5cdH1cblxuXHR0cnkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAoc3RydWN0dXJlZENsb25lKHZhbHVlKSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAodmFsdWUpO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBSZWFjdGlvbiwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBzbmFwc2hvdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jbG9uZS5qcyc7XG5pbXBvcnQgeyBERVJJVkVELCBBU1lOQywgUFJPWFlfUEFUSF9TWU1CT0wsIFNUQVRFX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGVmZmVjdF90cmFja2luZyB9IGZyb20gJy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfcmVhY3Rpb24sIHVudHJhY2sgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB0cmFjZXM6IEVycm9yW107XG4gKiB9fSBUcmFjZUVudHJ5XG4gKi9cblxuLyoqIEB0eXBlIHt7IHJlYWN0aW9uOiBSZWFjdGlvbiB8IG51bGwsIGVudHJpZXM6IE1hcDxWYWx1ZSwgVHJhY2VFbnRyeT4gfSB8IG51bGx9ICovXG5leHBvcnQgbGV0IHRyYWNpbmdfZXhwcmVzc2lvbnMgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7VmFsdWV9IHNpZ25hbFxuICogQHBhcmFtIHtUcmFjZUVudHJ5fSBbZW50cnldXG4gKi9cbmZ1bmN0aW9uIGxvZ19lbnRyeShzaWduYWwsIGVudHJ5KSB7XG5cdGNvbnN0IHZhbHVlID0gc2lnbmFsLnY7XG5cblx0aWYgKHZhbHVlID09PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgdHlwZSA9IGdldF90eXBlKHNpZ25hbCk7XG5cdGNvbnN0IGN1cnJlbnRfcmVhY3Rpb24gPSAvKiogQHR5cGUge1JlYWN0aW9ufSAqLyAoYWN0aXZlX3JlYWN0aW9uKTtcblx0Y29uc3QgZGlydHkgPSBzaWduYWwud3YgPiBjdXJyZW50X3JlYWN0aW9uLnd2IHx8IGN1cnJlbnRfcmVhY3Rpb24ud3YgPT09IDA7XG5cdGNvbnN0IHN0eWxlID0gZGlydHlcblx0XHQ/ICdjb2xvcjogQ29ybmZsb3dlckJsdWU7IGZvbnQtd2VpZ2h0OiBib2xkJ1xuXHRcdDogJ2NvbG9yOiBncmV5OyBmb250LXdlaWdodDogbm9ybWFsJztcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuXHRcdHNpZ25hbC5sYWJlbCA/IGAlYyR7dHlwZX0lYyAke3NpZ25hbC5sYWJlbH1gIDogYCVjJHt0eXBlfSVjYCxcblx0XHRzdHlsZSxcblx0XHRkaXJ0eSA/ICdmb250LXdlaWdodDogbm9ybWFsJyA6IHN0eWxlLFxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgU1RBVEVfU1lNQk9MIGluIHZhbHVlXG5cdFx0XHQ/IHNuYXBzaG90KHZhbHVlLCB0cnVlKVxuXHRcdFx0OiB2YWx1ZVxuXHQpO1xuXG5cdGlmICh0eXBlID09PSAnJGRlcml2ZWQnKSB7XG5cdFx0Y29uc3QgZGVwcyA9IG5ldyBTZXQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKS5kZXBzKTtcblx0XHRmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG5cdFx0XHRsb2dfZW50cnkoZGVwKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoc2lnbmFsLmNyZWF0ZWQpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdGNvbnNvbGUubG9nKHNpZ25hbC5jcmVhdGVkKTtcblx0fVxuXG5cdGlmIChkaXJ0eSAmJiBzaWduYWwudXBkYXRlZCkge1xuXHRcdGZvciAoY29uc3QgdXBkYXRlZCBvZiBzaWduYWwudXBkYXRlZC52YWx1ZXMoKSkge1xuXHRcdFx0aWYgKHVwZGF0ZWQuZXJyb3IpIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdFx0Y29uc29sZS5sb2codXBkYXRlZC5lcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGVudHJ5KSB7XG5cdFx0Zm9yICh2YXIgdHJhY2Ugb2YgZW50cnkudHJhY2VzKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS5sb2codHJhY2UpO1xuXHRcdH1cblx0fVxuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdGNvbnNvbGUuZ3JvdXBFbmQoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzaWduYWxcbiAqIEByZXR1cm5zIHsnJHN0YXRlJyB8ICckZGVyaXZlZCcgfCAnc3RvcmUnfVxuICovXG5mdW5jdGlvbiBnZXRfdHlwZShzaWduYWwpIHtcblx0aWYgKChzaWduYWwuZiAmIChERVJJVkVEIHwgQVNZTkMpKSAhPT0gMCkgcmV0dXJuICckZGVyaXZlZCc7XG5cdHJldHVybiBzaWduYWwubGFiZWw/LnN0YXJ0c1dpdGgoJyQnKSA/ICdzdG9yZScgOiAnJHN0YXRlJztcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGxhYmVsXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFjZShsYWJlbCwgZm4pIHtcblx0dmFyIHByZXZpb3VzbHlfdHJhY2luZ19leHByZXNzaW9ucyA9IHRyYWNpbmdfZXhwcmVzc2lvbnM7XG5cblx0dHJ5IHtcblx0XHR0cmFjaW5nX2V4cHJlc3Npb25zID0geyBlbnRyaWVzOiBuZXcgTWFwKCksIHJlYWN0aW9uOiBhY3RpdmVfcmVhY3Rpb24gfTtcblxuXHRcdHZhciBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdHZhciB2YWx1ZSA9IGZuKCk7XG5cdFx0dmFyIHRpbWUgPSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkudG9GaXhlZCgyKTtcblxuXHRcdHZhciBwcmVmaXggPSB1bnRyYWNrKGxhYmVsKTtcblxuXHRcdGlmICghZWZmZWN0X3RyYWNraW5nKCkpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmxvZyhgJHtwcmVmaXh9ICVjcmFuIG91dHNpZGUgb2YgYW4gZWZmZWN0ICgke3RpbWV9bXMpYCwgJ2NvbG9yOiBncmV5Jyk7XG5cdFx0fSBlbHNlIGlmICh0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXMuc2l6ZSA9PT0gMCkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUubG9nKGAke3ByZWZpeH0gJWNubyByZWFjdGl2ZSBkZXBlbmRlbmNpZXMgKCR7dGltZX1tcylgLCAnY29sb3I6IGdyZXknKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUuZ3JvdXAoYCR7cHJlZml4fSAlYygke3RpbWV9bXMpYCwgJ2NvbG9yOiBncmV5Jyk7XG5cblx0XHRcdHZhciBlbnRyaWVzID0gdHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzO1xuXG5cdFx0XHR1bnRyYWNrKCgpID0+IHtcblx0XHRcdFx0Zm9yIChjb25zdCBbc2lnbmFsLCB0cmFjZXNdIG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRsb2dfZW50cnkoc2lnbmFsLCB0cmFjZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dHJhY2luZ19leHByZXNzaW9ucyA9IG51bGw7XG5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMgPSBwcmV2aW91c2x5X3RyYWNpbmdfZXhwcmVzc2lvbnM7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzb3VyY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFnKHNvdXJjZSwgbGFiZWwpIHtcblx0c291cmNlLmxhYmVsID0gbGFiZWw7XG5cdHRhZ19wcm94eShzb3VyY2UudiwgbGFiZWwpO1xuXG5cdHJldHVybiBzb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWdfcHJveHkodmFsdWUsIGxhYmVsKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0dmFsdWU/LltQUk9YWV9QQVRIX1NZTUJPTF0/LihsYWJlbCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYWJlbCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykgcmV0dXJuIGBTeW1ib2woJHt2YWx1ZS5kZXNjcmlwdGlvbn0pYDtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuICc8ZnVuY3Rpb24+Jztcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUpIHJldHVybiAnPG9iamVjdD4nO1xuXHRyZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cbiIsICJpbXBvcnQgeyBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAqIEByZXR1cm5zIHtFcnJvciAmIHsgc3RhY2s6IHN0cmluZyB9IHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9lcnJvcihsYWJlbCkge1xuXHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuXHRjb25zdCBzdGFjayA9IGdldF9zdGFjaygpO1xuXG5cdGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHN0YWNrLnVuc2hpZnQoJ1xcbicpO1xuXG5cdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywge1xuXHRcdHZhbHVlOiBzdGFjay5qb2luKCdcXG4nKVxuXHR9KTtcblxuXHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICduYW1lJywge1xuXHRcdHZhbHVlOiBsYWJlbFxuXHR9KTtcblxuXHRyZXR1cm4gLyoqIEB0eXBlIHtFcnJvciAmIHsgc3RhY2s6IHN0cmluZyB9fSAqLyAoZXJyb3IpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdGFjaygpIHtcblx0Ly8gQHRzLWlnbm9yZSAtIGRvZXNuJ3QgZXhpc3QgZXZlcnl3aGVyZVxuXHRjb25zdCBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcblx0Ly8gQHRzLWlnbm9yZSAtIGRvZXNuJ3QgZXhpc3QgZXZlcnl3aGVyZVxuXHRFcnJvci5zdGFja1RyYWNlTGltaXQgPSBJbmZpbml0eTtcblx0Y29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcblx0Ly8gQHRzLWlnbm9yZSAtIGRvZXNuJ3QgZXhpc3QgZXZlcnl3aGVyZVxuXHRFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcblxuXHRpZiAoIXN0YWNrKSByZXR1cm4gW107XG5cblx0Y29uc3QgbGluZXMgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG5cdGNvbnN0IG5ld19saW5lcyA9IFtdO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBsaW5lID0gbGluZXNbaV07XG5cdFx0Y29uc3QgcG9zaXhpZmllZCA9IGxpbmUucmVwbGFjZUFsbCgnXFxcXCcsICcvJyk7XG5cblx0XHRpZiAobGluZS50cmltKCkgPT09ICdFcnJvcicpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChsaW5lLmluY2x1ZGVzKCd2YWxpZGF0ZV9lYWNoX2tleXMnKSkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHRcdGlmIChwb3NpeGlmaWVkLmluY2x1ZGVzKCdzdmVsdGUvc3JjL2ludGVybmFsJykgfHwgcG9zaXhpZmllZC5pbmNsdWRlcygnbm9kZV9tb2R1bGVzLy52aXRlJykpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdG5ld19saW5lcy5wdXNoKGxpbmUpO1xuXHR9XG5cblx0cmV0dXJuIG5ld19saW5lcztcbn1cbiIsICIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIERldlN0YWNrRW50cnksIEVmZmVjdCB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCwgYWN0aXZlX3JlYWN0aW9uIH0gZnJvbSAnLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGNyZWF0ZV91c2VyX2VmZmVjdCB9IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZywgbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEJSQU5DSF9FRkZFQ1QsIEVGRkVDVF9SQU4gfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbi8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dCB8IG51bGx9ICovXG5leHBvcnQgbGV0IGNvbXBvbmVudF9jb250ZXh0ID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dCB8IG51bGx9IGNvbnRleHQgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY29tcG9uZW50X2NvbnRleHQoY29udGV4dCkge1xuXHRjb21wb25lbnRfY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKiBAdHlwZSB7RGV2U3RhY2tFbnRyeSB8IG51bGx9ICovXG5leHBvcnQgbGV0IGRldl9zdGFjayA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0RldlN0YWNrRW50cnkgfCBudWxsfSBzdGFjayAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZXZfc3RhY2soc3RhY2spIHtcblx0ZGV2X3N0YWNrID0gc3RhY2s7XG59XG5cbi8qKlxuICogRXhlY3V0ZSBhIGNhbGxiYWNrIHdpdGggYSBuZXcgZGV2IHN0YWNrIGVudHJ5XG4gKiBAcGFyYW0geygpID0+IGFueX0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlXG4gKiBAcGFyYW0ge0RldlN0YWNrRW50cnlbJ3R5cGUnXX0gdHlwZSAtIFR5cGUgb2YgYmxvY2svY29tcG9uZW50XG4gKiBAcGFyYW0ge2FueX0gY29tcG9uZW50IC0gQ29tcG9uZW50IGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbGluZSAtIExpbmUgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gQ29sdW1uIG51bWJlclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbYWRkaXRpb25hbF0gLSBBbnkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgZGV2IHN0YWNrIGVudHJ5XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX3N2ZWx0ZV9tZXRhKGNhbGxiYWNrLCB0eXBlLCBjb21wb25lbnQsIGxpbmUsIGNvbHVtbiwgYWRkaXRpb25hbCkge1xuXHRjb25zdCBwYXJlbnQgPSBkZXZfc3RhY2s7XG5cblx0ZGV2X3N0YWNrID0ge1xuXHRcdHR5cGUsXG5cdFx0ZmlsZTogY29tcG9uZW50W0ZJTEVOQU1FXSxcblx0XHRsaW5lLFxuXHRcdGNvbHVtbixcblx0XHRwYXJlbnQsXG5cdFx0Li4uYWRkaXRpb25hbFxuXHR9O1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuIGNhbGxiYWNrKCk7XG5cdH0gZmluYWxseSB7XG5cdFx0ZGV2X3N0YWNrID0gcGFyZW50O1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgY29tcG9uZW50IGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBjdXJyZW50IGNvbXBvbmVudCBjb250ZXh0OlxuICogYGBgaHRtbFxuICogPCEtLSBBcHAuc3ZlbHRlIC0tPlxuICogPEZvbz5cbiAqICAgPEJhciAvPiA8IS0tIGNvbnRleHQgPT0gRm9vLnN2ZWx0ZSwgZnVuY3Rpb24gPT0gQXBwLnN2ZWx0ZSAtLT5cbiAqIDwvRm9vPlxuICogYGBgXG4gKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dFsnZnVuY3Rpb24nXX1cbiAqL1xuZXhwb3J0IGxldCBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBudWxsO1xuXG4vKiogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0WydmdW5jdGlvbiddfSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oZm4pIHtcblx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gZm47XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGBbZ2V0LCBzZXRdYCBwYWlyIG9mIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIGNvbnRleHQgaW4gYSB0eXBlLXNhZmUgd2F5LlxuICpcbiAqIGBnZXRgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgbm8gcGFyZW50IGNvbXBvbmVudCBjYWxsZWQgYHNldGAuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEByZXR1cm5zIHtbKCkgPT4gVCwgKGNvbnRleHQ6IFQpID0+IFRdfVxuICogQHNpbmNlIDUuNDAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dCgpIHtcblx0Y29uc3Qga2V5ID0ge307XG5cblx0cmV0dXJuIFtcblx0XHQoKSA9PiB7XG5cdFx0XHRpZiAoIWhhc0NvbnRleHQoa2V5KSkge1xuXHRcdFx0XHRlLm1pc3NpbmdfY29udGV4dCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2V0Q29udGV4dChrZXkpO1xuXHRcdH0sXG5cdFx0KGNvbnRleHQpID0+IHNldENvbnRleHQoa2V5LCBjb250ZXh0KVxuXHRdO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgYGtleWAuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIFtgY3JlYXRlQ29udGV4dGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUjY3JlYXRlQ29udGV4dCkgaXMgYSB0eXBlLXNhZmUgYWx0ZXJuYXRpdmUuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnZ2V0Q29udGV4dCcpO1xuXHRjb25zdCByZXN1bHQgPSAvKiogQHR5cGUge1R9ICovIChjb250ZXh0X21hcC5nZXQoa2V5KSk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXNzb2NpYXRlcyBhbiBhcmJpdHJhcnkgYGNvbnRleHRgIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGNvbXBvbmVudCBhbmQgdGhlIHNwZWNpZmllZCBga2V5YFxuICogYW5kIHJldHVybnMgdGhhdCBvYmplY3QuIFRoZSBjb250ZXh0IGlzIHRoZW4gYXZhaWxhYmxlIHRvIGNoaWxkcmVuIG9mIHRoZSBjb21wb25lbnRcbiAqIChpbmNsdWRpbmcgc2xvdHRlZCBjb250ZW50KSB3aXRoIGBnZXRDb250ZXh0YC5cbiAqXG4gKiBMaWtlIGxpZmVjeWNsZSBmdW5jdGlvbnMsIHRoaXMgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBbYGNyZWF0ZUNvbnRleHRgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvc3ZlbHRlI2NyZWF0ZUNvbnRleHQpIGlzIGEgdHlwZS1zYWZlIGFsdGVybmF0aXZlLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcGFyYW0ge1R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnc2V0Q29udGV4dCcpO1xuXG5cdGlmIChhc3luY19tb2RlX2ZsYWcpIHtcblx0XHR2YXIgZmxhZ3MgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmY7XG5cdFx0dmFyIHZhbGlkID1cblx0XHRcdCFhY3RpdmVfcmVhY3Rpb24gJiZcblx0XHRcdChmbGFncyAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwICYmXG5cdFx0XHQvLyBwb3AoKSBydW5zIHN5bmNocm9ub3VzbHksIHNvIHRoaXMgaW5kaWNhdGVzIHdlJ3JlIHNldHRpbmcgY29udGV4dCBhZnRlciBhbiBhd2FpdFxuXHRcdFx0ISgvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHR9ICovIChjb21wb25lbnRfY29udGV4dCkuaSk7XG5cblx0XHRpZiAoIXZhbGlkKSB7XG5cdFx0XHRlLnNldF9jb250ZXh0X2FmdGVyX2luaXQoKTtcblx0XHR9XG5cdH1cblxuXHRjb250ZXh0X21hcC5zZXQoa2V5LCBjb250ZXh0KTtcblx0cmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBga2V5YCBoYXMgYmVlbiBzZXQgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG5cdGNvbnN0IGNvbnRleHRfbWFwID0gZ2V0X29yX2luaXRfY29udGV4dF9tYXAoJ2hhc0NvbnRleHQnKTtcblx0cmV0dXJuIGNvbnRleHRfbWFwLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgd2hvbGUgY29udGV4dCBtYXAgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLiBVc2VmdWwsIGZvciBleGFtcGxlLCBpZiB5b3VcbiAqIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29tcG9uZW50IGFuZCB3YW50IHRvIHBhc3MgdGhlIGV4aXN0aW5nIGNvbnRleHQgdG8gaXQuXG4gKlxuICogQHRlbXBsYXRlIHtNYXA8YW55LCBhbnk+fSBbVD1NYXA8YW55LCBhbnk+XVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnZ2V0QWxsQ29udGV4dHMnKTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VH0gKi8gKGNvbnRleHRfbWFwKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHthbnl9IHJ1bmVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1c2gocHJvcHMsIHJ1bmVzID0gZmFsc2UsIGZuKSB7XG5cdGNvbXBvbmVudF9jb250ZXh0ID0ge1xuXHRcdHA6IGNvbXBvbmVudF9jb250ZXh0LFxuXHRcdGk6IGZhbHNlLFxuXHRcdGM6IG51bGwsXG5cdFx0ZTogbnVsbCxcblx0XHRzOiBwcm9wcyxcblx0XHR4OiBudWxsLFxuXHRcdGw6IGxlZ2FjeV9tb2RlX2ZsYWcgJiYgIXJ1bmVzID8geyBzOiBudWxsLCB1OiBudWxsLCAkOiBbXSB9IDogbnVsbFxuXHR9O1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBjb21wb25lbnQgZnVuY3Rpb25cblx0XHRjb21wb25lbnRfY29udGV4dC5mdW5jdGlvbiA9IGZuO1xuXHRcdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IGZuO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBUXG4gKiBAcGFyYW0ge1R9IFtjb21wb25lbnRdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvcChjb21wb25lbnQpIHtcblx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHR9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cdHZhciBlZmZlY3RzID0gY29udGV4dC5lO1xuXG5cdGlmIChlZmZlY3RzICE9PSBudWxsKSB7XG5cdFx0Y29udGV4dC5lID0gbnVsbDtcblxuXHRcdGZvciAodmFyIGZuIG9mIGVmZmVjdHMpIHtcblx0XHRcdGNyZWF0ZV91c2VyX2VmZmVjdChmbik7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNvbXBvbmVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29udGV4dC54ID0gY29tcG9uZW50O1xuXHR9XG5cblx0Y29udGV4dC5pID0gdHJ1ZTtcblxuXHRjb21wb25lbnRfY29udGV4dCA9IGNvbnRleHQucDtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uID8/IG51bGw7XG5cdH1cblxuXHRyZXR1cm4gY29tcG9uZW50ID8/IC8qKiBAdHlwZSB7VH0gKi8gKHt9KTtcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3J1bmVzKCkge1xuXHRyZXR1cm4gIWxlZ2FjeV9tb2RlX2ZsYWcgfHwgKGNvbXBvbmVudF9jb250ZXh0ICE9PSBudWxsICYmIGNvbXBvbmVudF9jb250ZXh0LmwgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+fVxuICovXG5mdW5jdGlvbiBnZXRfb3JfaW5pdF9jb250ZXh0X21hcChuYW1lKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KG5hbWUpO1xuXHR9XG5cblx0cmV0dXJuIChjb21wb25lbnRfY29udGV4dC5jID8/PSBuZXcgTWFwKGdldF9wYXJlbnRfY29udGV4dChjb21wb25lbnRfY29udGV4dCkgfHwgdW5kZWZpbmVkKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0fSBjb21wb25lbnRfY29udGV4dFxuICogQHJldHVybnMge01hcDx1bmtub3duLCB1bmtub3duPiB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldF9wYXJlbnRfY29udGV4dChjb21wb25lbnRfY29udGV4dCkge1xuXHRsZXQgcGFyZW50ID0gY29tcG9uZW50X2NvbnRleHQucDtcblx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IGNvbnRleHRfbWFwID0gcGFyZW50LmM7XG5cdFx0aWYgKGNvbnRleHRfbWFwICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dF9tYXA7XG5cdFx0fVxuXHRcdHBhcmVudCA9IHBhcmVudC5wO1xuXHR9XG5cdHJldHVybiBudWxsO1xufVxuIiwgImltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNfZmx1c2hpbmdfc3luYyB9IGZyb20gJy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuXG4vKiogQHR5cGUge0FycmF5PCgpID0+IHZvaWQ+fSAqL1xubGV0IG1pY3JvX3Rhc2tzID0gW107XG5cbmZ1bmN0aW9uIHJ1bl9taWNyb190YXNrcygpIHtcblx0dmFyIHRhc2tzID0gbWljcm9fdGFza3M7XG5cdG1pY3JvX3Rhc2tzID0gW107XG5cdHJ1bl9hbGwodGFza3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXVlX21pY3JvX3Rhc2soZm4pIHtcblx0aWYgKG1pY3JvX3Rhc2tzLmxlbmd0aCA9PT0gMCAmJiAhaXNfZmx1c2hpbmdfc3luYykge1xuXHRcdHZhciB0YXNrcyA9IG1pY3JvX3Rhc2tzO1xuXHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdC8vIElmIHRoaXMgaXMgZmFsc2UsIGEgZmx1c2hTeW5jIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZS4gRG8gX25vdF8gcnVuIG5ldyBzY2hlZHVsZWQgbWljcm90YXNrcyBpbiB0aGF0IGNhc2Vcblx0XHRcdC8vIGFzIHRoZSBvcmRlcmluZyBvZiBtaWNyb3Rhc2tzIHdvdWxkIGJlIGJyb2tlbiBhdCB0aGF0IHBvaW50IC0gY29uc2lkZXIgdGhpcyBjYXNlOlxuXHRcdFx0Ly8gLSBxdWV1ZV9taWNyb190YXNrIHNjaGVkdWxlcyBtaWNyb3Rhc2sgQSB0byBmbHVzaCB0YXNrIFhcblx0XHRcdC8vIC0gc3luY2hyb25vdXNseSBhZnRlciwgZmx1c2hTeW5jIHJ1bnMsIHByb2Nlc3NpbmcgdGFzayBYXG5cdFx0XHQvLyAtIHN5bmNocm9ub3VzbHkgYWZ0ZXIsIHNvbWUgb3RoZXIgbWljcm90YXNrIEIgaXMgc2NoZWR1bGVkLCBidXQgbm90IHRocm91Z2ggcXVldWVfbWljcm9fdGFzayBidXQgZm9yIGV4YW1wbGUgYSBQcm9taXNlLnJlc29sdmUoKSBpbiB1c2VyIGNvZGVcblx0XHRcdC8vIC0gc3luY2hyb25vdXNseSBhZnRlciwgcXVldWVfbWljcm9fdGFzayBzY2hlZHVsZXMgbWljcm90YXNrIEMgdG8gZmx1c2ggdGFzayBZXG5cdFx0XHQvLyAtIG9uZSB0aWNrIGxhdGVyLCBtaWNyb3Rhc2sgQSBub3cgcmVzb2x2ZXMsIGZsdXNoaW5nIHRhc2sgWSBiZWZvcmUgbWljcm90YXNrIEIsIHdoaWNoIGlzIGluY29ycmVjdFxuXHRcdFx0Ly8gVGhpcyBpZiBjaGVjayBwcmV2ZW50cyB0aGF0IHJhY2UgY29uZGl0aW9uICh0aGF0IHJlYWxpc3RpY2FsbHkgd2lsbCBvbmx5IGhhcHBlbiBpbiB0ZXN0cylcblx0XHRcdGlmICh0YXNrcyA9PT0gbWljcm9fdGFza3MpIHJ1bl9taWNyb190YXNrcygpO1xuXHRcdH0pO1xuXHR9XG5cblx0bWljcm9fdGFza3MucHVzaChmbik7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBydW4gYW55IHF1ZXVlZCB0YXNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoX3Rhc2tzKCkge1xuXHR3aGlsZSAobWljcm9fdGFza3MubGVuZ3RoID4gMCkge1xuXHRcdHJ1bl9taWNyb190YXNrcygpO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBCb3VuZGFyeSB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgaXNfZmlyZWZveCB9IGZyb20gJy4vZG9tL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgRVJST1JfVkFMVUUsIEJPVU5EQVJZX0VGRkVDVCwgRUZGRUNUX1JBTiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgZ2V0X2Rlc2NyaXB0b3IgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCwgYWN0aXZlX3JlYWN0aW9uIH0gZnJvbSAnLi9ydW50aW1lLmpzJztcblxuY29uc3QgYWRqdXN0bWVudHMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9lcnJvcihlcnJvcikge1xuXHR2YXIgZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHQvLyBmb3IgdW5vd25lZCBkZXJpdmVkcywgZG9uJ3QgdGhyb3cgdW50aWwgd2UgcmVhZCB0aGUgdmFsdWVcblx0aWYgKGVmZmVjdCA9PT0gbnVsbCkge1xuXHRcdC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGFjdGl2ZV9yZWFjdGlvbikuZiB8PSBFUlJPUl9WQUxVRTtcblx0XHRyZXR1cm4gZXJyb3I7XG5cdH1cblxuXHRpZiAoREVWICYmIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIWFkanVzdG1lbnRzLmhhcyhlcnJvcikpIHtcblx0XHRhZGp1c3RtZW50cy5zZXQoZXJyb3IsIGdldF9hZGp1c3RtZW50cyhlcnJvciwgZWZmZWN0KSk7XG5cdH1cblxuXHRpZiAoKGVmZmVjdC5mICYgRUZGRUNUX1JBTikgPT09IDApIHtcblx0XHQvLyBpZiB0aGUgZXJyb3Igb2NjdXJyZWQgd2hpbGUgY3JlYXRpbmcgdGhpcyBzdWJ0cmVlLCB3ZSBsZXQgaXRcblx0XHQvLyBidWJibGUgdXAgdW50aWwgaXQgaGl0cyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSBpdFxuXHRcdGlmICgoZWZmZWN0LmYgJiBCT1VOREFSWV9FRkZFQ1QpID09PSAwKSB7XG5cdFx0XHRpZiAoREVWICYmICFlZmZlY3QucGFyZW50ICYmIGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0YXBwbHlfYWRqdXN0bWVudHMoZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAoZWZmZWN0LmIpLmVycm9yKGVycm9yKTtcblx0fSBlbHNlIHtcblx0XHQvLyBvdGhlcndpc2Ugd2UgYnViYmxlIHVwIHRoZSBlZmZlY3QgdHJlZSBvdXJzZWx2ZXNcblx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIGVmZmVjdCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yXG4gKiBAcGFyYW0ge0VmZmVjdCB8IG51bGx9IGVmZmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBlZmZlY3QpIHtcblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuXHRcdGlmICgoZWZmZWN0LmYgJiBCT1VOREFSWV9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAoZWZmZWN0LmIpLmVycm9yKGVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWZmZWN0ID0gZWZmZWN0LnBhcmVudDtcblx0fVxuXG5cdGlmIChERVYgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdGFwcGx5X2FkanVzdG1lbnRzKGVycm9yKTtcblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuXG4vKipcbiAqIEFkZCB1c2VmdWwgaW5mb3JtYXRpb24gdG8gdGhlIGVycm9yIG1lc3NhZ2Uvc3RhY2sgaW4gZGV2ZWxvcG1lbnRcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmZ1bmN0aW9uIGdldF9hZGp1c3RtZW50cyhlcnJvciwgZWZmZWN0KSB7XG5cdGNvbnN0IG1lc3NhZ2VfZGVzY3JpcHRvciA9IGdldF9kZXNjcmlwdG9yKGVycm9yLCAnbWVzc2FnZScpO1xuXG5cdC8vIGlmIHRoZSBtZXNzYWdlIHdhcyBhbHJlYWR5IGNoYW5nZWQgYW5kIGl0J3Mgbm90IGNvbmZpZ3VyYWJsZSB3ZSBjYW4ndCBjaGFuZ2UgaXRcblx0Ly8gb3IgaXQgd2lsbCB0aHJvdyBhIGRpZmZlcmVudCBlcnJvciBzd2FsbG93aW5nIHRoZSBvcmlnaW5hbCBlcnJvclxuXHRpZiAobWVzc2FnZV9kZXNjcmlwdG9yICYmICFtZXNzYWdlX2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlKSByZXR1cm47XG5cblx0dmFyIGluZGVudCA9IGlzX2ZpcmVmb3ggPyAnICAnIDogJ1xcdCc7XG5cdHZhciBjb21wb25lbnRfc3RhY2sgPSBgXFxuJHtpbmRlbnR9aW4gJHtlZmZlY3QuZm4/Lm5hbWUgfHwgJzx1bmtub3duPid9YDtcblx0dmFyIGNvbnRleHQgPSBlZmZlY3QuY3R4O1xuXG5cdHdoaWxlIChjb250ZXh0ICE9PSBudWxsKSB7XG5cdFx0Y29tcG9uZW50X3N0YWNrICs9IGBcXG4ke2luZGVudH1pbiAke2NvbnRleHQuZnVuY3Rpb24/LltGSUxFTkFNRV0uc3BsaXQoJy8nKS5wb3AoKX1gO1xuXHRcdGNvbnRleHQgPSBjb250ZXh0LnA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgKyBgXFxuJHtjb21wb25lbnRfc3RhY2t9XFxuYCxcblx0XHRzdGFjazogZXJyb3Iuc3RhY2tcblx0XHRcdD8uc3BsaXQoJ1xcbicpXG5cdFx0XHQuZmlsdGVyKChsaW5lKSA9PiAhbGluZS5pbmNsdWRlcygnc3ZlbHRlL3NyYy9pbnRlcm5hbCcpKVxuXHRcdFx0LmpvaW4oJ1xcbicpXG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqL1xuZnVuY3Rpb24gYXBwbHlfYWRqdXN0bWVudHMoZXJyb3IpIHtcblx0Y29uc3QgYWRqdXN0ZWQgPSBhZGp1c3RtZW50cy5nZXQoZXJyb3IpO1xuXG5cdGlmIChhZGp1c3RlZCkge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ21lc3NhZ2UnLCB7XG5cdFx0XHR2YWx1ZTogYWRqdXN0ZWQubWVzc2FnZVxuXHRcdH0pO1xuXG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnc3RhY2snLCB7XG5cdFx0XHR2YWx1ZTogYWRqdXN0ZWQuc3RhY2tcblx0XHR9KTtcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgRm9yayB9IGZyb20gJ3N2ZWx0ZScgKi9cbi8qKiBAaW1wb3J0IHsgRGVyaXZlZCwgRWZmZWN0LCBSZWFjdGlvbiwgU291cmNlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRCTE9DS19FRkZFQ1QsXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdENMRUFOLFxuXHRERVNUUk9ZRUQsXG5cdERJUlRZLFxuXHRFRkZFQ1QsXG5cdEFTWU5DLFxuXHRJTkVSVCxcblx0UkVOREVSX0VGRkVDVCxcblx0Uk9PVF9FRkZFQ1QsXG5cdE1BWUJFX0RJUlRZLFxuXHRERVJJVkVELFxuXHRCT1VOREFSWV9FRkZFQ1QsXG5cdEVBR0VSX0VGRkVDVCxcblx0SEVBRF9FRkZFQ1QsXG5cdEVSUk9SX1ZBTFVFLFxuXHRXQVNfTUFSS0VELFxuXHRNQU5BR0VEX0VGRkVDVFxufSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBhc3luY19tb2RlX2ZsYWcgfSBmcm9tICcuLi8uLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBkZWZlcnJlZCwgZGVmaW5lX3Byb3BlcnR5IH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGdldCxcblx0aXNfZGlydHksXG5cdGlzX3VwZGF0aW5nX2VmZmVjdCxcblx0c2V0X2lzX3VwZGF0aW5nX2VmZmVjdCxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVwZGF0ZV9lZmZlY3Rcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBmbHVzaF90YXNrcywgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL2RvbS90YXNrLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaW52b2tlX2Vycm9yX2JvdW5kYXJ5IH0gZnJvbSAnLi4vZXJyb3ItaGFuZGxpbmcuanMnO1xuaW1wb3J0IHsgZmx1c2hfZWFnZXJfZWZmZWN0cywgb2xkX3ZhbHVlcywgc2V0X2VhZ2VyX2VmZmVjdHMsIHNvdXJjZSwgdXBkYXRlIH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGVhZ2VyX2VmZmVjdCwgdW5saW5rX2VmZmVjdCB9IGZyb20gJy4vZWZmZWN0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgcGFyZW50OiBFZmZlY3RUYXJnZXQgfCBudWxsO1xuICogICBlZmZlY3Q6IEVmZmVjdCB8IG51bGw7XG4gKiAgIGVmZmVjdHM6IEVmZmVjdFtdO1xuICogICByZW5kZXJfZWZmZWN0czogRWZmZWN0W107XG4gKiAgIGJsb2NrX2VmZmVjdHM6IEVmZmVjdFtdO1xuICogfX0gRWZmZWN0VGFyZ2V0XG4gKi9cblxuLyoqIEB0eXBlIHtTZXQ8QmF0Y2g+fSAqL1xuY29uc3QgYmF0Y2hlcyA9IG5ldyBTZXQoKTtcblxuLyoqIEB0eXBlIHtCYXRjaCB8IG51bGx9ICovXG5leHBvcnQgbGV0IGN1cnJlbnRfYmF0Y2ggPSBudWxsO1xuXG4vKipcbiAqIFRoaXMgaXMgbmVlZGVkIHRvIGF2b2lkIG92ZXJ3cml0aW5nIGlucHV0cyBpbiBub24tYXN5bmMgbW9kZVxuICogVE9ETyA2LjAgcmVtb3ZlIHRoaXMsIGFzIG5vbi1hc3luYyBtb2RlIHdpbGwgZ28gYXdheVxuICogQHR5cGUge0JhdGNoIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBwcmV2aW91c19iYXRjaCA9IG51bGw7XG5cbi8qKlxuICogV2hlbiB0aW1lIHRyYXZlbGxpbmcgKGkuZS4gd29ya2luZyBpbiBvbmUgYmF0Y2gsIHdoaWxlIG90aGVyIGJhdGNoZXNcbiAqIHN0aWxsIGhhdmUgb25nb2luZyB3b3JrKSwgd2UgaWdub3JlIHRoZSByZWFsIHZhbHVlcyBvZiBhZmZlY3RlZFxuICogc2lnbmFscyBpbiBmYXZvdXIgb2YgdGhlaXIgdmFsdWVzIHdpdGhpbiB0aGUgYmF0Y2hcbiAqIEB0eXBlIHtNYXA8VmFsdWUsIGFueT4gfCBudWxsfVxuICovXG5leHBvcnQgbGV0IGJhdGNoX3ZhbHVlcyA9IG51bGw7XG5cbi8vIFRPRE8gdGhpcyBzaG91bGQgcmVhbGx5IGJlIGEgcHJvcGVydHkgb2YgYGJhdGNoYFxuLyoqIEB0eXBlIHtFZmZlY3RbXX0gKi9cbmxldCBxdWV1ZWRfcm9vdF9lZmZlY3RzID0gW107XG5cbi8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cbmxldCBsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBudWxsO1xuXG5sZXQgaXNfZmx1c2hpbmcgPSBmYWxzZTtcbmV4cG9ydCBsZXQgaXNfZmx1c2hpbmdfc3luYyA9IGZhbHNlO1xuXG5leHBvcnQgY2xhc3MgQmF0Y2gge1xuXHRjb21taXR0ZWQgPSBmYWxzZTtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgdmFsdWVzIG9mIGFueSBzb3VyY2VzIHRoYXQgYXJlIHVwZGF0ZWQgaW4gdGhpcyBiYXRjaFxuXHQgKiBUaGV5IGtleXMgb2YgdGhpcyBtYXAgYXJlIGlkZW50aWNhbCB0byBgdGhpcy4jcHJldmlvdXNgXG5cdCAqIEB0eXBlIHtNYXA8U291cmNlLCBhbnk+fVxuXHQgKi9cblx0Y3VycmVudCA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogVGhlIHZhbHVlcyBvZiBhbnkgc291cmNlcyB0aGF0IGFyZSB1cGRhdGVkIGluIHRoaXMgYmF0Y2ggX2JlZm9yZV8gdGhvc2UgdXBkYXRlcyB0b29rIHBsYWNlLlxuXHQgKiBUaGV5IGtleXMgb2YgdGhpcyBtYXAgYXJlIGlkZW50aWNhbCB0byBgdGhpcy4jY3VycmVudGBcblx0ICogQHR5cGUge01hcDxTb3VyY2UsIGFueT59XG5cdCAqL1xuXHRwcmV2aW91cyA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogV2hlbiB0aGUgYmF0Y2ggaXMgY29tbWl0dGVkIChhbmQgdGhlIERPTSBpcyB1cGRhdGVkKSwgd2UgbmVlZCB0byByZW1vdmUgb2xkIGJyYW5jaGVzXG5cdCAqIGFuZCBhcHBlbmQgbmV3IG9uZXMgYnkgY2FsbGluZyB0aGUgZnVuY3Rpb25zIGFkZGVkIGluc2lkZSAoaWYvZWFjaC9rZXkvZXRjKSBibG9ja3Ncblx0ICogQHR5cGUge1NldDwoKSA9PiB2b2lkPn1cblx0ICovXG5cdCNjb21taXRfY2FsbGJhY2tzID0gbmV3IFNldCgpO1xuXG5cdC8qKlxuXHQgKiBJZiBhIGZvcmsgaXMgZGlzY2FyZGVkLCB3ZSBuZWVkIHRvIGRlc3Ryb3kgYW55IGVmZmVjdHMgdGhhdCBhcmUgbm8gbG9uZ2VyIG5lZWRlZFxuXHQgKiBAdHlwZSB7U2V0PChiYXRjaDogQmF0Y2gpID0+IHZvaWQ+fVxuXHQgKi9cblx0I2Rpc2NhcmRfY2FsbGJhY2tzID0gbmV3IFNldCgpO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIGFzeW5jIGVmZmVjdHMgdGhhdCBhcmUgY3VycmVudGx5IGluIGZsaWdodFxuXHQgKi9cblx0I3BlbmRpbmcgPSAwO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIGFzeW5jIGVmZmVjdHMgdGhhdCBhcmUgY3VycmVudGx5IGluIGZsaWdodCwgX25vdF8gaW5zaWRlIGEgcGVuZGluZyBib3VuZGFyeVxuXHQgKi9cblx0I2Jsb2NraW5nX3BlbmRpbmcgPSAwO1xuXG5cdC8qKlxuXHQgKiBBIGRlZmVycmVkIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYmF0Y2ggaXMgY29tbWl0dGVkLCB1c2VkIHdpdGggYHNldHRsZWQoKWBcblx0ICogVE9ETyByZXBsYWNlIHdpdGggUHJvbWlzZS53aXRoUmVzb2x2ZXJzIG9uY2Ugc3VwcG9ydGVkIHdpZGVseSBlbm91Z2hcblx0ICogQHR5cGUge3sgcHJvbWlzZTogUHJvbWlzZTx2b2lkPiwgcmVzb2x2ZTogKHZhbHVlPzogYW55KSA9PiB2b2lkLCByZWplY3Q6IChyZWFzb246IHVua25vd24pID0+IHZvaWQgfSB8IG51bGx9XG5cdCAqL1xuXHQjZGVmZXJyZWQgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBEZWZlcnJlZCBlZmZlY3RzICh3aGljaCBydW4gYWZ0ZXIgYXN5bmMgd29yayBoYXMgY29tcGxldGVkKSB0aGF0IGFyZSBESVJUWVxuXHQgKiBAdHlwZSB7RWZmZWN0W119XG5cdCAqL1xuXHQjZGlydHlfZWZmZWN0cyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBEZWZlcnJlZCBlZmZlY3RzIHRoYXQgYXJlIE1BWUJFX0RJUlRZXG5cdCAqIEB0eXBlIHtFZmZlY3RbXX1cblx0ICovXG5cdCNtYXliZV9kaXJ0eV9lZmZlY3RzID0gW107XG5cblx0LyoqXG5cdCAqIEEgc2V0IG9mIGJyYW5jaGVzIHRoYXQgc3RpbGwgZXhpc3QsIGJ1dCB3aWxsIGJlIGRlc3Ryb3llZCB3aGVuIHRoaXMgYmF0Y2hcblx0ICogaXMgY29tbWl0dGVkIFx1MjAxNCB3ZSBza2lwIG92ZXIgdGhlc2UgZHVyaW5nIGBwcm9jZXNzYFxuXHQgKiBAdHlwZSB7U2V0PEVmZmVjdD59XG5cdCAqL1xuXHRza2lwcGVkX2VmZmVjdHMgPSBuZXcgU2V0KCk7XG5cblx0aXNfZm9yayA9IGZhbHNlO1xuXG5cdGlzX2RlZmVycmVkKCkge1xuXHRcdHJldHVybiB0aGlzLmlzX2ZvcmsgfHwgdGhpcy4jYmxvY2tpbmdfcGVuZGluZyA+IDA7XG5cdH1cblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtFZmZlY3RbXX0gcm9vdF9lZmZlY3RzXG5cdCAqL1xuXHRwcm9jZXNzKHJvb3RfZWZmZWN0cykge1xuXHRcdHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblxuXHRcdHByZXZpb3VzX2JhdGNoID0gbnVsbDtcblxuXHRcdHRoaXMuYXBwbHkoKTtcblxuXHRcdC8qKiBAdHlwZSB7RWZmZWN0VGFyZ2V0fSAqL1xuXHRcdHZhciB0YXJnZXQgPSB7XG5cdFx0XHRwYXJlbnQ6IG51bGwsXG5cdFx0XHRlZmZlY3Q6IG51bGwsXG5cdFx0XHRlZmZlY3RzOiBbXSxcblx0XHRcdHJlbmRlcl9lZmZlY3RzOiBbXSxcblx0XHRcdGJsb2NrX2VmZmVjdHM6IFtdXG5cdFx0fTtcblxuXHRcdGZvciAoY29uc3Qgcm9vdCBvZiByb290X2VmZmVjdHMpIHtcblx0XHRcdHRoaXMuI3RyYXZlcnNlX2VmZmVjdF90cmVlKHJvb3QsIHRhcmdldCk7XG5cdFx0XHQvLyBOb3RlOiAjdHJhdmVyc2VfZWZmZWN0X3RyZWUgcnVucyBibG9jayBlZmZlY3RzIGVhZ2VybHksIHdoaWNoIGNhbiBzY2hlZHVsZSBlZmZlY3RzLFxuXHRcdFx0Ly8gd2hpY2ggbWVhbnMgcXVldWVkX3Jvb3RfZWZmZWN0cyBub3cgbWF5IGJlIGZpbGxlZCBhZ2Fpbi5cblxuXHRcdFx0Ly8gSGVscGZ1bCBmb3IgZGVidWdnaW5nIHJlYWN0aXZpdHkgbG9zcyB0aGF0IGhhcyB0byBkbyB3aXRoIGJyYW5jaGVzIGJlaW5nIHNraXBwZWQ6XG5cdFx0XHQvLyBsb2dfaW5jb25zaXN0ZW50X2JyYW5jaGVzKHJvb3QpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc19mb3JrKSB7XG5cdFx0XHR0aGlzLiNyZXNvbHZlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXNfZGVmZXJyZWQoKSkge1xuXHRcdFx0dGhpcy4jZGVmZXJfZWZmZWN0cyh0YXJnZXQuZWZmZWN0cyk7XG5cdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5yZW5kZXJfZWZmZWN0cyk7XG5cdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5ibG9ja19lZmZlY3RzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgc291cmNlcyBhcmUgd3JpdHRlbiB0bywgdGhlbiB3b3JrIG5lZWRzIHRvIGhhcHBlbiBpbiBhIHNlcGFyYXRlIGJhdGNoLCBlbHNlIHByaW9yIHNvdXJjZXMgd291bGQgYmUgbWl4ZWQgd2l0aFxuXHRcdFx0Ly8gbmV3bHkgdXBkYXRlZCBzb3VyY2VzLCB3aGljaCBjb3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3BzIHdoZW4gZWZmZWN0cyBydW4gb3ZlciBhbmQgb3ZlciBhZ2Fpbi5cblx0XHRcdHByZXZpb3VzX2JhdGNoID0gdGhpcztcblx0XHRcdGN1cnJlbnRfYmF0Y2ggPSBudWxsO1xuXG5cdFx0XHRmbHVzaF9xdWV1ZWRfZWZmZWN0cyh0YXJnZXQucmVuZGVyX2VmZmVjdHMpO1xuXHRcdFx0Zmx1c2hfcXVldWVkX2VmZmVjdHModGFyZ2V0LmVmZmVjdHMpO1xuXG5cdFx0XHRwcmV2aW91c19iYXRjaCA9IG51bGw7XG5cblx0XHRcdHRoaXMuI2RlZmVycmVkPy5yZXNvbHZlKCk7XG5cdFx0fVxuXG5cdFx0YmF0Y2hfdmFsdWVzID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmF2ZXJzZSB0aGUgZWZmZWN0IHRyZWUsIGV4ZWN1dGluZyBlZmZlY3RzIG9yIHN0YXNoaW5nXG5cdCAqIHRoZW0gZm9yIGxhdGVyIGV4ZWN1dGlvbiBhcyBhcHByb3ByaWF0ZVxuXHQgKiBAcGFyYW0ge0VmZmVjdH0gcm9vdFxuXHQgKiBAcGFyYW0ge0VmZmVjdFRhcmdldH0gdGFyZ2V0XG5cdCAqL1xuXHQjdHJhdmVyc2VfZWZmZWN0X3RyZWUocm9vdCwgdGFyZ2V0KSB7XG5cdFx0cm9vdC5mIF49IENMRUFOO1xuXG5cdFx0dmFyIGVmZmVjdCA9IHJvb3QuZmlyc3Q7XG5cblx0XHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblx0XHRcdHZhciBpc19icmFuY2ggPSAoZmxhZ3MgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgIT09IDA7XG5cdFx0XHR2YXIgaXNfc2tpcHBhYmxlX2JyYW5jaCA9IGlzX2JyYW5jaCAmJiAoZmxhZ3MgJiBDTEVBTikgIT09IDA7XG5cblx0XHRcdHZhciBza2lwID0gaXNfc2tpcHBhYmxlX2JyYW5jaCB8fCAoZmxhZ3MgJiBJTkVSVCkgIT09IDAgfHwgdGhpcy5za2lwcGVkX2VmZmVjdHMuaGFzKGVmZmVjdCk7XG5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBCT1VOREFSWV9FRkZFQ1QpICE9PSAwICYmIGVmZmVjdC5iPy5pc19wZW5kaW5nKCkpIHtcblx0XHRcdFx0dGFyZ2V0ID0ge1xuXHRcdFx0XHRcdHBhcmVudDogdGFyZ2V0LFxuXHRcdFx0XHRcdGVmZmVjdCxcblx0XHRcdFx0XHRlZmZlY3RzOiBbXSxcblx0XHRcdFx0XHRyZW5kZXJfZWZmZWN0czogW10sXG5cdFx0XHRcdFx0YmxvY2tfZWZmZWN0czogW11cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFza2lwICYmIGVmZmVjdC5mbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoaXNfYnJhbmNoKSB7XG5cdFx0XHRcdFx0ZWZmZWN0LmYgXj0gQ0xFQU47XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGZsYWdzICYgRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0XHRcdHRhcmdldC5lZmZlY3RzLnB1c2goZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChhc3luY19tb2RlX2ZsYWcgJiYgKGZsYWdzICYgKFJFTkRFUl9FRkZFQ1QgfCBNQU5BR0VEX0VGRkVDVCkpICE9PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnJlbmRlcl9lZmZlY3RzLnB1c2goZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc19kaXJ0eShlZmZlY3QpKSB7XG5cdFx0XHRcdFx0aWYgKChlZmZlY3QuZiAmIEJMT0NLX0VGRkVDVCkgIT09IDApIHRhcmdldC5ibG9ja19lZmZlY3RzLnB1c2goZWZmZWN0KTtcblx0XHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY2hpbGQgPSBlZmZlY3QuZmlyc3Q7XG5cblx0XHRcdFx0aWYgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZWZmZWN0ID0gY2hpbGQ7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVmZmVjdC5wYXJlbnQ7XG5cdFx0XHRlZmZlY3QgPSBlZmZlY3QubmV4dDtcblxuXHRcdFx0d2hpbGUgKGVmZmVjdCA9PT0gbnVsbCAmJiBwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKHBhcmVudCA9PT0gdGFyZ2V0LmVmZmVjdCkge1xuXHRcdFx0XHRcdC8vIFRPRE8gcmF0aGVyIHRoYW4gdHJhdmVyc2luZyBpbnRvIHBlbmRpbmcgYm91bmRhcmllcyBhbmQgZGVmZXJyaW5nIHRoZSBlZmZlY3RzLFxuXHRcdFx0XHRcdC8vIGNvdWxkIHdlIGp1c3QgYXR0YWNoIHRoZSBlZmZlY3RzIF90b18gdGhlIHBlbmRpbmcgYm91bmRhcnkgYW5kIHNjaGVkdWxlIHRoZW1cblx0XHRcdFx0XHQvLyBvbmNlIHRoZSBib3VuZGFyeSBpcyByZWFkeT9cblx0XHRcdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5lZmZlY3RzKTtcblx0XHRcdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5yZW5kZXJfZWZmZWN0cyk7XG5cdFx0XHRcdFx0dGhpcy4jZGVmZXJfZWZmZWN0cyh0YXJnZXQuYmxvY2tfZWZmZWN0cyk7XG5cblx0XHRcdFx0XHR0YXJnZXQgPSAvKiogQHR5cGUge0VmZmVjdFRhcmdldH0gKi8gKHRhcmdldC5wYXJlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWZmZWN0ID0gcGFyZW50Lm5leHQ7XG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RWZmZWN0W119IGVmZmVjdHNcblx0ICovXG5cdCNkZWZlcl9lZmZlY3RzKGVmZmVjdHMpIHtcblx0XHRmb3IgKGNvbnN0IGUgb2YgZWZmZWN0cykge1xuXHRcdFx0Y29uc3QgdGFyZ2V0ID0gKGUuZiAmIERJUlRZKSAhPT0gMCA/IHRoaXMuI2RpcnR5X2VmZmVjdHMgOiB0aGlzLiNtYXliZV9kaXJ0eV9lZmZlY3RzO1xuXHRcdFx0dGFyZ2V0LnB1c2goZSk7XG5cblx0XHRcdC8vIFNpbmNlIHdlJ3JlIG5vdCBleGVjdXRpbmcgdGhlc2UgZWZmZWN0cyBub3csIHdlIG5lZWQgdG8gY2xlYXIgYW55IFdBU19NQVJLRUQgZmxhZ3Ncblx0XHRcdC8vIHNvIHRoYXQgb3RoZXIgYmF0Y2hlcyBjYW4gY29ycmVjdGx5IHJlYWNoIHRoZXNlIGVmZmVjdHMgZHVyaW5nIHRoZWlyIG93biB0cmF2ZXJzYWxcblx0XHRcdHRoaXMuI2NsZWFyX21hcmtlZChlLmRlcHMpO1xuXG5cdFx0XHQvLyBtYXJrIGFzIGNsZWFuIHNvIHRoZXkgZ2V0IHNjaGVkdWxlZCBpZiB0aGV5IGRlcGVuZCBvbiBwZW5kaW5nIGFzeW5jIHN0YXRlXG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlLCBDTEVBTik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VmFsdWVbXSB8IG51bGx9IGRlcHNcblx0ICovXG5cdCNjbGVhcl9tYXJrZWQoZGVwcykge1xuXHRcdGlmIChkZXBzID09PSBudWxsKSByZXR1cm47XG5cblx0XHRmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG5cdFx0XHRpZiAoKGRlcC5mICYgREVSSVZFRCkgPT09IDAgfHwgKGRlcC5mICYgV0FTX01BUktFRCkgPT09IDApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGRlcC5mIF49IFdBU19NQVJLRUQ7XG5cblx0XHRcdHRoaXMuI2NsZWFyX21hcmtlZCgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChkZXApLmRlcHMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBc3NvY2lhdGUgYSBjaGFuZ2UgdG8gYSBnaXZlbiBzb3VyY2Ugd2l0aCB0aGUgY3VycmVudFxuXHQgKiBiYXRjaCwgbm90aW5nIGl0cyBwcmV2aW91cyBhbmQgY3VycmVudCB2YWx1ZXNcblx0ICogQHBhcmFtIHtTb3VyY2V9IHNvdXJjZVxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWVcblx0ICovXG5cdGNhcHR1cmUoc291cmNlLCB2YWx1ZSkge1xuXHRcdGlmICghdGhpcy5wcmV2aW91cy5oYXMoc291cmNlKSkge1xuXHRcdFx0dGhpcy5wcmV2aW91cy5zZXQoc291cmNlLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gRG9uJ3Qgc2F2ZSBlcnJvcnMgaW4gYGJhdGNoX3ZhbHVlc2AsIG9yIHRoZXkgd29uJ3QgYmUgdGhyb3duIGluIGBydW50aW1lLmpzI2dldGBcblx0XHRpZiAoKHNvdXJjZS5mICYgRVJST1JfVkFMVUUpID09PSAwKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnQuc2V0KHNvdXJjZSwgc291cmNlLnYpO1xuXHRcdFx0YmF0Y2hfdmFsdWVzPy5zZXQoc291cmNlLCBzb3VyY2Uudik7XG5cdFx0fVxuXHR9XG5cblx0YWN0aXZhdGUoKSB7XG5cdFx0Y3VycmVudF9iYXRjaCA9IHRoaXM7XG5cdFx0dGhpcy5hcHBseSgpO1xuXHR9XG5cblx0ZGVhY3RpdmF0ZSgpIHtcblx0XHQvLyBJZiB3ZSdyZSBub3QgdGhlIGN1cnJlbnQgYmF0Y2gsIGRvbid0IGRlYWN0aXZhdGUsXG5cdFx0Ly8gZWxzZSB3ZSBjb3VsZCBjcmVhdGUgem9tYmllIGJhdGNoZXMgdGhhdCBhcmUgbmV2ZXIgZmx1c2hlZFxuXHRcdGlmIChjdXJyZW50X2JhdGNoICE9PSB0aGlzKSByZXR1cm47XG5cblx0XHRjdXJyZW50X2JhdGNoID0gbnVsbDtcblx0XHRiYXRjaF92YWx1ZXMgPSBudWxsO1xuXHR9XG5cblx0Zmx1c2goKSB7XG5cdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXG5cdFx0aWYgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Zmx1c2hfZWZmZWN0cygpO1xuXG5cdFx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCAmJiBjdXJyZW50X2JhdGNoICE9PSB0aGlzKSB7XG5cdFx0XHRcdC8vIHRoaXMgY2FuIGhhcHBlbiBpZiBhIG5ldyBiYXRjaCB3YXMgY3JlYXRlZCBkdXJpbmcgYGZsdXNoX2VmZmVjdHMoKWBcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy4jcGVuZGluZyA9PT0gMCkge1xuXHRcdFx0dGhpcy5wcm9jZXNzKFtdKTsgLy8gVE9ETyB0aGlzIGZlZWxzIGF3a3dhcmRcblx0XHR9XG5cblx0XHR0aGlzLmRlYWN0aXZhdGUoKTtcblx0fVxuXG5cdGRpc2NhcmQoKSB7XG5cdFx0Zm9yIChjb25zdCBmbiBvZiB0aGlzLiNkaXNjYXJkX2NhbGxiYWNrcykgZm4odGhpcyk7XG5cdFx0dGhpcy4jZGlzY2FyZF9jYWxsYmFja3MuY2xlYXIoKTtcblx0fVxuXG5cdCNyZXNvbHZlKCkge1xuXHRcdGlmICh0aGlzLiNibG9ja2luZ19wZW5kaW5nID09PSAwKSB7XG5cdFx0XHQvLyBhcHBlbmQvcmVtb3ZlIGJyYW5jaGVzXG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIHRoaXMuI2NvbW1pdF9jYWxsYmFja3MpIGZuKCk7XG5cdFx0XHR0aGlzLiNjb21taXRfY2FsbGJhY2tzLmNsZWFyKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmcgPT09IDApIHtcblx0XHRcdHRoaXMuI2NvbW1pdCgpO1xuXHRcdH1cblx0fVxuXG5cdCNjb21taXQoKSB7XG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG90aGVyIHBlbmRpbmcgYmF0Y2hlcywgdGhleSBub3cgbmVlZCB0byBiZSAncmViYXNlZCcgXHUyMDE0XG5cdFx0Ly8gaW4gb3RoZXIgd29yZHMsIHdlIHJlLXJ1biBibG9jay9hc3luYyBlZmZlY3RzIHdpdGggdGhlIG5ld2x5XG5cdFx0Ly8gY29tbWl0dGVkIHN0YXRlLCB1bmxlc3MgdGhlIGJhdGNoIGluIHF1ZXN0aW9uIGhhcyBhIG1vcmVcblx0XHQvLyByZWNlbnQgdmFsdWUgZm9yIGEgZ2l2ZW4gc291cmNlXG5cdFx0aWYgKGJhdGNoZXMuc2l6ZSA+IDEpIHtcblx0XHRcdHRoaXMucHJldmlvdXMuY2xlYXIoKTtcblxuXHRcdFx0dmFyIHByZXZpb3VzX2JhdGNoX3ZhbHVlcyA9IGJhdGNoX3ZhbHVlcztcblx0XHRcdHZhciBpc19lYXJsaWVyID0gdHJ1ZTtcblxuXHRcdFx0LyoqIEB0eXBlIHtFZmZlY3RUYXJnZXR9ICovXG5cdFx0XHR2YXIgZHVtbXlfdGFyZ2V0ID0ge1xuXHRcdFx0XHRwYXJlbnQ6IG51bGwsXG5cdFx0XHRcdGVmZmVjdDogbnVsbCxcblx0XHRcdFx0ZWZmZWN0czogW10sXG5cdFx0XHRcdHJlbmRlcl9lZmZlY3RzOiBbXSxcblx0XHRcdFx0YmxvY2tfZWZmZWN0czogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoY29uc3QgYmF0Y2ggb2YgYmF0Y2hlcykge1xuXHRcdFx0XHRpZiAoYmF0Y2ggPT09IHRoaXMpIHtcblx0XHRcdFx0XHRpc19lYXJsaWVyID0gZmFsc2U7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiogQHR5cGUge1NvdXJjZVtdfSAqL1xuXHRcdFx0XHRjb25zdCBzb3VyY2VzID0gW107XG5cblx0XHRcdFx0Zm9yIChjb25zdCBbc291cmNlLCB2YWx1ZV0gb2YgdGhpcy5jdXJyZW50KSB7XG5cdFx0XHRcdFx0aWYgKGJhdGNoLmN1cnJlbnQuaGFzKHNvdXJjZSkpIHtcblx0XHRcdFx0XHRcdGlmIChpc19lYXJsaWVyICYmIHZhbHVlICE9PSBiYXRjaC5jdXJyZW50LmdldChzb3VyY2UpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGJyaW5nIHRoZSB2YWx1ZSB1cCB0byBkYXRlXG5cdFx0XHRcdFx0XHRcdGJhdGNoLmN1cnJlbnQuc2V0KHNvdXJjZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gc2FtZSB2YWx1ZSBvciBsYXRlciBiYXRjaCBoYXMgbW9yZSByZWNlbnQgdmFsdWUsXG5cdFx0XHRcdFx0XHRcdC8vIG5vIG5lZWQgdG8gcmUtcnVuIHRoZXNlIGVmZmVjdHNcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlLXJ1biBhc3luYy9ibG9jayBlZmZlY3RzIHRoYXQgZGVwZW5kIG9uIGRpc3RpbmN0IHZhbHVlcyBjaGFuZ2VkIGluIGJvdGggYmF0Y2hlc1xuXHRcdFx0XHRjb25zdCBvdGhlcnMgPSBbLi4uYmF0Y2guY3VycmVudC5rZXlzKCldLmZpbHRlcigocykgPT4gIXRoaXMuY3VycmVudC5oYXMocykpO1xuXHRcdFx0XHRpZiAob3RoZXJzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHQvLyBBdm9pZCBydW5uaW5nIHF1ZXVlZCByb290IGVmZmVjdHMgb24gdGhlIHdyb25nIGJyYW5jaFxuXHRcdFx0XHRcdHZhciBwcmV2X3F1ZXVlZF9yb290X2VmZmVjdHMgPSBxdWV1ZWRfcm9vdF9lZmZlY3RzO1xuXHRcdFx0XHRcdHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7U2V0PFZhbHVlPn0gKi9cblx0XHRcdFx0XHRjb25zdCBtYXJrZWQgPSBuZXcgU2V0KCk7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtNYXA8UmVhY3Rpb24sIGJvb2xlYW4+fSAqL1xuXHRcdFx0XHRcdGNvbnN0IGNoZWNrZWQgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuXHRcdFx0XHRcdFx0bWFya19lZmZlY3RzKHNvdXJjZSwgb3RoZXJzLCBtYXJrZWQsIGNoZWNrZWQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChxdWV1ZWRfcm9vdF9lZmZlY3RzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRfYmF0Y2ggPSBiYXRjaDtcblx0XHRcdFx0XHRcdGJhdGNoLmFwcGx5KCk7XG5cblx0XHRcdFx0XHRcdGZvciAoY29uc3Qgcm9vdCBvZiBxdWV1ZWRfcm9vdF9lZmZlY3RzKSB7XG5cdFx0XHRcdFx0XHRcdGJhdGNoLiN0cmF2ZXJzZV9lZmZlY3RfdHJlZShyb290LCBkdW1teV90YXJnZXQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBUT0RPIGRvIHdlIG5lZWQgdG8gZG8gYW55dGhpbmcgd2l0aCBgdGFyZ2V0YD8gZGVmZXIgYmxvY2sgZWZmZWN0cz9cblxuXHRcdFx0XHRcdFx0YmF0Y2guZGVhY3RpdmF0ZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHF1ZXVlZF9yb290X2VmZmVjdHMgPSBwcmV2X3F1ZXVlZF9yb290X2VmZmVjdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudF9iYXRjaCA9IG51bGw7XG5cdFx0XHRiYXRjaF92YWx1ZXMgPSBwcmV2aW91c19iYXRjaF92YWx1ZXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb21taXR0ZWQgPSB0cnVlO1xuXHRcdGJhdGNoZXMuZGVsZXRlKHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYmxvY2tpbmdcblx0ICovXG5cdGluY3JlbWVudChibG9ja2luZykge1xuXHRcdHRoaXMuI3BlbmRpbmcgKz0gMTtcblx0XHRpZiAoYmxvY2tpbmcpIHRoaXMuI2Jsb2NraW5nX3BlbmRpbmcgKz0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGJsb2NraW5nXG5cdCAqL1xuXHRkZWNyZW1lbnQoYmxvY2tpbmcpIHtcblx0XHR0aGlzLiNwZW5kaW5nIC09IDE7XG5cdFx0aWYgKGJsb2NraW5nKSB0aGlzLiNibG9ja2luZ19wZW5kaW5nIC09IDE7XG5cblx0XHR0aGlzLnJldml2ZSgpO1xuXHR9XG5cblx0cmV2aXZlKCkge1xuXHRcdGZvciAoY29uc3QgZSBvZiB0aGlzLiNkaXJ0eV9lZmZlY3RzKSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlLCBESVJUWSk7XG5cdFx0XHRzY2hlZHVsZV9lZmZlY3QoZSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBlIG9mIHRoaXMuI21heWJlX2RpcnR5X2VmZmVjdHMpIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGUsIE1BWUJFX0RJUlRZKTtcblx0XHRcdHNjaGVkdWxlX2VmZmVjdChlKTtcblx0XHR9XG5cblx0XHR0aGlzLiNkaXJ0eV9lZmZlY3RzID0gW107XG5cdFx0dGhpcy4jbWF5YmVfZGlydHlfZWZmZWN0cyA9IFtdO1xuXG5cdFx0dGhpcy5mbHVzaCgpO1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm4gKi9cblx0b25jb21taXQoZm4pIHtcblx0XHR0aGlzLiNjb21taXRfY2FsbGJhY2tzLmFkZChmbik7XG5cdH1cblxuXHQvKiogQHBhcmFtIHsoYmF0Y2g6IEJhdGNoKSA9PiB2b2lkfSBmbiAqL1xuXHRvbmRpc2NhcmQoZm4pIHtcblx0XHR0aGlzLiNkaXNjYXJkX2NhbGxiYWNrcy5hZGQoZm4pO1xuXHR9XG5cblx0c2V0dGxlZCgpIHtcblx0XHRyZXR1cm4gKHRoaXMuI2RlZmVycmVkID8/PSBkZWZlcnJlZCgpKS5wcm9taXNlO1xuXHR9XG5cblx0c3RhdGljIGVuc3VyZSgpIHtcblx0XHRpZiAoY3VycmVudF9iYXRjaCA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc3QgYmF0Y2ggPSAoY3VycmVudF9iYXRjaCA9IG5ldyBCYXRjaCgpKTtcblx0XHRcdGJhdGNoZXMuYWRkKGN1cnJlbnRfYmF0Y2gpO1xuXG5cdFx0XHRpZiAoIWlzX2ZsdXNoaW5nX3N5bmMpIHtcblx0XHRcdFx0QmF0Y2guZW5xdWV1ZSgoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRfYmF0Y2ggIT09IGJhdGNoKSB7XG5cdFx0XHRcdFx0XHQvLyBhIGZsdXNoU3luYyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWVcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRiYXRjaC5mbHVzaCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY3VycmVudF9iYXRjaDtcblx0fVxuXG5cdC8qKiBAcGFyYW0geygpID0+IHZvaWR9IHRhc2sgKi9cblx0c3RhdGljIGVucXVldWUodGFzaykge1xuXHRcdHF1ZXVlX21pY3JvX3Rhc2sodGFzayk7XG5cdH1cblxuXHRhcHBseSgpIHtcblx0XHRpZiAoIWFzeW5jX21vZGVfZmxhZyB8fCAoIXRoaXMuaXNfZm9yayAmJiBiYXRjaGVzLnNpemUgPT09IDEpKSByZXR1cm47XG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgYmF0Y2hlcywgd2UgYXJlICd0aW1lIHRyYXZlbGxpbmcnIFx1MjAxNFxuXHRcdC8vIHdlIG5lZWQgdG8gb3ZlcnJpZGUgdmFsdWVzIHdpdGggdGhlIG9uZXMgaW4gdGhpcyBiYXRjaC4uLlxuXHRcdGJhdGNoX3ZhbHVlcyA9IG5ldyBNYXAodGhpcy5jdXJyZW50KTtcblxuXHRcdC8vIC4uLmFuZCB1bmRvIGNoYW5nZXMgYmVsb25naW5nIHRvIG90aGVyIGJhdGNoZXNcblx0XHRmb3IgKGNvbnN0IGJhdGNoIG9mIGJhdGNoZXMpIHtcblx0XHRcdGlmIChiYXRjaCA9PT0gdGhpcykgY29udGludWU7XG5cblx0XHRcdGZvciAoY29uc3QgW3NvdXJjZSwgcHJldmlvdXNdIG9mIGJhdGNoLnByZXZpb3VzKSB7XG5cdFx0XHRcdGlmICghYmF0Y2hfdmFsdWVzLmhhcyhzb3VyY2UpKSB7XG5cdFx0XHRcdFx0YmF0Y2hfdmFsdWVzLnNldChzb3VyY2UsIHByZXZpb3VzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZmx1c2ggYW55IHBlbmRpbmcgdXBkYXRlcy5cbiAqIFJldHVybnMgdm9pZCBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZCwgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBjYWxsYmFjay5cbiAqIEB0ZW1wbGF0ZSBbVD12b2lkXVxuICogQHBhcmFtIHsoKCkgPT4gVCkgfCB1bmRlZmluZWR9IFtmbl1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG5cdHZhciB3YXNfZmx1c2hpbmdfc3luYyA9IGlzX2ZsdXNoaW5nX3N5bmM7XG5cdGlzX2ZsdXNoaW5nX3N5bmMgPSB0cnVlO1xuXG5cdHRyeSB7XG5cdFx0dmFyIHJlc3VsdDtcblxuXHRcdGlmIChmbikge1xuXHRcdFx0aWYgKGN1cnJlbnRfYmF0Y2ggIT09IG51bGwpIHtcblx0XHRcdFx0Zmx1c2hfZWZmZWN0cygpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHQgPSBmbigpO1xuXHRcdH1cblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRmbHVzaF90YXNrcygpO1xuXG5cdFx0XHRpZiAocXVldWVkX3Jvb3RfZWZmZWN0cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Y3VycmVudF9iYXRjaD8uZmx1c2goKTtcblxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluLCBpbiBjYXNlIHdlIGp1c3QgdXBkYXRlZCBhbiBgJGVmZmVjdC5wZW5kaW5nKClgXG5cdFx0XHRcdGlmIChxdWV1ZWRfcm9vdF9lZmZlY3RzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIHRoaXMgd291bGQgYmUgcmVzZXQgaW4gYGZsdXNoX2VmZmVjdHMoKWAgYnV0IHNpbmNlIHdlIGFyZSBlYXJseSByZXR1cm5pbmcgaGVyZSxcblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHJlc2V0IGl0IGhlcmUgYXMgd2VsbCBpbiBjYXNlIHRoZSBmaXJzdCB0aW1lIHRoZXJlJ3MgMCBxdWV1ZWQgcm9vdCBlZmZlY3RzXG5cdFx0XHRcdFx0bGFzdF9zY2hlZHVsZWRfZWZmZWN0ID0gbnVsbDtcblxuXHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge1R9ICovIChyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZsdXNoX2VmZmVjdHMoKTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfZmx1c2hpbmdfc3luYyA9IHdhc19mbHVzaGluZ19zeW5jO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGZsdXNoX2VmZmVjdHMoKSB7XG5cdHZhciB3YXNfdXBkYXRpbmdfZWZmZWN0ID0gaXNfdXBkYXRpbmdfZWZmZWN0O1xuXHRpc19mbHVzaGluZyA9IHRydWU7XG5cblx0dmFyIHNvdXJjZV9zdGFja3MgPSBERVYgPyBuZXcgU2V0KCkgOiBudWxsO1xuXG5cdHRyeSB7XG5cdFx0dmFyIGZsdXNoX2NvdW50ID0gMDtcblx0XHRzZXRfaXNfdXBkYXRpbmdfZWZmZWN0KHRydWUpO1xuXG5cdFx0d2hpbGUgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIGJhdGNoID0gQmF0Y2guZW5zdXJlKCk7XG5cblx0XHRcdGlmIChmbHVzaF9jb3VudCsrID4gMTAwMCkge1xuXHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0dmFyIHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNvdXJjZSBvZiBiYXRjaC5jdXJyZW50LmtleXMoKSkge1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBbc3RhY2ssIHVwZGF0ZV0gb2Ygc291cmNlLnVwZGF0ZWQgPz8gW10pIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVudHJ5ID0gdXBkYXRlcy5nZXQoc3RhY2spO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghZW50cnkpIHtcblx0XHRcdFx0XHRcdFx0XHRlbnRyeSA9IHsgZXJyb3I6IHVwZGF0ZS5lcnJvciwgY291bnQ6IDAgfTtcblx0XHRcdFx0XHRcdFx0XHR1cGRhdGVzLnNldChzdGFjaywgZW50cnkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0ZW50cnkuY291bnQgKz0gdXBkYXRlLmNvdW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMudmFsdWVzKCkpIHtcblx0XHRcdFx0XHRcdGlmICh1cGRhdGUuZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcih1cGRhdGUuZXJyb3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZmluaXRlX2xvb3BfZ3VhcmQoKTtcblx0XHRcdH1cblxuXHRcdFx0YmF0Y2gucHJvY2VzcyhxdWV1ZWRfcm9vdF9lZmZlY3RzKTtcblx0XHRcdG9sZF92YWx1ZXMuY2xlYXIoKTtcblxuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRmb3IgKGNvbnN0IHNvdXJjZSBvZiBiYXRjaC5jdXJyZW50LmtleXMoKSkge1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7U2V0PFNvdXJjZT59ICovIChzb3VyY2Vfc3RhY2tzKS5hZGQoc291cmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRpc19mbHVzaGluZyA9IGZhbHNlO1xuXHRcdHNldF9pc191cGRhdGluZ19lZmZlY3Qod2FzX3VwZGF0aW5nX2VmZmVjdCk7XG5cblx0XHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBudWxsO1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0Zm9yIChjb25zdCBzb3VyY2Ugb2YgLyoqIEB0eXBlIHtTZXQ8U291cmNlPn0gKi8gKHNvdXJjZV9zdGFja3MpKSB7XG5cdFx0XHRcdHNvdXJjZS51cGRhdGVkID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaW5maW5pdGVfbG9vcF9ndWFyZCgpIHtcblx0dHJ5IHtcblx0XHRlLmVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQoKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHQvLyBzdGFjayBjb250YWlucyBubyB1c2VmdWwgaW5mb3JtYXRpb24sIHJlcGxhY2UgaXRcblx0XHRcdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywgeyB2YWx1ZTogJycgfSk7XG5cdFx0fVxuXG5cdFx0Ly8gQmVzdCBlZmZvcnQ6IGludm9rZSB0aGUgYm91bmRhcnkgbmVhcmVzdCB0aGUgbW9zdCByZWNlbnRcblx0XHQvLyBlZmZlY3QgYW5kIGhvcGUgdGhhdCBpdCdzIHJlbGV2YW50IHRvIHRoZSBpbmZpbml0ZSBsb29wXG5cdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBsYXN0X3NjaGVkdWxlZF9lZmZlY3QpO1xuXHR9XG59XG5cbi8qKiBAdHlwZSB7U2V0PEVmZmVjdD4gfCBudWxsfSAqL1xuZXhwb3J0IGxldCBlYWdlcl9ibG9ja19lZmZlY3RzID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEVmZmVjdD59IGVmZmVjdHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBmbHVzaF9xdWV1ZWRfZWZmZWN0cyhlZmZlY3RzKSB7XG5cdHZhciBsZW5ndGggPSBlZmZlY3RzLmxlbmd0aDtcblx0aWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG5cdHZhciBpID0gMDtcblxuXHR3aGlsZSAoaSA8IGxlbmd0aCkge1xuXHRcdHZhciBlZmZlY3QgPSBlZmZlY3RzW2krK107XG5cblx0XHRpZiAoKGVmZmVjdC5mICYgKERFU1RST1lFRCB8IElORVJUKSkgPT09IDAgJiYgaXNfZGlydHkoZWZmZWN0KSkge1xuXHRcdFx0ZWFnZXJfYmxvY2tfZWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuXHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXG5cdFx0XHQvLyBFZmZlY3RzIHdpdGggbm8gZGVwZW5kZW5jaWVzIG9yIHRlYXJkb3duIGRvIG5vdCBnZXQgYWRkZWQgdG8gdGhlIGVmZmVjdCB0cmVlLlxuXHRcdFx0Ly8gRGVmZXJyZWQgZWZmZWN0cyAoZS5nLiBgJGVmZmVjdCguLi4pYCkgX2FyZV8gYWRkZWQgdG8gdGhlIHRyZWUgYmVjYXVzZSB3ZVxuXHRcdFx0Ly8gZG9uJ3Qga25vdyBpZiB3ZSBuZWVkIHRvIGtlZXAgdGhlbSB1bnRpbCB0aGV5IGFyZSBleGVjdXRlZC4gRG9pbmcgdGhlIGNoZWNrXG5cdFx0XHQvLyBoZXJlIChyYXRoZXIgdGhhbiBpbiBgdXBkYXRlX2VmZmVjdGApIGFsbG93cyB1cyB0byBza2lwIHRoZSB3b3JrIGZvclxuXHRcdFx0Ly8gaW1tZWRpYXRlIGVmZmVjdHMuXG5cdFx0XHRpZiAoZWZmZWN0LmRlcHMgPT09IG51bGwgJiYgZWZmZWN0LmZpcnN0ID09PSBudWxsICYmIGVmZmVjdC5ub2Rlc19zdGFydCA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBpZiB0aGVyZSdzIG5vIHRlYXJkb3duIG9yIGFib3J0IGNvbnRyb2xsZXIgd2UgY29tcGxldGVseSB1bmxpbmtcblx0XHRcdFx0Ly8gdGhlIGVmZmVjdCBmcm9tIHRoZSBncmFwaFxuXHRcdFx0XHRpZiAoZWZmZWN0LnRlYXJkb3duID09PSBudWxsICYmIGVmZmVjdC5hYyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSB0aGlzIGVmZmVjdCBmcm9tIHRoZSBncmFwaFxuXHRcdFx0XHRcdHVubGlua19lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBrZWVwIHRoZSBlZmZlY3QgaW4gdGhlIGdyYXBoLCBidXQgZnJlZSB1cCBzb21lIG1lbW9yeVxuXHRcdFx0XHRcdGVmZmVjdC5mbiA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdXBkYXRlX2VmZmVjdCgpIGhhcyBhIGZsdXNoU3luYygpIGluIGl0LCB3ZSBtYXkgaGF2ZSBmbHVzaGVkIGFub3RoZXIgZmx1c2hfcXVldWVkX2VmZmVjdHMoKSxcblx0XHRcdC8vIHdoaWNoIGFscmVhZHkgaGFuZGxlZCB0aGlzIGxvZ2ljIGFuZCBkaWQgc2V0IGVhZ2VyX2Jsb2NrX2VmZmVjdHMgdG8gbnVsbC5cblx0XHRcdGlmIChlYWdlcl9ibG9ja19lZmZlY3RzPy5zaXplID4gMCkge1xuXHRcdFx0XHRvbGRfdmFsdWVzLmNsZWFyKCk7XG5cblx0XHRcdFx0Zm9yIChjb25zdCBlIG9mIGVhZ2VyX2Jsb2NrX2VmZmVjdHMpIHtcblx0XHRcdFx0XHQvLyBTa2lwIGVhZ2VyIGVmZmVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiB1bm1vdW50ZWRcblx0XHRcdFx0XHRpZiAoKGUuZiAmIChERVNUUk9ZRUQgfCBJTkVSVCkpICE9PSAwKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdC8vIFJ1biBlZmZlY3RzIGluIG9yZGVyIGZyb20gYW5jZXN0b3IgdG8gZGVzY2VuZGFudCwgZWxzZSB3ZSBjb3VsZCBydW4gaW50byBudWxscG9pbnRlcnNcblx0XHRcdFx0XHQvKiogQHR5cGUge0VmZmVjdFtdfSAqL1xuXHRcdFx0XHRcdGNvbnN0IG9yZGVyZWRfZWZmZWN0cyA9IFtlXTtcblx0XHRcdFx0XHRsZXQgYW5jZXN0b3IgPSBlLnBhcmVudDtcblx0XHRcdFx0XHR3aGlsZSAoYW5jZXN0b3IgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmIChlYWdlcl9ibG9ja19lZmZlY3RzLmhhcyhhbmNlc3RvcikpIHtcblx0XHRcdFx0XHRcdFx0ZWFnZXJfYmxvY2tfZWZmZWN0cy5kZWxldGUoYW5jZXN0b3IpO1xuXHRcdFx0XHRcdFx0XHRvcmRlcmVkX2VmZmVjdHMucHVzaChhbmNlc3Rvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gb3JkZXJlZF9lZmZlY3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBlID0gb3JkZXJlZF9lZmZlY3RzW2pdO1xuXHRcdFx0XHRcdFx0Ly8gU2tpcCBlYWdlciBlZmZlY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gdW5tb3VudGVkXG5cdFx0XHRcdFx0XHRpZiAoKGUuZiAmIChERVNUUk9ZRUQgfCBJTkVSVCkpICE9PSAwKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWFnZXJfYmxvY2tfZWZmZWN0cy5jbGVhcigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGVhZ2VyX2Jsb2NrX2VmZmVjdHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgc2ltaWxhciB0byBgbWFya19yZWFjdGlvbnNgLCBidXQgaXQgb25seSBtYXJrcyBhc3luYy9ibG9jayBlZmZlY3RzXG4gKiBkZXBlbmRpbmcgb24gYHZhbHVlYCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZSBvdGhlciBgc291cmNlc2AsIHNvIHRoYXRcbiAqIHRoZXNlIGVmZmVjdHMgY2FuIHJlLXJ1biBhZnRlciBhbm90aGVyIGJhdGNoIGhhcyBiZWVuIGNvbW1pdHRlZFxuICogQHBhcmFtIHtWYWx1ZX0gdmFsdWVcbiAqIEBwYXJhbSB7U291cmNlW119IHNvdXJjZXNcbiAqIEBwYXJhbSB7U2V0PFZhbHVlPn0gbWFya2VkXG4gKiBAcGFyYW0ge01hcDxSZWFjdGlvbiwgYm9vbGVhbj59IGNoZWNrZWRcbiAqL1xuZnVuY3Rpb24gbWFya19lZmZlY3RzKHZhbHVlLCBzb3VyY2VzLCBtYXJrZWQsIGNoZWNrZWQpIHtcblx0aWYgKG1hcmtlZC5oYXModmFsdWUpKSByZXR1cm47XG5cdG1hcmtlZC5hZGQodmFsdWUpO1xuXG5cdGlmICh2YWx1ZS5yZWFjdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHJlYWN0aW9uIG9mIHZhbHVlLnJlYWN0aW9ucykge1xuXHRcdFx0Y29uc3QgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdFx0XHRpZiAoKGZsYWdzICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdFx0bWFya19lZmZlY3RzKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgc291cmNlcywgbWFya2VkLCBjaGVja2VkKTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdChmbGFncyAmIChBU1lOQyB8IEJMT0NLX0VGRkVDVCkpICE9PSAwICYmXG5cdFx0XHRcdChmbGFncyAmIERJUlRZKSA9PT0gMCAmJlxuXHRcdFx0XHRkZXBlbmRzX29uKHJlYWN0aW9uLCBzb3VyY2VzLCBjaGVja2VkKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBESVJUWSk7XG5cdFx0XHRcdHNjaGVkdWxlX2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogV2hlbiBjb21taXR0aW5nIGEgZm9yaywgd2UgbmVlZCB0byB0cmlnZ2VyIGVhZ2VyIGVmZmVjdHMgc28gdGhhdFxuICogYW55IGAkc3RhdGUuZWFnZXIoLi4uKWAgZXhwcmVzc2lvbnMgdXBkYXRlIGltbWVkaWF0ZWx5LiBUaGlzXG4gKiBmdW5jdGlvbiBhbGxvd3MgdXMgdG8gZGlzY292ZXIgdGhlbVxuICogQHBhcmFtIHtWYWx1ZX0gdmFsdWVcbiAqIEBwYXJhbSB7U2V0PEVmZmVjdD59IGVmZmVjdHNcbiAqL1xuZnVuY3Rpb24gbWFya19lYWdlcl9lZmZlY3RzKHZhbHVlLCBlZmZlY3RzKSB7XG5cdGlmICh2YWx1ZS5yZWFjdGlvbnMgPT09IG51bGwpIHJldHVybjtcblxuXHRmb3IgKGNvbnN0IHJlYWN0aW9uIG9mIHZhbHVlLnJlYWN0aW9ucykge1xuXHRcdGNvbnN0IGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRcdGlmICgoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0bWFya19lYWdlcl9lZmZlY3RzKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgZWZmZWN0cyk7XG5cdFx0fSBlbHNlIGlmICgoZmxhZ3MgJiBFQUdFUl9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgRElSVFkpO1xuXHRcdFx0ZWZmZWN0cy5hZGQoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChyZWFjdGlvbikpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHJlYWN0aW9uXG4gKiBAcGFyYW0ge1NvdXJjZVtdfSBzb3VyY2VzXG4gKiBAcGFyYW0ge01hcDxSZWFjdGlvbiwgYm9vbGVhbj59IGNoZWNrZWRcbiAqL1xuZnVuY3Rpb24gZGVwZW5kc19vbihyZWFjdGlvbiwgc291cmNlcywgY2hlY2tlZCkge1xuXHRjb25zdCBkZXBlbmRzID0gY2hlY2tlZC5nZXQocmVhY3Rpb24pO1xuXHRpZiAoZGVwZW5kcyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZGVwZW5kcztcblxuXHRpZiAocmVhY3Rpb24uZGVwcyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgZGVwIG9mIHJlYWN0aW9uLmRlcHMpIHtcblx0XHRcdGlmIChzb3VyY2VzLmluY2x1ZGVzKGRlcCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgoZGVwLmYgJiBERVJJVkVEKSAhPT0gMCAmJiBkZXBlbmRzX29uKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcCksIHNvdXJjZXMsIGNoZWNrZWQpKSB7XG5cdFx0XHRcdGNoZWNrZWQuc2V0KC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcCksIHRydWUpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjaGVja2VkLnNldChyZWFjdGlvbiwgZmFsc2UpO1xuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlX2VmZmVjdChzaWduYWwpIHtcblx0dmFyIGVmZmVjdCA9IChsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBzaWduYWwpO1xuXG5cdHdoaWxlIChlZmZlY3QucGFyZW50ICE9PSBudWxsKSB7XG5cdFx0ZWZmZWN0ID0gZWZmZWN0LnBhcmVudDtcblx0XHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRcdC8vIGlmIHRoZSBlZmZlY3QgaXMgYmVpbmcgc2NoZWR1bGVkIGJlY2F1c2UgYSBwYXJlbnQgKGVhY2gvYXdhaXQvZXRjKSBibG9ja1xuXHRcdC8vIHVwZGF0ZWQgYW4gaW50ZXJuYWwgc291cmNlLCBiYWlsIG91dCBvciB3ZSdsbCBjYXVzZSBhIHNlY29uZCBmbHVzaFxuXHRcdGlmIChcblx0XHRcdGlzX2ZsdXNoaW5nICYmXG5cdFx0XHRlZmZlY3QgPT09IGFjdGl2ZV9lZmZlY3QgJiZcblx0XHRcdChmbGFncyAmIEJMT0NLX0VGRkVDVCkgIT09IDAgJiZcblx0XHRcdChmbGFncyAmIEhFQURfRUZGRUNUKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgoZmxhZ3MgJiAoUk9PVF9FRkZFQ1QgfCBCUkFOQ0hfRUZGRUNUKSkgIT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBDTEVBTikgPT09IDApIHJldHVybjtcblx0XHRcdGVmZmVjdC5mIF49IENMRUFOO1xuXHRcdH1cblx0fVxuXG5cdHF1ZXVlZF9yb290X2VmZmVjdHMucHVzaChlZmZlY3QpO1xufVxuXG4vKiogQHR5cGUge1NvdXJjZTxudW1iZXI+W119ICovXG5sZXQgZWFnZXJfdmVyc2lvbnMgPSBbXTtcblxuZnVuY3Rpb24gZWFnZXJfZmx1c2goKSB7XG5cdHRyeSB7XG5cdFx0Zmx1c2hTeW5jKCgpID0+IHtcblx0XHRcdGZvciAoY29uc3QgdmVyc2lvbiBvZiBlYWdlcl92ZXJzaW9ucykge1xuXHRcdFx0XHR1cGRhdGUodmVyc2lvbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0gZmluYWxseSB7XG5cdFx0ZWFnZXJfdmVyc2lvbnMgPSBbXTtcblx0fVxufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGAkc3RhdGUuZWFnZXIoZm4oKSlgXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWdlcihmbikge1xuXHR2YXIgdmVyc2lvbiA9IHNvdXJjZSgwKTtcblx0dmFyIGluaXRpYWwgPSB0cnVlO1xuXHR2YXIgdmFsdWUgPSAvKiogQHR5cGUge1R9ICovICh1bmRlZmluZWQpO1xuXG5cdGdldCh2ZXJzaW9uKTtcblxuXHRlYWdlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChpbml0aWFsKSB7XG5cdFx0XHQvLyB0aGUgZmlyc3QgdGltZSB0aGlzIHJ1bnMsIHdlIGNyZWF0ZSBhbiBlYWdlciBlZmZlY3Rcblx0XHRcdC8vIHRoYXQgd2lsbCBydW4gZWFnZXJseSB3aGVuZXZlciB0aGUgZXhwcmVzc2lvbiBjaGFuZ2VzXG5cdFx0XHR2YXIgcHJldmlvdXNfYmF0Y2hfdmFsdWVzID0gYmF0Y2hfdmFsdWVzO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRiYXRjaF92YWx1ZXMgPSBudWxsO1xuXHRcdFx0XHR2YWx1ZSA9IGZuKCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRiYXRjaF92YWx1ZXMgPSBwcmV2aW91c19iYXRjaF92YWx1ZXM7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyB0aGUgc2Vjb25kIHRpbWUgdGhpcyBlZmZlY3QgcnVucywgaXQncyB0byBzY2hlZHVsZSBhXG5cdFx0Ly8gYHZlcnNpb25gIHVwZGF0ZS4gc2luY2UgdGhpcyB3aWxsIHJlY3JlYXRlIHRoZSBlZmZlY3QsXG5cdFx0Ly8gd2UgZG9uJ3QgbmVlZCB0byBldmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBoZXJlXG5cdFx0aWYgKGVhZ2VyX3ZlcnNpb25zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cXVldWVfbWljcm9fdGFzayhlYWdlcl9mbHVzaCk7XG5cdFx0fVxuXG5cdFx0ZWFnZXJfdmVyc2lvbnMucHVzaCh2ZXJzaW9uKTtcblx0fSk7XG5cblx0aW5pdGlhbCA9IGZhbHNlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgJ2ZvcmsnLCBpbiB3aGljaCBzdGF0ZSBjaGFuZ2VzIGFyZSBldmFsdWF0ZWQgYnV0IG5vdCBhcHBsaWVkIHRvIHRoZSBET00uXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3Igc3BlY3VsYXRpdmVseSBsb2FkaW5nIGRhdGEgKGZvciBleGFtcGxlKSB3aGVuIHlvdSBzdXNwZWN0IHRoYXRcbiAqIHRoZSB1c2VyIGlzIGFib3V0IHRvIHRha2Ugc29tZSBhY3Rpb24uXG4gKlxuICogRnJhbWV3b3JrcyBsaWtlIFN2ZWx0ZUtpdCBjYW4gdXNlIHRoaXMgdG8gcHJlbG9hZCBkYXRhIHdoZW4gdGhlIHVzZXIgdG91Y2hlcyBvclxuICogaG92ZXJzIG92ZXIgYSBsaW5rLCBtYWtpbmcgYW55IHN1YnNlcXVlbnQgbmF2aWdhdGlvbiBmZWVsIGluc3RhbnRhbmVvdXMuXG4gKlxuICogVGhlIGBmbmAgcGFyYW1ldGVyIGlzIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBtb2RpZmllcyBzb21lIHN0YXRlLiBUaGVcbiAqIHN0YXRlIGNoYW5nZXMgd2lsbCBiZSByZXZlcnRlZCBhZnRlciB0aGUgZm9yayBpcyBpbml0aWFsaXNlZCwgdGhlbiByZWFwcGxpZWRcbiAqIGlmIGFuZCB3aGVuIHRoZSBmb3JrIGlzIGV2ZW50dWFsbHkgY29tbWl0dGVkLlxuICpcbiAqIFdoZW4gaXQgYmVjb21lcyBjbGVhciB0aGF0IGEgZm9yayB3aWxsIF9ub3RfIGJlIGNvbW1pdHRlZCAoZS5nLiBiZWNhdXNlIHRoZVxuICogdXNlciBuYXZpZ2F0ZWQgZWxzZXdoZXJlKSwgaXQgbXVzdCBiZSBkaXNjYXJkZWQgdG8gYXZvaWQgbGVha2luZyBtZW1vcnkuXG4gKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMge0Zvcmt9XG4gKiBAc2luY2UgNS40MlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yayhmbikge1xuXHRpZiAoIWFzeW5jX21vZGVfZmxhZykge1xuXHRcdGUuZXhwZXJpbWVudGFsX2FzeW5jX3JlcXVpcmVkKCdmb3JrJyk7XG5cdH1cblxuXHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCkge1xuXHRcdGUuZm9ya190aW1pbmcoKTtcblx0fVxuXG5cdHZhciBiYXRjaCA9IEJhdGNoLmVuc3VyZSgpO1xuXHRiYXRjaC5pc19mb3JrID0gdHJ1ZTtcblx0YmF0Y2hfdmFsdWVzID0gbmV3IE1hcCgpO1xuXG5cdHZhciBjb21taXR0ZWQgPSBmYWxzZTtcblx0dmFyIHNldHRsZWQgPSBiYXRjaC5zZXR0bGVkKCk7XG5cblx0Zmx1c2hTeW5jKGZuKTtcblxuXHRiYXRjaF92YWx1ZXMgPSBudWxsO1xuXG5cdC8vIHJldmVydCBzdGF0ZSBjaGFuZ2VzXG5cdGZvciAodmFyIFtzb3VyY2UsIHZhbHVlXSBvZiBiYXRjaC5wcmV2aW91cykge1xuXHRcdHNvdXJjZS52ID0gdmFsdWU7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNvbW1pdDogYXN5bmMgKCkgPT4ge1xuXHRcdFx0aWYgKGNvbW1pdHRlZCkge1xuXHRcdFx0XHRhd2FpdCBzZXR0bGVkO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICghYmF0Y2hlcy5oYXMoYmF0Y2gpKSB7XG5cdFx0XHRcdGUuZm9ya19kaXNjYXJkZWQoKTtcblx0XHRcdH1cblxuXHRcdFx0Y29tbWl0dGVkID0gdHJ1ZTtcblxuXHRcdFx0YmF0Y2guaXNfZm9yayA9IGZhbHNlO1xuXG5cdFx0XHQvLyBhcHBseSBjaGFuZ2VzXG5cdFx0XHRmb3IgKHZhciBbc291cmNlLCB2YWx1ZV0gb2YgYmF0Y2guY3VycmVudCkge1xuXHRcdFx0XHRzb3VyY2UudiA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cmlnZ2VyIGFueSBgJHN0YXRlLmVhZ2VyKC4uLilgIGV4cHJlc3Npb25zIHdpdGggdGhlIG5ldyBzdGF0ZS5cblx0XHRcdC8vIGVhZ2VyIGVmZmVjdHMgZG9uJ3QgZ2V0IHNjaGVkdWxlZCBsaWtlIG90aGVyIGVmZmVjdHMsIHNvIHdlXG5cdFx0XHQvLyBjYW4ndCBqdXN0IGVuY291bnRlciB0aGVtIGR1cmluZyB0cmF2ZXJzYWwsIHdlIG5lZWQgdG9cblx0XHRcdC8vIHByb2FjdGl2ZWx5IGZsdXNoIHRoZW1cblx0XHRcdC8vIFRPRE8gbWF5YmUgdGhlcmUncyBhIGJldHRlciBpbXBsZW1lbnRhdGlvbj9cblx0XHRcdGZsdXNoU3luYygoKSA9PiB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7U2V0PEVmZmVjdD59ICovXG5cdFx0XHRcdHZhciBlYWdlcl9lZmZlY3RzID0gbmV3IFNldCgpO1xuXG5cdFx0XHRcdGZvciAodmFyIHNvdXJjZSBvZiBiYXRjaC5jdXJyZW50LmtleXMoKSkge1xuXHRcdFx0XHRcdG1hcmtfZWFnZXJfZWZmZWN0cyhzb3VyY2UsIGVhZ2VyX2VmZmVjdHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0X2VhZ2VyX2VmZmVjdHMoZWFnZXJfZWZmZWN0cyk7XG5cdFx0XHRcdGZsdXNoX2VhZ2VyX2VmZmVjdHMoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRiYXRjaC5yZXZpdmUoKTtcblx0XHRcdGF3YWl0IHNldHRsZWQ7XG5cdFx0fSxcblx0XHRkaXNjYXJkOiAoKSA9PiB7XG5cdFx0XHRpZiAoIWNvbW1pdHRlZCAmJiBiYXRjaGVzLmhhcyhiYXRjaCkpIHtcblx0XHRcdFx0YmF0Y2hlcy5kZWxldGUoYmF0Y2gpO1xuXHRcdFx0XHRiYXRjaC5kaXNjYXJkKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEZvcmNpYmx5IHJlbW92ZSBhbGwgY3VycmVudCBiYXRjaGVzLCB0byBwcmV2ZW50IGNyb3NzLXRhbGsgYmV0d2VlbiB0ZXN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG5cdGJhdGNoZXMuY2xlYXIoKTtcbn1cbiIsICJpbXBvcnQgeyBnZXQsIHRpY2ssIHVudHJhY2sgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlZmZlY3RfdHJhY2tpbmcsIHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSwgaW5jcmVtZW50IH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyB0YWcgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L2RvbS90YXNrLmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgYHN1YnNjcmliZWAgZnVuY3Rpb24gdGhhdCBpbnRlZ3JhdGVzIGV4dGVybmFsIGV2ZW50LWJhc2VkIHN5c3RlbXMgd2l0aCBTdmVsdGUncyByZWFjdGl2aXR5LlxuICogSXQncyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBpbnRlZ3JhdGluZyB3aXRoIHdlYiBBUElzIGxpa2UgYE1lZGlhUXVlcnlgLCBgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJgLCBvciBgV2ViU29ja2V0YC5cbiAqXG4gKiBJZiBgc3Vic2NyaWJlYCBpcyBjYWxsZWQgaW5zaWRlIGFuIGVmZmVjdCAoaW5jbHVkaW5nIGluZGlyZWN0bHksIGZvciBleGFtcGxlIGluc2lkZSBhIGdldHRlciksXG4gKiB0aGUgYHN0YXJ0YCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGB1cGRhdGVgIGZ1bmN0aW9uLiBXaGVuZXZlciBgdXBkYXRlYCBpcyBjYWxsZWQsIHRoZSBlZmZlY3QgcmUtcnVucy5cbiAqXG4gKiBJZiBgc3RhcnRgIHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBlZmZlY3QgaXMgZGVzdHJveWVkLlxuICpcbiAqIElmIGBzdWJzY3JpYmVgIGlzIGNhbGxlZCBpbiBtdWx0aXBsZSBlZmZlY3RzLCBgc3RhcnRgIHdpbGwgb25seSBiZSBjYWxsZWQgb25jZSBhcyBsb25nIGFzIHRoZSBlZmZlY3RzXG4gKiBhcmUgYWN0aXZlLCBhbmQgdGhlIHJldHVybmVkIHRlYXJkb3duIGZ1bmN0aW9uIHdpbGwgb25seSBiZSBjYWxsZWQgd2hlbiBhbGwgZWZmZWN0cyBhcmUgZGVzdHJveWVkLlxuICpcbiAqIEl0J3MgYmVzdCB1bmRlcnN0b29kIHdpdGggYW4gZXhhbXBsZS4gSGVyZSdzIGFuIGltcGxlbWVudGF0aW9uIG9mIFtgTWVkaWFRdWVyeWBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUtcmVhY3Rpdml0eSNNZWRpYVF1ZXJ5KTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgY3JlYXRlU3Vic2NyaWJlciB9IGZyb20gJ3N2ZWx0ZS9yZWFjdGl2aXR5JztcbiAqIGltcG9ydCB7IG9uIH0gZnJvbSAnc3ZlbHRlL2V2ZW50cyc7XG4gKlxuICogZXhwb3J0IGNsYXNzIE1lZGlhUXVlcnkge1xuICogXHQjcXVlcnk7XG4gKiBcdCNzdWJzY3JpYmU7XG4gKlxuICogXHRjb25zdHJ1Y3RvcihxdWVyeSkge1xuICogXHRcdHRoaXMuI3F1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoYCgke3F1ZXJ5fSlgKTtcbiAqXG4gKiBcdFx0dGhpcy4jc3Vic2NyaWJlID0gY3JlYXRlU3Vic2NyaWJlcigodXBkYXRlKSA9PiB7XG4gKiBcdFx0XHQvLyB3aGVuIHRoZSBgY2hhbmdlYCBldmVudCBvY2N1cnMsIHJlLXJ1biBhbnkgZWZmZWN0cyB0aGF0IHJlYWQgYHRoaXMuY3VycmVudGBcbiAqIFx0XHRcdGNvbnN0IG9mZiA9IG9uKHRoaXMuI3F1ZXJ5LCAnY2hhbmdlJywgdXBkYXRlKTtcbiAqXG4gKiBcdFx0XHQvLyBzdG9wIGxpc3RlbmluZyB3aGVuIGFsbCB0aGUgZWZmZWN0cyBhcmUgZGVzdHJveWVkXG4gKiBcdFx0XHRyZXR1cm4gKCkgPT4gb2ZmKCk7XG4gKiBcdFx0fSk7XG4gKiBcdH1cbiAqXG4gKiBcdGdldCBjdXJyZW50KCkge1xuICogXHRcdC8vIFRoaXMgbWFrZXMgdGhlIGdldHRlciByZWFjdGl2ZSwgaWYgcmVhZCBpbiBhbiBlZmZlY3RcbiAqIFx0XHR0aGlzLiNzdWJzY3JpYmUoKTtcbiAqXG4gKiBcdFx0Ly8gUmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBxdWVyeSwgd2hldGhlciBvciBub3Qgd2UncmUgaW4gYW4gZWZmZWN0XG4gKiBcdFx0cmV0dXJuIHRoaXMuI3F1ZXJ5Lm1hdGNoZXM7XG4gKiBcdH1cbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIHsodXBkYXRlOiAoKSA9PiB2b2lkKSA9PiAoKCkgPT4gdm9pZCkgfCB2b2lkfSBzdGFydFxuICogQHNpbmNlIDUuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmVyKHN0YXJ0KSB7XG5cdGxldCBzdWJzY3JpYmVycyA9IDA7XG5cdGxldCB2ZXJzaW9uID0gc291cmNlKDApO1xuXHQvKiogQHR5cGUgeygoKSA9PiB2b2lkKSB8IHZvaWR9ICovXG5cdGxldCBzdG9wO1xuXG5cdGlmIChERVYpIHtcblx0XHR0YWcodmVyc2lvbiwgJ2NyZWF0ZVN1YnNjcmliZXIgdmVyc2lvbicpO1xuXHR9XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoZWZmZWN0X3RyYWNraW5nKCkpIHtcblx0XHRcdGdldCh2ZXJzaW9uKTtcblxuXHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdGlmIChzdWJzY3JpYmVycyA9PT0gMCkge1xuXHRcdFx0XHRcdHN0b3AgPSB1bnRyYWNrKCgpID0+IHN0YXJ0KCgpID0+IGluY3JlbWVudCh2ZXJzaW9uKSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3Vic2NyaWJlcnMgKz0gMTtcblxuXHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gT25seSBjb3VudCBkb3duIGFmdGVyIGEgbWljcm90YXNrLCBlbHNlIHdlIHdvdWxkIHJlYWNoIDAgYmVmb3JlIG91ciBvd24gcmVuZGVyIGVmZmVjdCByZXJ1bnMsXG5cdFx0XHRcdFx0XHQvLyBidXQgcmVhY2ggMSBhZ2FpbiB3aGVuIHRoZSB0aWNrIGNhbGxiYWNrIG9mIHRoZSBwcmlvciB0ZWFyZG93biBydW5zLiBUaGF0IHdvdWxkIG1lYW4gd2Vcblx0XHRcdFx0XHRcdC8vIHJlLXN1YmNyaWJlIHVubmVjZXNzYXJpbHkgYW5kIGNyZWF0ZSBhIG1lbW9yeSBsZWFrIGJlY2F1c2UgdGhlIG9sZCBzdWJzY3JpcHRpb24gaXMgbmV2ZXIgY2xlYW5lZCB1cC5cblx0XHRcdFx0XHRcdHN1YnNjcmliZXJzIC09IDE7XG5cblx0XHRcdFx0XHRcdGlmIChzdWJzY3JpYmVycyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRzdG9wPy4oKTtcblx0XHRcdFx0XHRcdFx0c3RvcCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0Ly8gSW5jcmVtZW50IHRoZSB2ZXJzaW9uIHRvIGVuc3VyZSBhbnkgZGVwZW5kZW50IGRlcml2ZWRzIGFyZSBtYXJrZWQgZGlydHkgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIGlzIHBpY2tlZCB1cCBhZ2FpbiBsYXRlci5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UgZGlkbid0IGRvIHRoaXMgdGhlbiB0aGUgY29tcGFyaXNvbiBvZiB3cml0ZSB2ZXJzaW9ucyB3b3VsZCBkZXRlcm1pbmUgdGhhdCB0aGUgZGVyaXZlZCBoYXMgYSBsYXRlciB2ZXJzaW9uIHRoYW5cblx0XHRcdFx0XHRcdFx0Ly8gdGhlIHN1YnNjcmliZXIsIGFuZCBpdCB3b3VsZCBub3QgYmUgcmUtcnVuLlxuXHRcdFx0XHRcdFx0XHRpbmNyZW1lbnQodmVyc2lvbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFNvdXJjZSwgVGVtcGxhdGVOb2RlLCB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRCT1VOREFSWV9FRkZFQ1QsXG5cdENPTU1FTlRfTk9ERSxcblx0RUZGRUNUX1BSRVNFUlZFRCxcblx0RUZGRUNUX1RSQU5TUEFSRU5UXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IEhZRFJBVElPTl9TVEFSVF9FTFNFIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBzZXRfY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGhhbmRsZV9lcnJvciwgaW52b2tlX2Vycm9yX2JvdW5kYXJ5IH0gZnJvbSAnLi4vLi4vZXJyb3ItaGFuZGxpbmcuanMnO1xuaW1wb3J0IHtcblx0YmxvY2ssXG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdG1vdmVfZWZmZWN0LFxuXHRwYXVzZV9lZmZlY3Rcbn0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0Z2V0LFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdG5leHQsXG5cdHNraXBfbm9kZXMsXG5cdHNldF9oeWRyYXRlX25vZGVcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBCYXRjaCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuaW1wb3J0IHsgaW50ZXJuYWxfc2V0LCBzb3VyY2UgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgdGFnIH0gZnJvbSAnLi4vLi4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3Vic2NyaWJlciB9IGZyb20gJy4uLy4uLy4uLy4uL3JlYWN0aXZpdHkvY3JlYXRlLXN1YnNjcmliZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3RleHQgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogXHQgb25lcnJvcj86IChlcnJvcjogdW5rbm93biwgcmVzZXQ6ICgpID0+IHZvaWQpID0+IHZvaWQ7XG4gKiAgIGZhaWxlZD86IChhbmNob3I6IE5vZGUsIGVycm9yOiAoKSA9PiB1bmtub3duLCByZXNldDogKCkgPT4gKCkgPT4gdm9pZCkgPT4gdm9pZDtcbiAqICAgcGVuZGluZz86IChhbmNob3I6IE5vZGUpID0+IHZvaWQ7XG4gKiB9fSBCb3VuZGFyeVByb3BzXG4gKi9cblxudmFyIGZsYWdzID0gRUZGRUNUX1RSQU5TUEFSRU5UIHwgRUZGRUNUX1BSRVNFUlZFRCB8IEJPVU5EQVJZX0VGRkVDVDtcblxuLyoqXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtCb3VuZGFyeVByb3BzfSBwcm9wc1xuICogQHBhcmFtIHsoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9IGNoaWxkcmVuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5kYXJ5KG5vZGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRuZXcgQm91bmRhcnkobm9kZSwgcHJvcHMsIGNoaWxkcmVuKTtcbn1cblxuZXhwb3J0IGNsYXNzIEJvdW5kYXJ5IHtcblx0LyoqIEB0eXBlIHtCb3VuZGFyeSB8IG51bGx9ICovXG5cdHBhcmVudDtcblxuXHQjcGVuZGluZyA9IGZhbHNlO1xuXG5cdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqL1xuXHQjYW5jaG9yO1xuXG5cdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gKi9cblx0I2h5ZHJhdGVfb3BlbiA9IGh5ZHJhdGluZyA/IGh5ZHJhdGVfbm9kZSA6IG51bGw7XG5cblx0LyoqIEB0eXBlIHtCb3VuZGFyeVByb3BzfSAqL1xuXHQjcHJvcHM7XG5cblx0LyoqIEB0eXBlIHsoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9ICovXG5cdCNjaGlsZHJlbjtcblxuXHQvKiogQHR5cGUge0VmZmVjdH0gKi9cblx0I2VmZmVjdDtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdCNtYWluX2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHQjcGVuZGluZ19lZmZlY3QgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0I2ZhaWxlZF9lZmZlY3QgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudCB8IG51bGx9ICovXG5cdCNvZmZzY3JlZW5fZnJhZ21lbnQgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gKi9cblx0I3BlbmRpbmdfYW5jaG9yID0gbnVsbDtcblxuXHQjbG9jYWxfcGVuZGluZ19jb3VudCA9IDA7XG5cdCNwZW5kaW5nX2NvdW50ID0gMDtcblxuXHQjaXNfY3JlYXRpbmdfZmFsbGJhY2sgPSBmYWxzZTtcblxuXHQvKipcblx0ICogQSBzb3VyY2UgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYXN5bmMgZGVyaXZlZHMvZXhwcmVzc2lvbnMuXG5cdCAqIE9ubHkgY3JlYXRlZCBpZiBgJGVmZmVjdC5wZW5kaW5nKClgIGlzIHVzZWQgaW5zaWRlIHRoZSBib3VuZGFyeSxcblx0ICogb3RoZXJ3aXNlIHVwZGF0aW5nIHRoZSBzb3VyY2UgcmVzdWx0cyBpbiBuZWVkbGVzcyBgQmF0Y2guZW5zdXJlKClgXG5cdCAqIGNhbGxzIGZvbGxvd2VkIGJ5IG5vLW9wIGZsdXNoZXNcblx0ICogQHR5cGUge1NvdXJjZTxudW1iZXI+IHwgbnVsbH1cblx0ICovXG5cdCNlZmZlY3RfcGVuZGluZyA9IG51bGw7XG5cblx0I2VmZmVjdF9wZW5kaW5nX3N1YnNjcmliZXIgPSBjcmVhdGVTdWJzY3JpYmVyKCgpID0+IHtcblx0XHR0aGlzLiNlZmZlY3RfcGVuZGluZyA9IHNvdXJjZSh0aGlzLiNsb2NhbF9wZW5kaW5nX2NvdW50KTtcblxuXHRcdGlmIChERVYpIHtcblx0XHRcdHRhZyh0aGlzLiNlZmZlY3RfcGVuZGluZywgJyRlZmZlY3QucGVuZGluZygpJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuI2VmZmVjdF9wZW5kaW5nID0gbnVsbDtcblx0XHR9O1xuXHR9KTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcblx0ICogQHBhcmFtIHtCb3VuZGFyeVByb3BzfSBwcm9wc1xuXHQgKiBAcGFyYW0geygoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gY2hpbGRyZW5cblx0ICovXG5cdGNvbnN0cnVjdG9yKG5vZGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRcdHRoaXMuI2FuY2hvciA9IG5vZGU7XG5cdFx0dGhpcy4jcHJvcHMgPSBwcm9wcztcblx0XHR0aGlzLiNjaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG5cdFx0dGhpcy5wYXJlbnQgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmI7XG5cblx0XHR0aGlzLiNwZW5kaW5nID0gISF0aGlzLiNwcm9wcy5wZW5kaW5nO1xuXG5cdFx0dGhpcy4jZWZmZWN0ID0gYmxvY2soKCkgPT4ge1xuXHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5iID0gdGhpcztcblxuXHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRjb25zdCBjb21tZW50ID0gdGhpcy4jaHlkcmF0ZV9vcGVuO1xuXHRcdFx0XHRoeWRyYXRlX25leHQoKTtcblxuXHRcdFx0XHRjb25zdCBzZXJ2ZXJfcmVuZGVyZWRfcGVuZGluZyA9XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoY29tbWVudCkubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGNvbW1lbnQpLmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRcdGlmIChzZXJ2ZXJfcmVuZGVyZWRfcGVuZGluZykge1xuXHRcdFx0XHRcdHRoaXMuI2h5ZHJhdGVfcGVuZGluZ19jb250ZW50KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy4jaHlkcmF0ZV9yZXNvbHZlZF9jb250ZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhbmNob3IgPSB0aGlzLiNnZXRfYW5jaG9yKCk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGlzLiNtYWluX2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBjaGlsZHJlbihhbmNob3IpKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHR0aGlzLmVycm9yKGVycm9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLiNwZW5kaW5nX2NvdW50ID4gMCkge1xuXHRcdFx0XHRcdHRoaXMuI3Nob3dfcGVuZGluZ19zbmlwcGV0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy4jcGVuZGluZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuI3BlbmRpbmdfYW5jaG9yPy5yZW1vdmUoKTtcblx0XHRcdH07XG5cdFx0fSwgZmxhZ3MpO1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0dGhpcy4jYW5jaG9yID0gaHlkcmF0ZV9ub2RlO1xuXHRcdH1cblx0fVxuXG5cdCNoeWRyYXRlX3Jlc29sdmVkX2NvbnRlbnQoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuI21haW5fZWZmZWN0ID0gYnJhbmNoKCgpID0+IHRoaXMuI2NoaWxkcmVuKHRoaXMuI2FuY2hvcikpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmVycm9yKGVycm9yKTtcblx0XHR9XG5cblx0XHQvLyBTaW5jZSBzZXJ2ZXIgcmVuZGVyZWQgcmVzb2x2ZWQgY29udGVudCwgd2UgbmV2ZXIgc2hvdyBwZW5kaW5nIHN0YXRlXG5cdFx0Ly8gRXZlbiBpZiBjbGllbnQtc2lkZSBhc3luYyBvcGVyYXRpb25zIGFyZSBzdGlsbCBydW5uaW5nLCB0aGUgY29udGVudCBpcyBhbHJlYWR5IGRpc3BsYXllZFxuXHRcdHRoaXMuI3BlbmRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdCNoeWRyYXRlX3BlbmRpbmdfY29udGVudCgpIHtcblx0XHRjb25zdCBwZW5kaW5nID0gdGhpcy4jcHJvcHMucGVuZGluZztcblx0XHRpZiAoIXBlbmRpbmcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy4jcGVuZGluZ19lZmZlY3QgPSBicmFuY2goKCkgPT4gcGVuZGluZyh0aGlzLiNhbmNob3IpKTtcblxuXHRcdEJhdGNoLmVucXVldWUoKCkgPT4ge1xuXHRcdFx0dmFyIGFuY2hvciA9IHRoaXMuI2dldF9hbmNob3IoKTtcblxuXHRcdFx0dGhpcy4jbWFpbl9lZmZlY3QgPSB0aGlzLiNydW4oKCkgPT4ge1xuXHRcdFx0XHRCYXRjaC5lbnN1cmUoKTtcblx0XHRcdFx0cmV0dXJuIGJyYW5jaCgoKSA9PiB0aGlzLiNjaGlsZHJlbihhbmNob3IpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGhpcy4jcGVuZGluZ19jb3VudCA+IDApIHtcblx0XHRcdFx0dGhpcy4jc2hvd19wZW5kaW5nX3NuaXBwZXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHRoaXMuI3BlbmRpbmdfZWZmZWN0KSwgKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuI3BlbmRpbmdfZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy4jcGVuZGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0I2dldF9hbmNob3IoKSB7XG5cdFx0dmFyIGFuY2hvciA9IHRoaXMuI2FuY2hvcjtcblxuXHRcdGlmICh0aGlzLiNwZW5kaW5nKSB7XG5cdFx0XHR0aGlzLiNwZW5kaW5nX2FuY2hvciA9IGNyZWF0ZV90ZXh0KCk7XG5cdFx0XHR0aGlzLiNhbmNob3IuYmVmb3JlKHRoaXMuI3BlbmRpbmdfYW5jaG9yKTtcblxuXHRcdFx0YW5jaG9yID0gdGhpcy4jcGVuZGluZ19hbmNob3I7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFuY2hvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWZmZWN0IGV4aXN0cyBpbnNpZGUgYSBib3VuZGFyeSB3aG9zZSBwZW5kaW5nIHNuaXBwZXQgaXMgc2hvd25cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc19wZW5kaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLiNwZW5kaW5nIHx8ICghIXRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzX3BlbmRpbmcoKSk7XG5cdH1cblxuXHRoYXNfcGVuZGluZ19zbmlwcGV0KCkge1xuXHRcdHJldHVybiAhIXRoaXMuI3Byb3BzLnBlbmRpbmc7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHsoKSA9PiBFZmZlY3QgfCBudWxsfSBmblxuXHQgKi9cblx0I3J1bihmbikge1xuXHRcdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRcdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHR2YXIgcHJldmlvdXNfY3R4ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cblx0XHRzZXRfYWN0aXZlX2VmZmVjdCh0aGlzLiNlZmZlY3QpO1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24odGhpcy4jZWZmZWN0KTtcblx0XHRzZXRfY29tcG9uZW50X2NvbnRleHQodGhpcy4jZWZmZWN0LmN0eCk7XG5cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGZuKCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aGFuZGxlX2Vycm9yKGUpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRcdHNldF9jb21wb25lbnRfY29udGV4dChwcmV2aW91c19jdHgpO1xuXHRcdH1cblx0fVxuXG5cdCNzaG93X3BlbmRpbmdfc25pcHBldCgpIHtcblx0XHRjb25zdCBwZW5kaW5nID0gLyoqIEB0eXBlIHsoYW5jaG9yOiBOb2RlKSA9PiB2b2lkfSAqLyAodGhpcy4jcHJvcHMucGVuZGluZyk7XG5cblx0XHRpZiAodGhpcy4jbWFpbl9lZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI29mZnNjcmVlbl9mcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdHRoaXMuI29mZnNjcmVlbl9mcmFnbWVudC5hcHBlbmQoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovICh0aGlzLiNwZW5kaW5nX2FuY2hvcikpO1xuXHRcdFx0bW92ZV9lZmZlY3QodGhpcy4jbWFpbl9lZmZlY3QsIHRoaXMuI29mZnNjcmVlbl9mcmFnbWVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmdfZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBwZW5kaW5nKHRoaXMuI2FuY2hvcikpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBwZW5kaW5nIGNvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudGx5IHZpc2libGUgcGVuZGluZyBzbmlwcGV0LFxuXHQgKiBpZiBhbnksIHN1Y2ggdGhhdCB3ZSBjYW4gcmVwbGFjZSB0aGUgc25pcHBldCB3aXRoIGNvbnRlbnQgb25jZSB3b3JrIGlzIGRvbmVcblx0ICogQHBhcmFtIHsxIHwgLTF9IGRcblx0ICovXG5cdCN1cGRhdGVfcGVuZGluZ19jb3VudChkKSB7XG5cdFx0aWYgKCF0aGlzLmhhc19wZW5kaW5nX3NuaXBwZXQoKSkge1xuXHRcdFx0aWYgKHRoaXMucGFyZW50KSB7XG5cdFx0XHRcdHRoaXMucGFyZW50LiN1cGRhdGVfcGVuZGluZ19jb3VudChkKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGluIGEgc2NvcGUgd2l0aCBubyBwZW5kaW5nIHNuaXBwZXRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLiNwZW5kaW5nX2NvdW50ICs9IGQ7XG5cblx0XHRpZiAodGhpcy4jcGVuZGluZ19jb3VudCA9PT0gMCkge1xuXHRcdFx0dGhpcy4jcGVuZGluZyA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodGhpcy4jcGVuZGluZ19lZmZlY3QpIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KHRoaXMuI3BlbmRpbmdfZWZmZWN0LCAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4jcGVuZGluZ19lZmZlY3QgPSBudWxsO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuI29mZnNjcmVlbl9mcmFnbWVudCkge1xuXHRcdFx0XHR0aGlzLiNhbmNob3IuYmVmb3JlKHRoaXMuI29mZnNjcmVlbl9mcmFnbWVudCk7XG5cdFx0XHRcdHRoaXMuI29mZnNjcmVlbl9mcmFnbWVudCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgc291cmNlIHRoYXQgcG93ZXJzIGAkZWZmZWN0LnBlbmRpbmcoKWAgaW5zaWRlIHRoaXMgYm91bmRhcnksXG5cdCAqIGFuZCBjb250cm9scyB3aGVuIHRoZSBjdXJyZW50IGBwZW5kaW5nYCBzbmlwcGV0IChpZiBhbnkpIGlzIHJlbW92ZWQuXG5cdCAqIERvIG5vdCBjYWxsIGZyb20gaW5zaWRlIHRoZSBjbGFzc1xuXHQgKiBAcGFyYW0gezEgfCAtMX0gZFxuXHQgKi9cblx0dXBkYXRlX3BlbmRpbmdfY291bnQoZCkge1xuXHRcdHRoaXMuI3VwZGF0ZV9wZW5kaW5nX2NvdW50KGQpO1xuXG5cdFx0dGhpcy4jbG9jYWxfcGVuZGluZ19jb3VudCArPSBkO1xuXG5cdFx0aWYgKHRoaXMuI2VmZmVjdF9wZW5kaW5nKSB7XG5cdFx0XHRpbnRlcm5hbF9zZXQodGhpcy4jZWZmZWN0X3BlbmRpbmcsIHRoaXMuI2xvY2FsX3BlbmRpbmdfY291bnQpO1xuXHRcdH1cblx0fVxuXG5cdGdldF9lZmZlY3RfcGVuZGluZygpIHtcblx0XHR0aGlzLiNlZmZlY3RfcGVuZGluZ19zdWJzY3JpYmVyKCk7XG5cdFx0cmV0dXJuIGdldCgvKiogQHR5cGUge1NvdXJjZTxudW1iZXI+fSAqLyAodGhpcy4jZWZmZWN0X3BlbmRpbmcpKTtcblx0fVxuXG5cdC8qKiBAcGFyYW0ge3Vua25vd259IGVycm9yICovXG5cdGVycm9yKGVycm9yKSB7XG5cdFx0dmFyIG9uZXJyb3IgPSB0aGlzLiNwcm9wcy5vbmVycm9yO1xuXHRcdGxldCBmYWlsZWQgPSB0aGlzLiNwcm9wcy5mYWlsZWQ7XG5cblx0XHQvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgdG8gY2FwdHVyZSB0aGUgZXJyb3IsIG9yIGlmIHdlIGhpdCBhbiBlcnJvciB3aGlsZVxuXHRcdC8vIHJlbmRlcmluZyB0aGUgZmFsbGJhY2ssIHJlLXRocm93IGZvciBhbm90aGVyIGJvdW5kYXJ5IHRvIGhhbmRsZVxuXHRcdGlmICh0aGlzLiNpc19jcmVhdGluZ19mYWxsYmFjayB8fCAoIW9uZXJyb3IgJiYgIWZhaWxlZCkpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNtYWluX2VmZmVjdCkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QodGhpcy4jbWFpbl9lZmZlY3QpO1xuXHRcdFx0dGhpcy4jbWFpbl9lZmZlY3QgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNwZW5kaW5nX2VmZmVjdCkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QodGhpcy4jcGVuZGluZ19lZmZlY3QpO1xuXHRcdFx0dGhpcy4jcGVuZGluZ19lZmZlY3QgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNmYWlsZWRfZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCh0aGlzLiNmYWlsZWRfZWZmZWN0KTtcblx0XHRcdHRoaXMuI2ZhaWxlZF9lZmZlY3QgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovICh0aGlzLiNoeWRyYXRlX29wZW4pKTtcblx0XHRcdG5leHQoKTtcblx0XHRcdHNldF9oeWRyYXRlX25vZGUoc2tpcF9ub2RlcygpKTtcblx0XHR9XG5cblx0XHR2YXIgZGlkX3Jlc2V0ID0gZmFsc2U7XG5cdFx0dmFyIGNhbGxpbmdfb25fZXJyb3IgPSBmYWxzZTtcblxuXHRcdGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuXHRcdFx0aWYgKGRpZF9yZXNldCkge1xuXHRcdFx0XHR3LnN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZGlkX3Jlc2V0ID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGNhbGxpbmdfb25fZXJyb3IpIHtcblx0XHRcdFx0ZS5zdmVsdGVfYm91bmRhcnlfcmVzZXRfb25lcnJvcigpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgZmFpbHVyZSBoYXBwZW5lZCB3aGlsZSBmbHVzaGluZyBlZmZlY3RzLCBjdXJyZW50X2JhdGNoIGNhbiBiZSBudWxsXG5cdFx0XHRCYXRjaC5lbnN1cmUoKTtcblxuXHRcdFx0dGhpcy4jbG9jYWxfcGVuZGluZ19jb3VudCA9IDA7XG5cblx0XHRcdGlmICh0aGlzLiNmYWlsZWRfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdCh0aGlzLiNmYWlsZWRfZWZmZWN0LCAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4jZmFpbGVkX2VmZmVjdCA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB3ZSBpbnRlbnRpb25hbGx5IGRvIG5vdCB0cnkgdG8gZmluZCB0aGUgbmVhcmVzdCBwZW5kaW5nIGJvdW5kYXJ5LiBJZiB0aGlzIGJvdW5kYXJ5IGhhcyBvbmUsIHdlJ2xsIHJlbmRlciBpdCBvbiByZXNldFxuXHRcdFx0Ly8gYnV0IGl0IHdvdWxkIGJlIHJlYWxseSB3ZWlyZCB0byBzaG93IHRoZSBwYXJlbnQncyBib3VuZGFyeSBvbiBhIGNoaWxkIHJlc2V0LlxuXHRcdFx0dGhpcy4jcGVuZGluZyA9IHRoaXMuaGFzX3BlbmRpbmdfc25pcHBldCgpO1xuXG5cdFx0XHR0aGlzLiNtYWluX2VmZmVjdCA9IHRoaXMuI3J1bigoKSA9PiB7XG5cdFx0XHRcdHRoaXMuI2lzX2NyZWF0aW5nX2ZhbGxiYWNrID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiBicmFuY2goKCkgPT4gdGhpcy4jY2hpbGRyZW4odGhpcy4jYW5jaG9yKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHRoaXMuI3BlbmRpbmdfY291bnQgPiAwKSB7XG5cdFx0XHRcdHRoaXMuI3Nob3dfcGVuZGluZ19zbmlwcGV0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLiNwZW5kaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblxuXHRcdHRyeSB7XG5cdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRcdFx0Y2FsbGluZ19vbl9lcnJvciA9IHRydWU7XG5cdFx0XHRvbmVycm9yPy4oZXJyb3IsIHJlc2V0KTtcblx0XHRcdGNhbGxpbmdfb25fZXJyb3IgPSBmYWxzZTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCB0aGlzLiNlZmZlY3QgJiYgdGhpcy4jZWZmZWN0LnBhcmVudCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdH1cblxuXHRcdGlmIChmYWlsZWQpIHtcblx0XHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0XHR0aGlzLiNmYWlsZWRfZWZmZWN0ID0gdGhpcy4jcnVuKCgpID0+IHtcblx0XHRcdFx0XHRCYXRjaC5lbnN1cmUoKTtcblx0XHRcdFx0XHR0aGlzLiNpc19jcmVhdGluZ19mYWxsYmFjayA9IHRydWU7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGJyYW5jaCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGZhaWxlZChcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiNhbmNob3IsXG5cdFx0XHRcdFx0XHRcdFx0KCkgPT4gZXJyb3IsXG5cdFx0XHRcdFx0XHRcdFx0KCkgPT4gcmVzZXRcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAodGhpcy4jZWZmZWN0LnBhcmVudCkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdHRoaXMuI2lzX2NyZWF0aW5nX2ZhbGxiYWNrID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2JvdW5kYXJ5KCkge1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtCb3VuZGFyeX0gKi8gKC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwZW5kaW5nKCkge1xuXHRpZiAoYWN0aXZlX2VmZmVjdCA9PT0gbnVsbCkge1xuXHRcdGUuZWZmZWN0X3BlbmRpbmdfb3V0c2lkZV9yZWFjdGlvbigpO1xuXHR9XG5cblx0dmFyIGJvdW5kYXJ5ID0gYWN0aXZlX2VmZmVjdC5iO1xuXG5cdGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiAwOyAvLyBUT0RPIGV2ZW50dWFsbHkgd2Ugd2lsbCBuZWVkIHRoaXMgdG8gYmUgZ2xvYmFsXG5cdH1cblxuXHRyZXR1cm4gYm91bmRhcnkuZ2V0X2VmZmVjdF9wZW5kaW5nKCk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFYWNoSXRlbSwgRWFjaFN0YXRlLCBFZmZlY3QsIE1heWJlU291cmNlLCBTb3VyY2UsIFRlbXBsYXRlTm9kZSwgVHJhbnNpdGlvbk1hbmFnZXIsIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJzsgKi9cbmltcG9ydCB7XG5cdEVBQ0hfSU5ERVhfUkVBQ1RJVkUsXG5cdEVBQ0hfSVNfQU5JTUFURUQsXG5cdEVBQ0hfSVNfQ09OVFJPTExFRCxcblx0RUFDSF9JVEVNX0lNTVVUQUJMRSxcblx0RUFDSF9JVEVNX1JFQUNUSVZFLFxuXHRIWURSQVRJT05fRU5ELFxuXHRIWURSQVRJT05fU1RBUlRfRUxTRVxufSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0cmVhZF9oeWRyYXRpb25faW5zdHJ1Y3Rpb24sXG5cdHNraXBfbm9kZXMsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7XG5cdGNsZWFyX3RleHRfY29udGVudCxcblx0Y3JlYXRlX3RleHQsXG5cdGdldF9maXJzdF9jaGlsZCxcblx0Z2V0X25leHRfc2libGluZyxcblx0c2hvdWxkX2RlZmVyX2FwcGVuZFxufSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7XG5cdGJsb2NrLFxuXHRicmFuY2gsXG5cdGRlc3Ryb3lfZWZmZWN0LFxuXHRydW5fb3V0X3RyYW5zaXRpb25zLFxuXHRwYXVzZV9jaGlsZHJlbixcblx0cGF1c2VfZWZmZWN0LFxuXHRyZXN1bWVfZWZmZWN0XG59IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzb3VyY2UsIG11dGFibGVfc291cmNlLCBpbnRlcm5hbF9zZXQgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgYXJyYXlfZnJvbSwgaXNfYXJyYXkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFLCBJTkVSVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZXJpdmVkX3NhZmVfZXF1YWwgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfYmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLyoqXG4gKiBUaGUgcm93IG9mIGEga2V5ZWQgZWFjaCBibG9jayB0aGF0IGlzIGN1cnJlbnRseSB1cGRhdGluZy4gV2UgdHJhY2sgdGhpc1xuICogc28gdGhhdCBgYW5pbWF0ZTpgIGRpcmVjdGl2ZXMgaGF2ZSBzb21ldGhpbmcgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG9cbiAqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9XG4gKi9cbmV4cG9ydCBsZXQgY3VycmVudF9lYWNoX2l0ZW0gPSBudWxsO1xuXG4vKiogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IGl0ZW0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VycmVudF9lYWNoX2l0ZW0oaXRlbSkge1xuXHRjdXJyZW50X2VhY2hfaXRlbSA9IGl0ZW07XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IF9cbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmRleChfLCBpKSB7XG5cdHJldHVybiBpO1xufVxuXG4vKipcbiAqIFBhdXNlIG11bHRpcGxlIGVmZmVjdHMgc2ltdWx0YW5lb3VzbHksIGFuZCBjb29yZGluYXRlIHRoZWlyXG4gKiBzdWJzZXF1ZW50IGRlc3RydWN0aW9uLiBVc2VkIGluIGVhY2ggYmxvY2tzXG4gKiBAcGFyYW0ge0VhY2hTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7RWFjaEl0ZW1bXX0gdG9fZGVzdHJveVxuICogQHBhcmFtIHtudWxsIHwgTm9kZX0gY29udHJvbGxlZF9hbmNob3JcbiAqL1xuZnVuY3Rpb24gcGF1c2VfZWZmZWN0cyhzdGF0ZSwgdG9fZGVzdHJveSwgY29udHJvbGxlZF9hbmNob3IpIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblx0dmFyIGxlbmd0aCA9IHRvX2Rlc3Ryb3kubGVuZ3RoO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRwYXVzZV9jaGlsZHJlbih0b19kZXN0cm95W2ldLmUsIHRyYW5zaXRpb25zLCB0cnVlKTtcblx0fVxuXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsICgpID0+IHtcblx0XHQvLyBJZiB3ZSdyZSBpbiBhIGNvbnRyb2xsZWQgZWFjaCBibG9jayAoaS5lLiB0aGUgYmxvY2sgaXMgdGhlIG9ubHkgY2hpbGQgb2YgYW5cblx0XHQvLyBlbGVtZW50KSwgYW5kIHdlIGFyZSByZW1vdmluZyBhbGwgaXRlbXMsIF9hbmRfIHRoZXJlIGFyZSBubyBvdXQgdHJhbnNpdGlvbnMsXG5cdFx0Ly8gd2UgY2FuIHVzZSB0aGUgZmFzdCBwYXRoIFx1MjAxNCBlbXB0eWluZyB0aGUgZWxlbWVudCBhbmQgcmVwbGFjaW5nIHRoZSBhbmNob3Jcblx0XHR2YXIgZmFzdF9wYXRoID0gdHJhbnNpdGlvbnMubGVuZ3RoID09PSAwICYmIGNvbnRyb2xsZWRfYW5jaG9yICE9PSBudWxsO1xuXG5cdFx0Ly8gVE9ETyBvbmx5IGRlc3Ryb3kgZWZmZWN0cyBpZiBubyBwZW5kaW5nIGJhdGNoIG5lZWRzIHRoZW0uIG90aGVyd2lzZSxcblx0XHQvLyBqdXN0IHNldCBgaXRlbS5vYCBiYWNrIHRvIGBmYWxzZWBcblxuXHRcdGlmIChmYXN0X3BhdGgpIHtcblx0XHRcdHZhciBhbmNob3IgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChjb250cm9sbGVkX2FuY2hvcik7XG5cdFx0XHR2YXIgcGFyZW50X25vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChhbmNob3IucGFyZW50Tm9kZSk7XG5cblx0XHRcdGNsZWFyX3RleHRfY29udGVudChwYXJlbnRfbm9kZSk7XG5cdFx0XHRwYXJlbnRfbm9kZS5hcHBlbmQoYW5jaG9yKTtcblxuXHRcdFx0c3RhdGUuaXRlbXMuY2xlYXIoKTtcblx0XHRcdGxpbmsoc3RhdGUsIHRvX2Rlc3Ryb3lbMF0ucHJldiwgdG9fZGVzdHJveVtsZW5ndGggLSAxXS5uZXh0KTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRvX2Rlc3Ryb3lbaV07XG5cblx0XHRcdGlmICghZmFzdF9wYXRoKSB7XG5cdFx0XHRcdHN0YXRlLml0ZW1zLmRlbGV0ZShpdGVtLmspO1xuXHRcdFx0XHRsaW5rKHN0YXRlLCBpdGVtLnByZXYsIGl0ZW0ubmV4dCk7XG5cdFx0XHR9XG5cblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGl0ZW0uZSwgIWZhc3RfcGF0aCk7XG5cdFx0fVxuXG5cdFx0aWYgKHN0YXRlLmZpcnN0ID09PSB0b19kZXN0cm95WzBdKSB7XG5cdFx0XHRzdGF0ZS5maXJzdCA9IHRvX2Rlc3Ryb3lbMF0ucHJldjtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBDb21tZW50fSBub2RlIFRoZSBuZXh0IHNpYmxpbmcgbm9kZSwgb3IgdGhlIHBhcmVudCBub2RlIGlmIHRoaXMgaXMgYSAnY29udHJvbGxlZCcgYmxvY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHsoKSA9PiBWW119IGdldF9jb2xsZWN0aW9uXG4gKiBAcGFyYW0geyh2YWx1ZTogViwgaW5kZXg6IG51bWJlcikgPT4gYW55fSBnZXRfa2V5XG4gKiBAcGFyYW0geyhhbmNob3I6IE5vZGUsIGl0ZW06IE1heWJlU291cmNlPFY+LCBpbmRleDogTWF5YmVTb3VyY2U8bnVtYmVyPikgPT4gdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9IGZhbGxiYWNrX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2gobm9kZSwgZmxhZ3MsIGdldF9jb2xsZWN0aW9uLCBnZXRfa2V5LCByZW5kZXJfZm4sIGZhbGxiYWNrX2ZuID0gbnVsbCkge1xuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge01hcDxhbnksIEVhY2hJdGVtPn0gKi9cblx0dmFyIGl0ZW1zID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW0gfCBudWxsfSAqL1xuXHR2YXIgZmlyc3QgPSBudWxsO1xuXG5cdHZhciBpc19jb250cm9sbGVkID0gKGZsYWdzICYgRUFDSF9JU19DT05UUk9MTEVEKSAhPT0gMDtcblx0dmFyIGlzX3JlYWN0aXZlX3ZhbHVlID0gKGZsYWdzICYgRUFDSF9JVEVNX1JFQUNUSVZFKSAhPT0gMDtcblx0dmFyIGlzX3JlYWN0aXZlX2luZGV4ID0gKGZsYWdzICYgRUFDSF9JTkRFWF9SRUFDVElWRSkgIT09IDA7XG5cblx0aWYgKGlzX2NvbnRyb2xsZWQpIHtcblx0XHR2YXIgcGFyZW50X25vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKTtcblxuXHRcdGFuY2hvciA9IGh5ZHJhdGluZ1xuXHRcdFx0PyBzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7Q29tbWVudCB8IFRleHR9ICovIChnZXRfZmlyc3RfY2hpbGQocGFyZW50X25vZGUpKSlcblx0XHRcdDogcGFyZW50X25vZGUuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSk7XG5cdH1cblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHQvKiogQHR5cGUge3sgZnJhZ21lbnQ6IERvY3VtZW50RnJhZ21lbnQgfCBudWxsLCBlZmZlY3Q6IEVmZmVjdCB9IHwgbnVsbH0gKi9cblx0dmFyIGZhbGxiYWNrID0gbnVsbDtcblxuXHQvLyBUT0RPOiBpZGVhbGx5IHdlIGNvdWxkIHVzZSBkZXJpdmVkIGZvciBydW5lcyBtb2RlIGJ1dCBiZWNhdXNlIG9mIHRoZSBhYmlsaXR5XG5cdC8vIHRvIHVzZSBhIHN0b3JlIHdoaWNoIGNhbiBiZSBtdXRhdGVkLCB3ZSBjYW4ndCBkbyB0aGF0IGhlcmUgYXMgbXV0YXRpbmcgYSBzdG9yZVxuXHQvLyB3aWxsIHN0aWxsIHJlc3VsdCBpbiB0aGUgY29sbGVjdGlvbiBhcnJheSBiZWluZyB0aGUgc2FtZSBmcm9tIHRoZSBzdG9yZVxuXHR2YXIgZWFjaF9hcnJheSA9IGRlcml2ZWRfc2FmZV9lcXVhbCgoKSA9PiB7XG5cdFx0dmFyIGNvbGxlY3Rpb24gPSBnZXRfY29sbGVjdGlvbigpO1xuXG5cdFx0cmV0dXJuIGlzX2FycmF5KGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IGNvbGxlY3Rpb24gPT0gbnVsbCA/IFtdIDogYXJyYXlfZnJvbShjb2xsZWN0aW9uKTtcblx0fSk7XG5cblx0LyoqIEB0eXBlIHtWW119ICovXG5cdHZhciBhcnJheTtcblxuXHR2YXIgZmlyc3RfcnVuID0gdHJ1ZTtcblxuXHRmdW5jdGlvbiBjb21taXQoKSB7XG5cdFx0cmVjb25jaWxlKHN0YXRlLCBhcnJheSwgYW5jaG9yLCBmbGFncywgZ2V0X2tleSk7XG5cblx0XHRpZiAoZmFsbGJhY2sgIT09IG51bGwpIHtcblx0XHRcdGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0aWYgKGZhbGxiYWNrLmZyYWdtZW50KSB7XG5cdFx0XHRcdFx0YW5jaG9yLmJlZm9yZShmYWxsYmFjay5mcmFnbWVudCk7XG5cdFx0XHRcdFx0ZmFsbGJhY2suZnJhZ21lbnQgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VtZV9lZmZlY3QoZmFsbGJhY2suZWZmZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVmZmVjdC5maXJzdCA9IGZhbGxiYWNrLmVmZmVjdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdChmYWxsYmFjay5lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHQvLyBUT0RPIG9ubHkgbnVsbCBvdXQgaWYgbm8gcGVuZGluZyBiYXRjaCBuZWVkcyBpdCxcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UgcmUtYWRkIGBmYWxsYmFjay5mcmFnbWVudGAgYW5kIG1vdmUgdGhlXG5cdFx0XHRcdFx0Ly8gZWZmZWN0IGludG8gaXRcblx0XHRcdFx0XHRmYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBlZmZlY3QgPSBibG9jaygoKSA9PiB7XG5cdFx0YXJyYXkgPSAvKiogQHR5cGUge1ZbXX0gKi8gKGdldChlYWNoX2FycmF5KSk7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuXHRcdC8qKiBgdHJ1ZWAgaWYgdGhlcmUgd2FzIGEgaHlkcmF0aW9uIG1pc21hdGNoLiBOZWVkcyB0byBiZSBhIGBsZXRgIG9yIGVsc2UgaXQgaXNuJ3QgdHJlZXNoYWtlbiBvdXQgKi9cblx0XHRsZXQgbWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdHZhciBpc19lbHNlID0gcmVhZF9oeWRyYXRpb25faW5zdHJ1Y3Rpb24oYW5jaG9yKSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0U7XG5cblx0XHRcdGlmIChpc19lbHNlICE9PSAobGVuZ3RoID09PSAwKSkge1xuXHRcdFx0XHQvLyBoeWRyYXRpb24gbWlzbWF0Y2ggXHUyMDE0IHJlbW92ZSB0aGUgc2VydmVyLXJlbmRlcmVkIERPTSBhbmQgc3RhcnQgb3ZlclxuXHRcdFx0XHRhbmNob3IgPSBza2lwX25vZGVzKCk7XG5cblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShhbmNob3IpO1xuXHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0bWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBrZXlzID0gbmV3IFNldCgpO1xuXHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblx0XHR2YXIgcHJldiA9IG51bGw7XG5cdFx0dmFyIGRlZmVyID0gc2hvdWxkX2RlZmVyX2FwcGVuZCgpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRoeWRyYXRpbmcgJiZcblx0XHRcdFx0aHlkcmF0ZV9ub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiZcblx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhID09PSBIWURSQVRJT05fRU5EXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gVGhlIHNlcnZlciByZW5kZXJlZCBmZXdlciBpdGVtcyB0aGFuIGV4cGVjdGVkLFxuXHRcdFx0XHQvLyBzbyBicmVhayBvdXQgYW5kIGNvbnRpbnVlIGFwcGVuZGluZyBub24taHlkcmF0ZWQgaXRlbXNcblx0XHRcdFx0YW5jaG9yID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRcdFx0bWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHZhbHVlID0gYXJyYXlbaV07XG5cdFx0XHR2YXIga2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cblx0XHRcdHZhciBpdGVtID0gZmlyc3RfcnVuID8gbnVsbCA6IGl0ZW1zLmdldChrZXkpO1xuXG5cdFx0XHRpZiAoaXRlbSkge1xuXHRcdFx0XHQvLyB1cGRhdGUgYmVmb3JlIHJlY29uY2lsaWF0aW9uLCB0byB0cmlnZ2VyIGFueSBhc3luYyB1cGRhdGVzXG5cdFx0XHRcdGlmIChpc19yZWFjdGl2ZV92YWx1ZSkge1xuXHRcdFx0XHRcdGludGVybmFsX3NldChpdGVtLnYsIHZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc19yZWFjdGl2ZV9pbmRleCkge1xuXHRcdFx0XHRcdGludGVybmFsX3NldCgvKiogQHR5cGUge1ZhbHVlPG51bWJlcj59ICovIChpdGVtLmkpLCBpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpdGVtLmkgPSBpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRlZmVyKSB7XG5cdFx0XHRcdFx0YmF0Y2guc2tpcHBlZF9lZmZlY3RzLmRlbGV0ZShpdGVtLmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpdGVtID0gY3JlYXRlX2l0ZW0oXG5cdFx0XHRcdFx0Zmlyc3RfcnVuID8gYW5jaG9yIDogbnVsbCxcblx0XHRcdFx0XHRwcmV2LFxuXHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdHJlbmRlcl9mbixcblx0XHRcdFx0XHRmbGFncyxcblx0XHRcdFx0XHRnZXRfY29sbGVjdGlvblxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChmaXJzdF9ydW4pIHtcblx0XHRcdFx0XHRpdGVtLm8gPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGZpcnN0ID0gaXRlbTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHJldi5uZXh0ID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGl0ZW1zLnNldChrZXksIGl0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHRrZXlzLmFkZChrZXkpO1xuXHRcdH1cblxuXHRcdGlmIChsZW5ndGggPT09IDAgJiYgZmFsbGJhY2tfZm4gJiYgIWZhbGxiYWNrKSB7XG5cdFx0XHRpZiAoZmlyc3RfcnVuKSB7XG5cdFx0XHRcdGZhbGxiYWNrID0ge1xuXHRcdFx0XHRcdGZyYWdtZW50OiBudWxsLFxuXHRcdFx0XHRcdGVmZmVjdDogYnJhbmNoKCgpID0+IGZhbGxiYWNrX2ZuKGFuY2hvcikpXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBjcmVhdGVfdGV4dCgpO1xuXHRcdFx0XHRmcmFnbWVudC5hcHBlbmQodGFyZ2V0KTtcblxuXHRcdFx0XHRmYWxsYmFjayA9IHtcblx0XHRcdFx0XHRmcmFnbWVudCxcblx0XHRcdFx0XHRlZmZlY3Q6IGJyYW5jaCgoKSA9PiBmYWxsYmFja19mbih0YXJnZXQpKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBleGNlc3Mgbm9kZXNcblx0XHRpZiAoaHlkcmF0aW5nICYmIGxlbmd0aCA+IDApIHtcblx0XHRcdHNldF9oeWRyYXRlX25vZGUoc2tpcF9ub2RlcygpKTtcblx0XHR9XG5cblx0XHRpZiAoIWZpcnN0X3J1bikge1xuXHRcdFx0aWYgKGRlZmVyKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgaXRlbXMpIHtcblx0XHRcdFx0XHRpZiAoIWtleXMuaGFzKGtleSkpIHtcblx0XHRcdFx0XHRcdGJhdGNoLnNraXBwZWRfZWZmZWN0cy5hZGQoaXRlbS5lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXRjaC5vbmNvbW1pdChjb21taXQpO1xuXHRcdFx0XHRiYXRjaC5vbmRpc2NhcmQoKCkgPT4ge1xuXHRcdFx0XHRcdC8vIFRPRE8gcHJlc3VtYWJseSB3ZSBuZWVkIHRvIGRvIHNvbWV0aGluZyBoZXJlP1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbW1pdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB3ZSBtb3VudCB0aGUgZWFjaCBibG9jayBmb3IgdGhlIGZpcnN0IHRpbWUsIHRoZSBjb2xsZWN0aW9uIHdvbid0IGJlXG5cdFx0Ly8gY29ubmVjdGVkIHRvIHRoaXMgZWZmZWN0IGFzIHRoZSBlZmZlY3QgaGFzbid0IGZpbmlzaGVkIHJ1bm5pbmcgeWV0IGFuZCBpdHMgZGVwc1xuXHRcdC8vIHdvbid0IGJlIGFzc2lnbmVkLiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgd2hlbiByZWNvbmNpbGluZyB0aGUgZWFjaCBibG9ja1xuXHRcdC8vIHRoYXQgYSBtdXRhdGlvbiBvY2N1cnJlZCBhbmQgaXQncyBtYWRlIHRoZSBjb2xsZWN0aW9uIE1BWUJFX0RJUlRZLCBzbyByZWFkaW5nIHRoZVxuXHRcdC8vIGNvbGxlY3Rpb24gYWdhaW4gY2FuIHByb3ZpZGUgY29uc2lzdGVuY3kgdG8gdGhlIHJlYWN0aXZlIGdyYXBoIGFnYWluIGFzIHRoZSBkZXJpdmVkc1xuXHRcdC8vIHdpbGwgbm93IGJlIGBDTEVBTmAuXG5cdFx0Z2V0KGVhY2hfYXJyYXkpO1xuXHR9KTtcblxuXHQvKiogQHR5cGUge0VhY2hTdGF0ZX0gKi9cblx0dmFyIHN0YXRlID0geyBlZmZlY3QsIGZsYWdzLCBpdGVtcywgZmlyc3QgfTtcblxuXHRmaXJzdF9ydW4gPSBmYWxzZTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YW5jaG9yID0gaHlkcmF0ZV9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogQWRkLCByZW1vdmUsIG9yIHJlb3JkZXIgaXRlbXMgb3V0cHV0IGJ5IGFuIGVhY2ggYmxvY2sgYXMgaXRzIGlucHV0IGNoYW5nZXNcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0VhY2hTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7QXJyYXk8Vj59IGFycmF5XG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBDb21tZW50IHwgVGV4dH0gYW5jaG9yXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KHZhbHVlOiBWLCBpbmRleDogbnVtYmVyKSA9PiBhbnl9IGdldF9rZXlcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiByZWNvbmNpbGUoc3RhdGUsIGFycmF5LCBhbmNob3IsIGZsYWdzLCBnZXRfa2V5KSB7XG5cdHZhciBpc19hbmltYXRlZCA9IChmbGFncyAmIEVBQ0hfSVNfQU5JTUFURUQpICE9PSAwO1xuXG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHZhciBpdGVtcyA9IHN0YXRlLml0ZW1zO1xuXHR2YXIgY3VycmVudCA9IHN0YXRlLmZpcnN0O1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgU2V0PEVhY2hJdGVtPn0gKi9cblx0dmFyIHNlZW47XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9ICovXG5cdHZhciBwcmV2ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge3VuZGVmaW5lZCB8IFNldDxFYWNoSXRlbT59ICovXG5cdHZhciB0b19hbmltYXRlO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW1bXX0gKi9cblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtW119ICovXG5cdHZhciBzdGFzaGVkID0gW107XG5cblx0LyoqIEB0eXBlIHtWfSAqL1xuXHR2YXIgdmFsdWU7XG5cblx0LyoqIEB0eXBlIHthbnl9ICovXG5cdHZhciBrZXk7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGl0ZW07XG5cblx0LyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cdHZhciBpO1xuXG5cdGlmIChpc19hbmltYXRlZCkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdFx0aXRlbSA9IC8qKiBAdHlwZSB7RWFjaEl0ZW19ICovIChpdGVtcy5nZXQoa2V5KSk7XG5cblx0XHRcdC8vIG9mZnNjcmVlbiA9PSBjb21pbmcgaW4gbm93LCBubyBhbmltYXRpb24gaW4gdGhhdCBjYXNlLFxuXHRcdFx0Ly8gZWxzZSB0aGlzIHdvdWxkIGhhcHBlbiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8xNzE4MVxuXHRcdFx0aWYgKGl0ZW0ubykge1xuXHRcdFx0XHRpdGVtLmE/Lm1lYXN1cmUoKTtcblx0XHRcdFx0KHRvX2FuaW1hdGUgPz89IG5ldyBTZXQoKSkuYWRkKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhbHVlID0gYXJyYXlbaV07XG5cdFx0a2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cblx0XHRpdGVtID0gLyoqIEB0eXBlIHtFYWNoSXRlbX0gKi8gKGl0ZW1zLmdldChrZXkpKTtcblxuXHRcdHN0YXRlLmZpcnN0ID8/PSBpdGVtO1xuXG5cdFx0aWYgKCFpdGVtLm8pIHtcblx0XHRcdGl0ZW0ubyA9IHRydWU7XG5cblx0XHRcdHZhciBuZXh0ID0gcHJldiA/IHByZXYubmV4dCA6IGN1cnJlbnQ7XG5cblx0XHRcdGxpbmsoc3RhdGUsIHByZXYsIGl0ZW0pO1xuXHRcdFx0bGluayhzdGF0ZSwgaXRlbSwgbmV4dCk7XG5cblx0XHRcdG1vdmUoaXRlbSwgbmV4dCwgYW5jaG9yKTtcblx0XHRcdHByZXYgPSBpdGVtO1xuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdGN1cnJlbnQgPSBwcmV2Lm5leHQ7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoKGl0ZW0uZS5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0XHRyZXN1bWVfZWZmZWN0KGl0ZW0uZSk7XG5cdFx0XHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRcdFx0aXRlbS5hPy51bmZpeCgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5kZWxldGUoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0gIT09IGN1cnJlbnQpIHtcblx0XHRcdGlmIChzZWVuICE9PSB1bmRlZmluZWQgJiYgc2Vlbi5oYXMoaXRlbSkpIHtcblx0XHRcdFx0aWYgKG1hdGNoZWQubGVuZ3RoIDwgc3Rhc2hlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBtb3JlIGVmZmljaWVudCB0byBtb3ZlIGxhdGVyIGl0ZW1zIHRvIHRoZSBmcm9udFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IHN0YXNoZWRbMF07XG5cdFx0XHRcdFx0dmFyIGo7XG5cblx0XHRcdFx0XHRwcmV2ID0gc3RhcnQucHJldjtcblxuXHRcdFx0XHRcdHZhciBhID0gbWF0Y2hlZFswXTtcblx0XHRcdFx0XHR2YXIgYiA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRtb3ZlKG1hdGNoZWRbal0sIHN0YXJ0LCBhbmNob3IpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBzdGFzaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRzZWVuLmRlbGV0ZShzdGFzaGVkW2pdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBhLnByZXYsIGIubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgYSk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgYiwgc3RhcnQpO1xuXG5cdFx0XHRcdFx0Y3VycmVudCA9IHN0YXJ0O1xuXHRcdFx0XHRcdHByZXYgPSBiO1xuXHRcdFx0XHRcdGkgLT0gMTtcblxuXHRcdFx0XHRcdG1hdGNoZWQgPSBbXTtcblx0XHRcdFx0XHRzdGFzaGVkID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbW9yZSBlZmZpY2llbnQgdG8gbW92ZSBlYXJsaWVyIGl0ZW1zIHRvIHRoZSBiYWNrXG5cdFx0XHRcdFx0c2Vlbi5kZWxldGUoaXRlbSk7XG5cdFx0XHRcdFx0bW92ZShpdGVtLCBjdXJyZW50LCBhbmNob3IpO1xuXG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0sIHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgaXRlbSk7XG5cblx0XHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdHdoaWxlIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuayAhPT0ga2V5KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0IGFuZCBhbiBpdGVtIGhhcyBhbiBlZmZlY3QgdGhhdCBpcyBhbHJlYWR5IGluZXJ0LFxuXHRcdFx0XHQvLyBza2lwIG92ZXIgYWRkaW5nIGl0IHRvIG91ciBzZWVuIFNldCBhcyB0aGUgaXRlbSBpcyBhbHJlYWR5IGJlaW5nIGhhbmRsZWRcblx0XHRcdFx0aWYgKChjdXJyZW50LmUuZiAmIElORVJUKSA9PT0gMCkge1xuXHRcdFx0XHRcdChzZWVuID8/PSBuZXcgU2V0KCkpLmFkZChjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFzaGVkLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtID0gY3VycmVudDtcblx0XHR9XG5cblx0XHRtYXRjaGVkLnB1c2goaXRlbSk7XG5cdFx0cHJldiA9IGl0ZW07XG5cdFx0Y3VycmVudCA9IGl0ZW0ubmV4dDtcblx0fVxuXG5cdGxldCBoYXNfb2Zmc2NyZWVuX2l0ZW1zID0gaXRlbXMuc2l6ZSA+IGxlbmd0aDtcblxuXHRpZiAoY3VycmVudCAhPT0gbnVsbCB8fCBzZWVuICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgdG9fZGVzdHJveSA9IHNlZW4gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJyYXlfZnJvbShzZWVuKTtcblxuXHRcdHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdFx0XHQvLyBJZiB0aGUgZWFjaCBibG9jayBpc24ndCBpbmVydCwgdGhlbiBpbmVydCBlZmZlY3RzIGFyZSBjdXJyZW50bHkgb3V0cm9pbmcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBvbmNlIHRoZSB0cmFuc2l0aW9uIGlzIGZpbmlzaGVkXG5cdFx0XHRpZiAoKGN1cnJlbnQuZS5mICYgSU5FUlQpID09PSAwKSB7XG5cdFx0XHRcdHRvX2Rlc3Ryb3kucHVzaChjdXJyZW50KTtcblx0XHRcdH1cblx0XHRcdGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG5cdFx0fVxuXG5cdFx0dmFyIGRlc3Ryb3lfbGVuZ3RoID0gdG9fZGVzdHJveS5sZW5ndGg7XG5cblx0XHRoYXNfb2Zmc2NyZWVuX2l0ZW1zID0gaXRlbXMuc2l6ZSAtIGRlc3Ryb3lfbGVuZ3RoID4gbGVuZ3RoO1xuXG5cdFx0aWYgKGRlc3Ryb3lfbGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIGNvbnRyb2xsZWRfYW5jaG9yID0gKGZsYWdzICYgRUFDSF9JU19DT05UUk9MTEVEKSAhPT0gMCAmJiBsZW5ndGggPT09IDAgPyBhbmNob3IgOiBudWxsO1xuXG5cdFx0XHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRlc3Ryb3lfbGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0XHR0b19kZXN0cm95W2ldLmE/Lm1lYXN1cmUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZXN0cm95X2xlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dG9fZGVzdHJveVtpXS5hPy5maXgoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRwYXVzZV9lZmZlY3RzKHN0YXRlLCB0b19kZXN0cm95LCBjb250cm9sbGVkX2FuY2hvcik7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQXBwZW5kIG9mZnNjcmVlbiBpdGVtcyBhdCB0aGUgZW5kXG5cdGlmIChoYXNfb2Zmc2NyZWVuX2l0ZW1zKSB7XG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zLnZhbHVlcygpKSB7XG5cdFx0XHRpZiAoIWl0ZW0ubykge1xuXHRcdFx0XHRsaW5rKHN0YXRlLCBwcmV2LCBpdGVtKTtcblx0XHRcdFx0cHJldiA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0c3RhdGUuZWZmZWN0Lmxhc3QgPSBwcmV2ICYmIHByZXYuZTtcblxuXHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGlmICh0b19hbmltYXRlID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRcdGZvciAoaXRlbSBvZiB0b19hbmltYXRlKSB7XG5cdFx0XHRcdGl0ZW0uYT8uYXBwbHkoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge05vZGUgfCBudWxsfSBhbmNob3JcbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBwcmV2XG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge3Vua25vd259IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0geyhhbmNob3I6IE5vZGUsIGl0ZW06IFYgfCBTb3VyY2U8Vj4sIGluZGV4OiBudW1iZXIgfCBWYWx1ZTxudW1iZXI+LCBjb2xsZWN0aW9uOiAoKSA9PiBWW10pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtFYWNoSXRlbX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2l0ZW0oYW5jaG9yLCBwcmV2LCB2YWx1ZSwga2V5LCBpbmRleCwgcmVuZGVyX2ZuLCBmbGFncywgZ2V0X2NvbGxlY3Rpb24pIHtcblx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHR2YXIgcmVhY3RpdmUgPSAoZmxhZ3MgJiBFQUNIX0lURU1fUkVBQ1RJVkUpICE9PSAwO1xuXHR2YXIgbXV0YWJsZSA9IChmbGFncyAmIEVBQ0hfSVRFTV9JTU1VVEFCTEUpID09PSAwO1xuXG5cdHZhciB2ID0gcmVhY3RpdmUgPyAobXV0YWJsZSA/IG11dGFibGVfc291cmNlKHZhbHVlLCBmYWxzZSwgZmFsc2UpIDogc291cmNlKHZhbHVlKSkgOiB2YWx1ZTtcblx0dmFyIGkgPSAoZmxhZ3MgJiBFQUNIX0lOREVYX1JFQUNUSVZFKSA9PT0gMCA/IGluZGV4IDogc291cmNlKGluZGV4KTtcblxuXHRpZiAoREVWICYmIHJlYWN0aXZlKSB7XG5cdFx0Ly8gRm9yIHRyYWNpbmcgcHVycG9zZXMsIHdlIG5lZWQgdG8gbGluayB0aGUgc291cmNlIHNpZ25hbCB3ZSBjcmVhdGUgd2l0aCB0aGVcblx0XHQvLyBjb2xsZWN0aW9uICsgaW5kZXggc28gdGhhdCB0cmFjaW5nIHdvcmtzIGFzIGludGVuZGVkXG5cdFx0LyoqIEB0eXBlIHtWYWx1ZX0gKi8gKHYpLnRyYWNlID0gKCkgPT4ge1xuXHRcdFx0dmFyIGNvbGxlY3Rpb25faW5kZXggPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgPyBpbmRleCA6IGkudjtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRnZXRfY29sbGVjdGlvbigpW2NvbGxlY3Rpb25faW5kZXhdO1xuXHRcdH07XG5cdH1cblxuXHQvKiogQHR5cGUge0VhY2hJdGVtfSAqL1xuXHR2YXIgaXRlbSA9IHtcblx0XHRpLFxuXHRcdHYsXG5cdFx0azoga2V5LFxuXHRcdGE6IG51bGwsXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGU6IG51bGwsXG5cdFx0bzogZmFsc2UsXG5cdFx0cHJldixcblx0XHRuZXh0OiBudWxsXG5cdH07XG5cblx0Y3VycmVudF9lYWNoX2l0ZW0gPSBpdGVtO1xuXG5cdHRyeSB7XG5cdFx0aWYgKGFuY2hvciA9PT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kKChhbmNob3IgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0fVxuXG5cdFx0aXRlbS5lID0gYnJhbmNoKCgpID0+IHJlbmRlcl9mbigvKiogQHR5cGUge05vZGV9ICovIChhbmNob3IpLCB2LCBpLCBnZXRfY29sbGVjdGlvbikpO1xuXG5cdFx0aWYgKHByZXYgIT09IG51bGwpIHtcblx0XHRcdC8vIHdlIG9ubHkgbmVlZCB0byBzZXQgYHByZXYubmV4dCA9IGl0ZW1gLCBiZWNhdXNlXG5cdFx0XHQvLyBgaXRlbS5wcmV2ID0gcHJldmAgd2FzIHNldCBvbiBpbml0aWFsaXphdGlvbi5cblx0XHRcdC8vIHRoZSBlZmZlY3RzIHRoZW1zZWx2ZXMgYXJlIGFscmVhZHkgbGlua2VkXG5cdFx0XHRwcmV2Lm5leHQgPSBpdGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtO1xuXHR9IGZpbmFsbHkge1xuXHRcdGN1cnJlbnRfZWFjaF9pdGVtID0gcHJldmlvdXNfZWFjaF9pdGVtO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYWNoSXRlbX0gaXRlbVxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqIEBwYXJhbSB7VGV4dCB8IEVsZW1lbnQgfCBDb21tZW50fSBhbmNob3JcbiAqL1xuZnVuY3Rpb24gbW92ZShpdGVtLCBuZXh0LCBhbmNob3IpIHtcblx0dmFyIGVuZCA9IGl0ZW0ubmV4dCA/IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaXRlbS5uZXh0LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXG5cdHZhciBkZXN0ID0gbmV4dCA/IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobmV4dC5lLm5vZGVzX3N0YXJ0KSA6IGFuY2hvcjtcblx0dmFyIG5vZGUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGl0ZW0uZS5ub2Rlc19zdGFydCk7XG5cblx0d2hpbGUgKG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gZW5kKSB7XG5cdFx0dmFyIG5leHRfbm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0ZGVzdC5iZWZvcmUobm9kZSk7XG5cdFx0bm9kZSA9IG5leHRfbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IHByZXZcbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBuZXh0XG4gKi9cbmZ1bmN0aW9uIGxpbmsoc3RhdGUsIHByZXYsIG5leHQpIHtcblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHRzdGF0ZS5maXJzdCA9IG5leHQ7XG5cdFx0c3RhdGUuZWZmZWN0LmZpcnN0ID0gbmV4dCAmJiBuZXh0LmU7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKHByZXYuZS5uZXh0KSB7XG5cdFx0XHRwcmV2LmUubmV4dC5wcmV2ID0gbnVsbDtcblx0XHR9XG5cblx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdHByZXYuZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cdH1cblxuXHRpZiAobmV4dCAhPT0gbnVsbCkge1xuXHRcdGlmIChuZXh0LmUucHJldikge1xuXHRcdFx0bmV4dC5lLnByZXYubmV4dCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHRuZXh0LmUucHJldiA9IHByZXYgJiYgcHJldi5lO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVTVFJPWUVELCBTVEFMRV9SRUFDVElPTiB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0Y29tcG9uZW50X2NvbnRleHQsXG5cdGRldl9zdGFjayxcblx0aXNfcnVuZXMsXG5cdHNldF9jb21wb25lbnRfY29udGV4dCxcblx0c2V0X2Rldl9zdGFja1xufSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGdldF9ib3VuZGFyeSB9IGZyb20gJy4uL2RvbS9ibG9ja3MvYm91bmRhcnkuanMnO1xuaW1wb3J0IHsgaW52b2tlX2Vycm9yX2JvdW5kYXJ5IH0gZnJvbSAnLi4vZXJyb3ItaGFuZGxpbmcuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IEJhdGNoLCBjdXJyZW50X2JhdGNoIH0gZnJvbSAnLi9iYXRjaC5qcyc7XG5pbXBvcnQge1xuXHRhc3luY19kZXJpdmVkLFxuXHRjdXJyZW50X2FzeW5jX2VmZmVjdCxcblx0ZGVyaXZlZCxcblx0ZGVyaXZlZF9zYWZlX2VxdWFsLFxuXHRzZXRfZnJvbV9hc3luY19kZXJpdmVkXG59IGZyb20gJy4vZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgYWJvcnRlZCB9IGZyb20gJy4vZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGluZywgc2V0X2h5ZHJhdGVfbm9kZSwgc2tpcF9ub2RlcyB9IGZyb20gJy4uL2RvbS9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3VycmVudF9lYWNoX2l0ZW0sIHNldF9jdXJyZW50X2VhY2hfaXRlbSB9IGZyb20gJy4uL2RvbS9ibG9ja3MvZWFjaC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxQcm9taXNlPHZvaWQ+Pn0gYmxvY2tlcnNcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gYW55Pn0gc3luY1xuICogQHBhcmFtIHtBcnJheTwoKSA9PiBQcm9taXNlPGFueT4+fSBhc3luY1xuICogQHBhcmFtIHsodmFsdWVzOiBWYWx1ZVtdKSA9PiBhbnl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGJsb2NrZXJzLCBzeW5jLCBhc3luYywgZm4pIHtcblx0Y29uc3QgZCA9IGlzX3J1bmVzKCkgPyBkZXJpdmVkIDogZGVyaXZlZF9zYWZlX2VxdWFsO1xuXG5cdGlmIChhc3luYy5sZW5ndGggPT09IDAgJiYgYmxvY2tlcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0Zm4oc3luYy5tYXAoZCkpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBiYXRjaCA9IGN1cnJlbnRfYmF0Y2g7XG5cdHZhciBwYXJlbnQgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdHZhciByZXN0b3JlID0gY2FwdHVyZSgpO1xuXG5cdGZ1bmN0aW9uIHJ1bigpIHtcblx0XHRQcm9taXNlLmFsbChhc3luYy5tYXAoKGV4cHJlc3Npb24pID0+IGFzeW5jX2Rlcml2ZWQoZXhwcmVzc2lvbikpKVxuXHRcdFx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0XHRyZXN0b3JlKCk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmbihbLi4uc3luYy5tYXAoZCksIC4uLnJlc3VsdF0pO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdC8vIGlnbm9yZSBlcnJvcnMgaW4gYmxvY2tzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGVzdHJveWVkXG5cdFx0XHRcdFx0aWYgKChwYXJlbnQuZiAmIERFU1RST1lFRCkgPT09IDApIHtcblx0XHRcdFx0XHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgcGFyZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXRjaD8uZGVhY3RpdmF0ZSgpO1xuXHRcdFx0XHR1bnNldF9jb250ZXh0KCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIHBhcmVudCk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdGlmIChibG9ja2Vycy5sZW5ndGggPiAwKSB7XG5cdFx0UHJvbWlzZS5hbGwoYmxvY2tlcnMpLnRoZW4oKCkgPT4ge1xuXHRcdFx0cmVzdG9yZSgpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gcnVuKCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRiYXRjaD8uZGVhY3RpdmF0ZSgpO1xuXHRcdFx0XHR1bnNldF9jb250ZXh0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0cnVuKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U8dm9pZD4+fSBibG9ja2Vyc1xuICogQHBhcmFtIHsodmFsdWVzOiBWYWx1ZVtdKSA9PiBhbnl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5fYWZ0ZXJfYmxvY2tlcnMoYmxvY2tlcnMsIGZuKSB7XG5cdHZhciBlYWNoX2l0ZW0gPSBjdXJyZW50X2VhY2hfaXRlbTsgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBwYXJ0IG9mIGNhcHR1cmU/XG5cdGZsYXR0ZW4oYmxvY2tlcnMsIFtdLCBbXSwgKHYpID0+IHtcblx0XHRzZXRfY3VycmVudF9lYWNoX2l0ZW0oZWFjaF9pdGVtKTtcblx0XHRmbih2KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIGN1cnJlbnQgZWZmZWN0IGNvbnRleHQgc28gdGhhdCB3ZSBjYW4gcmVzdG9yZSBpdCBhZnRlclxuICogc29tZSBhc3luY2hyb25vdXMgd29yayBoYXMgaGFwcGVuZWQgKHNvIHRoYXQgZS5nLiBgYXdhaXQgYSArIGJgXG4gKiBjYXVzZXMgYGJgIHRvIGJlIHJlZ2lzdGVyZWQgYXMgYSBkZXBlbmRlbmN5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmUoKSB7XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19jb21wb25lbnRfY29udGV4dCA9IGNvbXBvbmVudF9jb250ZXh0O1xuXHR2YXIgcHJldmlvdXNfYmF0Y2ggPSBjdXJyZW50X2JhdGNoO1xuXG5cdGlmIChERVYpIHtcblx0XHR2YXIgcHJldmlvdXNfZGV2X3N0YWNrID0gZGV2X3N0YWNrO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHJlc3RvcmUoYWN0aXZhdGVfYmF0Y2ggPSB0cnVlKSB7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfY29tcG9uZW50X2NvbnRleHQocHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdGlmIChhY3RpdmF0ZV9iYXRjaCkgcHJldmlvdXNfYmF0Y2g/LmFjdGl2YXRlKCk7XG5cblx0XHRpZiAoREVWKSB7XG5cdFx0XHRzZXRfZnJvbV9hc3luY19kZXJpdmVkKG51bGwpO1xuXHRcdFx0c2V0X2Rldl9zdGFjayhwcmV2aW91c19kZXZfc3RhY2spO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBXcmFwcyBhbiBgYXdhaXRgIGV4cHJlc3Npb24gaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBlZmZlY3QgY29udGV4dCB0aGF0IHdhc1xuICogYWN0aXZlIGJlZm9yZSB0aGUgZXhwcmVzc2lvbiBldmFsdWF0ZWQgY2FuIGJlIHJlYXBwbGllZCBhZnRlcndhcmRzIFx1MjAxNFxuICogYGF3YWl0IGEgKyBiYCBiZWNvbWVzIGAoYXdhaXQgJC5zYXZlKGEpKSgpICsgYmBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1Byb21pc2U8VD59IHByb21pc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPCgpID0+IFQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZShwcm9taXNlKSB7XG5cdHZhciByZXN0b3JlID0gY2FwdHVyZSgpO1xuXHR2YXIgdmFsdWUgPSBhd2FpdCBwcm9taXNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0cmVzdG9yZSgpO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXNldCBgY3VycmVudF9hc3luY19lZmZlY3RgIGFmdGVyIHRoZSBgcHJvbWlzZWAgcmVzb2x2ZXMsIHNvXG4gKiB0aGF0IHdlIGNhbiBlbWl0IGBhd2FpdF9yZWFjdGl2aXR5X2xvc3NgIHdhcm5pbmdzXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtQcm9taXNlPFQ+fSBwcm9taXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwoKSA9PiBUPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNrX3JlYWN0aXZpdHlfbG9zcyhwcm9taXNlKSB7XG5cdHZhciBwcmV2aW91c19hc3luY19lZmZlY3QgPSBjdXJyZW50X2FzeW5jX2VmZmVjdDtcblx0dmFyIHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdHNldF9mcm9tX2FzeW5jX2Rlcml2ZWQocHJldmlvdXNfYXN5bmNfZWZmZWN0KTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG59XG5cbi8qKlxuICogVXNlZCBpbiBgZm9yIGF3YWl0YCBsb29wcyBpbiBERVYsIHNvXG4gKiB0aGF0IHdlIGNhbiBlbWl0IGBhd2FpdF9yZWFjdGl2aXR5X2xvc3NgIHdhcm5pbmdzXG4gKiBhZnRlciBlYWNoIGBhc3luY19pdGVyYXRvcmAgcmVzdWx0IHJlc29sdmVzIGFuZFxuICogYWZ0ZXIgdGhlIGBhc3luY19pdGVyYXRvcmAgcmV0dXJuIHJlc29sdmVzIChpZiBpdCBydW5zKVxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBUUmV0dXJuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+IHwgQXN5bmNJdGVyYWJsZTxUPn0gaXRlcmFibGVcbiAqIEByZXR1cm5zIHtBc3luY0dlbmVyYXRvcjxULCBUUmV0dXJuIHwgdW5kZWZpbmVkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBmb3JfYXdhaXRfdHJhY2tfcmVhY3Rpdml0eV9sb3NzKGl0ZXJhYmxlKSB7XG5cdC8vIFRoaXMgaXMgYmFzZWQgb24gdGhlIGFsZ29yaXRobXMgZGVzY3JpYmVkIGluIEVDTUEtMjYyOlxuXHQvLyBGb3JJbi9PZkJvZHlFdmFsdWF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyL211bHRpcGFnZS9lY21hc2NyaXB0LWxhbmd1YWdlLXN0YXRlbWVudHMtYW5kLWRlY2xhcmF0aW9ucy5odG1sI3NlYy1ydW50aW1lLXNlbWFudGljcy1mb3Jpbi1kaXYtb2Zib2R5ZXZhbHVhdGlvbi1saHMtc3RtdC1pdGVyYXRvci1saHNraW5kLWxhYmVsc2V0XG5cdC8vIEFzeW5jSXRlcmF0b3JDbG9zZVxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi9tdWx0aXBhZ2UvYWJzdHJhY3Qtb3BlcmF0aW9ucy5odG1sI3NlYy1hc3luY2l0ZXJhdG9yY2xvc2VcblxuXHQvKiogQHR5cGUge0FzeW5jSXRlcmF0b3I8VCwgVFJldHVybj59ICovXG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0/LigpID8/IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0/LigpO1xuXG5cdGlmIChpdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgbm90IGFzeW5jIGl0ZXJhYmxlJyk7XG5cdH1cblxuXHQvKiogV2hldGhlciB0aGUgY29tcGxldGlvbiBvZiB0aGUgaXRlcmF0b3Igd2FzIFwibm9ybWFsXCIsIG1lYW5pbmcgaXQgd2Fzbid0IGVuZGVkIHZpYSBgYnJlYWtgIG9yIGEgc2ltaWxhciBtZXRob2QgKi9cblx0bGV0IG5vcm1hbF9jb21wbGV0aW9uID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IChhd2FpdCB0cmFja19yZWFjdGl2aXR5X2xvc3MoaXRlcmF0b3IubmV4dCgpKSkoKTtcblx0XHRcdGlmIChkb25lKSB7XG5cdFx0XHRcdG5vcm1hbF9jb21wbGV0aW9uID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR5aWVsZCB2YWx1ZTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gSWYgdGhlIGl0ZXJhdG9yIGhhZCBhIG5vcm1hbCBjb21wbGV0aW9uIGFuZCBgcmV0dXJuYCBpcyBkZWZpbmVkIG9uIHRoZSBpdGVyYXRvciwgY2FsbCBpdCBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxuXHRcdGlmIChub3JtYWxfY29tcGxldGlvbiAmJiBpdGVyYXRvci5yZXR1cm4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuc2FmZS1maW5hbGx5XG5cdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHtUUmV0dXJufSAqLyAoKGF3YWl0IHRyYWNrX3JlYWN0aXZpdHlfbG9zcyhpdGVyYXRvci5yZXR1cm4oKSkpKCkudmFsdWUpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zZXRfY29udGV4dCgpIHtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdHNldF9jb21wb25lbnRfY29udGV4dChudWxsKTtcblxuXHRpZiAoREVWKSB7XG5cdFx0c2V0X2Zyb21fYXN5bmNfZGVyaXZlZChudWxsKTtcblx0XHRzZXRfZGV2X3N0YWNrKG51bGwpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IGFuY2hvclxuICogQHBhcmFtIHsodGFyZ2V0OiBUZW1wbGF0ZU5vZGUpID0+IFByb21pc2U8dm9pZD59IGZuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY19ib2R5KGFuY2hvciwgZm4pIHtcblx0dmFyIGJvdW5kYXJ5ID0gZ2V0X2JvdW5kYXJ5KCk7XG5cdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblx0dmFyIGJsb2NraW5nID0gIWJvdW5kYXJ5LmlzX3BlbmRpbmcoKTtcblxuXHRib3VuZGFyeS51cGRhdGVfcGVuZGluZ19jb3VudCgxKTtcblx0YmF0Y2guaW5jcmVtZW50KGJsb2NraW5nKTtcblxuXHR2YXIgYWN0aXZlID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHR2YXIgd2FzX2h5ZHJhdGluZyA9IGh5ZHJhdGluZztcblx0dmFyIG5leHRfaHlkcmF0ZV9ub2RlID0gdW5kZWZpbmVkO1xuXG5cdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0bmV4dF9oeWRyYXRlX25vZGUgPSBza2lwX25vZGVzKGZhbHNlKTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0dmFyIHByb21pc2UgPSBmbihhbmNob3IpO1xuXHR9IGZpbmFsbHkge1xuXHRcdGlmIChuZXh0X2h5ZHJhdGVfbm9kZSkge1xuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShuZXh0X2h5ZHJhdGVfbm9kZSk7XG5cdFx0XHRoeWRyYXRlX25leHQoKTtcblx0XHR9XG5cdH1cblxuXHR0cnkge1xuXHRcdGF3YWl0IHByb21pc2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aWYgKCFhYm9ydGVkKGFjdGl2ZSkpIHtcblx0XHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgYWN0aXZlKTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoLTEpO1xuXHRcdGJhdGNoLmRlY3JlbWVudChibG9ja2luZyk7XG5cblx0XHR1bnNldF9jb250ZXh0KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+Pn0gdGh1bmtzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW4odGh1bmtzKSB7XG5cdGNvbnN0IHJlc3RvcmUgPSBjYXB0dXJlKCk7XG5cblx0dmFyIGJvdW5kYXJ5ID0gZ2V0X2JvdW5kYXJ5KCk7XG5cdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblx0dmFyIGJsb2NraW5nID0gIWJvdW5kYXJ5LmlzX3BlbmRpbmcoKTtcblxuXHRib3VuZGFyeS51cGRhdGVfcGVuZGluZ19jb3VudCgxKTtcblx0YmF0Y2guaW5jcmVtZW50KGJsb2NraW5nKTtcblxuXHR2YXIgYWN0aXZlID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHQvKiogQHR5cGUge251bGwgfCB7IGVycm9yOiBhbnkgfX0gKi9cblx0dmFyIGVycm9yZWQgPSBudWxsO1xuXG5cdC8qKiBAcGFyYW0ge2FueX0gZXJyb3IgKi9cblx0Y29uc3QgaGFuZGxlX2Vycm9yID0gKGVycm9yKSA9PiB7XG5cdFx0ZXJyb3JlZCA9IHsgZXJyb3IgfTsgLy8gd3JhcCBpbiBvYmplY3QgaW4gY2FzZSBhIHByb21pc2UgcmVqZWN0cyB3aXRoIGEgZmFsc3kgdmFsdWVcblxuXHRcdGlmICghYWJvcnRlZChhY3RpdmUpKSB7XG5cdFx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIGFjdGl2ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRodW5rc1swXSgpKS5jYXRjaChoYW5kbGVfZXJyb3IpO1xuXG5cdHZhciBwcm9taXNlcyA9IFtwcm9taXNlXTtcblxuXHRmb3IgKGNvbnN0IGZuIG9mIHRodW5rcy5zbGljZSgxKSkge1xuXHRcdHByb21pc2UgPSBwcm9taXNlXG5cdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmIChlcnJvcmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3JlZC5lcnJvcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhYm9ydGVkKGFjdGl2ZSkpIHtcblx0XHRcdFx0XHR0aHJvdyBTVEFMRV9SRUFDVElPTjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmVzdG9yZSgpO1xuXHRcdFx0XHRcdHJldHVybiBmbigpO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdC8vIFRPRE8gZG8gd2UgbmVlZCBpdCBoZXJlIGFzIHdlbGwgYXMgYmVsb3c/XG5cdFx0XHRcdFx0dW5zZXRfY29udGV4dCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKGhhbmRsZV9lcnJvcilcblx0XHRcdC5maW5hbGx5KCgpID0+IHtcblx0XHRcdFx0dW5zZXRfY29udGV4dCgpO1xuXHRcdFx0fSk7XG5cblx0XHRwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuXHR9XG5cblx0cHJvbWlzZVxuXHRcdC8vIHdhaXQgb25lIG1vcmUgdGljaywgc28gdGhhdCB0ZW1wbGF0ZSBlZmZlY3RzIGFyZVxuXHRcdC8vIGd1YXJhbnRlZWQgdG8gcnVuIGJlZm9yZSBgJGVmZmVjdCguLi4pYFxuXHRcdC50aGVuKCgpID0+IFByb21pc2UucmVzb2x2ZSgpKVxuXHRcdC5maW5hbGx5KCgpID0+IHtcblx0XHRcdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KC0xKTtcblx0XHRcdGJhdGNoLmRlY3JlbWVudChibG9ja2luZyk7XG5cdFx0fSk7XG5cblx0cmV0dXJuIHByb21pc2VzO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRGVyaXZlZCwgRWZmZWN0LCBTb3VyY2UgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBCYXRjaCB9IGZyb20gJy4vYmF0Y2guanMnOyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRFUlJPUl9WQUxVRSxcblx0Q0xFQU4sXG5cdERFUklWRUQsXG5cdERJUlRZLFxuXHRFRkZFQ1RfUFJFU0VSVkVELFxuXHRNQVlCRV9ESVJUWSxcblx0U1RBTEVfUkVBQ1RJT04sXG5cdEFTWU5DLFxuXHRXQVNfTUFSS0VELFxuXHRDT05ORUNURUQsXG5cdERFU1RST1lFRFxufSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1cGRhdGVfcmVhY3Rpb24sXG5cdGluY3JlbWVudF93cml0ZV92ZXJzaW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0cHVzaF9yZWFjdGlvbl92YWx1ZSxcblx0aXNfZGVzdHJveWluZ19lZmZlY3Rcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlcXVhbHMsIHNhZmVfZXF1YWxzIH0gZnJvbSAnLi9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGFzeW5jX2VmZmVjdCwgZGVzdHJveV9lZmZlY3QsIGVmZmVjdF90cmFja2luZywgdGVhcmRvd24gfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZWFnZXJfZWZmZWN0cywgaW50ZXJuYWxfc2V0LCBzZXRfZWFnZXJfZWZmZWN0cywgc291cmNlIH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGdldF9lcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9kZXYuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnLCB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IEJvdW5kYXJ5IH0gZnJvbSAnLi4vZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBiYXRjaF92YWx1ZXMsIGN1cnJlbnRfYmF0Y2ggfSBmcm9tICcuL2JhdGNoLmpzJztcbmltcG9ydCB7IHVuc2V0X2NvbnRleHQgfSBmcm9tICcuL2FzeW5jLmpzJztcbmltcG9ydCB7IGRlZmVycmVkIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuZXhwb3J0IGxldCBjdXJyZW50X2FzeW5jX2VmZmVjdCA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0VmZmVjdCB8IG51bGx9IHYgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZnJvbV9hc3luY19kZXJpdmVkKHYpIHtcblx0Y3VycmVudF9hc3luY19lZmZlY3QgPSB2O1xufVxuXG5leHBvcnQgY29uc3QgcmVjZW50X2FzeW5jX2Rlcml2ZWRzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0geygpID0+IFZ9IGZuXG4gKiBAcmV0dXJucyB7RGVyaXZlZDxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChmbikge1xuXHR2YXIgZmxhZ3MgPSBERVJJVkVEIHwgRElSVFk7XG5cdHZhciBwYXJlbnRfZGVyaXZlZCA9XG5cdFx0YWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmIChhY3RpdmVfcmVhY3Rpb24uZiAmIERFUklWRUQpICE9PSAwXG5cdFx0XHQ/IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGFjdGl2ZV9yZWFjdGlvbilcblx0XHRcdDogbnVsbDtcblxuXHRpZiAoYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdC8vIFNpbmNlIGRlcml2ZWRzIGFyZSBldmFsdWF0ZWQgbGF6aWx5LCBhbnkgZWZmZWN0cyBjcmVhdGVkIGluc2lkZSB0aGVtIGFyZVxuXHRcdC8vIGNyZWF0ZWQgdG9vIGxhdGUgdG8gZW5zdXJlIHRoYXQgdGhlIHBhcmVudCBlZmZlY3QgaXMgYWRkZWQgdG8gdGhlIHRyZWVcblx0XHRhY3RpdmVfZWZmZWN0LmYgfD0gRUZGRUNUX1BSRVNFUlZFRDtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RGVyaXZlZDxWPn0gKi9cblx0Y29uc3Qgc2lnbmFsID0ge1xuXHRcdGN0eDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0ZGVwczogbnVsbCxcblx0XHRlZmZlY3RzOiBudWxsLFxuXHRcdGVxdWFscyxcblx0XHRmOiBmbGFncyxcblx0XHRmbixcblx0XHRyZWFjdGlvbnM6IG51bGwsXG5cdFx0cnY6IDAsXG5cdFx0djogLyoqIEB0eXBlIHtWfSAqLyAoVU5JTklUSUFMSVpFRCksXG5cdFx0d3Y6IDAsXG5cdFx0cGFyZW50OiBwYXJlbnRfZGVyaXZlZCA/PyBhY3RpdmVfZWZmZWN0LFxuXHRcdGFjOiBudWxsXG5cdH07XG5cblx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZykge1xuXHRcdHNpZ25hbC5jcmVhdGVkID0gZ2V0X2Vycm9yKCdjcmVhdGVkIGF0Jyk7XG5cdH1cblxuXHRyZXR1cm4gc2lnbmFsO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0geygpID0+IFYgfCBQcm9taXNlPFY+fSBmblxuICogQHBhcmFtIHtzdHJpbmd9IFtsb2NhdGlvbl0gSWYgcHJvdmlkZWQsIHByaW50IGEgd2FybmluZyBpZiB0aGUgdmFsdWUgaXMgbm90IHJlYWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdXBkYXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTb3VyY2U8Vj4+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3luY19kZXJpdmVkKGZuLCBsb2NhdGlvbikge1xuXHRsZXQgcGFyZW50ID0gLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0aWYgKHBhcmVudCA9PT0gbnVsbCkge1xuXHRcdGUuYXN5bmNfZGVyaXZlZF9vcnBoYW4oKTtcblx0fVxuXG5cdHZhciBib3VuZGFyeSA9IC8qKiBAdHlwZSB7Qm91bmRhcnl9ICovIChwYXJlbnQuYik7XG5cblx0dmFyIHByb21pc2UgPSAvKiogQHR5cGUge1Byb21pc2U8Vj59ICovICgvKiogQHR5cGUge3Vua25vd259ICovICh1bmRlZmluZWQpKTtcblx0dmFyIHNpZ25hbCA9IHNvdXJjZSgvKiogQHR5cGUge1Z9ICovIChVTklOSVRJQUxJWkVEKSk7XG5cblx0Ly8gb25seSBzdXNwZW5kIGluIGFzeW5jIGRlcml2ZWRzIGNyZWF0ZWQgb24gaW5pdGlhbGlzYXRpb25cblx0dmFyIHNob3VsZF9zdXNwZW5kID0gIWFjdGl2ZV9yZWFjdGlvbjtcblxuXHQvKiogQHR5cGUge01hcDxCYXRjaCwgUmV0dXJuVHlwZTx0eXBlb2YgZGVmZXJyZWQ8Vj4+Pn0gKi9cblx0dmFyIGRlZmVycmVkcyA9IG5ldyBNYXAoKTtcblxuXHRhc3luY19lZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChERVYpIGN1cnJlbnRfYXN5bmNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHRcdC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgZGVmZXJyZWQ8Vj4+fSAqL1xuXHRcdHZhciBkID0gZGVmZXJyZWQoKTtcblx0XHRwcm9taXNlID0gZC5wcm9taXNlO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIElmIHRoaXMgY29kZSBpcyBjaGFuZ2VkIGF0IHNvbWUgcG9pbnQsIG1ha2Ugc3VyZSB0byBzdGlsbCBhY2Nlc3MgdGhlIHRoZW4gcHJvcGVydHlcblx0XHRcdC8vIG9mIGZuKCkgdG8gcmVhZCBhbnkgc2lnbmFscyBpdCBtaWdodCBhY2Nlc3MsIHNvIHRoYXQgd2UgdHJhY2sgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG5cdFx0XHQvLyBXZSBjYWxsIGB1bnNldF9jb250ZXh0YCB0byB1bmRvIGFueSBgc2F2ZWAgY2FsbHMgdGhhdCBoYXBwZW4gaW5zaWRlIGBmbigpYFxuXHRcdFx0UHJvbWlzZS5yZXNvbHZlKGZuKCkpXG5cdFx0XHRcdC50aGVuKGQucmVzb2x2ZSwgZC5yZWplY3QpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoYmF0Y2ggPT09IGN1cnJlbnRfYmF0Y2ggJiYgYmF0Y2guY29tbWl0dGVkKSB7XG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgYmF0Y2ggd2FzIHJlamVjdGVkIGFzIHN0YWxlLCB3ZSBuZWVkIHRvIGNsZWFudXBcblx0XHRcdFx0XHRcdC8vIGFmdGVyIGFueSBgJC5zYXZlKC4uLilgIGNhbGxzIGluc2lkZSBgZm4oKWBcblx0XHRcdFx0XHRcdGJhdGNoLmRlYWN0aXZhdGUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR1bnNldF9jb250ZXh0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRkLnJlamVjdChlcnJvcik7XG5cdFx0XHR1bnNldF9jb250ZXh0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKERFVikgY3VycmVudF9hc3luY19lZmZlY3QgPSBudWxsO1xuXG5cdFx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXG5cdFx0aWYgKHNob3VsZF9zdXNwZW5kKSB7XG5cdFx0XHR2YXIgYmxvY2tpbmcgPSAhYm91bmRhcnkuaXNfcGVuZGluZygpO1xuXG5cdFx0XHRib3VuZGFyeS51cGRhdGVfcGVuZGluZ19jb3VudCgxKTtcblx0XHRcdGJhdGNoLmluY3JlbWVudChibG9ja2luZyk7XG5cblx0XHRcdGRlZmVycmVkcy5nZXQoYmF0Y2gpPy5yZWplY3QoU1RBTEVfUkVBQ1RJT04pO1xuXHRcdFx0ZGVmZXJyZWRzLmRlbGV0ZShiYXRjaCk7IC8vIGRlbGV0ZSB0byBlbnN1cmUgY29ycmVjdCBvcmRlciBpbiBNYXAgaXRlcmF0aW9uIGJlbG93XG5cdFx0XHRkZWZlcnJlZHMuc2V0KGJhdGNoLCBkKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge2FueX0gdmFsdWVcblx0XHQgKiBAcGFyYW0ge3Vua25vd259IGVycm9yXG5cdFx0ICovXG5cdFx0Y29uc3QgaGFuZGxlciA9ICh2YWx1ZSwgZXJyb3IgPSB1bmRlZmluZWQpID0+IHtcblx0XHRcdGN1cnJlbnRfYXN5bmNfZWZmZWN0ID0gbnVsbDtcblxuXHRcdFx0YmF0Y2guYWN0aXZhdGUoKTtcblxuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGlmIChlcnJvciAhPT0gU1RBTEVfUkVBQ1RJT04pIHtcblx0XHRcdFx0XHRzaWduYWwuZiB8PSBFUlJPUl9WQUxVRTtcblxuXHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIGVycm9yIGlzIHRoZSB3cm9uZyB0eXBlLCBidXQgd2UgZG9uJ3QgY2FyZVxuXHRcdFx0XHRcdGludGVybmFsX3NldChzaWduYWwsIGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKChzaWduYWwuZiAmIEVSUk9SX1ZBTFVFKSAhPT0gMCkge1xuXHRcdFx0XHRcdHNpZ25hbC5mIF49IEVSUk9SX1ZBTFVFO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW50ZXJuYWxfc2V0KHNpZ25hbCwgdmFsdWUpO1xuXG5cdFx0XHRcdC8vIEFsbCBwcmlvciBhc3luYyBkZXJpdmVkIHJ1bnMgYXJlIG5vdyBzdGFsZVxuXHRcdFx0XHRmb3IgKGNvbnN0IFtiLCBkXSBvZiBkZWZlcnJlZHMpIHtcblx0XHRcdFx0XHRkZWZlcnJlZHMuZGVsZXRlKGIpO1xuXHRcdFx0XHRcdGlmIChiID09PSBiYXRjaCkgYnJlYWs7XG5cdFx0XHRcdFx0ZC5yZWplY3QoU1RBTEVfUkVBQ1RJT04pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKERFViAmJiBsb2NhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmVjZW50X2FzeW5jX2Rlcml2ZWRzLmFkZChzaWduYWwpO1xuXG5cdFx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAocmVjZW50X2FzeW5jX2Rlcml2ZWRzLmhhcyhzaWduYWwpKSB7XG5cdFx0XHRcdFx0XHRcdHcuYXdhaXRfd2F0ZXJmYWxsKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc2lnbmFsLmxhYmVsKSwgbG9jYXRpb24pO1xuXHRcdFx0XHRcdFx0XHRyZWNlbnRfYXN5bmNfZGVyaXZlZHMuZGVsZXRlKHNpZ25hbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHNob3VsZF9zdXNwZW5kKSB7XG5cdFx0XHRcdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KC0xKTtcblx0XHRcdFx0YmF0Y2guZGVjcmVtZW50KGJsb2NraW5nKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZC5wcm9taXNlLnRoZW4oaGFuZGxlciwgKGUpID0+IGhhbmRsZXIobnVsbCwgZSB8fCAndW5rbm93bicpKTtcblx0fSk7XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdGZvciAoY29uc3QgZCBvZiBkZWZlcnJlZHMudmFsdWVzKCkpIHtcblx0XHRcdGQucmVqZWN0KFNUQUxFX1JFQUNUSU9OKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBhZGQgYSBmbGFnIHRoYXQgbGV0cyB0aGlzIGJlIHByaW50ZWQgYXMgYSBkZXJpdmVkXG5cdFx0Ly8gd2hlbiB1c2luZyBgJGluc3BlY3QudHJhY2UoKWBcblx0XHRzaWduYWwuZiB8PSBBU1lOQztcblx0fVxuXG5cdHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsKSA9PiB7XG5cdFx0LyoqIEBwYXJhbSB7UHJvbWlzZTxWPn0gcCAqL1xuXHRcdGZ1bmN0aW9uIG5leHQocCkge1xuXHRcdFx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0XHRcdGlmIChwID09PSBwcm9taXNlKSB7XG5cdFx0XHRcdFx0ZnVsZmlsKHNpZ25hbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gaWYgdGhlIGVmZmVjdCByZS1ydW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBwcm9taXNlXG5cdFx0XHRcdFx0Ly8gcmVzb2x2ZXMsIGRlbGF5IHJlc29sdXRpb24gdW50aWwgd2UgaGF2ZSBhIHZhbHVlXG5cdFx0XHRcdFx0bmV4dChwcm9taXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRwLnRoZW4oZ28sIGdvKTtcblx0XHR9XG5cblx0XHRuZXh0KHByb21pc2UpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWfSBmblxuICogQHJldHVybnMge0Rlcml2ZWQ8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXJfZGVyaXZlZChmbikge1xuXHRjb25zdCBkID0gZGVyaXZlZChmbik7XG5cblx0aWYgKCFhc3luY19tb2RlX2ZsYWcpIHB1c2hfcmVhY3Rpb25fdmFsdWUoZCk7XG5cblx0cmV0dXJuIGQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZm5cbiAqIEByZXR1cm5zIHtEZXJpdmVkPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkX3NhZmVfZXF1YWwoZm4pIHtcblx0Y29uc3Qgc2lnbmFsID0gZGVyaXZlZChmbik7XG5cdHNpZ25hbC5lcXVhbHMgPSBzYWZlX2VxdWFscztcblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9kZXJpdmVkX2VmZmVjdHMoZGVyaXZlZCkge1xuXHR2YXIgZWZmZWN0cyA9IGRlcml2ZWQuZWZmZWN0cztcblxuXHRpZiAoZWZmZWN0cyAhPT0gbnVsbCkge1xuXHRcdGRlcml2ZWQuZWZmZWN0cyA9IG51bGw7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoZWZmZWN0c1tpXSkpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgdXBkYXRpbmcgZGVyaXZlZHMsIHVzZWQgdG8gZGV0ZWN0IGluZmluaXRlIHJlY3Vyc2lvblxuICogaW4gZGV2IG1vZGUgYW5kIHByb3ZpZGUgYSBuaWNlciBlcnJvciB0aGFuICd0b28gbXVjaCByZWN1cnNpb24nXG4gKiBAdHlwZSB7RGVyaXZlZFtdfVxuICovXG5sZXQgc3RhY2sgPSBbXTtcblxuLyoqXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqIEByZXR1cm5zIHtFZmZlY3QgfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRfZGVyaXZlZF9wYXJlbnRfZWZmZWN0KGRlcml2ZWQpIHtcblx0dmFyIHBhcmVudCA9IGRlcml2ZWQucGFyZW50O1xuXHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0aWYgKChwYXJlbnQuZiAmIERFUklWRUQpID09PSAwKSB7XG5cdFx0XHQvLyBUaGUgb3JpZ2luYWwgcGFyZW50IGVmZmVjdCBtaWdodCd2ZSBiZWVuIGRlc3Ryb3llZCBidXQgdGhlIGRlcml2ZWRcblx0XHRcdC8vIGlzIHVzZWQgZWxzZXdoZXJlIG5vdyAtIGRvIG5vdCByZXR1cm4gdGhlIGRlc3Ryb3llZCBlZmZlY3QgaW4gdGhhdCBjYXNlXG5cdFx0XHRyZXR1cm4gKHBhcmVudC5mICYgREVTVFJPWUVEKSA9PT0gMCA/IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocGFyZW50KSA6IG51bGw7XG5cdFx0fVxuXHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlX2Rlcml2ZWQoZGVyaXZlZCkge1xuXHR2YXIgdmFsdWU7XG5cdHZhciBwcmV2X2FjdGl2ZV9lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdHNldF9hY3RpdmVfZWZmZWN0KGdldF9kZXJpdmVkX3BhcmVudF9lZmZlY3QoZGVyaXZlZCkpO1xuXG5cdGlmIChERVYpIHtcblx0XHRsZXQgcHJldl9lYWdlcl9lZmZlY3RzID0gZWFnZXJfZWZmZWN0cztcblx0XHRzZXRfZWFnZXJfZWZmZWN0cyhuZXcgU2V0KCkpO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoc3RhY2suaW5jbHVkZXMoZGVyaXZlZCkpIHtcblx0XHRcdFx0ZS5kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZigpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGFjay5wdXNoKGRlcml2ZWQpO1xuXG5cdFx0XHRkZXJpdmVkLmYgJj0gfldBU19NQVJLRUQ7XG5cdFx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyhkZXJpdmVkKTtcblx0XHRcdHZhbHVlID0gdXBkYXRlX3JlYWN0aW9uKGRlcml2ZWQpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2X2FjdGl2ZV9lZmZlY3QpO1xuXHRcdFx0c2V0X2VhZ2VyX2VmZmVjdHMocHJldl9lYWdlcl9lZmZlY3RzKTtcblx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnkge1xuXHRcdFx0ZGVyaXZlZC5mICY9IH5XQVNfTUFSS0VEO1xuXHRcdFx0ZGVzdHJveV9kZXJpdmVkX2VmZmVjdHMoZGVyaXZlZCk7XG5cdFx0XHR2YWx1ZSA9IHVwZGF0ZV9yZWFjdGlvbihkZXJpdmVkKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldl9hY3RpdmVfZWZmZWN0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9kZXJpdmVkKGRlcml2ZWQpIHtcblx0dmFyIHZhbHVlID0gZXhlY3V0ZV9kZXJpdmVkKGRlcml2ZWQpO1xuXG5cdGlmICghZGVyaXZlZC5lcXVhbHModmFsdWUpKSB7XG5cdFx0Ly8gaW4gYSBmb3JrLCB3ZSBkb24ndCB1cGRhdGUgdGhlIHVuZGVybHlpbmcgdmFsdWUsIGp1c3QgYGJhdGNoX3ZhbHVlc2AuXG5cdFx0Ly8gdGhlIHVuZGVybHlpbmcgdmFsdWUgd2lsbCBiZSB1cGRhdGVkIHdoZW4gdGhlIGZvcmsgaXMgY29tbWl0dGVkLlxuXHRcdC8vIG90aGVyd2lzZSwgdGhlIG5leHQgdGltZSB3ZSBnZXQgaGVyZSBhZnRlciBhICdyZWFsIHdvcmxkJyBzdGF0ZVxuXHRcdC8vIGNoYW5nZSwgYGRlcml2ZWQuZXF1YWxzYCBtYXkgaW5jb3JyZWN0bHkgcmV0dXJuIGB0cnVlYFxuXHRcdGlmICghY3VycmVudF9iYXRjaD8uaXNfZm9yaykge1xuXHRcdFx0ZGVyaXZlZC52ID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0ZGVyaXZlZC53diA9IGluY3JlbWVudF93cml0ZV92ZXJzaW9uKCk7XG5cdH1cblxuXHQvLyBkb24ndCBtYXJrIGRlcml2ZWQgY2xlYW4gaWYgd2UncmUgcmVhZGluZyBpdCBpbnNpZGUgYVxuXHQvLyBjbGVhbnVwIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhY2hlIGEgc3RhbGUgdmFsdWVcblx0aWYgKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gRHVyaW5nIHRpbWUgdHJhdmVsaW5nIHdlIGRvbid0IHdhbnQgdG8gcmVzZXQgdGhlIHN0YXR1cyBzbyB0aGF0XG5cdC8vIHRyYXZlcnNhbCBvZiB0aGUgZ3JhcGggaW4gdGhlIG90aGVyIGJhdGNoZXMgc3RpbGwgaGFwcGVuc1xuXHRpZiAoYmF0Y2hfdmFsdWVzICE9PSBudWxsKSB7XG5cdFx0Ly8gb25seSBjYWNoZSB0aGUgdmFsdWUgaWYgd2UncmUgaW4gYSB0cmFja2luZyBjb250ZXh0LCBvdGhlcndpc2Ugd2Ugd29uJ3Rcblx0XHQvLyBjbGVhciB0aGUgY2FjaGUgaW4gYG1hcmtfcmVhY3Rpb25zYCB3aGVuIGRlcGVuZGVuY2llcyBhcmUgdXBkYXRlZFxuXHRcdGlmIChlZmZlY3RfdHJhY2tpbmcoKSB8fCBjdXJyZW50X2JhdGNoPy5pc19mb3JrKSB7XG5cdFx0XHRiYXRjaF92YWx1ZXMuc2V0KGRlcml2ZWQsIHZhbHVlKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHN0YXR1cyA9IChkZXJpdmVkLmYgJiBDT05ORUNURUQpID09PSAwID8gTUFZQkVfRElSVFkgOiBDTEVBTjtcblx0XHRzZXRfc2lnbmFsX3N0YXR1cyhkZXJpdmVkLCBzdGF0dXMpO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFNvdXJjZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHVudHJhY2tlZF93cml0ZXMsXG5cdGdldCxcblx0c2V0X3VudHJhY2tlZF93cml0ZXMsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHRpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbixcblx0dXBkYXRlX2VmZmVjdCxcblx0Y3VycmVudF9zb3VyY2VzLFxuXHRpc19kaXJ0eSxcblx0dW50cmFja2luZyxcblx0aXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHB1c2hfcmVhY3Rpb25fdmFsdWUsXG5cdHNldF9pc191cGRhdGluZ19lZmZlY3QsXG5cdGlzX3VwZGF0aW5nX2VmZmVjdFxufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGVxdWFscywgc2FmZV9lcXVhbHMgfSBmcm9tICcuL2VxdWFsaXR5LmpzJztcbmltcG9ydCB7XG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRESVJUWSxcblx0QlJBTkNIX0VGRkVDVCxcblx0RUFHRVJfRUZGRUNULFxuXHRNQVlCRV9ESVJUWSxcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0QVNZTkMsXG5cdFdBU19NQVJLRUQsXG5cdENPTk5FQ1RFRFxufSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBsZWdhY3lfbW9kZV9mbGFnLCB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IHRhZ19wcm94eSB9IGZyb20gJy4uL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IGdldF9lcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9kZXYuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGlzX3J1bmVzIH0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBCYXRjaCwgYmF0Y2hfdmFsdWVzLCBlYWdlcl9ibG9ja19lZmZlY3RzLCBzY2hlZHVsZV9lZmZlY3QgfSBmcm9tICcuL2JhdGNoLmpzJztcbmltcG9ydCB7IHByb3h5IH0gZnJvbSAnLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgZXhlY3V0ZV9kZXJpdmVkIH0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5cbi8qKiBAdHlwZSB7U2V0PGFueT59ICovXG5leHBvcnQgbGV0IGVhZ2VyX2VmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKiBAdHlwZSB7TWFwPFNvdXJjZSwgYW55Pn0gKi9cbmV4cG9ydCBjb25zdCBvbGRfdmFsdWVzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U2V0PGFueT59IHZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9lYWdlcl9lZmZlY3RzKHYpIHtcblx0ZWFnZXJfZWZmZWN0cyA9IHY7XG59XG5cbmxldCBlYWdlcl9lZmZlY3RzX2RlZmVycmVkID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZWFnZXJfZWZmZWN0c19kZWZlcnJlZCgpIHtcblx0ZWFnZXJfZWZmZWN0c19kZWZlcnJlZCA9IHRydWU7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdlxuICogQHBhcmFtIHtFcnJvciB8IG51bGx9IFtzdGFja11cbiAqIEByZXR1cm5zIHtTb3VyY2U8Vj59XG4gKi9cbi8vIFRPRE8gcmVuYW1lIHRoaXMgdG8gYHN0YXRlYCB0aHJvdWdob3V0IHRoZSBjb2RlYmFzZVxuZXhwb3J0IGZ1bmN0aW9uIHNvdXJjZSh2LCBzdGFjaykge1xuXHQvKiogQHR5cGUge1ZhbHVlfSAqL1xuXHR2YXIgc2lnbmFsID0ge1xuXHRcdGY6IDAsIC8vIFRPRE8gaWRlYWxseSB3ZSBjb3VsZCBza2lwIHRoaXMgYWx0b2dldGhlciwgYnV0IGl0IGNhdXNlcyB0eXBlIGVycm9yc1xuXHRcdHYsXG5cdFx0cmVhY3Rpb25zOiBudWxsLFxuXHRcdGVxdWFscyxcblx0XHRydjogMCxcblx0XHR3djogMFxuXHR9O1xuXG5cdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRzaWduYWwuY3JlYXRlZCA9IHN0YWNrID8/IGdldF9lcnJvcignY3JlYXRlZCBhdCcpO1xuXHRcdHNpZ25hbC51cGRhdGVkID0gbnVsbDtcblx0XHRzaWduYWwuc2V0X2R1cmluZ19lZmZlY3QgPSBmYWxzZTtcblx0XHRzaWduYWwudHJhY2UgPSBudWxsO1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKiBAcGFyYW0ge0Vycm9yIHwgbnVsbH0gW3N0YWNrXVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZSh2LCBzdGFjaykge1xuXHRjb25zdCBzID0gc291cmNlKHYsIHN0YWNrKTtcblxuXHRwdXNoX3JlYWN0aW9uX3ZhbHVlKHMpO1xuXG5cdHJldHVybiBzO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IGluaXRpYWxfdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbXV0YWJsZV1cbiAqIEByZXR1cm5zIHtTb3VyY2U8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIG11dGFibGVfc291cmNlKGluaXRpYWxfdmFsdWUsIGltbXV0YWJsZSA9IGZhbHNlLCB0cmFja2FibGUgPSB0cnVlKSB7XG5cdGNvbnN0IHMgPSBzb3VyY2UoaW5pdGlhbF92YWx1ZSk7XG5cdGlmICghaW1tdXRhYmxlKSB7XG5cdFx0cy5lcXVhbHMgPSBzYWZlX2VxdWFscztcblx0fVxuXG5cdC8vIGJpbmQgdGhlIHNpZ25hbCB0byB0aGUgY29tcG9uZW50IGNvbnRleHQsIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHQvLyB0cmFjayB1cGRhdGVzIHRvIHRyaWdnZXIgYmVmb3JlVXBkYXRlL2FmdGVyVXBkYXRlIGNhbGxiYWNrc1xuXHRpZiAobGVnYWN5X21vZGVfZmxhZyAmJiB0cmFja2FibGUgJiYgY29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiYgY29tcG9uZW50X2NvbnRleHQubCAhPT0gbnVsbCkge1xuXHRcdChjb21wb25lbnRfY29udGV4dC5sLnMgPz89IFtdKS5wdXNoKHMpO1xuXHR9XG5cblx0cmV0dXJuIHM7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VmFsdWU8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXV0YXRlKHNvdXJjZSwgdmFsdWUpIHtcblx0c2V0KFxuXHRcdHNvdXJjZSxcblx0XHR1bnRyYWNrKCgpID0+IGdldChzb3VyY2UpKVxuXHQpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U291cmNlPFY+fSBzb3VyY2VcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZF9wcm94eV1cbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHNvdXJjZSwgdmFsdWUsIHNob3VsZF9wcm94eSA9IGZhbHNlKSB7XG5cdGlmIChcblx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiZcblx0XHQvLyBzaW5jZSB3ZSBhcmUgdW50cmFja2luZyB0aGUgZnVuY3Rpb24gaW5zaWRlIGAkaW5zcGVjdC53aXRoYCB3ZSBuZWVkIHRvIGFkZCB0aGlzIGNoZWNrXG5cdFx0Ly8gdG8gZW5zdXJlIHdlIGVycm9yIGlmIHN0YXRlIGlzIHNldCBpbnNpZGUgYW4gaW5zcGVjdCBlZmZlY3Rcblx0XHQoIXVudHJhY2tpbmcgfHwgKGFjdGl2ZV9yZWFjdGlvbi5mICYgRUFHRVJfRUZGRUNUKSAhPT0gMCkgJiZcblx0XHRpc19ydW5lcygpICYmXG5cdFx0KGFjdGl2ZV9yZWFjdGlvbi5mICYgKERFUklWRUQgfCBCTE9DS19FRkZFQ1QgfCBBU1lOQyB8IEVBR0VSX0VGRkVDVCkpICE9PSAwICYmXG5cdFx0IWN1cnJlbnRfc291cmNlcz8uaW5jbHVkZXMoc291cmNlKVxuXHQpIHtcblx0XHRlLnN0YXRlX3Vuc2FmZV9tdXRhdGlvbigpO1xuXHR9XG5cblx0bGV0IG5ld192YWx1ZSA9IHNob3VsZF9wcm94eSA/IHByb3h5KHZhbHVlKSA6IHZhbHVlO1xuXG5cdGlmIChERVYpIHtcblx0XHR0YWdfcHJveHkobmV3X3ZhbHVlLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNvdXJjZS5sYWJlbCkpO1xuXHR9XG5cblx0cmV0dXJuIGludGVybmFsX3NldChzb3VyY2UsIG5ld192YWx1ZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U291cmNlPFY+fSBzb3VyY2VcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJuYWxfc2V0KHNvdXJjZSwgdmFsdWUpIHtcblx0aWYgKCFzb3VyY2UuZXF1YWxzKHZhbHVlKSkge1xuXHRcdHZhciBvbGRfdmFsdWUgPSBzb3VyY2UudjtcblxuXHRcdGlmIChpc19kZXN0cm95aW5nX2VmZmVjdCkge1xuXHRcdFx0b2xkX3ZhbHVlcy5zZXQoc291cmNlLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9sZF92YWx1ZXMuc2V0KHNvdXJjZSwgb2xkX3ZhbHVlKTtcblx0XHR9XG5cblx0XHRzb3VyY2UudiA9IHZhbHVlO1xuXG5cdFx0dmFyIGJhdGNoID0gQmF0Y2guZW5zdXJlKCk7XG5cdFx0YmF0Y2guY2FwdHVyZShzb3VyY2UsIG9sZF92YWx1ZSk7XG5cblx0XHRpZiAoREVWKSB7XG5cdFx0XHRpZiAodHJhY2luZ19tb2RlX2ZsYWcgfHwgYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRzb3VyY2UudXBkYXRlZCA/Pz0gbmV3IE1hcCgpO1xuXG5cdFx0XHRcdC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3aGVuIG5vdCB1c2luZyAkaW5zcGVjdC50cmFjZSwgd2Ugb25seSBzdGFydCBjb2xsZWN0aW5nIHN0YWNrIHRyYWNlc1xuXHRcdFx0XHQvLyBhZnRlciB0aGUgc2FtZSBzb3VyY2UgaGFzIGJlZW4gdXBkYXRlZCBtb3JlIHRoYW4gNSB0aW1lcyBpbiB0aGUgc2FtZSBmbHVzaCBjeWNsZS5cblx0XHRcdFx0Y29uc3QgY291bnQgPSAoc291cmNlLnVwZGF0ZWQuZ2V0KCcnKT8uY291bnQgPz8gMCkgKyAxO1xuXHRcdFx0XHRzb3VyY2UudXBkYXRlZC5zZXQoJycsIHsgZXJyb3I6IC8qKiBAdHlwZSB7YW55fSAqLyAobnVsbCksIGNvdW50IH0pO1xuXG5cdFx0XHRcdGlmICh0cmFjaW5nX21vZGVfZmxhZyB8fCBjb3VudCA+IDUpIHtcblx0XHRcdFx0XHRjb25zdCBlcnJvciA9IGdldF9lcnJvcigndXBkYXRlZCBhdCcpO1xuXG5cdFx0XHRcdFx0aWYgKGVycm9yICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRsZXQgZW50cnkgPSBzb3VyY2UudXBkYXRlZC5nZXQoZXJyb3Iuc3RhY2spO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWVudHJ5KSB7XG5cdFx0XHRcdFx0XHRcdGVudHJ5ID0geyBlcnJvciwgY291bnQ6IDAgfTtcblx0XHRcdFx0XHRcdFx0c291cmNlLnVwZGF0ZWQuc2V0KGVycm9yLnN0YWNrLCBlbnRyeSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGVudHJ5LmNvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhY3RpdmVfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHNvdXJjZS5zZXRfZHVyaW5nX2VmZmVjdCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKChzb3VyY2UuZiAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHQvLyBpZiB3ZSBhcmUgYXNzaWduaW5nIHRvIGEgZGlydHkgZGVyaXZlZCB3ZSBzZXQgaXQgdG8gY2xlYW4vbWF5YmUgZGlydHkgYnV0IHdlIGFsc28gZWFnZXJseSBleGVjdXRlIGl0IHRvIHRyYWNrIHRoZSBkZXBlbmRlbmNpZXNcblx0XHRcdGlmICgoc291cmNlLmYgJiBESVJUWSkgIT09IDApIHtcblx0XHRcdFx0ZXhlY3V0ZV9kZXJpdmVkKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNvdXJjZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhzb3VyY2UsIChzb3VyY2UuZiAmIENPTk5FQ1RFRCkgIT09IDAgPyBDTEVBTiA6IE1BWUJFX0RJUlRZKTtcblx0XHR9XG5cblx0XHRzb3VyY2Uud3YgPSBpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbigpO1xuXG5cdFx0Ly8gRm9yIGRlYnVnZ2luZywgaW4gY2FzZSB5b3Ugd2FudCB0byBrbm93IHdoaWNoIHJlYWN0aW9ucyBhcmUgYmVpbmcgc2NoZWR1bGVkOlxuXHRcdC8vIGxvZ19yZWFjdGlvbnMoc291cmNlKTtcblx0XHRtYXJrX3JlYWN0aW9ucyhzb3VyY2UsIERJUlRZKTtcblxuXHRcdC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgY3VycmVudCByZWFjdGlvbiBtaWdodCBub3QgaGF2ZSB1cC10by1kYXRlIGRlcGVuZGVuY2llc1xuXHRcdC8vIHdoaWxzdCBpdCdzIGFjdGl2ZWx5IHJ1bm5pbmcuIFNvIGluIHRoZSBjYXNlIG9mIGVuc3VyaW5nIGl0IHJlZ2lzdGVycyB0aGUgcmVhY3Rpb25cblx0XHQvLyBwcm9wZXJseSBmb3IgaXRzZWxmLCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgY3VycmVudCBlZmZlY3QgYWN0dWFsbHkgZ2V0c1xuXHRcdC8vIHNjaGVkdWxlZC4gaS5lOiBgJGVmZmVjdCgoKSA9PiB4KyspYFxuXHRcdGlmIChcblx0XHRcdGlzX3J1bmVzKCkgJiZcblx0XHRcdGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiZcblx0XHRcdChhY3RpdmVfZWZmZWN0LmYgJiBDTEVBTikgIT09IDAgJiZcblx0XHRcdChhY3RpdmVfZWZmZWN0LmYgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgPT09IDBcblx0XHQpIHtcblx0XHRcdGlmICh1bnRyYWNrZWRfd3JpdGVzID09PSBudWxsKSB7XG5cdFx0XHRcdHNldF91bnRyYWNrZWRfd3JpdGVzKFtzb3VyY2VdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVudHJhY2tlZF93cml0ZXMucHVzaChzb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghYmF0Y2guaXNfZm9yayAmJiBlYWdlcl9lZmZlY3RzLnNpemUgPiAwICYmICFlYWdlcl9lZmZlY3RzX2RlZmVycmVkKSB7XG5cdFx0XHRmbHVzaF9lYWdlcl9lZmZlY3RzKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfZWFnZXJfZWZmZWN0cygpIHtcblx0ZWFnZXJfZWZmZWN0c19kZWZlcnJlZCA9IGZhbHNlO1xuXHR2YXIgcHJldl9pc191cGRhdGluZ19lZmZlY3QgPSBpc191cGRhdGluZ19lZmZlY3Q7XG5cdHNldF9pc191cGRhdGluZ19lZmZlY3QodHJ1ZSk7XG5cblx0Y29uc3QgaW5zcGVjdHMgPSBBcnJheS5mcm9tKGVhZ2VyX2VmZmVjdHMpO1xuXG5cdHRyeSB7XG5cdFx0Zm9yIChjb25zdCBlZmZlY3Qgb2YgaW5zcGVjdHMpIHtcblx0XHRcdC8vIE1hcmsgY2xlYW4gaW5zcGVjdC1lZmZlY3RzIGFzIG1heWJlIGRpcnR5IGFuZCB0aGVuIGNoZWNrIHRoZWlyIGRpcnRpbmVzc1xuXHRcdFx0Ly8gaW5zdGVhZCBvZiBqdXN0IHVwZGF0aW5nIHRoZSBlZmZlY3RzIC0gdGhpcyB3YXkgd2UgYXZvaWQgb3ZlcmZpcmluZy5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgIT09IDApIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBNQVlCRV9ESVJUWSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc19kaXJ0eShlZmZlY3QpKSB7XG5cdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2lzX3VwZGF0aW5nX2VmZmVjdChwcmV2X2lzX3VwZGF0aW5nX2VmZmVjdCk7XG5cdH1cblxuXHRlYWdlcl9lZmZlY3RzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtudW1iZXIgfCBiaWdpbnR9IFRcbiAqIEBwYXJhbSB7U291cmNlPFQ+fSBzb3VyY2VcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlKHNvdXJjZSwgZCA9IDEpIHtcblx0dmFyIHZhbHVlID0gZ2V0KHNvdXJjZSk7XG5cdHZhciByZXN1bHQgPSBkID09PSAxID8gdmFsdWUrKyA6IHZhbHVlLS07XG5cblx0c2V0KHNvdXJjZSwgdmFsdWUpO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge251bWJlciB8IGJpZ2ludH0gVFxuICogQHBhcmFtIHtTb3VyY2U8VD59IHNvdXJjZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlKHNvdXJjZSwgZCA9IDEpIHtcblx0dmFyIHZhbHVlID0gZ2V0KHNvdXJjZSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gc2V0KHNvdXJjZSwgZCA9PT0gMSA/ICsrdmFsdWUgOiAtLXZhbHVlKTtcbn1cblxuLyoqXG4gKiBTaWxlbnRseSAod2l0aG91dCB1c2luZyBgZ2V0YCkgaW5jcmVtZW50IGEgc291cmNlXG4gKiBAcGFyYW0ge1NvdXJjZTxudW1iZXI+fSBzb3VyY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudChzb3VyY2UpIHtcblx0c2V0KHNvdXJjZSwgc291cmNlLnYgKyAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzaWduYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXMgc2hvdWxkIGJlIERJUlRZIG9yIE1BWUJFX0RJUlRZXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gbWFya19yZWFjdGlvbnMoc2lnbmFsLCBzdGF0dXMpIHtcblx0dmFyIHJlYWN0aW9ucyA9IHNpZ25hbC5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgPT09IG51bGwpIHJldHVybjtcblxuXHR2YXIgcnVuZXMgPSBpc19ydW5lcygpO1xuXHR2YXIgbGVuZ3RoID0gcmVhY3Rpb25zLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHJlYWN0aW9uID0gcmVhY3Rpb25zW2ldO1xuXHRcdHZhciBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0XHQvLyBJbiBsZWdhY3kgbW9kZSwgc2tpcCB0aGUgY3VycmVudCBlZmZlY3QgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdGlmICghcnVuZXMgJiYgcmVhY3Rpb24gPT09IGFjdGl2ZV9lZmZlY3QpIGNvbnRpbnVlO1xuXG5cdFx0Ly8gSW5zcGVjdCBlZmZlY3RzIG5lZWQgdG8gcnVuIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHRoZSBzdGFjayB0cmFjZSBtYWtlcyBzZW5zZVxuXHRcdGlmIChERVYgJiYgKGZsYWdzICYgRUFHRVJfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0ZWFnZXJfZWZmZWN0cy5hZGQocmVhY3Rpb24pO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFyIG5vdF9kaXJ0eSA9IChmbGFncyAmIERJUlRZKSA9PT0gMDtcblxuXHRcdC8vIGRvbid0IHNldCBhIERJUlRZIHJlYWN0aW9uIHRvIE1BWUJFX0RJUlRZXG5cdFx0aWYgKG5vdF9kaXJ0eSkge1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIHN0YXR1cyk7XG5cdFx0fVxuXG5cdFx0aWYgKChmbGFncyAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHR2YXIgZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKTtcblxuXHRcdFx0YmF0Y2hfdmFsdWVzPy5kZWxldGUoZGVyaXZlZCk7XG5cblx0XHRcdGlmICgoZmxhZ3MgJiBXQVNfTUFSS0VEKSA9PT0gMCkge1xuXHRcdFx0XHQvLyBPbmx5IGNvbm5lY3RlZCBkZXJpdmVkcyBjYW4gYmUgcmVsaWFibHkgdW5tYXJrZWQgcmlnaHQgYXdheVxuXHRcdFx0XHRpZiAoZmxhZ3MgJiBDT05ORUNURUQpIHtcblx0XHRcdFx0XHRyZWFjdGlvbi5mIHw9IFdBU19NQVJLRUQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXJrX3JlYWN0aW9ucyhkZXJpdmVkLCBNQVlCRV9ESVJUWSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChub3RfZGlydHkpIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBCTE9DS19FRkZFQ1QpICE9PSAwICYmIGVhZ2VyX2Jsb2NrX2VmZmVjdHMgIT09IG51bGwpIHtcblx0XHRcdFx0ZWFnZXJfYmxvY2tfZWZmZWN0cy5hZGQoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChyZWFjdGlvbikpO1xuXHRcdFx0fVxuXG5cdFx0XHRzY2hlZHVsZV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChyZWFjdGlvbikpO1xuXHRcdH1cblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0Z2V0LFxuXHRhY3RpdmVfZWZmZWN0LFxuXHR1cGRhdGVfdmVyc2lvbixcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfdXBkYXRlX3ZlcnNpb24sXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi9ydW50aW1lLmpzJztcbmltcG9ydCB7XG5cdGFycmF5X3Byb3RvdHlwZSxcblx0Z2V0X2Rlc2NyaXB0b3IsXG5cdGdldF9wcm90b3R5cGVfb2YsXG5cdGlzX2FycmF5LFxuXHRvYmplY3RfcHJvdG90eXBlXG59IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRzdGF0ZSBhcyBzb3VyY2UsXG5cdHNldCxcblx0aW5jcmVtZW50LFxuXHRmbHVzaF9lYWdlcl9lZmZlY3RzLFxuXHRzZXRfZWFnZXJfZWZmZWN0c19kZWZlcnJlZFxufSBmcm9tICcuL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBQUk9YWV9QQVRIX1NZTUJPTCwgU1RBVEVfU1lNQk9MIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IHRhZyB9IGZyb20gJy4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgZ2V0X2Vycm9yIH0gZnJvbSAnLi4vc2hhcmVkL2Rldi5qcyc7XG5pbXBvcnQgeyB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uL2ZsYWdzL2luZGV4LmpzJztcblxuLy8gVE9ETyBtb3ZlIGFsbCByZWdleGVzIGludG8gc2hhcmVkIG1vZHVsZT9cbmNvbnN0IHJlZ2V4X2lzX3ZhbGlkX2lkZW50aWZpZXIgPSAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKiQvO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3h5KHZhbHVlKSB7XG5cdC8vIGlmIG5vbi1wcm94eWFibGUsIG9yIGlzIGFscmVhZHkgYSBwcm94eSwgcmV0dXJuIGB2YWx1ZWBcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwgfHwgU1RBVEVfU1lNQk9MIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0Y29uc3QgcHJvdG90eXBlID0gZ2V0X3Byb3RvdHlwZV9vZih2YWx1ZSk7XG5cblx0aWYgKHByb3RvdHlwZSAhPT0gb2JqZWN0X3Byb3RvdHlwZSAmJiBwcm90b3R5cGUgIT09IGFycmF5X3Byb3RvdHlwZSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7TWFwPGFueSwgU291cmNlPGFueT4+fSAqL1xuXHR2YXIgc291cmNlcyA9IG5ldyBNYXAoKTtcblx0dmFyIGlzX3Byb3hpZWRfYXJyYXkgPSBpc19hcnJheSh2YWx1ZSk7XG5cdHZhciB2ZXJzaW9uID0gc291cmNlKDApO1xuXG5cdHZhciBzdGFjayA9IERFViAmJiB0cmFjaW5nX21vZGVfZmxhZyA/IGdldF9lcnJvcignY3JlYXRlZCBhdCcpIDogbnVsbDtcblx0dmFyIHBhcmVudF92ZXJzaW9uID0gdXBkYXRlX3ZlcnNpb247XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVzIHRoZSBwcm94eSBpbiB0aGUgY29udGV4dCBvZiB0aGUgcmVhY3Rpb24gaXQgd2FzIG9yaWdpbmFsbHkgY3JlYXRlZCBpbiwgaWYgYW55XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cblx0ICovXG5cdHZhciB3aXRoX3BhcmVudCA9IChmbikgPT4ge1xuXHRcdGlmICh1cGRhdGVfdmVyc2lvbiA9PT0gcGFyZW50X3ZlcnNpb24pIHtcblx0XHRcdHJldHVybiBmbigpO1xuXHRcdH1cblxuXHRcdC8vIGNoaWxkIHNvdXJjZSBpcyBiZWluZyBjcmVhdGVkIGFmdGVyIHRoZSBpbml0aWFsIHByb3h5IFx1MjAxNFxuXHRcdC8vIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcmVhY3Rpb25cblx0XHR2YXIgcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0dmFyIHZlcnNpb24gPSB1cGRhdGVfdmVyc2lvbjtcblxuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdFx0c2V0X3VwZGF0ZV92ZXJzaW9uKHBhcmVudF92ZXJzaW9uKTtcblxuXHRcdHZhciByZXN1bHQgPSBmbigpO1xuXG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihyZWFjdGlvbik7XG5cdFx0c2V0X3VwZGF0ZV92ZXJzaW9uKHZlcnNpb24pO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRpZiAoaXNfcHJveGllZF9hcnJheSkge1xuXHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIHRoZSBsZW5ndGggc291cmNlIGVhZ2VybHkgdG8gZW5zdXJlIHRoYXRcblx0XHQvLyBtdXRhdGlvbnMgdG8gdGhlIGFycmF5IGFyZSBwcm9wZXJseSBzeW5jZWQgd2l0aCBvdXIgcHJveHlcblx0XHRzb3VyY2VzLnNldCgnbGVuZ3RoJywgc291cmNlKC8qKiBAdHlwZSB7YW55W119ICovICh2YWx1ZSkubGVuZ3RoLCBzdGFjaykpO1xuXHRcdGlmIChERVYpIHtcblx0XHRcdHZhbHVlID0gLyoqIEB0eXBlIHthbnl9ICovIChpbnNwZWN0YWJsZV9hcnJheSgvKiogQHR5cGUge2FueVtdfSAqLyAodmFsdWUpKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIFVzZWQgaW4gZGV2IGZvciAkaW5zcGVjdC50cmFjZSgpICovXG5cdHZhciBwYXRoID0gJyc7XG5cdGxldCB1cGRhdGluZyA9IGZhbHNlO1xuXHQvKiogQHBhcmFtIHtzdHJpbmd9IG5ld19wYXRoICovXG5cdGZ1bmN0aW9uIHVwZGF0ZV9wYXRoKG5ld19wYXRoKSB7XG5cdFx0aWYgKHVwZGF0aW5nKSByZXR1cm47XG5cdFx0dXBkYXRpbmcgPSB0cnVlO1xuXHRcdHBhdGggPSBuZXdfcGF0aDtcblxuXHRcdHRhZyh2ZXJzaW9uLCBgJHtwYXRofSB2ZXJzaW9uYCk7XG5cblx0XHQvLyByZW5hbWUgYWxsIGNoaWxkIHNvdXJjZXMgYW5kIGNoaWxkIHByb3hpZXNcblx0XHRmb3IgKGNvbnN0IFtwcm9wLCBzb3VyY2VdIG9mIHNvdXJjZXMpIHtcblx0XHRcdHRhZyhzb3VyY2UsIGdldF9sYWJlbChwYXRoLCBwcm9wKSk7XG5cdFx0fVxuXHRcdHVwZGF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gbmV3IFByb3h5KC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpLCB7XG5cdFx0ZGVmaW5lUHJvcGVydHkoXywgcHJvcCwgZGVzY3JpcHRvcikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci5jb25maWd1cmFibGUgPT09IGZhbHNlIHx8XG5cdFx0XHRcdGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2Vcblx0XHRcdCkge1xuXHRcdFx0XHQvLyB3ZSBkaXNhbGxvdyBub24tYmFzaWMgZGVzY3JpcHRvcnMsIGJlY2F1c2UgdW5sZXNzIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlXG5cdFx0XHRcdC8vIHRhcmdldCBvYmplY3QgXHUyMDE0IHdoaWNoIHdlIGF2b2lkLCBzbyB0aGF0IHN0YXRlIGNhbiBiZSBmb3JrZWQgXHUyMDE0IHdlIHdpbGwgcnVuXG5cdFx0XHRcdC8vIGFmb3VsIG9mIHRoZSB2YXJpb3VzIGludmFyaWFudHNcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkvUHJveHkvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yI2ludmFyaWFudHNcblx0XHRcdFx0ZS5zdGF0ZV9kZXNjcmlwdG9yc19maXhlZCgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cyA9IHdpdGhfcGFyZW50KCgpID0+IHtcblx0XHRcdFx0XHR2YXIgcyA9IHNvdXJjZShkZXNjcmlwdG9yLnZhbHVlLCBzdGFjayk7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdFx0aWYgKERFViAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcztcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXQocywgZGVzY3JpcHRvci52YWx1ZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHByb3AgaW4gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0Y29uc3QgcyA9IHdpdGhfcGFyZW50KCgpID0+IHNvdXJjZShVTklOSVRJQUxJWkVELCBzdGFjaykpO1xuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0XHRcdGluY3JlbWVudCh2ZXJzaW9uKTtcblxuXHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0KHMsIFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHRpbmNyZW1lbnQodmVyc2lvbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuXHRcdFx0aWYgKHByb3AgPT09IFNUQVRFX1NZTUJPTCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChERVYgJiYgcHJvcCA9PT0gUFJPWFlfUEFUSF9TWU1CT0wpIHtcblx0XHRcdFx0cmV0dXJuIHVwZGF0ZV9wYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0dmFyIGV4aXN0cyA9IHByb3AgaW4gdGFyZ2V0O1xuXG5cdFx0XHQvLyBjcmVhdGUgYSBzb3VyY2UsIGJ1dCBvbmx5IGlmIGl0J3MgYW4gb3duIHByb3BlcnR5IGFuZCBub3QgYSBwcm90b3R5cGUgcHJvcGVydHlcblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQgJiYgKCFleGlzdHMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpKSB7XG5cdFx0XHRcdHMgPSB3aXRoX3BhcmVudCgoKSA9PiB7XG5cdFx0XHRcdFx0dmFyIHAgPSBwcm94eShleGlzdHMgPyB0YXJnZXRbcHJvcF0gOiBVTklOSVRJQUxJWkVEKTtcblx0XHRcdFx0XHR2YXIgcyA9IHNvdXJjZShwLCBzdGFjayk7XG5cblx0XHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0XHR0YWcocywgZ2V0X2xhYmVsKHBhdGgsIHByb3ApKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIHYgPSBnZXQocyk7XG5cdFx0XHRcdHJldHVybiB2ID09PSBVTklOSVRJQUxJWkVEID8gdW5kZWZpbmVkIDogdjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuXHRcdH0sXG5cblx0XHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdGlmIChkZXNjcmlwdG9yICYmICd2YWx1ZScgaW4gZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0XHRpZiAocykgZGVzY3JpcHRvci52YWx1ZSA9IGdldChzKTtcblx0XHRcdH0gZWxzZSBpZiAoZGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdFx0dmFyIHZhbHVlID0gc291cmNlPy52O1xuXG5cdFx0XHRcdGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0fSxcblxuXHRcdGhhcyh0YXJnZXQsIHByb3ApIHtcblx0XHRcdGlmIChwcm9wID09PSBTVEFURV9TWU1CT0wpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgaGFzID0gKHMgIT09IHVuZGVmaW5lZCAmJiBzLnYgIT09IFVOSU5JVElBTElaRUQpIHx8IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0cyAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdChhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmICghaGFzIHx8IGdldF9kZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk/LndyaXRhYmxlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cyA9IHdpdGhfcGFyZW50KCgpID0+IHtcblx0XHRcdFx0XHRcdHZhciBwID0gaGFzID8gcHJveHkodGFyZ2V0W3Byb3BdKSA6IFVOSU5JVElBTElaRUQ7XG5cdFx0XHRcdFx0XHR2YXIgcyA9IHNvdXJjZShwLCBzdGFjayk7XG5cblx0XHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdFx0dGFnKHMsIGdldF9sYWJlbChwYXRoLCBwcm9wKSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBnZXQocyk7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFzO1xuXHRcdH0sXG5cblx0XHRzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgaGFzID0gcHJvcCBpbiB0YXJnZXQ7XG5cblx0XHRcdC8vIHZhcmlhYmxlLmxlbmd0aCA9IHZhbHVlIC0+IGNsZWFyIGFsbCBzaWduYWxzIHdpdGggaW5kZXggPj0gdmFsdWVcblx0XHRcdGlmIChpc19wcm94aWVkX2FycmF5ICYmIHByb3AgPT09ICdsZW5ndGgnKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSB2YWx1ZTsgaSA8IC8qKiBAdHlwZSB7U291cmNlPG51bWJlcj59ICovIChzKS52OyBpICs9IDEpIHtcblx0XHRcdFx0XHR2YXIgb3RoZXJfcyA9IHNvdXJjZXMuZ2V0KGkgKyAnJyk7XG5cdFx0XHRcdFx0aWYgKG90aGVyX3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c2V0KG90aGVyX3MsIFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaSBpbiB0YXJnZXQpIHtcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBpdGVtIGV4aXN0cyBpbiB0aGUgb3JpZ2luYWwsIHdlIG5lZWQgdG8gY3JlYXRlIGFuIHVuaW5pdGlhbGl6ZWQgc291cmNlLFxuXHRcdFx0XHRcdFx0Ly8gZWxzZSBhIGxhdGVyIHJlYWQgb2YgdGhlIHByb3BlcnR5IHdvdWxkIHJlc3VsdCBpbiBhIHNvdXJjZSBiZWluZyBjcmVhdGVkIHdpdGhcblx0XHRcdFx0XHRcdC8vIHRoZSB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwgaXRlbSBhdCB0aGF0IGluZGV4LlxuXHRcdFx0XHRcdFx0b3RoZXJfcyA9IHdpdGhfcGFyZW50KCgpID0+IHNvdXJjZShVTklOSVRJQUxJWkVELCBzdGFjaykpO1xuXHRcdFx0XHRcdFx0c291cmNlcy5zZXQoaSArICcnLCBvdGhlcl9zKTtcblxuXHRcdFx0XHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRcdFx0XHR0YWcob3RoZXJfcywgZ2V0X2xhYmVsKHBhdGgsIGkpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZW4ndCB5ZXQgY3JlYXRlZCBhIHNvdXJjZSBmb3IgdGhpcyBwcm9wZXJ0eSwgd2UgbmVlZCB0byBlbnN1cmVcblx0XHRcdC8vIHdlIGRvIHNvIG90aGVyd2lzZSBpZiB3ZSByZWFkIGl0IGxhdGVyLCB0aGVuIHRoZSB3cml0ZSB3b24ndCBiZSB0cmFja2VkIGFuZFxuXHRcdFx0Ly8gdGhlIGhldXJpc3RpY3Mgb2YgZWZmZWN0cyB3aWxsIGJlIGRpZmZlcmVudCB2cyBpZiB3ZSBoYWQgcmVhZCB0aGUgcHJveGllZFxuXHRcdFx0Ly8gb2JqZWN0IHByb3BlcnR5IGJlZm9yZSB3cml0aW5nIHRvIHRoYXQgcHJvcGVydHkuXG5cdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICghaGFzIHx8IGdldF9kZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk/LndyaXRhYmxlKSB7XG5cdFx0XHRcdFx0cyA9IHdpdGhfcGFyZW50KCgpID0+IHNvdXJjZSh1bmRlZmluZWQsIHN0YWNrKSk7XG5cblx0XHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0XHR0YWcocywgZ2V0X2xhYmVsKHBhdGgsIHByb3ApKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2V0KHMsIHByb3h5KHZhbHVlKSk7XG5cblx0XHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFzID0gcy52ICE9PSBVTklOSVRJQUxJWkVEO1xuXG5cdFx0XHRcdHZhciBwID0gd2l0aF9wYXJlbnQoKCkgPT4gcHJveHkodmFsdWUpKTtcblx0XHRcdFx0c2V0KHMsIHApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdC8vIFNldCB0aGUgbmV3IHZhbHVlIGJlZm9yZSB1cGRhdGluZyBhbnkgc2lnbmFscyBzbyB0aGF0IGFueSBsaXN0ZW5lcnMgZ2V0IHRoZSBuZXcgdmFsdWVcblx0XHRcdGlmIChkZXNjcmlwdG9yPy5zZXQpIHtcblx0XHRcdFx0ZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWhhcykge1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG11dGF0ZWQgYW4gYXJyYXkgZGlyZWN0bHksIHdlIG1pZ2h0IG5lZWQgdG9cblx0XHRcdFx0Ly8gc2lnbmFsIHRoYXQgbGVuZ3RoIGhhcyBhbHNvIGNoYW5nZWQuIERvIGl0IGJlZm9yZSB1cGRhdGluZyBtZXRhZGF0YVxuXHRcdFx0XHQvLyB0byBlbnN1cmUgdGhhdCBpdGVyYXRpbmcgb3ZlciB0aGUgYXJyYXkgYXMgYSByZXN1bHQgb2YgYSBtZXRhZGF0YSB1cGRhdGVcblx0XHRcdFx0Ly8gd2lsbCBub3QgY2F1c2UgdGhlIGxlbmd0aCB0byBiZSBvdXQgb2Ygc3luYy5cblx0XHRcdFx0aWYgKGlzX3Byb3hpZWRfYXJyYXkgJiYgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFyIGxzID0gLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHNvdXJjZXMuZ2V0KCdsZW5ndGgnKSk7XG5cdFx0XHRcdFx0dmFyIG4gPSBOdW1iZXIocHJvcCk7XG5cblx0XHRcdFx0XHRpZiAoTnVtYmVyLmlzSW50ZWdlcihuKSAmJiBuID49IGxzLnYpIHtcblx0XHRcdFx0XHRcdHNldChscywgbiArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluY3JlbWVudCh2ZXJzaW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdG93bktleXModGFyZ2V0KSB7XG5cdFx0XHRnZXQodmVyc2lvbik7XG5cblx0XHRcdHZhciBvd25fa2V5cyA9IFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmZpbHRlcigoa2V5KSA9PiB7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzLmdldChrZXkpO1xuXHRcdFx0XHRyZXR1cm4gc291cmNlID09PSB1bmRlZmluZWQgfHwgc291cmNlLnYgIT09IFVOSU5JVElBTElaRUQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yICh2YXIgW2tleSwgc291cmNlXSBvZiBzb3VyY2VzKSB7XG5cdFx0XHRcdGlmIChzb3VyY2UudiAhPT0gVU5JTklUSUFMSVpFRCAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG5cdFx0XHRcdFx0b3duX2tleXMucHVzaChrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvd25fa2V5cztcblx0XHR9LFxuXG5cdFx0c2V0UHJvdG90eXBlT2YoKSB7XG5cdFx0XHRlLnN0YXRlX3Byb3RvdHlwZV9maXhlZCgpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3ltYm9sfSBwcm9wXG4gKi9cbmZ1bmN0aW9uIGdldF9sYWJlbChwYXRoLCBwcm9wKSB7XG5cdGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHJldHVybiBgJHtwYXRofVtTeW1ib2woJHtwcm9wLmRlc2NyaXB0aW9uID8/ICcnfSldYDtcblx0aWYgKHJlZ2V4X2lzX3ZhbGlkX2lkZW50aWZpZXIudGVzdChwcm9wKSkgcmV0dXJuIGAke3BhdGh9LiR7cHJvcH1gO1xuXHRyZXR1cm4gL15cXGQrJC8udGVzdChwcm9wKSA/IGAke3BhdGh9WyR7cHJvcH1dYCA6IGAke3BhdGh9Wycke3Byb3B9J11gO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3Byb3hpZWRfdmFsdWUodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTVEFURV9TWU1CT0wgaW4gdmFsdWUpIHtcblx0XHRcdHJldHVybiB2YWx1ZVtTVEFURV9TWU1CT0xdO1xuXHRcdH1cblx0fSBjYXRjaCB7XG5cdFx0Ly8gdGhlIGFib3ZlIGlmIGNoZWNrIGNhbiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaW4gcXVlc3Rpb25cblx0XHQvLyBpcyB0aGUgY29udGVudFdpbmRvdyBvZiBhbiBpZnJhbWUgb24gYW5vdGhlciBkb21haW4sIGluIHdoaWNoXG5cdFx0Ly8gY2FzZSB3ZSB3YW50IHRvIGp1c3QgcmV0dXJuIHRoZSB2YWx1ZSAoYmVjYXVzZSBpdCdzIGRlZmluaXRlbHlcblx0XHQvLyBub3QgYSBwcm94aWVkIHZhbHVlKSBzbyB3ZSBkb24ndCBicmVhayBhbnkgSmF2YVNjcmlwdCBpbnRlcmFjdGluZ1xuXHRcdC8vIHdpdGggdGhhdCBpZnJhbWUgKHN1Y2ggYXMgdmFyaW91cyBwYXltZW50IGNvbXBhbmllcyBjbGllbnQgc2lkZVxuXHRcdC8vIEphdmFTY3JpcHQgbGlicmFyaWVzIGludGVyYWN0aW5nIHdpdGggdGhlaXIgaWZyYW1lcyBvbiB0aGUgc2FtZVxuXHRcdC8vIGRvbWFpbilcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKGEsIGIpIHtcblx0cmV0dXJuIE9iamVjdC5pcyhnZXRfcHJveGllZF92YWx1ZShhKSwgZ2V0X3Byb3hpZWRfdmFsdWUoYikpO1xufVxuXG5jb25zdCBBUlJBWV9NVVRBVElOR19NRVRIT0RTID0gbmV3IFNldChbXG5cdCdjb3B5V2l0aGluJyxcblx0J2ZpbGwnLFxuXHQncG9wJyxcblx0J3B1c2gnLFxuXHQncmV2ZXJzZScsXG5cdCdzaGlmdCcsXG5cdCdzb3J0Jyxcblx0J3NwbGljZScsXG5cdCd1bnNoaWZ0J1xuXSk7XG5cbi8qKlxuICogV3JhcCBhcnJheSBtdXRhdGluZyBtZXRob2RzIHNvICRpbnNwZWN0IGlzIHRyaWdnZXJlZCBvbmx5IG9uY2UgYW5kXG4gKiB0byBwcmV2ZW50IGxvZ2dpbmcgYW4gYXJyYXkgaW4gaW50ZXJtZWRpYXRlIHN0YXRlIChlLmcuIHdpdGggYW4gZW1wdHkgc2xvdClcbiAqIEBwYXJhbSB7YW55W119IGFycmF5XG4gKi9cbmZ1bmN0aW9uIGluc3BlY3RhYmxlX2FycmF5KGFycmF5KSB7XG5cdHJldHVybiBuZXcgUHJveHkoYXJyYXksIHtcblx0XHRnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuXHRcdFx0dmFyIHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG5cdFx0XHRpZiAoIUFSUkFZX01VVEFUSU5HX01FVEhPRFMuaGFzKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocHJvcCkpKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAdGhpcyB7YW55W119XG5cdFx0XHQgKiBAcGFyYW0ge2FueVtdfSBhcmdzXG5cdFx0XHQgKi9cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdFx0XHRzZXRfZWFnZXJfZWZmZWN0c19kZWZlcnJlZCgpO1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHRcdGZsdXNoX2VhZ2VyX2VmZmVjdHMoKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0fVxuXHR9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9wcm94aWVkX3ZhbHVlIH0gZnJvbSAnLi4vcHJveHkuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9hcnJheV9wcm90b3R5cGVfd2FybmluZ3MoKSB7XG5cdGNvbnN0IGFycmF5X3Byb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblx0Ly8gVGhlIFJFUEwgZW5kcyB1cCBoZXJlIG92ZXIgYW5kIG92ZXIsIGFuZCB0aGlzIHByZXZlbnRzIGl0IGZyb20gYWRkaW5nIG1vcmUgYW5kIG1vcmUgcGF0Y2hlc1xuXHQvLyBvZiB0aGUgc2FtZSBraW5kIHRvIHRoZSBwcm90b3R5cGUsIHdoaWNoIHdvdWxkIHNsb3cgZG93biBldmVyeXRoaW5nIG92ZXIgdGltZS5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRjb25zdCBjbGVhbnVwID0gQXJyYXkuX19zdmVsdGVfY2xlYW51cDtcblx0aWYgKGNsZWFudXApIHtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjb25zdCB7IGluZGV4T2YsIGxhc3RJbmRleE9mLCBpbmNsdWRlcyB9ID0gYXJyYXlfcHJvdG90eXBlO1xuXG5cdGFycmF5X3Byb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21faW5kZXgpIHtcblx0XHRjb25zdCBpbmRleCA9IGluZGV4T2YuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4KTtcblxuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGZvciAobGV0IGkgPSBmcm9tX2luZGV4ID8/IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5LmluZGV4T2YoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdGFycmF5X3Byb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tX2luZGV4KSB7XG5cdFx0Ly8gd2UgbmVlZCB0byBzcGVjaWZ5IHRoaXMubGVuZ3RoIC0gMSBiZWNhdXNlIGl0J3MgcHJvYmFibHkgdXNpbmcgc29tZXRoaW5nIGxpa2Vcblx0XHQvLyBgYXJndW1lbnRzYCBpbnNpZGUgc28gcGFzc2luZyB1bmRlZmluZWQgaXMgZGlmZmVyZW50IGZyb20gbm90IHBhc3NpbmcgYW55dGhpbmdcblx0XHRjb25zdCBpbmRleCA9IGxhc3RJbmRleE9mLmNhbGwodGhpcywgaXRlbSwgZnJvbV9pbmRleCA/PyB0aGlzLmxlbmd0aCAtIDEpO1xuXG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gKGZyb21faW5kZXggPz8gdGhpcy5sZW5ndGggLSAxKTsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5Lmxhc3RJbmRleE9mKC4uLiknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblx0fTtcblxuXHRhcnJheV9wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbV9pbmRleCkge1xuXHRcdGNvbnN0IGhhcyA9IGluY2x1ZGVzLmNhbGwodGhpcywgaXRlbSwgZnJvbV9pbmRleCk7XG5cblx0XHRpZiAoIWhhcykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5LmluY2x1ZGVzKC4uLiknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBoYXM7XG5cdH07XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRBcnJheS5fX3N2ZWx0ZV9jbGVhbnVwID0gKCkgPT4ge1xuXHRcdGFycmF5X3Byb3RvdHlwZS5pbmRleE9mID0gaW5kZXhPZjtcblx0XHRhcnJheV9wcm90b3R5cGUubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcblx0XHRhcnJheV9wcm90b3R5cGUuaW5jbHVkZXMgPSBpbmNsdWRlcztcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXF1YWxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaWN0X2VxdWFscyhhLCBiLCBlcXVhbCA9IHRydWUpIHtcblx0Ly8gdHJ5LWNhdGNoIG5lZWRlZCBiZWNhdXNlIHRoaXMgdHJpZXMgdG8gcmVhZCBwcm9wZXJ0aWVzIG9mIGBhYCBhbmQgYGJgLFxuXHQvLyB3aGljaCBjb3VsZCBiZSBkaXNhbGxvd2VkIGZvciBleGFtcGxlIGluIGEgc2VjdXJlIGNvbnRleHRcblx0dHJ5IHtcblx0XHRpZiAoKGEgPT09IGIpICE9PSAoZ2V0X3Byb3hpZWRfdmFsdWUoYSkgPT09IGdldF9wcm94aWVkX3ZhbHVlKGIpKSkge1xuXHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaChlcXVhbCA/ICc9PT0nIDogJyE9PScpO1xuXHRcdH1cblx0fSBjYXRjaCB7fVxuXG5cdHJldHVybiAoYSA9PT0gYikgPT09IGVxdWFsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHBhcmFtIHtib29sZWFufSBlcXVhbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYiwgZXF1YWwgPSB0cnVlKSB7XG5cdGlmICgoYSA9PSBiKSAhPT0gKGdldF9wcm94aWVkX3ZhbHVlKGEpID09IGdldF9wcm94aWVkX3ZhbHVlKGIpKSkge1xuXHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goZXF1YWwgPyAnPT0nIDogJyE9Jyk7XG5cdH1cblxuXHRyZXR1cm4gKGEgPT0gYikgPT09IGVxdWFsO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzIH0gZnJvbSAnLi4vZGV2L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yLCBpc19leHRlbnNpYmxlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IFRFWFRfTk9ERSwgRUZGRUNUX1JBTiB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGVhZ2VyX2Jsb2NrX2VmZmVjdHMgfSBmcm9tICcuLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLy8gZXhwb3J0IHRoZXNlIGZvciByZWZlcmVuY2UgaW4gdGhlIGNvbXBpbGVkIGNvZGUsIG1ha2luZyBnbG9iYWwgbmFtZSBkZWR1cGxpY2F0aW9uIHVubmVjZXNzYXJ5XG4vKiogQHR5cGUge1dpbmRvd30gKi9cbmV4cG9ydCB2YXIgJHdpbmRvdztcblxuLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbmV4cG9ydCB2YXIgJGRvY3VtZW50O1xuXG4vKiogQHR5cGUge2Jvb2xlYW59ICovXG5leHBvcnQgdmFyIGlzX2ZpcmVmb3g7XG5cbi8qKiBAdHlwZSB7KCkgPT4gTm9kZSB8IG51bGx9ICovXG52YXIgZmlyc3RfY2hpbGRfZ2V0dGVyO1xuLyoqIEB0eXBlIHsoKSA9PiBOb2RlIHwgbnVsbH0gKi9cbnZhciBuZXh0X3NpYmxpbmdfZ2V0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlc2UgbGF6aWx5IHRvIGF2b2lkIGlzc3VlcyB3aGVuIHVzaW5nIHRoZSBydW50aW1lIGluIGEgc2VydmVyIGNvbnRleHRcbiAqIHdoZXJlIHRoZXNlIGdsb2JhbHMgYXJlIG5vdCBhdmFpbGFibGUgd2hpbGUgYXZvaWRpbmcgYSBzZXBhcmF0ZSBzZXJ2ZXIgZW50cnkgcG9pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfb3BlcmF0aW9ucygpIHtcblx0aWYgKCR3aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdCR3aW5kb3cgPSB3aW5kb3c7XG5cdCRkb2N1bWVudCA9IGRvY3VtZW50O1xuXHRpc19maXJlZm94ID0gL0ZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0dmFyIGVsZW1lbnRfcHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG5cdHZhciBub2RlX3Byb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlO1xuXHR2YXIgdGV4dF9wcm90b3R5cGUgPSBUZXh0LnByb3RvdHlwZTtcblxuXHQvLyBAdHMtaWdub3JlXG5cdGZpcnN0X2NoaWxkX2dldHRlciA9IGdldF9kZXNjcmlwdG9yKG5vZGVfcHJvdG90eXBlLCAnZmlyc3RDaGlsZCcpLmdldDtcblx0Ly8gQHRzLWlnbm9yZVxuXHRuZXh0X3NpYmxpbmdfZ2V0dGVyID0gZ2V0X2Rlc2NyaXB0b3Iobm9kZV9wcm90b3R5cGUsICduZXh0U2libGluZycpLmdldDtcblxuXHRpZiAoaXNfZXh0ZW5zaWJsZShlbGVtZW50X3Byb3RvdHlwZSkpIHtcblx0XHQvLyB0aGUgZm9sbG93aW5nIGFzc2lnbm1lbnRzIGltcHJvdmUgcGVyZiBvZiBsb29rdXBzIG9uIERPTSBub2Rlc1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX2NsaWNrID0gdW5kZWZpbmVkO1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX2NsYXNzTmFtZSA9IHVuZGVmaW5lZDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19hdHRyaWJ1dGVzID0gbnVsbDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19zdHlsZSA9IHVuZGVmaW5lZDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19lID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKGlzX2V4dGVuc2libGUodGV4dF9wcm90b3R5cGUpKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHRleHRfcHJvdG90eXBlLl9fdCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19zdmVsdGVfbWV0YSA9IG51bGw7XG5cblx0XHRpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncygpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV90ZXh0KHZhbHVlID0gJycpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG4vKkBfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfZmlyc3RfY2hpbGQobm9kZSkge1xuXHRyZXR1cm4gZmlyc3RfY2hpbGRfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuLypAX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X25leHRfc2libGluZyhub2RlKSB7XG5cdHJldHVybiBuZXh0X3NpYmxpbmdfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGQobm9kZSwgaXNfdGV4dCkge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBnZXRfZmlyc3RfY2hpbGQobm9kZSk7XG5cdH1cblxuXHR2YXIgY2hpbGQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChoeWRyYXRlX25vZGUpKTtcblxuXHQvLyBDaGlsZCBjYW4gYmUgbnVsbCBpZiB3ZSBoYXZlIGFuIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSBjaGlsZCwgbGlrZSBgPHA+e3RleHR9PC9wPmAsIHdoZXJlIGB0ZXh0YCBpcyBlbXB0eVxuXHRpZiAoY2hpbGQgPT09IG51bGwpIHtcblx0XHRjaGlsZCA9IGh5ZHJhdGVfbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblx0fSBlbHNlIGlmIChpc190ZXh0ICYmIGNoaWxkLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcblx0XHR2YXIgdGV4dCA9IGNyZWF0ZV90ZXh0KCk7XG5cdFx0Y2hpbGQ/LmJlZm9yZSh0ZXh0KTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHRleHQpO1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9XG5cblx0c2V0X2h5ZHJhdGVfbm9kZShjaGlsZCk7XG5cdHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnQgfCBUZW1wbGF0ZU5vZGUgfCBUZW1wbGF0ZU5vZGVbXX0gZnJhZ21lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzX3RleHRdXG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdF9jaGlsZChmcmFnbWVudCwgaXNfdGV4dCA9IGZhbHNlKSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0Ly8gd2hlbiBub3QgaHlkcmF0aW5nLCBgZnJhZ21lbnRgIGlzIGEgYERvY3VtZW50RnJhZ21lbnRgICh0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYG9wZW5fZnJhZ2ApXG5cdFx0dmFyIGZpcnN0ID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGZyYWdtZW50KSkpO1xuXG5cdFx0Ly8gVE9ETyBwcmV2ZW50IHVzZXIgY29tbWVudHMgd2l0aCB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gcHJlc2VydmVDb21tZW50cyBpcyB0cnVlXG5cdFx0aWYgKGZpcnN0IGluc3RhbmNlb2YgQ29tbWVudCAmJiBmaXJzdC5kYXRhID09PSAnJykgcmV0dXJuIGdldF9uZXh0X3NpYmxpbmcoZmlyc3QpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9XG5cblx0Ly8gaWYgYW4ge2V4cHJlc3Npb259IGlzIGVtcHR5IGR1cmluZyBTU1IsIHRoZXJlIG1pZ2h0IGJlIG5vXG5cdC8vIHRleHQgbm9kZSB0byBoeWRyYXRlIFx1MjAxNCB3ZSBtdXN0IHRoZXJlZm9yZSBjcmVhdGUgb25lXG5cdGlmIChpc190ZXh0ICYmIGh5ZHJhdGVfbm9kZT8ubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblxuXHRcdGh5ZHJhdGVfbm9kZT8uYmVmb3JlKHRleHQpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xufVxuXG4vKipcbiAqIERvbid0IG1hcmsgdGhpcyBhcyBzaWRlLWVmZmVjdC1mcmVlLCBoeWRyYXRpb24gbmVlZHMgdG8gd2FsayBhbGwgbm9kZXNcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2libGluZyhub2RlLCBjb3VudCA9IDEsIGlzX3RleHQgPSBmYWxzZSkge1xuXHRsZXQgbmV4dF9zaWJsaW5nID0gaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZTtcblx0dmFyIGxhc3Rfc2libGluZztcblxuXHR3aGlsZSAoY291bnQtLSkge1xuXHRcdGxhc3Rfc2libGluZyA9IG5leHRfc2libGluZztcblx0XHRuZXh0X3NpYmxpbmcgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobmV4dF9zaWJsaW5nKSk7XG5cdH1cblxuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBuZXh0X3NpYmxpbmc7XG5cdH1cblxuXHQvLyBpZiBhIHNpYmxpbmcge2V4cHJlc3Npb259IGlzIGVtcHR5IGR1cmluZyBTU1IsIHRoZXJlIG1pZ2h0IGJlIG5vXG5cdC8vIHRleHQgbm9kZSB0byBoeWRyYXRlIFx1MjAxNCB3ZSBtdXN0IHRoZXJlZm9yZSBjcmVhdGUgb25lXG5cdGlmIChpc190ZXh0ICYmIG5leHRfc2libGluZz8ubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblx0XHQvLyBJZiB0aGUgbmV4dCBzaWJsaW5nIGlzIGBudWxsYCBhbmQgd2UncmUgaGFuZGxpbmcgdGV4dCB0aGVuIGl0J3MgYmVjYXVzZVxuXHRcdC8vIHRoZSBTU1IgY29udGVudCB3YXMgZW1wdHkgZm9yIHRoZSB0ZXh0LCBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIGEgbmV3IHRleHRcblx0XHQvLyBub2RlIGFuZCBpbnNlcnQgaXQgYWZ0ZXIgdGhlIGxhc3Qgc2libGluZ1xuXHRcdGlmIChuZXh0X3NpYmxpbmcgPT09IG51bGwpIHtcblx0XHRcdGxhc3Rfc2libGluZz8uYWZ0ZXIodGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5leHRfc2libGluZy5iZWZvcmUodGV4dCk7XG5cdFx0fVxuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRzZXRfaHlkcmF0ZV9ub2RlKG5leHRfc2libGluZyk7XG5cdHJldHVybiAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5leHRfc2libGluZyk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJfdGV4dF9jb250ZW50KG5vZGUpIHtcblx0bm9kZS50ZXh0Q29udGVudCA9ICcnO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHdlJ3JlIHVwZGF0aW5nIHRoZSBjdXJyZW50IGJsb2NrLCBmb3IgZXhhbXBsZSBgY29uZGl0aW9uYCBpblxuICogYW4gYHsjaWYgY29uZGl0aW9ufWAgYmxvY2sganVzdCBjaGFuZ2VkLiBJbiB0aGlzIGNhc2UsIHRoZSBicmFuY2ggc2hvdWxkIGJlXG4gKiBhcHBlbmRlZCAob3IgcmVtb3ZlZCkgYXQgdGhlIHNhbWUgdGltZSBhcyBvdGhlciB1cGRhdGVzIHdpdGhpbiB0aGVcbiAqIGN1cnJlbnQgYDxzdmVsdGU6Ym91bmRhcnk+YFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkX2RlZmVyX2FwcGVuZCgpIHtcblx0aWYgKCFhc3luY19tb2RlX2ZsYWcpIHJldHVybiBmYWxzZTtcblx0aWYgKGVhZ2VyX2Jsb2NrX2VmZmVjdHMgIT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuXHR2YXIgZmxhZ3MgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmY7XG5cdHJldHVybiAoZmxhZ3MgJiBFRkZFQ1RfUkFOKSAhPT0gMDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lc3BhY2VdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2lzXVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9lbGVtZW50KHRhZywgbmFtZXNwYWNlLCBpcykge1xuXHRsZXQgb3B0aW9ucyA9IGlzID8geyBpcyB9IDogdW5kZWZpbmVkO1xuXHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZywgb3B0aW9ucyk7XG5cdH1cblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCgpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jb21tZW50KGRhdGEgPSAnJykge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSA9ICcnKSB7XG5cdGlmIChrZXkuc3RhcnRzV2l0aCgneGxpbms6JykpIHtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywga2V5LCB2YWx1ZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbn1cbiIsICJpbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY2xlYXJfdGV4dF9jb250ZW50LCBnZXRfZmlyc3RfY2hpbGQgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b2ZvY3VzKGRvbSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlKSB7XG5cdFx0Y29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0ZG9tLmF1dG9mb2N1cyA9IHRydWU7XG5cblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBib2R5KSB7XG5cdFx0XHRcdGRvbS5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGNoaWxkIG9mIGEgdGV4dGFyZWEgYWN0dWFsbHkgY29ycmVzcG9uZHMgdG8gdGhlIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSwgc28gd2UgbmVlZFxuICogdG8gcmVtb3ZlIGl0IHVwb24gaHlkcmF0aW9uIHRvIGF2b2lkIGEgYnVnIHdoZW4gc29tZW9uZSByZXNldHMgdGhlIGZvcm0gdmFsdWUuXG4gKiBAcGFyYW0ge0hUTUxUZXh0QXJlYUVsZW1lbnR9IGRvbVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVfdGV4dGFyZWFfY2hpbGQoZG9tKSB7XG5cdGlmIChoeWRyYXRpbmcgJiYgZ2V0X2ZpcnN0X2NoaWxkKGRvbSkgIT09IG51bGwpIHtcblx0XHRjbGVhcl90ZXh0X2NvbnRlbnQoZG9tKTtcblx0fVxufVxuXG5sZXQgbGlzdGVuaW5nX3RvX2Zvcm1fcmVzZXQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCkge1xuXHRpZiAoIWxpc3RlbmluZ190b19mb3JtX3Jlc2V0KSB7XG5cdFx0bGlzdGVuaW5nX3RvX2Zvcm1fcmVzZXQgPSB0cnVlO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHQncmVzZXQnLFxuXHRcdFx0KGV2dCkgPT4ge1xuXHRcdFx0XHQvLyBOZWVkcyB0byBoYXBwZW4gb25lIHRpY2sgbGF0ZXIgb3IgZWxzZSB0aGUgZG9tIHByb3BlcnRpZXMgb2YgdGhlIGZvcm1cblx0XHRcdFx0Ly8gZWxlbWVudHMgaGF2ZSBub3QgdXBkYXRlZCB0byB0aGVpciByZXNldCB2YWx1ZXMgeWV0XG5cdFx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdGlmICghZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgZSBvZiAvKipAdHlwZSB7SFRNTEZvcm1FbGVtZW50fSAqLyAoZXZ0LnRhcmdldCkuZWxlbWVudHMpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRcdFx0XHRlLl9fb25fcj8uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHQvLyBJbiB0aGUgY2FwdHVyZSBwaGFzZSB0byBndWFyYW50ZWUgd2UgZ2V0IG5vdGljZWQgb2YgaXQgKG5vIHBvc3NpYmlsaXR5IG9mIHN0b3BQcm9wYWdhdGlvbilcblx0XHRcdHsgY2FwdHVyZTogdHJ1ZSB9XG5cdFx0KTtcblx0fVxufVxuIiwgImltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBhZGRfZm9ybV9yZXNldF9saXN0ZW5lciB9IGZyb20gJy4uL21pc2MuanMnO1xuXG4vKipcbiAqIEZpcmVzIHRoZSBoYW5kbGVyIG9uY2UgaW1tZWRpYXRlbHkgKHVubGVzcyBjb3JyZXNwb25kaW5nIGFyZyBpcyBzZXQgdG8gYGZhbHNlYCksXG4gKiB0aGVuIGxpc3RlbnMgdG8gdGhlIGdpdmVuIGV2ZW50cyB1bnRpbCB0aGUgcmVuZGVyIGVmZmVjdCBjb250ZXh0IGlzIGRlc3Ryb3llZFxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV2ZW50c1xuICogQHBhcmFtIHsoZXZlbnQ/OiBFdmVudCkgPT4gdm9pZH0gaGFuZGxlclxuICogQHBhcmFtIHthbnl9IGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRzLCBoYW5kbGVyLCBjYWxsX2hhbmRsZXJfaW1tZWRpYXRlbHkgPSB0cnVlKSB7XG5cdGlmIChjYWxsX2hhbmRsZXJfaW1tZWRpYXRlbHkpIHtcblx0XHRoYW5kbGVyKCk7XG5cdH1cblxuXHRmb3IgKHZhciBuYW1lIG9mIGV2ZW50cykge1xuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuXHR9XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdGZvciAodmFyIG5hbWUgb2YgZXZlbnRzKSB7XG5cdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoZm4pIHtcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGZuKCk7XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIExpc3RlbiB0byB0aGUgZ2l2ZW4gZXZlbnQsIGFuZCB0aGVuIGluc3RhbnRpYXRlIGEgZ2xvYmFsIGZvcm0gcmVzZXQgbGlzdGVuZXIgaWYgbm90IGFscmVhZHkgZG9uZSxcbiAqIHRvIG5vdGlmeSBhbGwgYmluZGluZ3Mgd2hlbiB0aGUgZm9ybSBpcyByZXNldFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0geyhpc19yZXNldD86IHRydWUpID0+IHZvaWR9IGhhbmRsZXJcbiAqIEBwYXJhbSB7KGlzX3Jlc2V0PzogdHJ1ZSkgPT4gdm9pZH0gW29uX3Jlc2V0XVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb25fcmVzZXQgPSBoYW5kbGVyKSB7XG5cdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKCkgPT4gd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KGhhbmRsZXIpKTtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRjb25zdCBwcmV2ID0gZWxlbWVudC5fX29uX3I7XG5cdGlmIChwcmV2KSB7XG5cdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBjaGVja2JveCB0aGF0IGNhbiBoYXZlIG11bHRpcGxlIGJpbmRzIChncm91cCAmIGNoZWNrZWQpXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnQuX19vbl9yID0gKCkgPT4ge1xuXHRcdFx0cHJldigpO1xuXHRcdFx0b25fcmVzZXQodHJ1ZSk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX29uX3IgPSAoKSA9PiBvbl9yZXNldCh0cnVlKTtcblx0fVxuXG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBDb21wb25lbnRDb250ZXh0TGVnYWN5LCBEZXJpdmVkLCBFZmZlY3QsIFRlbXBsYXRlTm9kZSwgVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHtcblx0aXNfZGlydHksXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0dXBkYXRlX2VmZmVjdCxcblx0Z2V0LFxuXHRpc19kZXN0cm95aW5nX2VmZmVjdCxcblx0cmVtb3ZlX3JlYWN0aW9ucyxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbixcblx0c2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0LFxuXHRzZXRfc2lnbmFsX3N0YXR1cyxcblx0dW50cmFjayxcblx0dW50cmFja2luZ1xufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7XG5cdERJUlRZLFxuXHRCUkFOQ0hfRUZGRUNULFxuXHRSRU5ERVJfRUZGRUNULFxuXHRFRkZFQ1QsXG5cdERFU1RST1lFRCxcblx0SU5FUlQsXG5cdEVGRkVDVF9SQU4sXG5cdEJMT0NLX0VGRkVDVCxcblx0Uk9PVF9FRkZFQ1QsXG5cdEVGRkVDVF9UUkFOU1BBUkVOVCxcblx0REVSSVZFRCxcblx0Q0xFQU4sXG5cdEVBR0VSX0VGRkVDVCxcblx0SEVBRF9FRkZFQ1QsXG5cdE1BWUJFX0RJUlRZLFxuXHRFRkZFQ1RfUFJFU0VSVkVELFxuXHRTVEFMRV9SRUFDVElPTixcblx0VVNFUl9FRkZFQ1QsXG5cdEFTWU5DLFxuXHRDT05ORUNURUQsXG5cdE1BTkFHRURfRUZGRUNUXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5IH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuLi9kb20vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCwgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLCBkZXZfc3RhY2sgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IEJhdGNoLCBjdXJyZW50X2JhdGNoLCBzY2hlZHVsZV9lZmZlY3QgfSBmcm9tICcuL2JhdGNoLmpzJztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuL2FzeW5jLmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4uL2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaGFyZWQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7JyRlZmZlY3QnIHwgJyRlZmZlY3QucHJlJyB8ICckaW5zcGVjdCd9IHJ1bmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VmZmVjdChydW5lKSB7XG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0aWYgKGFjdGl2ZV9yZWFjdGlvbiA9PT0gbnVsbCkge1xuXHRcdFx0ZS5lZmZlY3Rfb3JwaGFuKHJ1bmUpO1xuXHRcdH1cblxuXHRcdGUuZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCgpO1xuXHR9XG5cblx0aWYgKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0KSB7XG5cdFx0ZS5lZmZlY3RfaW5fdGVhcmRvd24ocnVuZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge0VmZmVjdH0gcGFyZW50X2VmZmVjdFxuICovXG5mdW5jdGlvbiBwdXNoX2VmZmVjdChlZmZlY3QsIHBhcmVudF9lZmZlY3QpIHtcblx0dmFyIHBhcmVudF9sYXN0ID0gcGFyZW50X2VmZmVjdC5sYXN0O1xuXHRpZiAocGFyZW50X2xhc3QgPT09IG51bGwpIHtcblx0XHRwYXJlbnRfZWZmZWN0Lmxhc3QgPSBwYXJlbnRfZWZmZWN0LmZpcnN0ID0gZWZmZWN0O1xuXHR9IGVsc2Uge1xuXHRcdHBhcmVudF9sYXN0Lm5leHQgPSBlZmZlY3Q7XG5cdFx0ZWZmZWN0LnByZXYgPSBwYXJlbnRfbGFzdDtcblx0XHRwYXJlbnRfZWZmZWN0Lmxhc3QgPSBlZmZlY3Q7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHBhcmFtIHtudWxsIHwgKCgpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCkpfSBmblxuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfZWZmZWN0KHR5cGUsIGZuLCBzeW5jKSB7XG5cdHZhciBwYXJlbnQgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBFbnN1cmUgdGhlIHBhcmVudCBpcyBuZXZlciBhbiBpbnNwZWN0IGVmZmVjdFxuXHRcdHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgKHBhcmVudC5mICYgRUFHRVJfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0XHR9XG5cdH1cblxuXHRpZiAocGFyZW50ICE9PSBudWxsICYmIChwYXJlbnQuZiAmIElORVJUKSAhPT0gMCkge1xuXHRcdHR5cGUgfD0gSU5FUlQ7XG5cdH1cblxuXHQvKiogQHR5cGUge0VmZmVjdH0gKi9cblx0dmFyIGVmZmVjdCA9IHtcblx0XHRjdHg6IGNvbXBvbmVudF9jb250ZXh0LFxuXHRcdGRlcHM6IG51bGwsXG5cdFx0bm9kZXNfc3RhcnQ6IG51bGwsXG5cdFx0bm9kZXNfZW5kOiBudWxsLFxuXHRcdGY6IHR5cGUgfCBESVJUWSB8IENPTk5FQ1RFRCxcblx0XHRmaXJzdDogbnVsbCxcblx0XHRmbixcblx0XHRsYXN0OiBudWxsLFxuXHRcdG5leHQ6IG51bGwsXG5cdFx0cGFyZW50LFxuXHRcdGI6IHBhcmVudCAmJiBwYXJlbnQuYixcblx0XHRwcmV2OiBudWxsLFxuXHRcdHRlYXJkb3duOiBudWxsLFxuXHRcdHRyYW5zaXRpb25zOiBudWxsLFxuXHRcdHd2OiAwLFxuXHRcdGFjOiBudWxsXG5cdH07XG5cblx0aWYgKERFVikge1xuXHRcdGVmZmVjdC5jb21wb25lbnRfZnVuY3Rpb24gPSBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb247XG5cdH1cblxuXHRpZiAoc3luYykge1xuXHRcdHRyeSB7XG5cdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRlZmZlY3QuZiB8PSBFRkZFQ1RfUkFOO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChmbiAhPT0gbnVsbCkge1xuXHRcdHNjaGVkdWxlX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZSA9IGVmZmVjdDtcblxuXHQvLyBpZiBhbiBlZmZlY3QgaGFzIGFscmVhZHkgcmFuIGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUga2VwdCBpbiB0aGUgdHJlZVxuXHQvLyAoYmVjYXVzZSBpdCB3b24ndCByZS1ydW4sIGhhcyBubyBET00sIGFuZCBoYXMgbm8gdGVhcmRvd24gZXRjKVxuXHQvLyB0aGVuIHdlIHNraXAgaXQgYW5kIGdvIHRvIGl0cyBjaGlsZCAoaWYgYW55KVxuXHRpZiAoXG5cdFx0c3luYyAmJlxuXHRcdGUuZGVwcyA9PT0gbnVsbCAmJlxuXHRcdGUudGVhcmRvd24gPT09IG51bGwgJiZcblx0XHRlLm5vZGVzX3N0YXJ0ID09PSBudWxsICYmXG5cdFx0ZS5maXJzdCA9PT0gZS5sYXN0ICYmIC8vIGVpdGhlciBgbnVsbGAsIG9yIGEgc2luZ3VsYXIgY2hpbGRcblx0XHQoZS5mICYgRUZGRUNUX1BSRVNFUlZFRCkgPT09IDBcblx0KSB7XG5cdFx0ZSA9IGUuZmlyc3Q7XG5cdFx0aWYgKCh0eXBlICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCAmJiAodHlwZSAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDAgJiYgZSAhPT0gbnVsbCkge1xuXHRcdFx0ZS5mIHw9IEVGRkVDVF9UUkFOU1BBUkVOVDtcblx0XHR9XG5cdH1cblxuXHRpZiAoZSAhPT0gbnVsbCkge1xuXHRcdGUucGFyZW50ID0gcGFyZW50O1xuXG5cdFx0aWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0cHVzaF9lZmZlY3QoZSwgcGFyZW50KTtcblx0XHR9XG5cblx0XHQvLyBpZiB3ZSdyZSBpbiBhIGRlcml2ZWQsIGFkZCB0aGUgZWZmZWN0IHRoZXJlIHRvb1xuXHRcdGlmIChcblx0XHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdFx0KGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDAgJiZcblx0XHRcdCh0eXBlICYgUk9PVF9FRkZFQ1QpID09PSAwXG5cdFx0KSB7XG5cdFx0XHR2YXIgZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGFjdGl2ZV9yZWFjdGlvbik7XG5cdFx0XHQoZGVyaXZlZC5lZmZlY3RzID8/PSBbXSkucHVzaChlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnRyYWNraW5nKClgXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF90cmFja2luZygpIHtcblx0cmV0dXJuIGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAhdW50cmFja2luZztcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZWFyZG93bihmbikge1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QsIG51bGwsIGZhbHNlKTtcblx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBDTEVBTik7XG5cdGVmZmVjdC50ZWFyZG93biA9IGZuO1xuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0KC4uLilgXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VyX2VmZmVjdChmbikge1xuXHR2YWxpZGF0ZV9lZmZlY3QoJyRlZmZlY3QnKTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGZuLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnJGVmZmVjdCdcblx0XHR9KTtcblx0fVxuXG5cdC8vIE5vbi1uZXN0ZWQgYCRlZmZlY3QoLi4uKWAgaW4gYSBjb21wb25lbnQgc2hvdWxkIGJlIGRlZmVycmVkXG5cdC8vIHVudGlsIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZFxuXHR2YXIgZmxhZ3MgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmY7XG5cdHZhciBkZWZlciA9ICFhY3RpdmVfcmVhY3Rpb24gJiYgKGZsYWdzICYgQlJBTkNIX0VGRkVDVCkgIT09IDAgJiYgKGZsYWdzICYgRUZGRUNUX1JBTikgPT09IDA7XG5cblx0aWYgKGRlZmVyKSB7XG5cdFx0Ly8gVG9wLWxldmVsIGAkZWZmZWN0KC4uLilgIGluIGFuIHVubW91bnRlZCBjb21wb25lbnQgXHUyMDE0IGRlZmVyIHVudGlsIG1vdW50XG5cdFx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHR9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cdFx0KGNvbnRleHQuZSA/Pz0gW10pLnB1c2goZm4pO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEV2ZXJ5dGhpbmcgZWxzZSBcdTIwMTQgY3JlYXRlIGltbWVkaWF0ZWx5XG5cdFx0cmV0dXJuIGNyZWF0ZV91c2VyX2VmZmVjdChmbik7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfdXNlcl9lZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoRUZGRUNUIHwgVVNFUl9FRkZFQ1QsIGZuLCBmYWxzZSk7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3QucHJlKC4uLilgXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlcl9wcmVfZWZmZWN0KGZuKSB7XG5cdHZhbGlkYXRlX2VmZmVjdCgnJGVmZmVjdC5wcmUnKTtcblx0aWYgKERFVikge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG5cdFx0XHR2YWx1ZTogJyRlZmZlY3QucHJlJ1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QgfCBVU0VSX0VGRkVDVCwgZm4sIHRydWUpO1xufVxuXG4vKiogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhZ2VyX2VmZmVjdChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChFQUdFUl9FRkZFQ1QsIGZuLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdC5yb290KC4uLilgXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF9yb290KGZuKSB7XG5cdEJhdGNoLmVuc3VyZSgpO1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJPT1RfRUZGRUNUIHwgRUZGRUNUX1BSRVNFUlZFRCwgZm4sIHRydWUpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0fTtcbn1cblxuLyoqXG4gKiBBbiBlZmZlY3Qgcm9vdCB3aG9zZSBjaGlsZHJlbiBjYW4gdHJhbnNpdGlvbiBvdXRcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsob3B0aW9ucz86IHsgb3V0cm8/OiBib29sZWFuIH0pID0+IFByb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfcm9vdChmbikge1xuXHRCYXRjaC5lbnN1cmUoKTtcblx0Y29uc3QgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChST09UX0VGRkVDVCB8IEVGRkVDVF9QUkVTRVJWRUQsIGZuLCB0cnVlKTtcblxuXHRyZXR1cm4gKG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsKSA9PiB7XG5cdFx0XHRpZiAob3B0aW9ucy5vdXRybykge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZWZmZWN0LCAoKSA9PiB7XG5cdFx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0XHRmdWxmaWwodW5kZWZpbmVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHRmdWxmaWwodW5kZWZpbmVkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEVGRkVDVCwgZm4sIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJDogLi5gXG4gKiBAcGFyYW0geygpID0+IGFueX0gZGVwc1xuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3ByZV9lZmZlY3QoZGVwcywgZm4pIHtcblx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cblx0LyoqIEB0eXBlIHt7IGVmZmVjdDogbnVsbCB8IEVmZmVjdCwgcmFuOiBib29sZWFuLCBkZXBzOiAoKSA9PiBhbnkgfX0gKi9cblx0dmFyIHRva2VuID0geyBlZmZlY3Q6IG51bGwsIHJhbjogZmFsc2UsIGRlcHMgfTtcblxuXHRjb250ZXh0LmwuJC5wdXNoKHRva2VuKTtcblxuXHR0b2tlbi5lZmZlY3QgPSByZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRkZXBzKCk7XG5cblx0XHQvLyBJZiB0aGlzIGxlZ2FjeSBwcmUgZWZmZWN0IGhhcyBhbHJlYWR5IHJ1biBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgcmVzZXQsIHRoZW5cblx0XHQvLyBiYWlsIG91dCB0byBlbXVsYXRlIHRoZSBzYW1lIGJlaGF2aW9yLlxuXHRcdGlmICh0b2tlbi5yYW4pIHJldHVybjtcblxuXHRcdHRva2VuLnJhbiA9IHRydWU7XG5cdFx0dW50cmFjayhmbik7XG5cdH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3ByZV9lZmZlY3RfcmVzZXQoKSB7XG5cdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdC8vIFJ1biBkaXJ0eSBgJDpgIHN0YXRlbWVudHNcblx0XHRmb3IgKHZhciB0b2tlbiBvZiBjb250ZXh0LmwuJCkge1xuXHRcdFx0dG9rZW4uZGVwcygpO1xuXG5cdFx0XHR2YXIgZWZmZWN0ID0gdG9rZW4uZWZmZWN0O1xuXG5cdFx0XHQvLyBJZiB0aGUgZWZmZWN0IGlzIENMRUFOLCB0aGVuIG1ha2UgaXQgTUFZQkVfRElSVFkuIFRoaXMgZW5zdXJlcyB3ZSB0cmF2ZXJzZSB0aHJvdWdoXG5cdFx0XHQvLyB0aGUgZWZmZWN0cyBkZXBlbmRlbmNpZXMgYW5kIGNvcnJlY3RseSBlbnN1cmUgZWFjaCBkZXBlbmRlbmN5IGlzIHVwLXRvLWRhdGUuXG5cdFx0XHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pICE9PSAwKSB7XG5cdFx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgTUFZQkVfRElSVFkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNfZGlydHkoZWZmZWN0KSkge1xuXHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdHRva2VuLnJhbiA9IGZhbHNlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jX2VmZmVjdChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChBU1lOQyB8IEVGRkVDVF9QUkVTRVJWRUQsIGZuLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyX2VmZmVjdChmbiwgZmxhZ3MgPSAwKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QgfCBmbGFncywgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KC4uLmV4cHJlc3Npb25zOiBhbnkpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IGFueT59IHN5bmNcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gUHJvbWlzZTxhbnk+Pn0gYXN5bmNcbiAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZTx2b2lkPj59IGJsb2NrZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZV9lZmZlY3QoZm4sIHN5bmMgPSBbXSwgYXN5bmMgPSBbXSwgYmxvY2tlcnMgPSBbXSkge1xuXHRmbGF0dGVuKGJsb2NrZXJzLCBzeW5jLCBhc3luYywgKHZhbHVlcykgPT4ge1xuXHRcdGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCwgKCkgPT4gZm4oLi4udmFsdWVzLm1hcChnZXQpKSwgdHJ1ZSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIExpa2UgYHRlbXBsYXRlX2VmZmVjdGAsIGJ1dCB3aXRoIGFuIGVmZmVjdCB3aGljaCBpcyBkZWZlcnJlZCB1bnRpbCB0aGUgYmF0Y2ggY29tbWl0c1xuICogQHBhcmFtIHsoLi4uZXhwcmVzc2lvbnM6IGFueSkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gYW55Pn0gc3luY1xuICogQHBhcmFtIHtBcnJheTwoKSA9PiBQcm9taXNlPGFueT4+fSBhc3luY1xuICogQHBhcmFtIHtBcnJheTxQcm9taXNlPHZvaWQ+Pn0gYmxvY2tlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmVycmVkX3RlbXBsYXRlX2VmZmVjdChmbiwgc3luYyA9IFtdLCBhc3luYyA9IFtdLCBibG9ja2VycyA9IFtdKSB7XG5cdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblx0dmFyIGlzX2FzeW5jID0gYXN5bmMubGVuZ3RoID4gMCB8fCBibG9ja2Vycy5sZW5ndGggPiAwO1xuXG5cdGlmIChpc19hc3luYykgYmF0Y2guaW5jcmVtZW50KHRydWUpO1xuXG5cdGZsYXR0ZW4oYmxvY2tlcnMsIHN5bmMsIGFzeW5jLCAodmFsdWVzKSA9PiB7XG5cdFx0Y3JlYXRlX2VmZmVjdChFRkZFQ1QsICgpID0+IGZuKC4uLnZhbHVlcy5tYXAoZ2V0KSksIGZhbHNlKTtcblx0XHRpZiAoaXNfYXN5bmMpIGJhdGNoLmRlY3JlbWVudCh0cnVlKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrKGZuLCBmbGFncyA9IDApIHtcblx0dmFyIGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoQkxPQ0tfRUZGRUNUIHwgZmxhZ3MsIGZuLCB0cnVlKTtcblx0aWYgKERFVikge1xuXHRcdGVmZmVjdC5kZXZfc3RhY2sgPSBkZXZfc3RhY2s7XG5cdH1cblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFuYWdlZChmbiwgZmxhZ3MgPSAwKSB7XG5cdHZhciBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KE1BTkFHRURfRUZGRUNUIHwgZmxhZ3MsIGZuLCB0cnVlKTtcblx0aWYgKERFVikge1xuXHRcdGVmZmVjdC5kZXZfc3RhY2sgPSBkZXZfc3RhY2s7XG5cdH1cblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChCUkFOQ0hfRUZGRUNUIHwgRUZGRUNUX1BSRVNFUlZFRCwgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCkge1xuXHR2YXIgdGVhcmRvd24gPSBlZmZlY3QudGVhcmRvd247XG5cdGlmICh0ZWFyZG93biAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IHByZXZpb3VzbHlfZGVzdHJveWluZ19lZmZlY3QgPSBpc19kZXN0cm95aW5nX2VmZmVjdDtcblx0XHRjb25zdCBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QodHJ1ZSk7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHR0cnkge1xuXHRcdFx0dGVhcmRvd24uY2FsbChudWxsKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0KHByZXZpb3VzbHlfZGVzdHJveWluZ19lZmZlY3QpO1xuXHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHBhcmFtIHtib29sZWFufSByZW1vdmVfZG9tXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKHNpZ25hbCwgcmVtb3ZlX2RvbSA9IGZhbHNlKSB7XG5cdHZhciBlZmZlY3QgPSBzaWduYWwuZmlyc3Q7XG5cdHNpZ25hbC5maXJzdCA9IHNpZ25hbC5sYXN0ID0gbnVsbDtcblxuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IGVmZmVjdC5hYztcblxuXHRcdGlmIChjb250cm9sbGVyICE9PSBudWxsKSB7XG5cdFx0XHR3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmFib3J0KFNUQUxFX1JFQUNUSU9OKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBuZXh0ID0gZWZmZWN0Lm5leHQ7XG5cblx0XHRpZiAoKGVmZmVjdC5mICYgUk9PVF9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHQvLyB0aGlzIGlzIG5vdyBhbiBpbmRlcGVuZGVudCByb290XG5cdFx0XHRlZmZlY3QucGFyZW50ID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0LCByZW1vdmVfZG9tKTtcblx0XHR9XG5cblx0XHRlZmZlY3QgPSBuZXh0O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbihzaWduYWwpIHtcblx0dmFyIGVmZmVjdCA9IHNpZ25hbC5maXJzdDtcblxuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblx0XHRpZiAoKGVmZmVjdC5mICYgQlJBTkNIX0VGRkVDVCkgPT09IDApIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0fVxuXHRcdGVmZmVjdCA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVfZG9tXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VmZmVjdChlZmZlY3QsIHJlbW92ZV9kb20gPSB0cnVlKSB7XG5cdHZhciByZW1vdmVkID0gZmFsc2U7XG5cblx0aWYgKFxuXHRcdChyZW1vdmVfZG9tIHx8IChlZmZlY3QuZiAmIEhFQURfRUZGRUNUKSAhPT0gMCkgJiZcblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgIT09IG51bGwgJiZcblx0XHRlZmZlY3Qubm9kZXNfZW5kICE9PSBudWxsXG5cdCkge1xuXHRcdHJlbW92ZV9lZmZlY3RfZG9tKGVmZmVjdC5ub2Rlc19zdGFydCwgLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChlZmZlY3Qubm9kZXNfZW5kKSk7XG5cdFx0cmVtb3ZlZCA9IHRydWU7XG5cdH1cblxuXHRkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihlZmZlY3QsIHJlbW92ZV9kb20gJiYgIXJlbW92ZWQpO1xuXHRyZW1vdmVfcmVhY3Rpb25zKGVmZmVjdCwgMCk7XG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgREVTVFJPWUVEKTtcblxuXHR2YXIgdHJhbnNpdGlvbnMgPSBlZmZlY3QudHJhbnNpdGlvbnM7XG5cblx0aWYgKHRyYW5zaXRpb25zICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIHRyYW5zaXRpb25zKSB7XG5cdFx0XHR0cmFuc2l0aW9uLnN0b3AoKTtcblx0XHR9XG5cdH1cblxuXHRleGVjdXRlX2VmZmVjdF90ZWFyZG93bihlZmZlY3QpO1xuXG5cdHZhciBwYXJlbnQgPSBlZmZlY3QucGFyZW50O1xuXG5cdC8vIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIGFueSBjaGlsZHJlbiwgdGhlbiBza2lwIHRoaXMgd29yayBhbHRvZ2V0aGVyXG5cdGlmIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LmZpcnN0ICE9PSBudWxsKSB7XG5cdFx0dW5saW5rX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdGVmZmVjdC5jb21wb25lbnRfZnVuY3Rpb24gPSBudWxsO1xuXHR9XG5cblx0Ly8gYGZpcnN0YCBhbmQgYGNoaWxkYCBhcmUgbnVsbGVkIG91dCBpbiBkZXN0cm95X2VmZmVjdF9jaGlsZHJlblxuXHQvLyB3ZSBkb24ndCBudWxsIG91dCBgcGFyZW50YCBzbyB0aGF0IGVycm9yIHByb3BhZ2F0aW9uIGNhbiB3b3JrIGNvcnJlY3RseVxuXHRlZmZlY3QubmV4dCA9XG5cdFx0ZWZmZWN0LnByZXYgPVxuXHRcdGVmZmVjdC50ZWFyZG93biA9XG5cdFx0ZWZmZWN0LmN0eCA9XG5cdFx0ZWZmZWN0LmRlcHMgPVxuXHRcdGVmZmVjdC5mbiA9XG5cdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID1cblx0XHRlZmZlY3Qubm9kZXNfZW5kID1cblx0XHRlZmZlY3QuYWMgPVxuXHRcdFx0bnVsbDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSBub2RlXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gZW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVfZWZmZWN0X2RvbShub2RlLCBlbmQpIHtcblx0d2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZSB8IG51bGx9ICovXG5cdFx0dmFyIG5leHQgPSBub2RlID09PSBlbmQgPyBudWxsIDogLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblxuXHRcdG5vZGUucmVtb3ZlKCk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBEZXRhY2ggYW4gZWZmZWN0IGZyb20gdGhlIGVmZmVjdCB0cmVlLCBmcmVlaW5nIHVwIG1lbW9yeSBhbmRcbiAqIHJlZHVjaW5nIHRoZSBhbW91bnQgb2Ygd29yayB0aGF0IGhhcHBlbnMgb24gc3Vic2VxdWVudCB0cmF2ZXJzYWxzXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpbmtfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgcGFyZW50ID0gZWZmZWN0LnBhcmVudDtcblx0dmFyIHByZXYgPSBlZmZlY3QucHJldjtcblx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblxuXHRpZiAocHJldiAhPT0gbnVsbCkgcHJldi5uZXh0ID0gbmV4dDtcblx0aWYgKG5leHQgIT09IG51bGwpIG5leHQucHJldiA9IHByZXY7XG5cblx0aWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGlmIChwYXJlbnQuZmlyc3QgPT09IGVmZmVjdCkgcGFyZW50LmZpcnN0ID0gbmV4dDtcblx0XHRpZiAocGFyZW50Lmxhc3QgPT09IGVmZmVjdCkgcGFyZW50Lmxhc3QgPSBwcmV2O1xuXHR9XG59XG5cbi8qKlxuICogV2hlbiBhIGJsb2NrIGVmZmVjdCBpcyByZW1vdmVkLCB3ZSBkb24ndCBpbW1lZGlhdGVseSBkZXN0cm95IGl0IG9yIHlhbmsgaXRcbiAqIG91dCBvZiB0aGUgRE9NLCBiZWNhdXNlIGl0IG1pZ2h0IGhhdmUgdHJhbnNpdGlvbnMuIEluc3RlYWQsIHdlICdwYXVzZScgaXQuXG4gKiBJdCBzdGF5cyBhcm91bmQgKGluIG1lbW9yeSwgYW5kIGluIHRoZSBET00pIHVudGlsIG91dHJvIHRyYW5zaXRpb25zIGhhdmVcbiAqIGNvbXBsZXRlZCwgYW5kIGlmIHRoZSBzdGF0ZSBjaGFuZ2UgaXMgcmV2ZXJzZWQgdGhlbiB3ZSBfcmVzdW1lXyBpdC5cbiAqIEEgcGF1c2VkIGVmZmVjdCBkb2VzIG5vdCB1cGRhdGUsIGFuZCB0aGUgRE9NIHN1YnRyZWUgYmVjb21lcyBpbmVydC5cbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXVxuICogQHBhcmFtIHtib29sZWFufSBbZGVzdHJveV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdXNlX2VmZmVjdChlZmZlY3QsIGNhbGxiYWNrLCBkZXN0cm95ID0gdHJ1ZSkge1xuXHQvKiogQHR5cGUge1RyYW5zaXRpb25NYW5hZ2VyW119ICovXG5cdHZhciB0cmFuc2l0aW9ucyA9IFtdO1xuXG5cdHBhdXNlX2NoaWxkcmVuKGVmZmVjdCwgdHJhbnNpdGlvbnMsIHRydWUpO1xuXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsICgpID0+IHtcblx0XHRpZiAoZGVzdHJveSkgZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gdHJhbnNpdGlvbnNcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsIGZuKSB7XG5cdHZhciByZW1haW5pbmcgPSB0cmFuc2l0aW9ucy5sZW5ndGg7XG5cdGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdFx0dmFyIGNoZWNrID0gKCkgPT4gLS1yZW1haW5pbmcgfHwgZm4oKTtcblx0XHRmb3IgKHZhciB0cmFuc2l0aW9uIG9mIHRyYW5zaXRpb25zKSB7XG5cdFx0XHR0cmFuc2l0aW9uLm91dChjaGVjayk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge1RyYW5zaXRpb25NYW5hZ2VyW119IHRyYW5zaXRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXVzZV9jaGlsZHJlbihlZmZlY3QsIHRyYW5zaXRpb25zLCBsb2NhbCkge1xuXHRpZiAoKGVmZmVjdC5mICYgSU5FUlQpICE9PSAwKSByZXR1cm47XG5cdGVmZmVjdC5mIF49IElORVJUO1xuXG5cdGlmIChlZmZlY3QudHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgZWZmZWN0LnRyYW5zaXRpb25zKSB7XG5cdFx0XHRpZiAodHJhbnNpdGlvbi5pc19nbG9iYWwgfHwgbG9jYWwpIHtcblx0XHRcdFx0dHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgY2hpbGQgPSBlZmZlY3QuZmlyc3Q7XG5cblx0d2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0dmFyIHNpYmxpbmcgPSBjaGlsZC5uZXh0O1xuXHRcdHZhciB0cmFuc3BhcmVudCA9XG5cdFx0XHQoY2hpbGQuZiAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDAgfHxcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBicmFuY2ggZWZmZWN0IHdpdGhvdXQgYSBibG9jayBlZmZlY3QgcGFyZW50LFxuXHRcdFx0Ly8gaXQgbWVhbnMgdGhlIHBhcmVudCBibG9jayBlZmZlY3Qgd2FzIHBydW5lZC4gSW4gdGhhdCBjYXNlLFxuXHRcdFx0Ly8gdHJhbnNwYXJlbmN5IGluZm9ybWF0aW9uIHdhcyB0cmFuc2ZlcnJlZCB0byB0aGUgYnJhbmNoIGVmZmVjdC5cblx0XHRcdCgoY2hpbGQuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwICYmIChlZmZlY3QuZiAmIEJMT0NLX0VGRkVDVCkgIT09IDApO1xuXHRcdC8vIFRPRE8gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHBhdXNlX2NoaWxkcmVuIHJlY3Vyc2l2ZWx5IHdpdGggYSBsaW5rZWQgbGlzdCBpbiBwbGFjZVxuXHRcdC8vIGl0J3Mgc2xpZ2h0bHkgbW9yZSBpbnZvbHZlZCB0aG91Z2ggYXMgd2UgaGF2ZSB0byBhY2NvdW50IGZvciBgdHJhbnNwYXJlbnRgIGNoYW5naW5nXG5cdFx0Ly8gdGhyb3VnaCB0aGUgdHJlZS5cblx0XHRwYXVzZV9jaGlsZHJlbihjaGlsZCwgdHJhbnNpdGlvbnMsIHRyYW5zcGFyZW50ID8gbG9jYWwgOiBmYWxzZSk7XG5cdFx0Y2hpbGQgPSBzaWJsaW5nO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBwYXVzZV9lZmZlY3RgLiBXZSBjYWxsIHRoaXMgaWYgKGZvciBleGFtcGxlKVxuICogYHhgIGJlY29tZXMgZmFsc3kgdGhlbiB0cnV0aHk6IGB7I2lmIHh9Li4uey9pZn1gXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN1bWVfZWZmZWN0KGVmZmVjdCkge1xuXHRyZXN1bWVfY2hpbGRyZW4oZWZmZWN0LCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZV9jaGlsZHJlbihlZmZlY3QsIGxvY2FsKSB7XG5cdGlmICgoZWZmZWN0LmYgJiBJTkVSVCkgPT09IDApIHJldHVybjtcblx0ZWZmZWN0LmYgXj0gSU5FUlQ7XG5cblx0Ly8gSWYgYSBkZXBlbmRlbmN5IG9mIHRoaXMgZWZmZWN0IGNoYW5nZWQgd2hpbGUgaXQgd2FzIHBhdXNlZCxcblx0Ly8gc2NoZWR1bGUgdGhlIGVmZmVjdCB0byB1cGRhdGUuIHdlIGRvbid0IHVzZSBgaXNfZGlydHlgXG5cdC8vIGhlcmUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGVhZ2VybHkgcmVjb21wdXRlIGEgZGVyaXZlZCBsaWtlXG5cdC8vIGB7I2lmIGZvb317Zm9vLmJhcigpfXsvaWZ9YCBpZiBgZm9vYCBpcyBub3cgYHVuZGVmaW5lZFxuXHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pID09PSAwKSB7XG5cdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBESVJUWSk7XG5cdFx0c2NoZWR1bGVfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHR2YXIgY2hpbGQgPSBlZmZlY3QuZmlyc3Q7XG5cblx0d2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0dmFyIHNpYmxpbmcgPSBjaGlsZC5uZXh0O1xuXHRcdHZhciB0cmFuc3BhcmVudCA9IChjaGlsZC5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCB8fCAoY2hpbGQuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwO1xuXHRcdC8vIFRPRE8gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHJlc3VtZV9jaGlsZHJlbiByZWN1cnNpdmVseSB3aXRoIGEgbGlua2VkIGxpc3QgaW4gcGxhY2Vcblx0XHQvLyBpdCdzIHNsaWdodGx5IG1vcmUgaW52b2x2ZWQgdGhvdWdoIGFzIHdlIGhhdmUgdG8gYWNjb3VudCBmb3IgYHRyYW5zcGFyZW50YCBjaGFuZ2luZ1xuXHRcdC8vIHRocm91Z2ggdGhlIHRyZWUuXG5cdFx0cmVzdW1lX2NoaWxkcmVuKGNoaWxkLCB0cmFuc3BhcmVudCA/IGxvY2FsIDogZmFsc2UpO1xuXHRcdGNoaWxkID0gc2libGluZztcblx0fVxuXG5cdGlmIChlZmZlY3QudHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgZWZmZWN0LnRyYW5zaXRpb25zKSB7XG5cdFx0XHRpZiAodHJhbnNpdGlvbi5pc19nbG9iYWwgfHwgbG9jYWwpIHtcblx0XHRcdFx0dHJhbnNpdGlvbi5pbigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRlZChlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpKSB7XG5cdHJldHVybiAoZWZmZWN0LmYgJiBERVNUUk9ZRUQpICE9PSAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVfZWZmZWN0KGVmZmVjdCwgZnJhZ21lbnQpIHtcblx0dmFyIG5vZGUgPSBlZmZlY3Qubm9kZXNfc3RhcnQ7XG5cdHZhciBlbmQgPSBlZmZlY3Qubm9kZXNfZW5kO1xuXG5cdHdoaWxlIChub2RlICE9PSBudWxsKSB7XG5cdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHRcdHZhciBuZXh0ID0gbm9kZSA9PT0gZW5kID8gbnVsbCA6IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cblx0XHRmcmFnbWVudC5hcHBlbmQobm9kZSk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGludGVybmFsX3NldCB9IGZyb20gJy4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtTZXQ8VmFsdWU+IHwgbnVsbH1cbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBsZXQgY2FwdHVyZWRfc2lnbmFscyA9IG51bGw7XG5cbi8qKlxuICogQ2FwdHVyZSBhbiBhcnJheSBvZiBhbGwgdGhlIHNpZ25hbHMgdGhhdCBhcmUgcmVhZCB3aGVuIGBmbmAgaXMgY2FsbGVkXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICovXG5mdW5jdGlvbiBjYXB0dXJlX3NpZ25hbHMoZm4pIHtcblx0dmFyIHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHMgPSBjYXB0dXJlZF9zaWduYWxzO1xuXG5cdHRyeSB7XG5cdFx0Y2FwdHVyZWRfc2lnbmFscyA9IG5ldyBTZXQoKTtcblxuXHRcdHVudHJhY2soZm4pO1xuXG5cdFx0aWYgKHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHMgIT09IG51bGwpIHtcblx0XHRcdGZvciAodmFyIHNpZ25hbCBvZiBjYXB0dXJlZF9zaWduYWxzKSB7XG5cdFx0XHRcdHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHMuYWRkKHNpZ25hbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhcHR1cmVkX3NpZ25hbHM7XG5cdH0gZmluYWxseSB7XG5cdFx0Y2FwdHVyZWRfc2lnbmFscyA9IHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHM7XG5cdH1cbn1cblxuLyoqXG4gKiBJbnZva2VzIGEgZnVuY3Rpb24gYW5kIGNhcHR1cmVzIGFsbCBzaWduYWxzIHRoYXQgYXJlIHJlYWQgZHVyaW5nIHRoZSBpbnZvY2F0aW9uLFxuICogdGhlbiBpbnZhbGlkYXRlcyB0aGVtLlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZV9pbm5lcl9zaWduYWxzKGZuKSB7XG5cdGZvciAodmFyIHNpZ25hbCBvZiBjYXB0dXJlX3NpZ25hbHMoZm4pKSB7XG5cdFx0aW50ZXJuYWxfc2V0KHNpZ25hbCwgc2lnbmFsLnYpO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFJlYWN0aW9uLCBTaWduYWwsIFNvdXJjZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvcnMsIGdldF9wcm90b3R5cGVfb2YsIGluZGV4X29mIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGRlc3Ryb3lfYmxvY2tfZWZmZWN0X2NoaWxkcmVuLFxuXHRkZXN0cm95X2VmZmVjdF9jaGlsZHJlbixcblx0ZWZmZWN0X3RyYWNraW5nLFxuXHRleGVjdXRlX2VmZmVjdF90ZWFyZG93blxufSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQge1xuXHRESVJUWSxcblx0TUFZQkVfRElSVFksXG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRERVNUUk9ZRUQsXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdFNUQVRFX1NZTUJPTCxcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0Q09OTkVDVEVELFxuXHRSRUFDVElPTl9JU19VUERBVElORyxcblx0U1RBTEVfUkVBQ1RJT04sXG5cdEVSUk9SX1ZBTFVFLFxuXHRXQVNfTUFSS0VELFxuXHRNQU5BR0VEX0VGRkVDVFxufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBvbGRfdmFsdWVzIH0gZnJvbSAnLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHtcblx0ZGVzdHJveV9kZXJpdmVkX2VmZmVjdHMsXG5cdGV4ZWN1dGVfZGVyaXZlZCxcblx0Y3VycmVudF9hc3luY19lZmZlY3QsXG5cdHJlY2VudF9hc3luY19kZXJpdmVkcyxcblx0dXBkYXRlX2Rlcml2ZWRcbn0gZnJvbSAnLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZywgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyB0cmFjaW5nX2V4cHJlc3Npb25zIH0gZnJvbSAnLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyBnZXRfZXJyb3IgfSBmcm9tICcuLi9zaGFyZWQvZGV2LmpzJztcbmltcG9ydCB7XG5cdGNvbXBvbmVudF9jb250ZXh0LFxuXHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24sXG5cdGRldl9zdGFjayxcblx0aXNfcnVuZXMsXG5cdHNldF9jb21wb25lbnRfY29udGV4dCxcblx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbixcblx0c2V0X2Rldl9zdGFja1xufSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7XG5cdEJhdGNoLFxuXHRiYXRjaF92YWx1ZXMsXG5cdGN1cnJlbnRfYmF0Y2gsXG5cdGZsdXNoU3luYyxcblx0c2NoZWR1bGVfZWZmZWN0XG59IGZyb20gJy4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5pbXBvcnQgeyBoYW5kbGVfZXJyb3IgfSBmcm9tICcuL2Vycm9yLWhhbmRsaW5nLmpzJztcbmltcG9ydCB7IFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgY2FwdHVyZWRfc2lnbmFscyB9IGZyb20gJy4vbGVnYWN5LmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NoYXJlZC5qcyc7XG5cbmV4cG9ydCBsZXQgaXNfdXBkYXRpbmdfZWZmZWN0ID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lzX3VwZGF0aW5nX2VmZmVjdCh2YWx1ZSkge1xuXHRpc191cGRhdGluZ19lZmZlY3QgPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGxldCBpc19kZXN0cm95aW5nX2VmZmVjdCA9IGZhbHNlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pc19kZXN0cm95aW5nX2VmZmVjdCh2YWx1ZSkge1xuXHRpc19kZXN0cm95aW5nX2VmZmVjdCA9IHZhbHVlO1xufVxuXG4vKiogQHR5cGUge251bGwgfCBSZWFjdGlvbn0gKi9cbmV4cG9ydCBsZXQgYWN0aXZlX3JlYWN0aW9uID0gbnVsbDtcblxuZXhwb3J0IGxldCB1bnRyYWNraW5nID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge251bGwgfCBSZWFjdGlvbn0gcmVhY3Rpb24gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYWN0aXZlX3JlYWN0aW9uKHJlYWN0aW9uKSB7XG5cdGFjdGl2ZV9yZWFjdGlvbiA9IHJlYWN0aW9uO1xufVxuXG4vKiogQHR5cGUge251bGwgfCBFZmZlY3R9ICovXG5leHBvcnQgbGV0IGFjdGl2ZV9lZmZlY3QgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtudWxsIHwgRWZmZWN0fSBlZmZlY3QgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYWN0aXZlX2VmZmVjdChlZmZlY3QpIHtcblx0YWN0aXZlX2VmZmVjdCA9IGVmZmVjdDtcbn1cblxuLyoqXG4gKiBXaGVuIHNvdXJjZXMgYXJlIGNyZWF0ZWQgd2l0aGluIGEgcmVhY3Rpb24sIHJlYWRpbmcgYW5kIHdyaXRpbmdcbiAqIHRoZW0gd2l0aGluIHRoYXQgcmVhY3Rpb24gc2hvdWxkIG5vdCBjYXVzZSBhIHJlLXJ1blxuICogQHR5cGUge251bGwgfCBTb3VyY2VbXX1cbiAqL1xuZXhwb3J0IGxldCBjdXJyZW50X3NvdXJjZXMgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtWYWx1ZX0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoX3JlYWN0aW9uX3ZhbHVlKHZhbHVlKSB7XG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKCFhc3luY19tb2RlX2ZsYWcgfHwgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDApKSB7XG5cdFx0aWYgKGN1cnJlbnRfc291cmNlcyA9PT0gbnVsbCkge1xuXHRcdFx0Y3VycmVudF9zb3VyY2VzID0gW3ZhbHVlXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VycmVudF9zb3VyY2VzLnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFRoZSBkZXBlbmRlbmNpZXMgb2YgdGhlIHJlYWN0aW9uIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkLiBJbiBtYW55IGNhc2VzLFxuICogdGhlIGRlcGVuZGVuY2llcyBhcmUgdW5jaGFuZ2VkIGJldHdlZW4gcnVucywgYW5kIHNvIHRoaXMgd2lsbCBiZSBgbnVsbGAgdW5sZXNzXG4gKiBhbmQgdW50aWwgYSBuZXcgZGVwZW5kZW5jeSBpcyBhY2Nlc3NlZCBcdTIwMTQgd2UgdHJhY2sgdGhpcyB2aWEgYHNraXBwZWRfZGVwc2BcbiAqIEB0eXBlIHtudWxsIHwgVmFsdWVbXX1cbiAqL1xubGV0IG5ld19kZXBzID0gbnVsbDtcblxubGV0IHNraXBwZWRfZGVwcyA9IDA7XG5cbi8qKlxuICogVHJhY2tzIHdyaXRlcyB0aGF0IHRoZSBlZmZlY3QgaXQncyBleGVjdXRlZCBpbiBkb2Vzbid0IGxpc3RlbiB0byB5ZXQsXG4gKiBzbyB0aGF0IHRoZSBkZXBlbmRlbmN5IGNhbiBiZSBhZGRlZCB0byB0aGUgZWZmZWN0IGxhdGVyIG9uIGlmIGl0IHRoZW4gcmVhZHMgaXRcbiAqIEB0eXBlIHtudWxsIHwgU291cmNlW119XG4gKi9cbmV4cG9ydCBsZXQgdW50cmFja2VkX3dyaXRlcyA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge251bGwgfCBTb3VyY2VbXX0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfdW50cmFja2VkX3dyaXRlcyh2YWx1ZSkge1xuXHR1bnRyYWNrZWRfd3JpdGVzID0gdmFsdWU7XG59XG5cbi8qKlxuICogQHR5cGUge251bWJlcn0gVXNlZCBieSBzb3VyY2VzIGFuZCBkZXJpdmVkcyBmb3IgaGFuZGxpbmcgdXBkYXRlcy5cbiAqIFZlcnNpb24gc3RhcnRzIGZyb20gMSBzbyB0aGF0IHVub3duZWQgZGVyaXZlZHMgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGEgY3JlYXRlZCBlZmZlY3QgYW5kIGEgcnVuIG9uZSBmb3IgdHJhY2luZ1xuICoqL1xuZXhwb3J0IGxldCB3cml0ZV92ZXJzaW9uID0gMTtcblxuLyoqIEB0eXBlIHtudW1iZXJ9IFVzZWQgdG8gdmVyc2lvbiBlYWNoIHJlYWQgb2YgYSBzb3VyY2Ugb2YgZGVyaXZlZCB0byBhdm9pZCBkdXBsaWNhdGluZyBkZXBlZGVuY2llcyBpbnNpZGUgYSByZWFjdGlvbiAqL1xubGV0IHJlYWRfdmVyc2lvbiA9IDA7XG5cbmV4cG9ydCBsZXQgdXBkYXRlX3ZlcnNpb24gPSByZWFkX3ZlcnNpb247XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfdXBkYXRlX3ZlcnNpb24odmFsdWUpIHtcblx0dXBkYXRlX3ZlcnNpb24gPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudF93cml0ZV92ZXJzaW9uKCkge1xuXHRyZXR1cm4gKyt3cml0ZV92ZXJzaW9uO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGRlcml2ZWQgb3IgZWZmZWN0IGlzIGRpcnR5LlxuICogSWYgaXQgaXMgTUFZQkVfRElSVFksIHdpbGwgc2V0IHRoZSBzdGF0dXMgdG8gQ0xFQU5cbiAqIEBwYXJhbSB7UmVhY3Rpb259IHJlYWN0aW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2RpcnR5KHJlYWN0aW9uKSB7XG5cdHZhciBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0aWYgKChmbGFncyAmIERJUlRZKSAhPT0gMCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGZsYWdzICYgREVSSVZFRCkge1xuXHRcdHJlYWN0aW9uLmYgJj0gfldBU19NQVJLRUQ7XG5cdH1cblxuXHRpZiAoKGZsYWdzICYgTUFZQkVfRElSVFkpICE9PSAwKSB7XG5cdFx0dmFyIGRlcGVuZGVuY2llcyA9IHJlYWN0aW9uLmRlcHM7XG5cblx0XHRpZiAoZGVwZW5kZW5jaWVzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcblxuXHRcdFx0XHRpZiAoaXNfZGlydHkoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwZW5kZW5jeSkpKSB7XG5cdFx0XHRcdFx0dXBkYXRlX2Rlcml2ZWQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwZW5kZW5jeSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRlcGVuZGVuY3kud3YgPiByZWFjdGlvbi53dikge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0KGZsYWdzICYgQ09OTkVDVEVEKSAhPT0gMCAmJlxuXHRcdFx0Ly8gRHVyaW5nIHRpbWUgdHJhdmVsaW5nIHdlIGRvbid0IHdhbnQgdG8gcmVzZXQgdGhlIHN0YXR1cyBzbyB0aGF0XG5cdFx0XHQvLyB0cmF2ZXJzYWwgb2YgdGhlIGdyYXBoIGluIHRoZSBvdGhlciBiYXRjaGVzIHN0aWxsIGhhcHBlbnNcblx0XHRcdGJhdGNoX3ZhbHVlcyA9PT0gbnVsbFxuXHRcdCkge1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIENMRUFOKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWYWx1ZX0gc2lnbmFsXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyb290XVxuICovXG5mdW5jdGlvbiBzY2hlZHVsZV9wb3NzaWJsZV9lZmZlY3Rfc2VsZl9pbnZhbGlkYXRpb24oc2lnbmFsLCBlZmZlY3QsIHJvb3QgPSB0cnVlKSB7XG5cdHZhciByZWFjdGlvbnMgPSBzaWduYWwucmVhY3Rpb25zO1xuXHRpZiAocmVhY3Rpb25zID09PSBudWxsKSByZXR1cm47XG5cblx0aWYgKCFhc3luY19tb2RlX2ZsYWcgJiYgY3VycmVudF9zb3VyY2VzPy5pbmNsdWRlcyhzaWduYWwpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZWFjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgcmVhY3Rpb24gPSByZWFjdGlvbnNbaV07XG5cblx0XHRpZiAoKHJlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0c2NoZWR1bGVfcG9zc2libGVfZWZmZWN0X3NlbGZfaW52YWxpZGF0aW9uKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgZWZmZWN0LCBmYWxzZSk7XG5cdFx0fSBlbHNlIGlmIChlZmZlY3QgPT09IHJlYWN0aW9uKSB7XG5cdFx0XHRpZiAocm9vdCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgRElSVFkpO1xuXHRcdFx0fSBlbHNlIGlmICgocmVhY3Rpb24uZiAmIENMRUFOKSAhPT0gMCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgTUFZQkVfRElSVFkpO1xuXHRcdFx0fVxuXHRcdFx0c2NoZWR1bGVfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqIEBwYXJhbSB7UmVhY3Rpb259IHJlYWN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3JlYWN0aW9uKHJlYWN0aW9uKSB7XG5cdHZhciBwcmV2aW91c19kZXBzID0gbmV3X2RlcHM7XG5cdHZhciBwcmV2aW91c19za2lwcGVkX2RlcHMgPSBza2lwcGVkX2RlcHM7XG5cdHZhciBwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzID0gdW50cmFja2VkX3dyaXRlcztcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfc291cmNlcyA9IGN1cnJlbnRfc291cmNlcztcblx0dmFyIHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdHZhciBwcmV2aW91c191bnRyYWNraW5nID0gdW50cmFja2luZztcblx0dmFyIHByZXZpb3VzX3VwZGF0ZV92ZXJzaW9uID0gdXBkYXRlX3ZlcnNpb247XG5cblx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRuZXdfZGVwcyA9IC8qKiBAdHlwZSB7bnVsbCB8IFZhbHVlW119ICovIChudWxsKTtcblx0c2tpcHBlZF9kZXBzID0gMDtcblx0dW50cmFja2VkX3dyaXRlcyA9IG51bGw7XG5cdGFjdGl2ZV9yZWFjdGlvbiA9IChmbGFncyAmIChCUkFOQ0hfRUZGRUNUIHwgUk9PVF9FRkZFQ1QpKSA9PT0gMCA/IHJlYWN0aW9uIDogbnVsbDtcblxuXHRjdXJyZW50X3NvdXJjZXMgPSBudWxsO1xuXHRzZXRfY29tcG9uZW50X2NvbnRleHQocmVhY3Rpb24uY3R4KTtcblx0dW50cmFja2luZyA9IGZhbHNlO1xuXHR1cGRhdGVfdmVyc2lvbiA9ICsrcmVhZF92ZXJzaW9uO1xuXG5cdGlmIChyZWFjdGlvbi5hYyAhPT0gbnVsbCkge1xuXHRcdHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0XHQvKiogQHR5cGUge0Fib3J0Q29udHJvbGxlcn0gKi8gKHJlYWN0aW9uLmFjKS5hYm9ydChTVEFMRV9SRUFDVElPTik7XG5cdFx0fSk7XG5cblx0XHRyZWFjdGlvbi5hYyA9IG51bGw7XG5cdH1cblxuXHR0cnkge1xuXHRcdHJlYWN0aW9uLmYgfD0gUkVBQ1RJT05fSVNfVVBEQVRJTkc7XG5cdFx0dmFyIGZuID0gLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gKHJlYWN0aW9uLmZuKTtcblx0XHR2YXIgcmVzdWx0ID0gZm4oKTtcblx0XHR2YXIgZGVwcyA9IHJlYWN0aW9uLmRlcHM7XG5cblx0XHRpZiAobmV3X2RlcHMgIT09IG51bGwpIHtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRyZW1vdmVfcmVhY3Rpb25zKHJlYWN0aW9uLCBza2lwcGVkX2RlcHMpO1xuXG5cdFx0XHRpZiAoZGVwcyAhPT0gbnVsbCAmJiBza2lwcGVkX2RlcHMgPiAwKSB7XG5cdFx0XHRcdGRlcHMubGVuZ3RoID0gc2tpcHBlZF9kZXBzICsgbmV3X2RlcHMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbmV3X2RlcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRkZXBzW3NraXBwZWRfZGVwcyArIGldID0gbmV3X2RlcHNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlYWN0aW9uLmRlcHMgPSBkZXBzID0gbmV3X2RlcHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc191cGRhdGluZ19lZmZlY3QgJiYgZWZmZWN0X3RyYWNraW5nKCkgJiYgKHJlYWN0aW9uLmYgJiBDT05ORUNURUQpICE9PSAwKSB7XG5cdFx0XHRcdGZvciAoaSA9IHNraXBwZWRfZGVwczsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHQoZGVwc1tpXS5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKHJlYWN0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZGVwcyAhPT0gbnVsbCAmJiBza2lwcGVkX2RlcHMgPCBkZXBzLmxlbmd0aCkge1xuXHRcdFx0cmVtb3ZlX3JlYWN0aW9ucyhyZWFjdGlvbiwgc2tpcHBlZF9kZXBzKTtcblx0XHRcdGRlcHMubGVuZ3RoID0gc2tpcHBlZF9kZXBzO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlJ3JlIGluc2lkZSBhbiBlZmZlY3QgYW5kIHdlIGhhdmUgdW50cmFja2VkIHdyaXRlcywgdGhlbiB3ZSBuZWVkIHRvXG5cdFx0Ly8gZW5zdXJlIHRoYXQgaWYgYW55IG9mIHRob3NlIHVudHJhY2tlZCB3cml0ZXMgcmVzdWx0IGluIHJlLWludmFsaWRhdGlvblxuXHRcdC8vIG9mIHRoZSBjdXJyZW50IGVmZmVjdCwgdGhlbiB0aGF0IGhhcHBlbnMgYWNjb3JkaW5nbHlcblx0XHRpZiAoXG5cdFx0XHRpc19ydW5lcygpICYmXG5cdFx0XHR1bnRyYWNrZWRfd3JpdGVzICE9PSBudWxsICYmXG5cdFx0XHQhdW50cmFja2luZyAmJlxuXHRcdFx0ZGVwcyAhPT0gbnVsbCAmJlxuXHRcdFx0KHJlYWN0aW9uLmYgJiAoREVSSVZFRCB8IE1BWUJFX0RJUlRZIHwgRElSVFkpKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IC8qKiBAdHlwZSB7U291cmNlW119ICovICh1bnRyYWNrZWRfd3JpdGVzKS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzY2hlZHVsZV9wb3NzaWJsZV9lZmZlY3Rfc2VsZl9pbnZhbGlkYXRpb24oXG5cdFx0XHRcdFx0dW50cmFja2VkX3dyaXRlc1tpXSxcblx0XHRcdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlIGFyZSByZXR1cm5pbmcgdG8gYW4gcHJldmlvdXMgcmVhY3Rpb24gdGhlblxuXHRcdC8vIHdlIG5lZWQgdG8gaW5jcmVtZW50IHRoZSByZWFkIHZlcnNpb24gdG8gZW5zdXJlIHRoYXRcblx0XHQvLyBhbnkgZGVwZW5kZW5jaWVzIGluIHRoaXMgcmVhY3Rpb24gYXJlbid0IG1hcmtlZCB3aXRoXG5cdFx0Ly8gdGhlIHNhbWUgdmVyc2lvblxuXHRcdGlmIChwcmV2aW91c19yZWFjdGlvbiAhPT0gbnVsbCAmJiBwcmV2aW91c19yZWFjdGlvbiAhPT0gcmVhY3Rpb24pIHtcblx0XHRcdHJlYWRfdmVyc2lvbisrO1xuXG5cdFx0XHRpZiAodW50cmFja2VkX3dyaXRlcyAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocHJldmlvdXNfdW50cmFja2VkX3dyaXRlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHByZXZpb3VzX3VudHJhY2tlZF93cml0ZXMgPSB1bnRyYWNrZWRfd3JpdGVzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByZXZpb3VzX3VudHJhY2tlZF93cml0ZXMucHVzaCguLi4vKiogQHR5cGUge1NvdXJjZVtdfSAqLyAodW50cmFja2VkX3dyaXRlcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKChyZWFjdGlvbi5mICYgRVJST1JfVkFMVUUpICE9PSAwKSB7XG5cdFx0XHRyZWFjdGlvbi5mIF49IEVSUk9SX1ZBTFVFO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIGhhbmRsZV9lcnJvcihlcnJvcik7XG5cdH0gZmluYWxseSB7XG5cdFx0cmVhY3Rpb24uZiBePSBSRUFDVElPTl9JU19VUERBVElORztcblx0XHRuZXdfZGVwcyA9IHByZXZpb3VzX2RlcHM7XG5cdFx0c2tpcHBlZF9kZXBzID0gcHJldmlvdXNfc2tpcHBlZF9kZXBzO1xuXHRcdHVudHJhY2tlZF93cml0ZXMgPSBwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzO1xuXHRcdGFjdGl2ZV9yZWFjdGlvbiA9IHByZXZpb3VzX3JlYWN0aW9uO1xuXHRcdGN1cnJlbnRfc291cmNlcyA9IHByZXZpb3VzX3NvdXJjZXM7XG5cdFx0c2V0X2NvbXBvbmVudF9jb250ZXh0KHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0KTtcblx0XHR1bnRyYWNraW5nID0gcHJldmlvdXNfdW50cmFja2luZztcblx0XHR1cGRhdGVfdmVyc2lvbiA9IHByZXZpb3VzX3VwZGF0ZV92ZXJzaW9uO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHNpZ25hbFxuICogQHBhcmFtIHtWYWx1ZTxWPn0gZGVwZW5kZW5jeVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZV9yZWFjdGlvbihzaWduYWwsIGRlcGVuZGVuY3kpIHtcblx0bGV0IHJlYWN0aW9ucyA9IGRlcGVuZGVuY3kucmVhY3Rpb25zO1xuXHRpZiAocmVhY3Rpb25zICE9PSBudWxsKSB7XG5cdFx0dmFyIGluZGV4ID0gaW5kZXhfb2YuY2FsbChyZWFjdGlvbnMsIHNpZ25hbCk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dmFyIG5ld19sZW5ndGggPSByZWFjdGlvbnMubGVuZ3RoIC0gMTtcblx0XHRcdGlmIChuZXdfbGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJlYWN0aW9ucyA9IGRlcGVuZGVuY3kucmVhY3Rpb25zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFN3YXAgd2l0aCBsYXN0IGVsZW1lbnQgYW5kIHRoZW4gcmVtb3ZlLlxuXHRcdFx0XHRyZWFjdGlvbnNbaW5kZXhdID0gcmVhY3Rpb25zW25ld19sZW5ndGhdO1xuXHRcdFx0XHRyZWFjdGlvbnMucG9wKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgdGhlIGRlcml2ZWQgaGFzIG5vIHJlYWN0aW9ucywgdGhlbiB3ZSBjYW4gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSBncmFwaCxcblx0Ly8gYWxsb3dpbmcgaXQgdG8gZWl0aGVyIHJlY29ubmVjdCBpbiB0aGUgZnV0dXJlLCBvciBiZSBHQydkIGJ5IHRoZSBWTS5cblx0aWYgKFxuXHRcdHJlYWN0aW9ucyA9PT0gbnVsbCAmJlxuXHRcdChkZXBlbmRlbmN5LmYgJiBERVJJVkVEKSAhPT0gMCAmJlxuXHRcdC8vIERlc3Ryb3lpbmcgYSBjaGlsZCBlZmZlY3Qgd2hpbGUgdXBkYXRpbmcgYSBwYXJlbnQgZWZmZWN0IGNhbiBjYXVzZSBhIGRlcGVuZGVuY3kgdG8gYXBwZWFyXG5cdFx0Ly8gdG8gYmUgdW51c2VkLCB3aGVuIGluIGZhY3QgaXQgaXMgdXNlZCBieSB0aGUgY3VycmVudGx5LXVwZGF0aW5nIHBhcmVudC4gQ2hlY2tpbmcgYG5ld19kZXBzYFxuXHRcdC8vIGFsbG93cyB1cyB0byBza2lwIHRoZSBleHBlbnNpdmUgd29yayBvZiBkaXNjb25uZWN0aW5nIGFuZCBpbW1lZGlhdGVseSByZWNvbm5lY3RpbmcgaXRcblx0XHQobmV3X2RlcHMgPT09IG51bGwgfHwgIW5ld19kZXBzLmluY2x1ZGVzKGRlcGVuZGVuY3kpKVxuXHQpIHtcblx0XHRzZXRfc2lnbmFsX3N0YXR1cyhkZXBlbmRlbmN5LCBNQVlCRV9ESVJUWSk7XG5cdFx0Ly8gSWYgd2UgYXJlIHdvcmtpbmcgd2l0aCBhIGRlcml2ZWQgdGhhdCBpcyBvd25lZCBieSBhbiBlZmZlY3QsIHRoZW4gbWFyayBpdCBhcyBiZWluZ1xuXHRcdC8vIGRpc2Nvbm5lY3RlZCBhbmQgcmVtb3ZlIHRoZSBtYXJrIGZsYWcsIGFzIGl0IGNhbm5vdCBiZSByZWxpYWJseSByZW1vdmVkIG90aGVyd2lzZVxuXHRcdGlmICgoZGVwZW5kZW5jeS5mICYgQ09OTkVDVEVEKSAhPT0gMCkge1xuXHRcdFx0ZGVwZW5kZW5jeS5mIF49IENPTk5FQ1RFRDtcblx0XHRcdGRlcGVuZGVuY3kuZiAmPSB+V0FTX01BUktFRDtcblx0XHR9XG5cdFx0Ly8gRGlzY29ubmVjdCBhbnkgcmVhY3Rpb25zIG93bmVkIGJ5IHRoaXMgcmVhY3Rpb25cblx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cygvKiogQHR5cGUge0Rlcml2ZWR9ICoqLyAoZGVwZW5kZW5jeSkpO1xuXHRcdHJlbW92ZV9yZWFjdGlvbnMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqKi8gKGRlcGVuZGVuY3kpLCAwKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X2luZGV4XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9yZWFjdGlvbnMoc2lnbmFsLCBzdGFydF9pbmRleCkge1xuXHR2YXIgZGVwZW5kZW5jaWVzID0gc2lnbmFsLmRlcHM7XG5cdGlmIChkZXBlbmRlbmNpZXMgPT09IG51bGwpIHJldHVybjtcblxuXHRmb3IgKHZhciBpID0gc3RhcnRfaW5kZXg7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRyZW1vdmVfcmVhY3Rpb24oc2lnbmFsLCBkZXBlbmRlbmNpZXNbaV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRpZiAoKGZsYWdzICYgREVTVFJPWUVEKSAhPT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgQ0xFQU4pO1xuXG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHR2YXIgd2FzX3VwZGF0aW5nX2VmZmVjdCA9IGlzX3VwZGF0aW5nX2VmZmVjdDtcblxuXHRhY3RpdmVfZWZmZWN0ID0gZWZmZWN0O1xuXHRpc191cGRhdGluZ19lZmZlY3QgPSB0cnVlO1xuXG5cdGlmIChERVYpIHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2ZuID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbik7XG5cdFx0dmFyIHByZXZpb3VzX3N0YWNrID0gLyoqIEB0eXBlIHthbnl9ICovIChkZXZfc3RhY2spO1xuXHRcdC8vIG9ubHkgYmxvY2sgZWZmZWN0cyBoYXZlIGEgZGV2IHN0YWNrLCBrZWVwIHRoZSBjdXJyZW50IG9uZSBvdGhlcndpc2Vcblx0XHRzZXRfZGV2X3N0YWNrKGVmZmVjdC5kZXZfc3RhY2sgPz8gZGV2X3N0YWNrKTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKChmbGFncyAmIChCTE9DS19FRkZFQ1QgfCBNQU5BR0VEX0VGRkVDVCkpICE9PSAwKSB7XG5cdFx0XHRkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbihlZmZlY3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihlZmZlY3QpO1xuXHRcdH1cblxuXHRcdGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCk7XG5cdFx0dmFyIHRlYXJkb3duID0gdXBkYXRlX3JlYWN0aW9uKGVmZmVjdCk7XG5cdFx0ZWZmZWN0LnRlYXJkb3duID0gdHlwZW9mIHRlYXJkb3duID09PSAnZnVuY3Rpb24nID8gdGVhcmRvd24gOiBudWxsO1xuXHRcdGVmZmVjdC53diA9IHdyaXRlX3ZlcnNpb247XG5cblx0XHQvLyBJbiBERVYsIGluY3JlbWVudCB2ZXJzaW9ucyBvZiBhbnkgc291cmNlcyB0aGF0IHdlcmUgd3JpdHRlbiB0byBkdXJpbmcgdGhlIGVmZmVjdCxcblx0XHQvLyBzbyB0aGF0IHRoZXkgYXJlIGNvcnJlY3RseSBtYXJrZWQgYXMgZGlydHkgd2hlbiB0aGUgZWZmZWN0IHJlLXJ1bnNcblx0XHRpZiAoREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnICYmIChlZmZlY3QuZiAmIERJUlRZKSAhPT0gMCAmJiBlZmZlY3QuZGVwcyAhPT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgZGVwIG9mIGVmZmVjdC5kZXBzKSB7XG5cdFx0XHRcdGlmIChkZXAuc2V0X2R1cmluZ19lZmZlY3QpIHtcblx0XHRcdFx0XHRkZXAud3YgPSBpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbigpO1xuXHRcdFx0XHRcdGRlcC5zZXRfZHVyaW5nX2VmZmVjdCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGlzX3VwZGF0aW5nX2VmZmVjdCA9IHdhc191cGRhdGluZ19lZmZlY3Q7XG5cdFx0YWN0aXZlX2VmZmVjdCA9IHByZXZpb3VzX2VmZmVjdDtcblxuXHRcdGlmIChERVYpIHtcblx0XHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24ocHJldmlvdXNfY29tcG9uZW50X2ZuKTtcblx0XHRcdHNldF9kZXZfc3RhY2socHJldmlvdXNfc3RhY2spO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbnkgcGVuZGluZyBzdGF0ZSBjaGFuZ2VzIGhhdmUgYmVlbiBhcHBsaWVkLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0aWNrKCkge1xuXHRpZiAoYXN5bmNfbW9kZV9mbGFnKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChmKSA9PiB7XG5cdFx0XHQvLyBSYWNlIHRoZW0gYWdhaW5zdCBlYWNoIG90aGVyIC0gaW4gYWxtb3N0IGFsbCBjYXNlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2lsbCBmaXJlIGZpcnN0LFxuXHRcdFx0Ly8gYnV0IGUuZy4gaW4gY2FzZSB0aGUgd2luZG93IGlzIG5vdCBmb2N1c2VkIG9yIGEgdmlldyB0cmFuc2l0aW9uIGhhcHBlbnMsIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuXHRcdFx0Ly8gd2lsbCBiZSBkZWxheWVkIGFuZCBzZXRUaW1lb3V0IGhlbHBzIHVzIHJlc29sdmUgZmFzdCBlbm91Z2ggaW4gdGhhdCBjYXNlXG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZigpKTtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4gZigpKTtcblx0XHR9KTtcblx0fVxuXG5cdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXG5cdC8vIEJ5IGNhbGxpbmcgZmx1c2hTeW5jIHdlIGd1YXJhbnRlZSB0aGF0IGFueSBwZW5kaW5nIHN0YXRlIGNoYW5nZXMgYXJlIGFwcGxpZWQgYWZ0ZXIgb25lIHRpY2suXG5cdC8vIFRPRE8gbG9vayBpbnRvIHdoZXRoZXIgd2UgY2FuIG1ha2UgZmx1c2hpbmcgc3Vic2VxdWVudCB1cGRhdGVzIHN5bmNocm9ub3VzbHkgaW4gdGhlIGZ1dHVyZS5cblx0Zmx1c2hTeW5jKCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFueSBzdGF0ZSBjaGFuZ2VzLCBhbmQgYXN5bmNocm9ub3VzIHdvcmsgcmVzdWx0aW5nIGZyb20gdGhlbSxcbiAqIGhhdmUgcmVzb2x2ZWQgYW5kIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZFxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKiBAc2luY2UgNS4zNlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dGxlZCgpIHtcblx0cmV0dXJuIEJhdGNoLmVuc3VyZSgpLnNldHRsZWQoKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWYWx1ZTxWPn0gc2lnbmFsXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzaWduYWwpIHtcblx0dmFyIGZsYWdzID0gc2lnbmFsLmY7XG5cdHZhciBpc19kZXJpdmVkID0gKGZsYWdzICYgREVSSVZFRCkgIT09IDA7XG5cblx0Y2FwdHVyZWRfc2lnbmFscz8uYWRkKHNpZ25hbCk7XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGRlcGVuZGVuY3kgb24gdGhlIGN1cnJlbnQgcmVhY3Rpb24gc2lnbmFsLlxuXHRpZiAoYWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmICF1bnRyYWNraW5nKSB7XG5cdFx0Ly8gaWYgd2UncmUgaW4gYSBkZXJpdmVkIHRoYXQgaXMgYmVpbmcgcmVhZCBpbnNpZGUgYW4gX2FzeW5jXyBkZXJpdmVkLFxuXHRcdC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgZWZmZWN0IHdhcyBhbHJlYWR5IGRlc3Ryb3llZC4gSW4gdGhpcyBjYXNlLFxuXHRcdC8vIHdlIGRvbid0IGFkZCB0aGUgZGVwZW5kZW5jeSwgYmVjYXVzZSB0aGF0IHdvdWxkIGNyZWF0ZSBhIG1lbW9yeSBsZWFrXG5cdFx0dmFyIGRlc3Ryb3llZCA9IGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiYgKGFjdGl2ZV9lZmZlY3QuZiAmIERFU1RST1lFRCkgIT09IDA7XG5cblx0XHRpZiAoIWRlc3Ryb3llZCAmJiAhY3VycmVudF9zb3VyY2VzPy5pbmNsdWRlcyhzaWduYWwpKSB7XG5cdFx0XHR2YXIgZGVwcyA9IGFjdGl2ZV9yZWFjdGlvbi5kZXBzO1xuXG5cdFx0XHRpZiAoKGFjdGl2ZV9yZWFjdGlvbi5mICYgUkVBQ1RJT05fSVNfVVBEQVRJTkcpICE9PSAwKSB7XG5cdFx0XHRcdC8vIHdlJ3JlIGluIHRoZSBlZmZlY3QgaW5pdC91cGRhdGUgY3ljbGVcblx0XHRcdFx0aWYgKHNpZ25hbC5ydiA8IHJlYWRfdmVyc2lvbikge1xuXHRcdFx0XHRcdHNpZ25hbC5ydiA9IHJlYWRfdmVyc2lvbjtcblxuXHRcdFx0XHRcdC8vIElmIHRoZSBzaWduYWwgaXMgYWNjZXNzaW5nIHRoZSBzYW1lIGRlcGVuZGVuY2llcyBpbiB0aGUgc2FtZVxuXHRcdFx0XHRcdC8vIG9yZGVyIGFzIGl0IGRpZCBsYXN0IHRpbWUsIGluY3JlbWVudCBgc2tpcHBlZF9kZXBzYFxuXHRcdFx0XHRcdC8vIHJhdGhlciB0aGFuIHVwZGF0aW5nIGBuZXdfZGVwc2AsIHdoaWNoIGNyZWF0ZXMgR0MgY29zdFxuXHRcdFx0XHRcdGlmIChuZXdfZGVwcyA9PT0gbnVsbCAmJiBkZXBzICE9PSBudWxsICYmIGRlcHNbc2tpcHBlZF9kZXBzXSA9PT0gc2lnbmFsKSB7XG5cdFx0XHRcdFx0XHRza2lwcGVkX2RlcHMrKztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5ld19kZXBzID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRuZXdfZGVwcyA9IFtzaWduYWxdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIW5ld19kZXBzLmluY2x1ZGVzKHNpZ25hbCkpIHtcblx0XHRcdFx0XHRcdG5ld19kZXBzLnB1c2goc2lnbmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHdlJ3JlIGFkZGluZyBhIGRlcGVuZGVuY3kgb3V0c2lkZSB0aGUgaW5pdC91cGRhdGUgY3ljbGVcblx0XHRcdFx0Ly8gKGkuZS4gYWZ0ZXIgYW4gYGF3YWl0YClcblx0XHRcdFx0KGFjdGl2ZV9yZWFjdGlvbi5kZXBzID8/PSBbXSkucHVzaChzaWduYWwpO1xuXG5cdFx0XHRcdHZhciByZWFjdGlvbnMgPSBzaWduYWwucmVhY3Rpb25zO1xuXG5cdFx0XHRcdGlmIChyZWFjdGlvbnMgPT09IG51bGwpIHtcblx0XHRcdFx0XHRzaWduYWwucmVhY3Rpb25zID0gW2FjdGl2ZV9yZWFjdGlvbl07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXJlYWN0aW9ucy5pbmNsdWRlcyhhY3RpdmVfcmVhY3Rpb24pKSB7XG5cdFx0XHRcdFx0cmVhY3Rpb25zLnB1c2goYWN0aXZlX3JlYWN0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHQvLyBUT0RPIHJlaW5zdGF0ZSB0aGlzLCBidXQgbWFrZSBpdCBhY3R1YWxseSB3b3JrXG5cdFx0Ly8gaWYgKGN1cnJlbnRfYXN5bmNfZWZmZWN0KSB7XG5cdFx0Ly8gXHR2YXIgdHJhY2tpbmcgPSAoY3VycmVudF9hc3luY19lZmZlY3QuZiAmIFJFQUNUSU9OX0lTX1VQREFUSU5HKSAhPT0gMDtcblx0XHQvLyBcdHZhciB3YXNfcmVhZCA9IGN1cnJlbnRfYXN5bmNfZWZmZWN0LmRlcHM/LmluY2x1ZGVzKHNpZ25hbCk7XG5cblx0XHQvLyBcdGlmICghdHJhY2tpbmcgJiYgIXVudHJhY2tpbmcgJiYgIXdhc19yZWFkKSB7XG5cdFx0Ly8gXHRcdHcuYXdhaXRfcmVhY3Rpdml0eV9sb3NzKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc2lnbmFsLmxhYmVsKSk7XG5cblx0XHQvLyBcdFx0dmFyIHRyYWNlID0gZ2V0X2Vycm9yKCd0cmFjZWQgYXQnKTtcblx0XHQvLyBcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHQvLyBcdFx0aWYgKHRyYWNlKSBjb25zb2xlLndhcm4odHJhY2UpO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH1cblxuXHRcdHJlY2VudF9hc3luY19kZXJpdmVkcy5kZWxldGUoc2lnbmFsKTtcblxuXHRcdGlmIChcblx0XHRcdHRyYWNpbmdfbW9kZV9mbGFnICYmXG5cdFx0XHQhdW50cmFja2luZyAmJlxuXHRcdFx0dHJhY2luZ19leHByZXNzaW9ucyAhPT0gbnVsbCAmJlxuXHRcdFx0YWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmXG5cdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zLnJlYWN0aW9uID09PSBhY3RpdmVfcmVhY3Rpb25cblx0XHQpIHtcblx0XHRcdC8vIFVzZWQgd2hlbiBtYXBwaW5nIHN0YXRlIGJldHdlZW4gc3BlY2lhbCBibG9ja3MgbGlrZSBgZWFjaGBcblx0XHRcdGlmIChzaWduYWwudHJhY2UpIHtcblx0XHRcdFx0c2lnbmFsLnRyYWNlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdHJhY2UgPSBnZXRfZXJyb3IoJ3RyYWNlZCBhdCcpO1xuXG5cdFx0XHRcdGlmICh0cmFjZSkge1xuXHRcdFx0XHRcdHZhciBlbnRyeSA9IHRyYWNpbmdfZXhwcmVzc2lvbnMuZW50cmllcy5nZXQoc2lnbmFsKTtcblxuXHRcdFx0XHRcdGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRlbnRyeSA9IHsgdHJhY2VzOiBbXSB9O1xuXHRcdFx0XHRcdFx0dHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzLnNldChzaWduYWwsIGVudHJ5KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgbGFzdCA9IGVudHJ5LnRyYWNlc1tlbnRyeS50cmFjZXMubGVuZ3RoIC0gMV07XG5cblx0XHRcdFx0XHQvLyB0cmFjZXMgY2FuIGJlIGR1cGxpY2F0ZWQsIGUuZy4gYnkgYHNuYXBzaG90YCBpbnZva2luZyBib3RoXG5cdFx0XHRcdFx0Ly8gYm90aCBgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBhbmQgYGdldGAgdHJhcHMgYXQgb25jZVxuXHRcdFx0XHRcdGlmICh0cmFjZS5zdGFjayAhPT0gbGFzdD8uc3RhY2spIHtcblx0XHRcdFx0XHRcdGVudHJ5LnRyYWNlcy5wdXNoKHRyYWNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaXNfZGVzdHJveWluZ19lZmZlY3QpIHtcblx0XHRpZiAob2xkX3ZhbHVlcy5oYXMoc2lnbmFsKSkge1xuXHRcdFx0cmV0dXJuIG9sZF92YWx1ZXMuZ2V0KHNpZ25hbCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzX2Rlcml2ZWQpIHtcblx0XHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKTtcblxuXHRcdFx0dmFyIHZhbHVlID0gZGVyaXZlZC52O1xuXG5cdFx0XHQvLyBpZiB0aGUgZGVyaXZlZCBpcyBkaXJ0eSBhbmQgaGFzIHJlYWN0aW9ucywgb3IgZGVwZW5kcyBvbiB0aGUgdmFsdWVzIHRoYXQganVzdCBjaGFuZ2VkLCByZS1leGVjdXRlXG5cdFx0XHQvLyAoYSBkZXJpdmVkIGNhbiBiZSBtYXliZV9kaXJ0eSBkdWUgdG8gdGhlIGVmZmVjdCBkZXN0cm95IHJlbW92aW5nIGl0cyBsYXN0IHJlYWN0aW9uKVxuXHRcdFx0aWYgKFxuXHRcdFx0XHQoKGRlcml2ZWQuZiAmIENMRUFOKSA9PT0gMCAmJiBkZXJpdmVkLnJlYWN0aW9ucyAhPT0gbnVsbCkgfHxcblx0XHRcdFx0ZGVwZW5kc19vbl9vbGRfdmFsdWVzKGRlcml2ZWQpXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFsdWUgPSBleGVjdXRlX2Rlcml2ZWQoZGVyaXZlZCk7XG5cdFx0XHR9XG5cblx0XHRcdG9sZF92YWx1ZXMuc2V0KGRlcml2ZWQsIHZhbHVlKTtcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChcblx0XHRpc19kZXJpdmVkICYmXG5cdFx0KCFiYXRjaF92YWx1ZXM/LmhhcyhzaWduYWwpIHx8IChjdXJyZW50X2JhdGNoPy5pc19mb3JrICYmICFlZmZlY3RfdHJhY2tpbmcoKSkpXG5cdCkge1xuXHRcdGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpO1xuXG5cdFx0aWYgKGlzX2RpcnR5KGRlcml2ZWQpKSB7XG5cdFx0XHR1cGRhdGVfZGVyaXZlZChkZXJpdmVkKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfdXBkYXRpbmdfZWZmZWN0ICYmIGVmZmVjdF90cmFja2luZygpICYmIChkZXJpdmVkLmYgJiBDT05ORUNURUQpID09PSAwKSB7XG5cdFx0XHRyZWNvbm5lY3QoZGVyaXZlZCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGJhdGNoX3ZhbHVlcz8uaGFzKHNpZ25hbCkpIHtcblx0XHRyZXR1cm4gYmF0Y2hfdmFsdWVzLmdldChzaWduYWwpO1xuXHR9XG5cblx0aWYgKChzaWduYWwuZiAmIEVSUk9SX1ZBTFVFKSAhPT0gMCkge1xuXHRcdHRocm93IHNpZ25hbC52O1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbC52O1xufVxuXG4vKipcbiAqIChSZSljb25uZWN0IGEgZGlzY29ubmVjdGVkIGRlcml2ZWQsIHNvIHRoYXQgaXQgaXMgbm90aWZpZWRcbiAqIG9mIGNoYW5nZXMgaW4gYG1hcmtfcmVhY3Rpb25zYFxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKi9cbmZ1bmN0aW9uIHJlY29ubmVjdChkZXJpdmVkKSB7XG5cdGlmIChkZXJpdmVkLmRlcHMgPT09IG51bGwpIHJldHVybjtcblxuXHRkZXJpdmVkLmYgXj0gQ09OTkVDVEVEO1xuXG5cdGZvciAoY29uc3QgZGVwIG9mIGRlcml2ZWQuZGVwcykge1xuXHRcdChkZXAucmVhY3Rpb25zID8/PSBbXSkucHVzaChkZXJpdmVkKTtcblxuXHRcdGlmICgoZGVwLmYgJiBERVJJVkVEKSAhPT0gMCAmJiAoZGVwLmYgJiBDT05ORUNURUQpID09PSAwKSB7XG5cdFx0XHRyZWNvbm5lY3QoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwKSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWQgKi9cbmZ1bmN0aW9uIGRlcGVuZHNfb25fb2xkX3ZhbHVlcyhkZXJpdmVkKSB7XG5cdGlmIChkZXJpdmVkLnYgPT09IFVOSU5JVElBTElaRUQpIHJldHVybiB0cnVlOyAvLyB3ZSBkb24ndCBrbm93LCBzbyBhc3N1bWUgdGhlIHdvcnN0XG5cdGlmIChkZXJpdmVkLmRlcHMgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuXHRmb3IgKGNvbnN0IGRlcCBvZiBkZXJpdmVkLmRlcHMpIHtcblx0XHRpZiAob2xkX3ZhbHVlcy5oYXMoZGVwKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKChkZXAuZiAmIERFUklWRUQpICE9PSAwICYmIGRlcGVuZHNfb25fb2xkX3ZhbHVlcygvKiogQHR5cGUge0Rlcml2ZWR9ICovIChkZXApKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIExpa2UgYGdldGAsIGJ1dCBjaGVja3MgZm9yIGB1bmRlZmluZWRgLiBVc2VkIGZvciBgdmFyYCBkZWNsYXJhdGlvbnMgYmVjYXVzZSB0aGV5IGNhbiBiZSBhY2Nlc3NlZCBiZWZvcmUgYmVpbmcgZGVjbGFyZWRcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+IHwgdW5kZWZpbmVkfSBzaWduYWxcbiAqIEByZXR1cm5zIHtWIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9nZXQoc2lnbmFsKSB7XG5cdHJldHVybiBzaWduYWwgJiYgZ2V0KHNpZ25hbCk7XG59XG5cbi8qKlxuICogV2hlbiB1c2VkIGluc2lkZSBhIFtgJGRlcml2ZWRgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGRlcml2ZWQpIG9yIFtgJGVmZmVjdGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0KSxcbiAqIGFueSBzdGF0ZSByZWFkIGluc2lkZSBgZm5gIHdpbGwgbm90IGJlIHRyZWF0ZWQgYXMgYSBkZXBlbmRlbmN5LlxuICpcbiAqIGBgYHRzXG4gKiAkZWZmZWN0KCgpID0+IHtcbiAqICAgLy8gdGhpcyB3aWxsIHJ1biB3aGVuIGBkYXRhYCBjaGFuZ2VzLCBidXQgbm90IHdoZW4gYHRpbWVgIGNoYW5nZXNcbiAqICAgc2F2ZShkYXRhLCB7XG4gKiAgICAgdGltZXN0YW1wOiB1bnRyYWNrKCgpID0+IHRpbWUpXG4gKiAgIH0pO1xuICogfSk7XG4gKiBgYGBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVudHJhY2soZm4pIHtcblx0dmFyIHByZXZpb3VzX3VudHJhY2tpbmcgPSB1bnRyYWNraW5nO1xuXHR0cnkge1xuXHRcdHVudHJhY2tpbmcgPSB0cnVlO1xuXHRcdHJldHVybiBmbigpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHVudHJhY2tpbmcgPSBwcmV2aW91c191bnRyYWNraW5nO1xuXHR9XG59XG5cbmNvbnN0IFNUQVRVU19NQVNLID0gfihESVJUWSB8IE1BWUJFX0RJUlRZIHwgQ0xFQU4pO1xuXG4vKipcbiAqIEBwYXJhbSB7U2lnbmFsfSBzaWduYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NpZ25hbF9zdGF0dXMoc2lnbmFsLCBzdGF0dXMpIHtcblx0c2lnbmFsLmYgPSAoc2lnbmFsLmYgJiBTVEFUVVNfTUFTSykgfCBzdGF0dXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPn0gb2JqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZyB8IHN5bWJvbD59IGtleXNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVfZnJvbV9vYmplY3Qob2JqLCBrZXlzKSB7XG5cdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj59ICovXG5cdHZhciByZXN1bHQgPSB7fTtcblxuXHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0aWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcblx0XHRcdHJlc3VsdFtrZXldID0gb2JqW2tleV07XG5cdFx0fVxuXHR9XG5cblx0Zm9yICh2YXIgc3ltYm9sIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSkge1xuXHRcdGlmIChPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bWJvbCkgJiYgIWtleXMuaW5jbHVkZXMoc3ltYm9sKSkge1xuXHRcdFx0cmVzdWx0W3N5bWJvbF0gPSBvYmpbc3ltYm9sXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFBvc3NpYmx5IHRyYXZlcnNlIGFuIG9iamVjdCBhbmQgcmVhZCBhbGwgaXRzIHByb3BlcnRpZXMgc28gdGhhdCB0aGV5J3JlIGFsbCByZWFjdGl2ZSBpbiBjYXNlIHRoaXMgaXMgYCRzdGF0ZWAuXG4gKiBEb2VzIG9ubHkgY2hlY2sgZmlyc3QgbGV2ZWwgb2YgYW4gb2JqZWN0IGZvciBwZXJmb3JtYW5jZSByZWFzb25zIChoZXVyaXN0aWMgc2hvdWxkIGJlIGdvb2QgZm9yIDk5JSBvZiBhbGwgY2FzZXMpLlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBfcmVhZF9zdGF0ZSh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCAhdmFsdWUgfHwgdmFsdWUgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChTVEFURV9TWU1CT0wgaW4gdmFsdWUpIHtcblx0XHRkZWVwX3JlYWQodmFsdWUpO1xuXHR9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdGZvciAobGV0IGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0Y29uc3QgcHJvcCA9IHZhbHVlW2tleV07XG5cdFx0XHRpZiAodHlwZW9mIHByb3AgPT09ICdvYmplY3QnICYmIHByb3AgJiYgU1RBVEVfU1lNQk9MIGluIHByb3ApIHtcblx0XHRcdFx0ZGVlcF9yZWFkKHByb3ApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIERlZXBseSB0cmF2ZXJzZSBhbiBvYmplY3QgYW5kIHJlYWQgYWxsIGl0cyBwcm9wZXJ0aWVzXG4gKiBzbyB0aGF0IHRoZXkncmUgYWxsIHJlYWN0aXZlIGluIGNhc2UgdGhpcyBpcyBgJHN0YXRlYFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxhbnk+fSB2aXNpdGVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBfcmVhZCh2YWx1ZSwgdmlzaXRlZCA9IG5ldyBTZXQoKSkge1xuXHRpZiAoXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZSBET00gZWxlbWVudHNcblx0XHQhKHZhbHVlIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpICYmXG5cdFx0IXZpc2l0ZWQuaGFzKHZhbHVlKVxuXHQpIHtcblx0XHR2aXNpdGVkLmFkZCh2YWx1ZSk7XG5cdFx0Ly8gV2hlbiB3b3JraW5nIHdpdGggYSBwb3NzaWJsZSBTdmVsdGVEYXRlLCB0aGlzXG5cdFx0Ly8gd2lsbCBlbnN1cmUgd2UgY2FwdHVyZSBjaGFuZ2VzIHRvIGl0LlxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdHZhbHVlLmdldFRpbWUoKTtcblx0XHR9XG5cdFx0Zm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkZWVwX3JlYWQodmFsdWVba2V5XSwgdmlzaXRlZCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IHByb3RvID0gZ2V0X3Byb3RvdHlwZV9vZih2YWx1ZSk7XG5cdFx0aWYgKFxuXHRcdFx0cHJvdG8gIT09IE9iamVjdC5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBBcnJheS5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBNYXAucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gU2V0LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IERhdGUucHJvdG90eXBlXG5cdFx0KSB7XG5cdFx0XHRjb25zdCBkZXNjcmlwdG9ycyA9IGdldF9kZXNjcmlwdG9ycyhwcm90byk7XG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gZGVzY3JpcHRvcnMpIHtcblx0XHRcdFx0Y29uc3QgZ2V0ID0gZGVzY3JpcHRvcnNba2V5XS5nZXQ7XG5cdFx0XHRcdGlmIChnZXQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Z2V0LmNhbGwodmFsdWUpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBBY3Rpb24sIEFjdGlvblJldHVybiB9IGZyb20gJy4uL2FjdGlvbi9wdWJsaWMnICovXG4vKiogQGltcG9ydCB7IEF0dGFjaG1lbnQgfSBmcm9tICcuL3B1YmxpYycgKi9cbmltcG9ydCB7IG5vb3AsIHJlbmRlcl9lZmZlY3QgfSBmcm9tICdzdmVsdGUvaW50ZXJuYWwvY2xpZW50JztcbmltcG9ydCB7IEFUVEFDSE1FTlRfS0VZIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuLi9pbmRleC1jbGllbnQuanMnO1xuaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBrZXkgdGhhdCB3aWxsIGJlIHJlY29nbmlzZWQgYXMgYW4gYXR0YWNobWVudCB3aGVuIHRoZSBvYmplY3QgaXMgc3ByZWFkIG9udG8gYW4gZWxlbWVudCxcbiAqIGFzIGEgcHJvZ3JhbW1hdGljIGFsdGVybmF0aXZlIHRvIHVzaW5nIGB7QGF0dGFjaCAuLi59YC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBsaWJyYXJ5IGF1dGhvcnMsIHRob3VnaFxuICogaXMgZ2VuZXJhbGx5IG5vdCBuZWVkZWQgd2hlbiBidWlsZGluZyBhbiBhcHAuXG4gKlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0PlxuICogXHRpbXBvcnQgeyBjcmVhdGVBdHRhY2htZW50S2V5IH0gZnJvbSAnc3ZlbHRlL2F0dGFjaG1lbnRzJztcbiAqXG4gKiBcdGNvbnN0IHByb3BzID0ge1xuICogXHRcdGNsYXNzOiAnY29vbCcsXG4gKiBcdFx0b25jbGljazogKCkgPT4gYWxlcnQoJ2NsaWNrZWQnKSxcbiAqIFx0XHRbY3JlYXRlQXR0YWNobWVudEtleSgpXTogKG5vZGUpID0+IHtcbiAqIFx0XHRcdG5vZGUudGV4dENvbnRlbnQgPSAnYXR0YWNoZWQhJztcbiAqIFx0XHR9XG4gKiBcdH07XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8YnV0dG9uIHsuLi5wcm9wc30+Y2xpY2sgbWU8L2J1dHRvbj5cbiAqIGBgYFxuICogQHNpbmNlIDUuMjlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUF0dGFjaG1lbnRLZXkoKSB7XG5cdHJldHVybiBTeW1ib2woQVRUQUNITUVOVF9LRVkpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIFthY3Rpb25dKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS91c2UpIGludG8gYW4gW2F0dGFjaG1lbnRdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9AYXR0YWNoKSBrZWVwaW5nIHRoZSBzYW1lIGJlaGF2aW9yLlxuICogSXQncyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gc3RhcnQgdXNpbmcgYXR0YWNobWVudHMgb24gY29tcG9uZW50cyBidXQgeW91IGhhdmUgYWN0aW9ucyBwcm92aWRlZCBieSBhIGxpYnJhcnkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCBfcmV0dXJuc18gdGhlIGFyZ3VtZW50IHRvIHRoZVxuICogYWN0aW9uIGZ1bmN0aW9uLCBub3QgdGhlIGFyZ3VtZW50IGl0c2VsZi5cbiAqXG4gKiBgYGBzdmVsdGVcbiAqIDwhLS0gd2l0aCBhbiBhY3Rpb24gLS0+XG4gKiA8ZGl2IHVzZTpmb289e2Jhcn0+Li4uPC9kaXY+XG4gKlxuICogPCEtLSB3aXRoIGFuIGF0dGFjaG1lbnQgLS0+XG4gKiA8ZGl2IHtAYXR0YWNoIGZyb21BY3Rpb24oZm9vLCAoKSA9PiBiYXIpfT4uLi48L2Rpdj5cbiAqIGBgYFxuICogQHRlbXBsYXRlIHtFdmVudFRhcmdldH0gRVxuICogQHRlbXBsYXRlIHt1bmtub3dufSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7QWN0aW9uPEUsIFQ+IHwgKChlbGVtZW50OiBFLCBhcmc6IFQpID0+IHZvaWQgfCBBY3Rpb25SZXR1cm48VD4pfSBhY3Rpb24gVGhlIGFjdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIHsoKSA9PiBUfSBmbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYXJndW1lbnQgZm9yIHRoZSBhY3Rpb25cbiAqIEByZXR1cm5zIHtBdHRhY2htZW50PEU+fVxuICovXG4vKipcbiAqIENvbnZlcnRzIGFuIFthY3Rpb25dKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS91c2UpIGludG8gYW4gW2F0dGFjaG1lbnRdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9AYXR0YWNoKSBrZWVwaW5nIHRoZSBzYW1lIGJlaGF2aW9yLlxuICogSXQncyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gc3RhcnQgdXNpbmcgYXR0YWNobWVudHMgb24gY29tcG9uZW50cyBidXQgeW91IGhhdmUgYWN0aW9ucyBwcm92aWRlZCBieSBhIGxpYnJhcnkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCBfcmV0dXJuc18gdGhlIGFyZ3VtZW50IHRvIHRoZVxuICogYWN0aW9uIGZ1bmN0aW9uLCBub3QgdGhlIGFyZ3VtZW50IGl0c2VsZi5cbiAqXG4gKiBgYGBzdmVsdGVcbiAqIDwhLS0gd2l0aCBhbiBhY3Rpb24gLS0+XG4gKiA8ZGl2IHVzZTpmb289e2Jhcn0+Li4uPC9kaXY+XG4gKlxuICogPCEtLSB3aXRoIGFuIGF0dGFjaG1lbnQgLS0+XG4gKiA8ZGl2IHtAYXR0YWNoIGZyb21BY3Rpb24oZm9vLCAoKSA9PiBiYXIpfT4uLi48L2Rpdj5cbiAqIGBgYFxuICogQHRlbXBsYXRlIHtFdmVudFRhcmdldH0gRVxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge0FjdGlvbjxFLCB2b2lkPiB8ICgoZWxlbWVudDogRSkgPT4gdm9pZCB8IEFjdGlvblJldHVybjx2b2lkPil9IGFjdGlvbiBUaGUgYWN0aW9uIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QXR0YWNobWVudDxFPn1cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBbYWN0aW9uXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdXNlKSBpbnRvIGFuIFthdHRhY2htZW50XShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvQGF0dGFjaCkga2VlcGluZyB0aGUgc2FtZSBiZWhhdmlvci5cbiAqIEl0J3MgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHN0YXJ0IHVzaW5nIGF0dGFjaG1lbnRzIG9uIGNvbXBvbmVudHMgYnV0IHlvdSBoYXZlIGFjdGlvbnMgcHJvdmlkZWQgYnkgYSBsaWJyYXJ5LlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgX3JldHVybnNfIHRoZSBhcmd1bWVudCB0byB0aGVcbiAqIGFjdGlvbiBmdW5jdGlvbiwgbm90IHRoZSBhcmd1bWVudCBpdHNlbGYuXG4gKlxuICogYGBgc3ZlbHRlXG4gKiA8IS0tIHdpdGggYW4gYWN0aW9uIC0tPlxuICogPGRpdiB1c2U6Zm9vPXtiYXJ9Pi4uLjwvZGl2PlxuICpcbiAqIDwhLS0gd2l0aCBhbiBhdHRhY2htZW50IC0tPlxuICogPGRpdiB7QGF0dGFjaCBmcm9tQWN0aW9uKGZvbywgKCkgPT4gYmFyKX0+Li4uPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUge0V2ZW50VGFyZ2V0fSBFXG4gKiBAdGVtcGxhdGUge3Vua25vd259IFRcbiAqIEBwYXJhbSB7QWN0aW9uPEUsIFQ+IHwgKChlbGVtZW50OiBFLCBhcmc6IFQpID0+IHZvaWQgfCBBY3Rpb25SZXR1cm48VD4pfSBhY3Rpb24gVGhlIGFjdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIHsoKSA9PiBUfSBmbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYXJndW1lbnQgZm9yIHRoZSBhY3Rpb25cbiAqIEByZXR1cm5zIHtBdHRhY2htZW50PEU+fVxuICogQHNpbmNlIDUuMzJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BY3Rpb24oYWN0aW9uLCBmbiA9IC8qKiBAdHlwZSB7KCkgPT4gVH0gKi8gKG5vb3ApKSB7XG5cdHJldHVybiAoZWxlbWVudCkgPT4ge1xuXHRcdGNvbnN0IHsgdXBkYXRlLCBkZXN0cm95IH0gPSB1bnRyYWNrKCgpID0+IGFjdGlvbihlbGVtZW50LCBmbigpKSA/PyB7fSk7XG5cblx0XHRpZiAodXBkYXRlKSB7XG5cdFx0XHR2YXIgcmFuID0gZmFsc2U7XG5cdFx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0Y29uc3QgYXJnID0gZm4oKTtcblx0XHRcdFx0aWYgKHJhbikgdXBkYXRlKGFyZyk7XG5cdFx0XHR9KTtcblx0XHRcdHJhbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGRlc3Ryb3kpIHtcblx0XHRcdHRlYXJkb3duKGRlc3Ryb3kpO1xuXHRcdH1cblx0fTtcbn1cbiIsICJjb25zdCByZWdleF9yZXR1cm5fY2hhcmFjdGVycyA9IC9cXHIvZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChzdHIpIHtcblx0c3RyID0gc3RyLnJlcGxhY2UocmVnZXhfcmV0dXJuX2NoYXJhY3RlcnMsICcnKTtcblx0bGV0IGhhc2ggPSA1MzgxO1xuXHRsZXQgaSA9IHN0ci5sZW5ndGg7XG5cblx0d2hpbGUgKGktLSkgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoMzYpO1xufVxuXG5jb25zdCBWT0lEX0VMRU1FTlRfTkFNRVMgPSBbXG5cdCdhcmVhJyxcblx0J2Jhc2UnLFxuXHQnYnInLFxuXHQnY29sJyxcblx0J2NvbW1hbmQnLFxuXHQnZW1iZWQnLFxuXHQnaHInLFxuXHQnaW1nJyxcblx0J2lucHV0Jyxcblx0J2tleWdlbicsXG5cdCdsaW5rJyxcblx0J21ldGEnLFxuXHQncGFyYW0nLFxuXHQnc291cmNlJyxcblx0J3RyYWNrJyxcblx0J3dicidcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIG9mIGEgdm9pZCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfdm9pZChuYW1lKSB7XG5cdHJldHVybiBWT0lEX0VMRU1FTlRfTkFNRVMuaW5jbHVkZXMobmFtZSkgfHwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnIWRvY3R5cGUnO1xufVxuXG5jb25zdCBSRVNFUlZFRF9XT1JEUyA9IFtcblx0J2FyZ3VtZW50cycsXG5cdCdhd2FpdCcsXG5cdCdicmVhaycsXG5cdCdjYXNlJyxcblx0J2NhdGNoJyxcblx0J2NsYXNzJyxcblx0J2NvbnN0Jyxcblx0J2NvbnRpbnVlJyxcblx0J2RlYnVnZ2VyJyxcblx0J2RlZmF1bHQnLFxuXHQnZGVsZXRlJyxcblx0J2RvJyxcblx0J2Vsc2UnLFxuXHQnZW51bScsXG5cdCdldmFsJyxcblx0J2V4cG9ydCcsXG5cdCdleHRlbmRzJyxcblx0J2ZhbHNlJyxcblx0J2ZpbmFsbHknLFxuXHQnZm9yJyxcblx0J2Z1bmN0aW9uJyxcblx0J2lmJyxcblx0J2ltcGxlbWVudHMnLFxuXHQnaW1wb3J0Jyxcblx0J2luJyxcblx0J2luc3RhbmNlb2YnLFxuXHQnaW50ZXJmYWNlJyxcblx0J2xldCcsXG5cdCduZXcnLFxuXHQnbnVsbCcsXG5cdCdwYWNrYWdlJyxcblx0J3ByaXZhdGUnLFxuXHQncHJvdGVjdGVkJyxcblx0J3B1YmxpYycsXG5cdCdyZXR1cm4nLFxuXHQnc3RhdGljJyxcblx0J3N1cGVyJyxcblx0J3N3aXRjaCcsXG5cdCd0aGlzJyxcblx0J3Rocm93Jyxcblx0J3RydWUnLFxuXHQndHJ5Jyxcblx0J3R5cGVvZicsXG5cdCd2YXInLFxuXHQndm9pZCcsXG5cdCd3aGlsZScsXG5cdCd3aXRoJyxcblx0J3lpZWxkJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgd29yZGAgaXMgYSByZXNlcnZlZCBKYXZhU2NyaXB0IGtleXdvcmRcbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19yZXNlcnZlZCh3b3JkKSB7XG5cdHJldHVybiBSRVNFUlZFRF9XT1JEUy5pbmNsdWRlcyh3b3JkKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY2FwdHVyZV9ldmVudChuYW1lKSB7XG5cdHJldHVybiBuYW1lLmVuZHNXaXRoKCdjYXB0dXJlJykgJiYgbmFtZSAhPT0gJ2dvdHBvaW50ZXJjYXB0dXJlJyAmJiBuYW1lICE9PSAnbG9zdHBvaW50ZXJjYXB0dXJlJztcbn1cblxuLyoqIExpc3Qgb2YgRWxlbWVudCBldmVudHMgdGhhdCB3aWxsIGJlIGRlbGVnYXRlZCAqL1xuY29uc3QgREVMRUdBVEVEX0VWRU5UUyA9IFtcblx0J2JlZm9yZWlucHV0Jyxcblx0J2NsaWNrJyxcblx0J2NoYW5nZScsXG5cdCdkYmxjbGljaycsXG5cdCdjb250ZXh0bWVudScsXG5cdCdmb2N1c2luJyxcblx0J2ZvY3Vzb3V0Jyxcblx0J2lucHV0Jyxcblx0J2tleWRvd24nLFxuXHQna2V5dXAnLFxuXHQnbW91c2Vkb3duJyxcblx0J21vdXNlbW92ZScsXG5cdCdtb3VzZW91dCcsXG5cdCdtb3VzZW92ZXInLFxuXHQnbW91c2V1cCcsXG5cdCdwb2ludGVyZG93bicsXG5cdCdwb2ludGVybW92ZScsXG5cdCdwb2ludGVyb3V0Jyxcblx0J3BvaW50ZXJvdmVyJyxcblx0J3BvaW50ZXJ1cCcsXG5cdCd0b3VjaGVuZCcsXG5cdCd0b3VjaG1vdmUnLFxuXHQndG91Y2hzdGFydCdcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYGV2ZW50X25hbWVgIGlzIGEgZGVsZWdhdGVkIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuX2RlbGVnYXRlX2V2ZW50KGV2ZW50X25hbWUpIHtcblx0cmV0dXJuIERFTEVHQVRFRF9FVkVOVFMuaW5jbHVkZXMoZXZlbnRfbmFtZSk7XG59XG5cbi8qKlxuICogQXR0cmlidXRlcyB0aGF0IGFyZSBib29sZWFuLCBpLmUuIHRoZXkgYXJlIHByZXNlbnQgb3Igbm90IHByZXNlbnQuXG4gKi9cbmNvbnN0IERPTV9CT09MRUFOX0FUVFJJQlVURVMgPSBbXG5cdCdhbGxvd2Z1bGxzY3JlZW4nLFxuXHQnYXN5bmMnLFxuXHQnYXV0b2ZvY3VzJyxcblx0J2F1dG9wbGF5Jyxcblx0J2NoZWNrZWQnLFxuXHQnY29udHJvbHMnLFxuXHQnZGVmYXVsdCcsXG5cdCdkaXNhYmxlZCcsXG5cdCdmb3Jtbm92YWxpZGF0ZScsXG5cdCdpbmRldGVybWluYXRlJyxcblx0J2luZXJ0Jyxcblx0J2lzbWFwJyxcblx0J2xvb3AnLFxuXHQnbXVsdGlwbGUnLFxuXHQnbXV0ZWQnLFxuXHQnbm9tb2R1bGUnLFxuXHQnbm92YWxpZGF0ZScsXG5cdCdvcGVuJyxcblx0J3BsYXlzaW5saW5lJyxcblx0J3JlYWRvbmx5Jyxcblx0J3JlcXVpcmVkJyxcblx0J3JldmVyc2VkJyxcblx0J3NlYW1sZXNzJyxcblx0J3NlbGVjdGVkJyxcblx0J3dlYmtpdGRpcmVjdG9yeScsXG5cdCdkZWZlcicsXG5cdCdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsXG5cdCdkaXNhYmxlcmVtb3RlcGxheWJhY2snXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGBuYW1lYCBpcyBhIGJvb2xlYW4gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfYm9vbGVhbl9hdHRyaWJ1dGUobmFtZSkge1xuXHRyZXR1cm4gRE9NX0JPT0xFQU5fQVRUUklCVVRFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRoYXQgc2hvdWxkIGJlIGFsaWFzZWQgdG8gdGhlaXIgcHJvcGVydHkgbmFtZXNcbiAqIGJlY2F1c2UgdGhleSBiZWhhdmUgZGlmZmVyZW50bHkgYmV0d2VlbiBzZXR0aW5nIHRoZW0gYXMgYW4gYXR0cmlidXRlIGFuZFxuICogc2V0dGluZyB0aGVtIGFzIGEgcHJvcGVydHkuXG4gKi9cbmNvbnN0IEFUVFJJQlVURV9BTElBU0VTID0ge1xuXHQvLyBubyBgY2xhc3M6ICdjbGFzc05hbWUnYCBiZWNhdXNlIHdlIGhhbmRsZSB0aGF0IHNlcGFyYXRlbHlcblx0Zm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG5cdGlzbWFwOiAnaXNNYXAnLFxuXHRub21vZHVsZTogJ25vTW9kdWxlJyxcblx0cGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG5cdHJlYWRvbmx5OiAncmVhZE9ubHknLFxuXHRkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuXHRkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcblx0c3Jjb2JqZWN0OiAnc3JjT2JqZWN0Jyxcblx0bm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuXHRhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxzY3JlZW4nLFxuXHRkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcblx0ZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplX2F0dHJpYnV0ZShuYW1lKSB7XG5cdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdHJldHVybiBBVFRSSUJVVEVfQUxJQVNFU1tuYW1lXSA/PyBuYW1lO1xufVxuXG5jb25zdCBET01fUFJPUEVSVElFUyA9IFtcblx0Li4uRE9NX0JPT0xFQU5fQVRUUklCVVRFUyxcblx0J2Zvcm1Ob1ZhbGlkYXRlJyxcblx0J2lzTWFwJyxcblx0J25vTW9kdWxlJyxcblx0J3BsYXlzSW5saW5lJyxcblx0J3JlYWRPbmx5Jyxcblx0J3ZhbHVlJyxcblx0J3ZvbHVtZScsXG5cdCdkZWZhdWx0VmFsdWUnLFxuXHQnZGVmYXVsdENoZWNrZWQnLFxuXHQnc3JjT2JqZWN0Jyxcblx0J25vVmFsaWRhdGUnLFxuXHQnYWxsb3dGdWxsc2NyZWVuJyxcblx0J2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcblx0J2Rpc2FibGVSZW1vdGVQbGF5YmFjaydcbl07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2RvbV9wcm9wZXJ0eShuYW1lKSB7XG5cdHJldHVybiBET01fUFJPUEVSVElFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgTk9OX1NUQVRJQ19QUk9QRVJUSUVTID0gWydhdXRvZm9jdXMnLCAnbXV0ZWQnLCAnZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJ107XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGF0dHJpYnV0ZSBjYW5ub3QgYmUgc2V0IHRocm91Z2ggdGhlIHRlbXBsYXRlXG4gKiBzdHJpbmcsIGkuZS4gbmVlZHMgc29tZSBraW5kIG9mIEphdmFTY3JpcHQgaGFuZGxpbmcgdG8gd29yay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RfYmVfc2V0X3N0YXRpY2FsbHkobmFtZSkge1xuXHRyZXR1cm4gTk9OX1NUQVRJQ19QUk9QRVJUSUVTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG4vKipcbiAqIFN1YnNldCBvZiBkZWxlZ2F0ZWQgZXZlbnRzIHdoaWNoIHNob3VsZCBiZSBwYXNzaXZlIGJ5IGRlZmF1bHQuXG4gKiBUaGVzZSB0d28gYXJlIGFscmVhZHkgcGFzc2l2ZSB2aWEgYnJvd3NlciBkZWZhdWx0cyBvbiB3aW5kb3csIGRvY3VtZW50IGFuZCBib2R5LlxuICogQnV0IHNpbmNlXG4gKiAtIHdlJ3JlIGRlbGVnYXRpbmcgdGhlbVxuICogLSB0aGV5IGhhcHBlbiBvZnRlblxuICogLSB0aGV5IGFwcGx5IHRvIG1vYmlsZSB3aGljaCBpcyBnZW5lcmFsbHkgbGVzcyBwZXJmb3JtYW50XG4gKiB3ZSdyZSBtYXJraW5nIHRoZW0gYXMgcGFzc2l2ZSBieSBkZWZhdWx0IGZvciBvdGhlciBlbGVtZW50cywgdG9vLlxuICovXG5jb25zdCBQQVNTSVZFX0VWRU5UUyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgYSBwYXNzaXZlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcGFzc2l2ZV9ldmVudChuYW1lKSB7XG5cdHJldHVybiBQQVNTSVZFX0VWRU5UUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgQ09OVEVOVF9FRElUQUJMRV9CSU5ESU5HUyA9IFsndGV4dENvbnRlbnQnLCAnaW5uZXJIVE1MJywgJ2lubmVyVGV4dCddO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jb250ZW50X2VkaXRhYmxlX2JpbmRpbmcobmFtZSkge1xuXHRyZXR1cm4gQ09OVEVOVF9FRElUQUJMRV9CSU5ESU5HUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgTE9BRF9FUlJPUl9FTEVNRU5UUyA9IFtcblx0J2JvZHknLFxuXHQnZW1iZWQnLFxuXHQnaWZyYW1lJyxcblx0J2ltZycsXG5cdCdsaW5rJyxcblx0J29iamVjdCcsXG5cdCdzY3JpcHQnLFxuXHQnc3R5bGUnLFxuXHQndHJhY2snXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50IGVtaXRzIGBsb2FkYCBhbmQgYGVycm9yYCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19sb2FkX2Vycm9yX2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gTE9BRF9FUlJPUl9FTEVNRU5UUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgU1ZHX0VMRU1FTlRTID0gW1xuXHQnYWx0R2x5cGgnLFxuXHQnYWx0R2x5cGhEZWYnLFxuXHQnYWx0R2x5cGhJdGVtJyxcblx0J2FuaW1hdGUnLFxuXHQnYW5pbWF0ZUNvbG9yJyxcblx0J2FuaW1hdGVNb3Rpb24nLFxuXHQnYW5pbWF0ZVRyYW5zZm9ybScsXG5cdCdjaXJjbGUnLFxuXHQnY2xpcFBhdGgnLFxuXHQnY29sb3ItcHJvZmlsZScsXG5cdCdjdXJzb3InLFxuXHQnZGVmcycsXG5cdCdkZXNjJyxcblx0J2Rpc2NhcmQnLFxuXHQnZWxsaXBzZScsXG5cdCdmZUJsZW5kJyxcblx0J2ZlQ29sb3JNYXRyaXgnLFxuXHQnZmVDb21wb25lbnRUcmFuc2ZlcicsXG5cdCdmZUNvbXBvc2l0ZScsXG5cdCdmZUNvbnZvbHZlTWF0cml4Jyxcblx0J2ZlRGlmZnVzZUxpZ2h0aW5nJyxcblx0J2ZlRGlzcGxhY2VtZW50TWFwJyxcblx0J2ZlRGlzdGFudExpZ2h0Jyxcblx0J2ZlRHJvcFNoYWRvdycsXG5cdCdmZUZsb29kJyxcblx0J2ZlRnVuY0EnLFxuXHQnZmVGdW5jQicsXG5cdCdmZUZ1bmNHJyxcblx0J2ZlRnVuY1InLFxuXHQnZmVHYXVzc2lhbkJsdXInLFxuXHQnZmVJbWFnZScsXG5cdCdmZU1lcmdlJyxcblx0J2ZlTWVyZ2VOb2RlJyxcblx0J2ZlTW9ycGhvbG9neScsXG5cdCdmZU9mZnNldCcsXG5cdCdmZVBvaW50TGlnaHQnLFxuXHQnZmVTcGVjdWxhckxpZ2h0aW5nJyxcblx0J2ZlU3BvdExpZ2h0Jyxcblx0J2ZlVGlsZScsXG5cdCdmZVR1cmJ1bGVuY2UnLFxuXHQnZmlsdGVyJyxcblx0J2ZvbnQnLFxuXHQnZm9udC1mYWNlJyxcblx0J2ZvbnQtZmFjZS1mb3JtYXQnLFxuXHQnZm9udC1mYWNlLW5hbWUnLFxuXHQnZm9udC1mYWNlLXNyYycsXG5cdCdmb250LWZhY2UtdXJpJyxcblx0J2ZvcmVpZ25PYmplY3QnLFxuXHQnZycsXG5cdCdnbHlwaCcsXG5cdCdnbHlwaFJlZicsXG5cdCdoYXRjaCcsXG5cdCdoYXRjaHBhdGgnLFxuXHQnaGtlcm4nLFxuXHQnaW1hZ2UnLFxuXHQnbGluZScsXG5cdCdsaW5lYXJHcmFkaWVudCcsXG5cdCdtYXJrZXInLFxuXHQnbWFzaycsXG5cdCdtZXNoJyxcblx0J21lc2hncmFkaWVudCcsXG5cdCdtZXNocGF0Y2gnLFxuXHQnbWVzaHJvdycsXG5cdCdtZXRhZGF0YScsXG5cdCdtaXNzaW5nLWdseXBoJyxcblx0J21wYXRoJyxcblx0J3BhdGgnLFxuXHQncGF0dGVybicsXG5cdCdwb2x5Z29uJyxcblx0J3BvbHlsaW5lJyxcblx0J3JhZGlhbEdyYWRpZW50Jyxcblx0J3JlY3QnLFxuXHQnc2V0Jyxcblx0J3NvbGlkY29sb3InLFxuXHQnc3RvcCcsXG5cdCdzdmcnLFxuXHQnc3dpdGNoJyxcblx0J3N5bWJvbCcsXG5cdCd0ZXh0Jyxcblx0J3RleHRQYXRoJyxcblx0J3RyZWYnLFxuXHQndHNwYW4nLFxuXHQndW5rbm93bicsXG5cdCd1c2UnLFxuXHQndmlldycsXG5cdCd2a2Vybidcbl07XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3N2ZyhuYW1lKSB7XG5cdHJldHVybiBTVkdfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IE1BVEhNTF9FTEVNRU5UUyA9IFtcblx0J2Fubm90YXRpb24nLFxuXHQnYW5ub3RhdGlvbi14bWwnLFxuXHQnbWFjdGlvbicsXG5cdCdtYXRoJyxcblx0J21lcnJvcicsXG5cdCdtZnJhYycsXG5cdCdtaScsXG5cdCdtbXVsdGlzY3JpcHRzJyxcblx0J21uJyxcblx0J21vJyxcblx0J21vdmVyJyxcblx0J21wYWRkZWQnLFxuXHQnbXBoYW50b20nLFxuXHQnbXByZXNjcmlwdHMnLFxuXHQnbXJvb3QnLFxuXHQnbXJvdycsXG5cdCdtcycsXG5cdCdtc3BhY2UnLFxuXHQnbXNxcnQnLFxuXHQnbXN0eWxlJyxcblx0J21zdWInLFxuXHQnbXN1YnN1cCcsXG5cdCdtc3VwJyxcblx0J210YWJsZScsXG5cdCdtdGQnLFxuXHQnbXRleHQnLFxuXHQnbXRyJyxcblx0J211bmRlcicsXG5cdCdtdW5kZXJvdmVyJyxcblx0J3NlbWFudGljcydcbl07XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX21hdGhtbChuYW1lKSB7XG5cdHJldHVybiBNQVRITUxfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IFNUQVRFX0NSRUFUSU9OX1JVTkVTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcblx0JyRzdGF0ZScsXG5cdCckc3RhdGUucmF3Jyxcblx0JyRkZXJpdmVkJyxcblx0JyRkZXJpdmVkLmJ5J1xuXSk7XG5cbmNvbnN0IFJVTkVTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcblx0Li4uU1RBVEVfQ1JFQVRJT05fUlVORVMsXG5cdCckc3RhdGUuZWFnZXInLFxuXHQnJHN0YXRlLnNuYXBzaG90Jyxcblx0JyRwcm9wcycsXG5cdCckcHJvcHMuaWQnLFxuXHQnJGJpbmRhYmxlJyxcblx0JyRlZmZlY3QnLFxuXHQnJGVmZmVjdC5wcmUnLFxuXHQnJGVmZmVjdC50cmFja2luZycsXG5cdCckZWZmZWN0LnJvb3QnLFxuXHQnJGVmZmVjdC5wZW5kaW5nJyxcblx0JyRpbnNwZWN0Jyxcblx0JyRpbnNwZWN0KCkud2l0aCcsXG5cdCckaW5zcGVjdC50cmFjZScsXG5cdCckaG9zdCdcbl0pO1xuXG4vKiogQHR5cGVkZWYge3R5cGVvZiBSVU5FU1tudW1iZXJdfSBSdW5lTmFtZSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmFtZSBpcyBSdW5lTmFtZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3J1bmUobmFtZSkge1xuXHRyZXR1cm4gUlVORVMuaW5jbHVkZXMoLyoqIEB0eXBlIHtSdW5lTmFtZX0gKi8gKG5hbWUpKTtcbn1cblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgU1RBVEVfQ1JFQVRJT05fUlVORVNbbnVtYmVyXX0gU3RhdGVDcmVhdGlvblJ1bmVOYW1lICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuYW1lIGlzIFN0YXRlQ3JlYXRpb25SdW5lTmFtZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3N0YXRlX2NyZWF0aW9uX3J1bmUobmFtZSkge1xuXHRyZXR1cm4gU1RBVEVfQ1JFQVRJT05fUlVORVMuaW5jbHVkZXMoLyoqIEB0eXBlIHtTdGF0ZUNyZWF0aW9uUnVuZU5hbWV9ICovIChuYW1lKSk7XG59XG5cbi8qKiBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgcmVxdWlyZSByYXcgY29udGVudHMgYW5kIHNob3VsZCBub3QgaGF2ZSBTU1IgY29tbWVudHMgcHV0IGluIHRoZW0gKi9cbmNvbnN0IFJBV19URVhUX0VMRU1FTlRTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsndGV4dGFyZWEnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3RpdGxlJ10pO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19yYXdfdGV4dF9lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIFJBV19URVhUX0VMRU1FTlRTLmluY2x1ZGVzKC8qKiBAdHlwZSB7dHlwZW9mIFJBV19URVhUX0VMRU1FTlRTW251bWJlcl19ICovIChuYW1lKSk7XG59XG5cbi8qKlxuICogUHJldmVudCBkZXZ0b29scyB0cnlpbmcgdG8gbWFrZSBgbG9jYXRpb25gIGEgY2xpY2thYmxlIGxpbmsgYnkgaW5zZXJ0aW5nIGEgemVyby13aWR0aCBzcGFjZVxuICogQHRlbXBsYXRlIHtzdHJpbmcgfCB1bmRlZmluZWR9IFRcbiAqIEBwYXJhbSB7VH0gbG9jYXRpb25cbiAqIEByZXR1cm5zIHtUfTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplX2xvY2F0aW9uKGxvY2F0aW9uKSB7XG5cdHJldHVybiAvKiogQHR5cGUge1R9ICovIChsb2NhdGlvbj8ucmVwbGFjZSgvXFwvL2csICcvXFx1MjAwYicpKTtcbn1cbiIsICJpbXBvcnQgeyBzYW5pdGl6ZV9sb2NhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgcHJvcGVydHksIGxvY2F0aW9uKSB7XG5cdGlmIChhICE9PSBiKSB7XG5cdFx0dy5hc3NpZ25tZW50X3ZhbHVlX3N0YWxlKHByb3BlcnR5LCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNhbml0aXplX2xvY2F0aW9uKGxvY2F0aW9uKSkpO1xuXHR9XG5cblx0cmV0dXJuIGE7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBsb2NhdGlvbikge1xuXHRyZXR1cm4gY29tcGFyZShcblx0XHQob2JqZWN0W3Byb3BlcnR5XSA9IHZhbHVlKSxcblx0XHR1bnRyYWNrKCgpID0+IG9iamVjdFtwcm9wZXJ0eV0pLFxuXHRcdHByb3BlcnR5LFxuXHRcdGxvY2F0aW9uXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX2FuZChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgbG9jYXRpb24pIHtcblx0cmV0dXJuIGNvbXBhcmUoXG5cdFx0KG9iamVjdFtwcm9wZXJ0eV0gJiY9IHZhbHVlKSxcblx0XHR1bnRyYWNrKCgpID0+IG9iamVjdFtwcm9wZXJ0eV0pLFxuXHRcdHByb3BlcnR5LFxuXHRcdGxvY2F0aW9uXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX29yKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBsb2NhdGlvbikge1xuXHRyZXR1cm4gY29tcGFyZShcblx0XHQob2JqZWN0W3Byb3BlcnR5XSB8fD0gdmFsdWUpLFxuXHRcdHVudHJhY2soKCkgPT4gb2JqZWN0W3Byb3BlcnR5XSksXG5cdFx0cHJvcGVydHksXG5cdFx0bG9jYXRpb25cblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25fbnVsbGlzaChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgbG9jYXRpb24pIHtcblx0cmV0dXJuIGNvbXBhcmUoXG5cdFx0KG9iamVjdFtwcm9wZXJ0eV0gPz89IHZhbHVlKSxcblx0XHR1bnRyYWNrKCgpID0+IG9iamVjdFtwcm9wZXJ0eV0pLFxuXHRcdHByb3BlcnR5LFxuXHRcdGxvY2F0aW9uXG5cdCk7XG59XG4iLCAiLyoqIEB0eXBlIHtNYXA8U3RyaW5nLCBTZXQ8SFRNTFN0eWxlRWxlbWVudD4+fSAqL1xudmFyIGFsbF9zdHlsZXMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGhhc2hcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyX3N0eWxlKGhhc2gsIHN0eWxlKSB7XG5cdHZhciBzdHlsZXMgPSBhbGxfc3R5bGVzLmdldChoYXNoKTtcblxuXHRpZiAoIXN0eWxlcykge1xuXHRcdHN0eWxlcyA9IG5ldyBTZXQoKTtcblx0XHRhbGxfc3R5bGVzLnNldChoYXNoLCBzdHlsZXMpO1xuXHR9XG5cblx0c3R5bGVzLmFkZChzdHlsZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBfc3R5bGVzKGhhc2gpIHtcblx0dmFyIHN0eWxlcyA9IGFsbF9zdHlsZXMuZ2V0KGhhc2gpO1xuXHRpZiAoIXN0eWxlcykgcmV0dXJuO1xuXG5cdGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG5cdFx0c3R5bGUucmVtb3ZlKCk7XG5cdH1cblxuXHRhbGxfc3R5bGVzLmRlbGV0ZShoYXNoKTtcbn1cbiIsICIvKiogQGltcG9ydCB7IFNvdXJjZUxvY2F0aW9uIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IENPTU1FTlRfTk9ERSwgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSwgRUxFTUVOVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgSFlEUkFUSU9OX0VORCwgSFlEUkFUSU9OX1NUQVJULCBIWURSQVRJT05fU1RBUlRfRUxTRSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9kb20vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGRldl9zdGFjayB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBmblxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge1NvdXJjZUxvY2F0aW9uW119IGxvY2F0aW9uc1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9sb2NhdGlvbnMoZm4sIGZpbGVuYW1lLCBsb2NhdGlvbnMpIHtcblx0cmV0dXJuICgvKiogQHR5cGUge2FueVtdfSAqLyAuLi5hcmdzKSA9PiB7XG5cdFx0Y29uc3QgZG9tID0gZm4oLi4uYXJncyk7XG5cblx0XHR2YXIgbm9kZSA9IGh5ZHJhdGluZyA/IGRvbSA6IGRvbS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA/IGRvbS5maXJzdENoaWxkIDogZG9tO1xuXHRcdGFzc2lnbl9sb2NhdGlvbnMobm9kZSwgZmlsZW5hbWUsIGxvY2F0aW9ucyk7XG5cblx0XHRyZXR1cm4gZG9tO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge1NvdXJjZUxvY2F0aW9ufSBsb2NhdGlvblxuICovXG5mdW5jdGlvbiBhc3NpZ25fbG9jYXRpb24oZWxlbWVudCwgZmlsZW5hbWUsIGxvY2F0aW9uKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdHBhcmVudDogZGV2X3N0YWNrLFxuXHRcdGxvYzogeyBmaWxlOiBmaWxlbmFtZSwgbGluZTogbG9jYXRpb25bMF0sIGNvbHVtbjogbG9jYXRpb25bMV0gfVxuXHR9O1xuXG5cdGlmIChsb2NhdGlvblsyXSkge1xuXHRcdGFzc2lnbl9sb2NhdGlvbnMoZWxlbWVudC5maXJzdENoaWxkLCBmaWxlbmFtZSwgbG9jYXRpb25bMl0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlIHwgbnVsbH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge1NvdXJjZUxvY2F0aW9uW119IGxvY2F0aW9uc1xuICovXG5mdW5jdGlvbiBhc3NpZ25fbG9jYXRpb25zKG5vZGUsIGZpbGVuYW1lLCBsb2NhdGlvbnMpIHtcblx0dmFyIGkgPSAwO1xuXHR2YXIgZGVwdGggPSAwO1xuXG5cdHdoaWxlIChub2RlICYmIGkgPCBsb2NhdGlvbnMubGVuZ3RoKSB7XG5cdFx0aWYgKGh5ZHJhdGluZyAmJiBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcblx0XHRcdHZhciBjb21tZW50ID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobm9kZSk7XG5cdFx0XHRpZiAoY29tbWVudC5kYXRhID09PSBIWURSQVRJT05fU1RBUlQgfHwgY29tbWVudC5kYXRhID09PSBIWURSQVRJT05fU1RBUlRfRUxTRSkgZGVwdGggKz0gMTtcblx0XHRcdGVsc2UgaWYgKGNvbW1lbnQuZGF0YVswXSA9PT0gSFlEUkFUSU9OX0VORCkgZGVwdGggLT0gMTtcblx0XHR9XG5cblx0XHRpZiAoZGVwdGggPT09IDAgJiYgbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG5cdFx0XHRhc3NpZ25fbG9jYXRpb24oLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSksIGZpbGVuYW1lLCBsb2NhdGlvbnNbaSsrXSk7XG5cdFx0fVxuXG5cdFx0bm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vYmluZGluZ3Mvc2hhcmVkLmpzJztcblxuLyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cbmV4cG9ydCBjb25zdCBhbGxfcmVnaXN0ZXJlZF9ldmVudHMgPSBuZXcgU2V0KCk7XG5cbi8qKiBAdHlwZSB7U2V0PChldmVudHM6IEFycmF5PHN0cmluZz4pID0+IHZvaWQ+fSAqL1xuZXhwb3J0IGNvbnN0IHJvb3RfZXZlbnRfaGFuZGxlcyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBTU1IgYWRkcyBvbmxvYWQgYW5kIG9uZXJyb3IgYXR0cmlidXRlcyB0byBjYXRjaCB0aG9zZSBldmVudHMgYmVmb3JlIHRoZSBoeWRyYXRpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgdGhvc2UgY2FzZXMsIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZXMgYW5kIHJlcGxheXMgdGhlIGV2ZW50cy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGF5X2V2ZW50cyhkb20pIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHRkb20ucmVtb3ZlQXR0cmlidXRlKCdvbmxvYWQnKTtcblx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25lcnJvcicpO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGV2ZW50ID0gZG9tLl9fZTtcblx0aWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZG9tLl9fZSA9IHVuZGVmaW5lZDtcblx0XHRxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAoZG9tLmlzQ29ubmVjdGVkKSB7XG5cdFx0XHRcdGRvbS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBkb21cbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gW2hhbmRsZXJdXG4gKiBAcGFyYW0ge0FkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuXHQvKipcblx0ICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuXHQgKi9cblx0ZnVuY3Rpb24gdGFyZ2V0X2hhbmRsZXIoLyoqIEB0eXBlIHtFdmVudH0gKi8gZXZlbnQpIHtcblx0XHRpZiAoIW9wdGlvbnMuY2FwdHVyZSkge1xuXHRcdFx0Ly8gT25seSBjYWxsIGluIHRoZSBidWJibGUgcGhhc2UsIGVsc2UgZGVsZWdhdGVkIGV2ZW50cyB3b3VsZCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBjYXB0dXJpbmcgZXZlbnRzXG5cdFx0XHRoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24uY2FsbChkb20sIGV2ZW50KTtcblx0XHR9XG5cdFx0aWYgKCFldmVudC5jYW5jZWxCdWJibGUpIHtcblx0XHRcdHJldHVybiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gaGFuZGxlcj8uY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaHJvbWUgaGFzIGEgYnVnIHdoZXJlIHBvaW50ZXIgZXZlbnRzIGRvbid0IHdvcmsgd2hlbiBhdHRhY2hlZCB0byBhIERPTSBlbGVtZW50IHRoYXQgaGFzIGJlZW4gY2xvbmVkXG5cdC8vIHdpdGggY2xvbmVOb2RlKCkgYW5kIHRoZSBET00gZWxlbWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIFRvIGVuc3VyZSB0aGUgZXZlbnQgd29ya3MsIHdlXG5cdC8vIGRlZmVyIHRoZSBhdHRhY2htZW50IHRpbGwgYWZ0ZXIgaXQncyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBkb2N1bWVudC4gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSBDaHJvbWUgZml4ZXNcblx0Ly8gdGhpcyBidWcuIFRoZSBzYW1lIGFwcGxpZXMgdG8gd2hlZWwgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXG5cdGlmIChcblx0XHRldmVudF9uYW1lLnN0YXJ0c1dpdGgoJ3BvaW50ZXInKSB8fFxuXHRcdGV2ZW50X25hbWUuc3RhcnRzV2l0aCgndG91Y2gnKSB8fFxuXHRcdGV2ZW50X25hbWUgPT09ICd3aGVlbCdcblx0KSB7XG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRkb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldF9oYW5kbGVyO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgaGFuZGxlci4gVXNpbmcgdGhpc1xuICogcmF0aGVyIHRoYW4gYGFkZEV2ZW50TGlzdGVuZXJgIHdpbGwgcHJlc2VydmUgdGhlIGNvcnJlY3Qgb3JkZXIgcmVsYXRpdmUgdG8gaGFuZGxlcnMgYWRkZWQgZGVjbGFyYXRpdmVseVxuICogKHdpdGggYXR0cmlidXRlcyBsaWtlIGBvbmNsaWNrYCksIHdoaWNoIHVzZSBldmVudCBkZWxlZ2F0aW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICogQHBhcmFtIHtBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcblx0dmFyIHRhcmdldF9oYW5kbGVyID0gY3JlYXRlX2V2ZW50KHR5cGUsIGVsZW1lbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gW2hhbmRsZXJdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjYXB0dXJlXVxuICogQHBhcmFtIHtib29sZWFufSBbcGFzc2l2ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBjYXB0dXJlLCBwYXNzaXZlKSB7XG5cdHZhciBvcHRpb25zID0geyBjYXB0dXJlLCBwYXNzaXZlIH07XG5cdHZhciB0YXJnZXRfaGFuZGxlciA9IGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG5cdGlmIChcblx0XHRkb20gPT09IGRvY3VtZW50LmJvZHkgfHxcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZG9tID09PSB3aW5kb3cgfHxcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZG9tID09PSBkb2N1bWVudCB8fFxuXHRcdC8vIEZpcmVmb3ggaGFzIHF1aXJreSBiZWhhdmlvciwgaXQgY2FuIGhhcHBlbiB0aGF0IHdlIHN0aWxsIGdldCBcImNhbnBsYXlcIiBldmVudHMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHJlbW92ZWRcblx0XHRkb20gaW5zdGFuY2VvZiBIVE1MTWVkaWFFbGVtZW50XG5cdCkge1xuXHRcdHRlYXJkb3duKCgpID0+IHtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGVnYXRlKGV2ZW50cykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGFsbF9yZWdpc3RlcmVkX2V2ZW50cy5hZGQoZXZlbnRzW2ldKTtcblx0fVxuXG5cdGZvciAodmFyIGZuIG9mIHJvb3RfZXZlbnRfaGFuZGxlcykge1xuXHRcdGZuKGV2ZW50cyk7XG5cdH1cbn1cblxuLy8gdXNlZCB0byBzdG9yZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcHJvcGFnYXRlZCBldmVudFxuLy8gdG8gcHJldmVudCBnYXJiYWdlIGNvbGxlY3Rpb24gYmV0d2VlbiBtaWNyb3Rhc2tzIGluIEZpcmVmb3hcbi8vIElmIHRoZSBldmVudCBvYmplY3QgaXMgR0NlZCB0b28gZWFybHksIHRoZSBleHBhbmRvIF9fcm9vdCBwcm9wZXJ0eVxuLy8gc2V0IG9uIHRoZSBldmVudCBvYmplY3QgaXMgbG9zdCwgY2F1c2luZyB0aGUgZXZlbnQgZGVsZWdhdGlvblxuLy8gdG8gcHJvY2VzcyB0aGUgZXZlbnQgdHdpY2VcbmxldCBsYXN0X3Byb3BhZ2F0ZWRfZXZlbnQgPSBudWxsO1xuXG4vKipcbiAqIEB0aGlzIHtFdmVudFRhcmdldH1cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbihldmVudCkge1xuXHR2YXIgaGFuZGxlcl9lbGVtZW50ID0gdGhpcztcblx0dmFyIG93bmVyX2RvY3VtZW50ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoaGFuZGxlcl9lbGVtZW50KS5vd25lckRvY3VtZW50O1xuXHR2YXIgZXZlbnRfbmFtZSA9IGV2ZW50LnR5cGU7XG5cdHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoPy4oKSB8fCBbXTtcblx0dmFyIGN1cnJlbnRfdGFyZ2V0ID0gLyoqIEB0eXBlIHtudWxsIHwgRWxlbWVudH0gKi8gKHBhdGhbMF0gfHwgZXZlbnQudGFyZ2V0KTtcblxuXHRsYXN0X3Byb3BhZ2F0ZWRfZXZlbnQgPSBldmVudDtcblxuXHQvLyBjb21wb3NlZFBhdGggY29udGFpbnMgbGlzdCBvZiBub2RlcyB0aGUgZXZlbnQgaGFzIHByb3BhZ2F0ZWQgdGhyb3VnaC5cblx0Ly8gV2UgY2hlY2sgX19yb290IHRvIHNraXAgYWxsIG5vZGVzIGJlbG93IGl0IGluIGNhc2UgdGhpcyBpcyBhXG5cdC8vIHBhcmVudCBvZiB0aGUgX19yb290IG5vZGUsIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZXJlJ3MgbmVzdGVkXG5cdC8vIG1vdW50ZWQgYXBwcy4gSW4gdGhpcyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBldmVudHMgbXVsdGlwbGUgdGltZXMuXG5cdHZhciBwYXRoX2lkeCA9IDA7XG5cblx0Ly8gdGhlIGBsYXN0X3Byb3BhZ2F0ZWRfZXZlbnQgPT09IGV2ZW50YCBjaGVjayBpcyByZWR1bmRhbnQsIGJ1dFxuXHQvLyB3aXRob3V0IGl0IHRoZSB2YXJpYWJsZSB3aWxsIGJlIERDRSdkIGFuZCB0aGluZ3Mgd2lsbFxuXHQvLyBmYWlsIG15c3RlcmlvdXNseSBpbiBGaXJlZm94XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgaXMgYWRkZWQgYmVsb3dcblx0dmFyIGhhbmRsZWRfYXQgPSBsYXN0X3Byb3BhZ2F0ZWRfZXZlbnQgPT09IGV2ZW50ICYmIGV2ZW50Ll9fcm9vdDtcblxuXHRpZiAoaGFuZGxlZF9hdCkge1xuXHRcdHZhciBhdF9pZHggPSBwYXRoLmluZGV4T2YoaGFuZGxlZF9hdCk7XG5cdFx0aWYgKFxuXHRcdFx0YXRfaWR4ICE9PSAtMSAmJlxuXHRcdFx0KGhhbmRsZXJfZWxlbWVudCA9PT0gZG9jdW1lbnQgfHwgaGFuZGxlcl9lbGVtZW50ID09PSAvKiogQHR5cGUge2FueX0gKi8gKHdpbmRvdykpXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGlzIGlzIHRoZSBmYWxsYmFjayBkb2N1bWVudCBsaXN0ZW5lciBvciBhIHdpbmRvdyBsaXN0ZW5lciwgYnV0IHRoZSBldmVudCB3YXMgYWxyZWFkeSBoYW5kbGVkXG5cdFx0XHQvLyAtPiBpZ25vcmUsIGJ1dCBzZXQgaGFuZGxlX2F0IHRvIGRvY3VtZW50L3dpbmRvdyBzbyB0aGF0IHdlJ3JlIHJlc2V0dGluZyB0aGUgZXZlbnRcblx0XHRcdC8vIGNoYWluIGluIGNhc2Ugc29tZW9uZSBtYW51YWxseSBkaXNwYXRjaGVzIHRoZSBzYW1lIGV2ZW50IG9iamVjdCBhZ2Fpbi5cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGV2ZW50Ll9fcm9vdCA9IGhhbmRsZXJfZWxlbWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXZSdyZSBkZWxpYmVyYXRlbHkgbm90IHNraXBwaW5nIGlmIHRoZSBpbmRleCBpcyBoaWdoZXIsIGJlY2F1c2Vcblx0XHQvLyBzb21lb25lIGNvdWxkIGNyZWF0ZSBhbiBldmVudCBwcm9ncmFtbWF0aWNhbGx5IGFuZCBlbWl0IGl0IG11bHRpcGxlIHRpbWVzLFxuXHRcdC8vIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBoYW5kbGUgdGhlIHdob2xlIHByb3BhZ2F0aW9uIGNoYWluIHByb3Blcmx5IGVhY2ggdGltZS5cblx0XHQvLyAodGhpcyB3aWxsIG9ubHkgYmUgYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtdWx0aXBsZSB0aW1lcyBhbmRcblx0XHQvLyB0aGUgZmFsbGJhY2sgZG9jdW1lbnQgbGlzdGVuZXIgaXNuJ3QgcmVhY2hlZCBpbiBiZXR3ZWVuLCBidXQgdGhhdCdzIHN1cGVyIHJhcmUpXG5cdFx0dmFyIGhhbmRsZXJfaWR4ID0gcGF0aC5pbmRleE9mKGhhbmRsZXJfZWxlbWVudCk7XG5cdFx0aWYgKGhhbmRsZXJfaWR4ID09PSAtMSkge1xuXHRcdFx0Ly8gaGFuZGxlX2lkeCBjYW4gdGhlb3JldGljYWxseSBiZSAtMSAoaGFwcGVuZWQgaW4gc29tZSBKU0RPTSB0ZXN0aW5nIHNjZW5hcmlvcyB3aXRoIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB3aW5kb3cgb2JqZWN0KVxuXHRcdFx0Ly8gc28gZ3VhcmQgYWdhaW5zdCB0aGF0LCB0b28sIGFuZCBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIHdhcyBoYW5kbGVkIGF0IHRoaXMgcG9pbnQuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGF0X2lkeCA8PSBoYW5kbGVyX2lkeCkge1xuXHRcdFx0cGF0aF9pZHggPSBhdF9pZHg7XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudF90YXJnZXQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChwYXRoW3BhdGhfaWR4XSB8fCBldmVudC50YXJnZXQpO1xuXHQvLyB0aGVyZSBjYW4gb25seSBiZSBvbmUgZGVsZWdhdGVkIGV2ZW50IHBlciBlbGVtZW50LCBhbmQgd2UgZWl0aGVyIGFscmVhZHkgaGFuZGxlZCB0aGUgY3VycmVudCB0YXJnZXQsXG5cdC8vIG9yIHRoaXMgaXMgdGhlIHZlcnkgZmlyc3QgdGFyZ2V0IGluIHRoZSBjaGFpbiB3aGljaCBoYXMgYSBub24tZGVsZWdhdGVkIGxpc3RlbmVyLCBpbiB3aGljaCBjYXNlIGl0J3Mgc2FmZVxuXHQvLyB0byBoYW5kbGUgYSBwb3NzaWJsZSBkZWxlZ2F0ZWQgZXZlbnQgb24gaXQgbGF0ZXIgKHRocm91Z2ggdGhlIHJvb3QgZGVsZWdhdGlvbiBsaXN0ZW5lciBmb3IgZXhhbXBsZSkuXG5cdGlmIChjdXJyZW50X3RhcmdldCA9PT0gaGFuZGxlcl9lbGVtZW50KSByZXR1cm47XG5cblx0Ly8gUHJveHkgY3VycmVudFRhcmdldCB0byBjb3JyZWN0IHRhcmdldFxuXHRkZWZpbmVfcHJvcGVydHkoZXZlbnQsICdjdXJyZW50VGFyZ2V0Jywge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudF90YXJnZXQgfHwgb3duZXJfZG9jdW1lbnQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBUaGlzIHN0YXJ0ZWQgYmVjYXVzZSBvZiBDaHJvbWl1bSBpc3N1ZSBodHRwczovL2Nocm9tZXN0YXR1cy5jb20vZmVhdHVyZS81MTI4Njk2ODIzNTQ1ODU2LFxuXHQvLyB3aGVyZSByZW1vdmFsIG9yIG1vdmluZyBvZiBvZiB0aGUgRE9NIGNhbiBjYXVzZSBzeW5jIGBibHVyYCBldmVudHMgdG8gZmlyZSwgd2hpY2ggY2FuIGNhdXNlIGxvZ2ljXG5cdC8vIHRvIHJ1biBpbnNpZGUgdGhlIGN1cnJlbnQgYGFjdGl2ZV9yZWFjdGlvbmAsIHdoaWNoIGlzbid0IHdoYXQgd2Ugd2FudCBhdCBhbGwuIEhvd2V2ZXIsIG9uIHJlZmxlY3Rpb24sXG5cdC8vIGl0J3MgcHJvYmFibHkgYmVzdCB0aGF0IGFsbCBldmVudCBoYW5kbGVkIGJ5IFN2ZWx0ZSBoYXZlIHRoaXMgYmVoYXZpb3VyLCBhcyB3ZSBkb24ndCByZWFsbHkgd2FudFxuXHQvLyBhbiBldmVudCBoYW5kbGVyIHRvIHJ1biBpbiB0aGUgY29udGV4dCBvZiBhbm90aGVyIHJlYWN0aW9uIG9yIGVmZmVjdC5cblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cblx0dHJ5IHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7dW5rbm93bn1cblx0XHQgKi9cblx0XHR2YXIgdGhyb3dfZXJyb3I7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3Vua25vd25bXX1cblx0XHQgKi9cblx0XHR2YXIgb3RoZXJfZXJyb3JzID0gW107XG5cblx0XHR3aGlsZSAoY3VycmVudF90YXJnZXQgIT09IG51bGwpIHtcblx0XHRcdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdFx0XHR2YXIgcGFyZW50X2VsZW1lbnQgPVxuXHRcdFx0XHRjdXJyZW50X3RhcmdldC5hc3NpZ25lZFNsb3QgfHxcblx0XHRcdFx0Y3VycmVudF90YXJnZXQucGFyZW50Tm9kZSB8fFxuXHRcdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5ob3N0IHx8XG5cdFx0XHRcdG51bGw7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0dmFyIGRlbGVnYXRlZCA9IGN1cnJlbnRfdGFyZ2V0WydfXycgKyBldmVudF9uYW1lXTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZGVsZWdhdGVkICE9IG51bGwgJiZcblx0XHRcdFx0XHQoISgvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5kaXNhYmxlZCkgfHxcblx0XHRcdFx0XHRcdC8vIERPTSBjb3VsZCd2ZSBiZWVuIHVwZGF0ZWQgYWxyZWFkeSBieSB0aGUgdGltZSB0aGlzIGlzIHJlYWNoZWQsIHNvIHdlIGNoZWNrIHRoaXMgYXMgd2VsbFxuXHRcdFx0XHRcdFx0Ly8gLT4gdGhlIHRhcmdldCBjb3VsZCBub3QgaGF2ZSBiZWVuIGRpc2FibGVkIGJlY2F1c2UgaXQgZW1pdHMgdGhlIGV2ZW50IGluIHRoZSBmaXJzdCBwbGFjZVxuXHRcdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ID09PSBjdXJyZW50X3RhcmdldClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZGVsZWdhdGVkLmNhbGwoY3VycmVudF90YXJnZXQsIGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKHRocm93X2Vycm9yKSB7XG5cdFx0XHRcdFx0b3RoZXJfZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93X2Vycm9yID0gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChldmVudC5jYW5jZWxCdWJibGUgfHwgcGFyZW50X2VsZW1lbnQgPT09IGhhbmRsZXJfZWxlbWVudCB8fCBwYXJlbnRfZWxlbWVudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGN1cnJlbnRfdGFyZ2V0ID0gcGFyZW50X2VsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHRocm93X2Vycm9yKSB7XG5cdFx0XHRmb3IgKGxldCBlcnJvciBvZiBvdGhlcl9lcnJvcnMpIHtcblx0XHRcdFx0Ly8gVGhyb3cgdGhlIHJlc3Qgb2YgdGhlIGVycm9ycywgb25lLWJ5LW9uZSBvbiBhIG1pY3JvdGFza1xuXHRcdFx0XHRxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgdGhyb3dfZXJyb3I7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgaXMgdXNlZCBhYm92ZVxuXHRcdGV2ZW50Ll9fcm9vdCA9IGhhbmRsZXJfZWxlbWVudDtcblx0XHQvLyBAdHMtaWdub3JlIHJlbW92ZSBwcm94eSBvbiBjdXJyZW50VGFyZ2V0XG5cdFx0ZGVsZXRlIGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIEluIGRldiwgd2FybiBpZiBhbiBldmVudCBoYW5kbGVyIGlzIG5vdCBhIGZ1bmN0aW9uLCBhcyBpdCBtZWFucyB0aGVcbiAqIHVzZXIgcHJvYmFibHkgY2FsbGVkIHRoZSBoYW5kbGVyIG9yIGZvcmdvdCB0byBhZGQgYSBgKCkgPT5gXG4gKiBAcGFyYW0geygpID0+IChldmVudDogRXZlbnQsIC4uLmFyZ3M6IGFueSkgPT4gdm9pZH0gdGh1bmtcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7W0V2ZW50LCAuLi5hbnldfSBhcmdzXG4gKiBAcGFyYW0ge2FueX0gY29tcG9uZW50XG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IFtsb2NdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVfcGFyZW5zXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkoXG5cdHRodW5rLFxuXHRlbGVtZW50LFxuXHRhcmdzLFxuXHRjb21wb25lbnQsXG5cdGxvYyxcblx0aGFzX3NpZGVfZWZmZWN0cyA9IGZhbHNlLFxuXHRyZW1vdmVfcGFyZW5zID0gZmFsc2Vcbikge1xuXHRsZXQgaGFuZGxlcjtcblx0bGV0IGVycm9yO1xuXG5cdHRyeSB7XG5cdFx0aGFuZGxlciA9IHRodW5rKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRlcnJvciA9IGU7XG5cdH1cblxuXHRpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicgJiYgKGhhc19zaWRlX2VmZmVjdHMgfHwgaGFuZGxlciAhPSBudWxsIHx8IGVycm9yKSkge1xuXHRcdGNvbnN0IGZpbGVuYW1lID0gY29tcG9uZW50Py5bRklMRU5BTUVdO1xuXHRcdGNvbnN0IGxvY2F0aW9uID0gbG9jID8gYCBhdCAke2ZpbGVuYW1lfToke2xvY1swXX06JHtsb2NbMV19YCA6IGAgaW4gJHtmaWxlbmFtZX1gO1xuXHRcdGNvbnN0IHBoYXNlID0gYXJnc1swXT8uZXZlbnRQaGFzZSA8IEV2ZW50LkJVQkJMSU5HX1BIQVNFID8gJ2NhcHR1cmUnIDogJyc7XG5cdFx0Y29uc3QgZXZlbnRfbmFtZSA9IGFyZ3NbMF0/LnR5cGUgKyBwaGFzZTtcblx0XHRjb25zdCBkZXNjcmlwdGlvbiA9IGBcXGAke2V2ZW50X25hbWV9XFxgIGhhbmRsZXIke2xvY2F0aW9ufWA7XG5cdFx0Y29uc3Qgc3VnZ2VzdGlvbiA9IHJlbW92ZV9wYXJlbnMgPyAncmVtb3ZlIHRoZSB0cmFpbGluZyBgKClgJyA6ICdhZGQgYSBsZWFkaW5nIGAoKSA9PmAnO1xuXG5cdFx0dy5ldmVudF9oYW5kbGVyX2ludmFsaWQoZGVzY3JpcHRpb24sIHN1Z2dlc3Rpb24pO1xuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0aGFuZGxlcj8uYXBwbHkoZWxlbWVudCwgYXJncyk7XG59XG4iLCAiLyoqIEBwYXJhbSB7c3RyaW5nfSBodG1sICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChodG1sKSB7XG5cdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblx0ZWxlbS5pbm5lckhUTUwgPSBodG1sLnJlcGxhY2VBbGwoJzwhPicsICc8IS0tLS0+Jyk7IC8vIFhIVE1MIGNvbXBsaWFuY2Vcblx0cmV0dXJuIGVsZW0uY29udGVudDtcbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVTdHJ1Y3R1cmUgfSBmcm9tICcuL3R5cGVzJyAqL1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZywgc2V0X2h5ZHJhdGVfbm9kZSB9IGZyb20gJy4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7XG5cdGNyZWF0ZV90ZXh0LFxuXHRnZXRfZmlyc3RfY2hpbGQsXG5cdGlzX2ZpcmVmb3gsXG5cdGNyZWF0ZV9lbGVtZW50LFxuXHRjcmVhdGVfZnJhZ21lbnQsXG5cdGNyZWF0ZV9jb21tZW50LFxuXHRzZXRfYXR0cmlidXRlXG59IGZyb20gJy4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sIH0gZnJvbSAnLi9yZWNvbmNpbGVyLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7XG5cdE5BTUVTUEFDRV9NQVRITUwsXG5cdE5BTUVTUEFDRV9TVkcsXG5cdFRFTVBMQVRFX0ZSQUdNRU5ULFxuXHRURU1QTEFURV9VU0VfSU1QT1JUX05PREUsXG5cdFRFTVBMQVRFX1VTRV9NQVRITUwsXG5cdFRFTVBMQVRFX1VTRV9TVkdcbn0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IENPTU1FTlRfTk9ERSwgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSwgRUZGRUNUX1JBTiwgVEVYVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBzdGFydFxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSBlbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbl9ub2RlcyhzdGFydCwgZW5kKSB7XG5cdHZhciBlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXHRpZiAoZWZmZWN0Lm5vZGVzX3N0YXJ0ID09PSBudWxsKSB7XG5cdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID0gc3RhcnQ7XG5cdFx0ZWZmZWN0Lm5vZGVzX2VuZCA9IGVuZDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tX2h0bWwoY29udGVudCwgZmxhZ3MpIHtcblx0dmFyIGlzX2ZyYWdtZW50ID0gKGZsYWdzICYgVEVNUExBVEVfRlJBR01FTlQpICE9PSAwO1xuXHR2YXIgdXNlX2ltcG9ydF9ub2RlID0gKGZsYWdzICYgVEVNUExBVEVfVVNFX0lNUE9SVF9OT0RFKSAhPT0gMDtcblxuXHQvKiogQHR5cGUge05vZGV9ICovXG5cdHZhciBub2RlO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZmlyc3QgaXRlbSBpcyBhIHRleHQvZWxlbWVudCBub2RlLiBJZiBub3QsIHdlIG5lZWQgdG9cblx0ICogY3JlYXRlIGFuIGFkZGl0aW9uYWwgY29tbWVudCBub2RlIHRvIGFjdCBhcyBgZWZmZWN0Lm5vZGVzLnN0YXJ0YFxuXHQgKi9cblx0dmFyIGhhc19zdGFydCA9ICFjb250ZW50LnN0YXJ0c1dpdGgoJzwhPicpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0XHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xuXHRcdH1cblxuXHRcdGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdG5vZGUgPSBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGhhc19zdGFydCA/IGNvbnRlbnQgOiAnPCE+JyArIGNvbnRlbnQpO1xuXHRcdFx0aWYgKCFpc19mcmFnbWVudCkgbm9kZSA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNsb25lID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChcblx0XHRcdHVzZV9pbXBvcnRfbm9kZSB8fCBpc19maXJlZm94ID8gZG9jdW1lbnQuaW1wb3J0Tm9kZShub2RlLCB0cnVlKSA6IG5vZGUuY2xvbmVOb2RlKHRydWUpXG5cdFx0KTtcblxuXHRcdGlmIChpc19mcmFnbWVudCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQoY2xvbmUpKTtcblx0XHRcdHZhciBlbmQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGNsb25lLmxhc3RDaGlsZCk7XG5cblx0XHRcdGFzc2lnbl9ub2RlcyhzdGFydCwgZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXNzaWduX25vZGVzKGNsb25lLCBjbG9uZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7J3N2ZycgfCAnbWF0aCd9IG5zXG4gKiBAcmV0dXJucyB7KCkgPT4gTm9kZSB8IE5vZGVbXX1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBmcm9tX25hbWVzcGFjZShjb250ZW50LCBmbGFncywgbnMgPSAnc3ZnJykge1xuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGZpcnN0IGl0ZW0gaXMgYSB0ZXh0L2VsZW1lbnQgbm9kZS4gSWYgbm90LCB3ZSBuZWVkIHRvXG5cdCAqIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbW1lbnQgbm9kZSB0byBhY3QgYXMgYGVmZmVjdC5ub2Rlcy5zdGFydGBcblx0ICovXG5cdHZhciBoYXNfc3RhcnQgPSAhY29udGVudC5zdGFydHNXaXRoKCc8IT4nKTtcblxuXHR2YXIgaXNfZnJhZ21lbnQgPSAoZmxhZ3MgJiBURU1QTEFURV9GUkFHTUVOVCkgIT09IDA7XG5cdHZhciB3cmFwcGVkID0gYDwke25zfT4ke2hhc19zdGFydCA/IGNvbnRlbnQgOiAnPCE+JyArIGNvbnRlbnR9PC8ke25zfT5gO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9ICovXG5cdHZhciBub2RlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0XHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xuXHRcdH1cblxuXHRcdGlmICghbm9kZSkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLyAoY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCh3cmFwcGVkKSk7XG5cdFx0XHR2YXIgcm9vdCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChmcmFnbWVudCkpO1xuXG5cdFx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0d2hpbGUgKGdldF9maXJzdF9jaGlsZChyb290KSkge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHJvb3QpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQocm9vdCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tX3N2Zyhjb250ZW50LCBmbGFncykge1xuXHRyZXR1cm4gZnJvbV9uYW1lc3BhY2UoY29udGVudCwgZmxhZ3MsICdzdmcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21fbWF0aG1sKGNvbnRlbnQsIGZsYWdzKSB7XG5cdHJldHVybiBmcm9tX25hbWVzcGFjZShjb250ZW50LCBmbGFncywgJ21hdGgnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RlbXBsYXRlU3RydWN0dXJlW119IHN0cnVjdHVyZVxuICogQHBhcmFtIHt0eXBlb2YgTkFNRVNQQUNFX1NWRyB8IHR5cGVvZiBOQU1FU1BBQ0VfTUFUSE1MIHwgdW5kZWZpbmVkfSBbbnNdXG4gKi9cbmZ1bmN0aW9uIGZyYWdtZW50X2Zyb21fdHJlZShzdHJ1Y3R1cmUsIG5zKSB7XG5cdHZhciBmcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCgpO1xuXG5cdGZvciAodmFyIGl0ZW0gb2Ygc3RydWN0dXJlKSB7XG5cdFx0aWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kKGNyZWF0ZV90ZXh0KGl0ZW0pKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdC8vIGlmIGBwcmVzZXJ2ZUNvbW1lbnRzID09PSB0cnVlYCwgY29tbWVudHMgYXJlIHJlcHJlc2VudGVkIGFzIGBbJy8vIDxkYXRhPiddYFxuXHRcdGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgaXRlbVswXVswXSA9PT0gJy8nKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmQoY3JlYXRlX2NvbW1lbnQoaXRlbSA/IGl0ZW1bMF0uc2xpY2UoMykgOiAnJykpO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29uc3QgW25hbWUsIGF0dHJpYnV0ZXMsIC4uLmNoaWxkcmVuXSA9IGl0ZW07XG5cblx0XHRjb25zdCBuYW1lc3BhY2UgPSBuYW1lID09PSAnc3ZnJyA/IE5BTUVTUEFDRV9TVkcgOiBuYW1lID09PSAnbWF0aCcgPyBOQU1FU1BBQ0VfTUFUSE1MIDogbnM7XG5cblx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZV9lbGVtZW50KG5hbWUsIG5hbWVzcGFjZSwgYXR0cmlidXRlcz8uaXMpO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdHNldF9hdHRyaWJ1dGUoZWxlbWVudCwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHRcdH1cblxuXHRcdGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID1cblx0XHRcdFx0ZWxlbWVudC50YWdOYW1lID09PSAnVEVNUExBVEUnXG5cdFx0XHRcdFx0PyAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovIChlbGVtZW50KS5jb250ZW50XG5cdFx0XHRcdFx0OiBlbGVtZW50O1xuXG5cdFx0XHR0YXJnZXQuYXBwZW5kKFxuXHRcdFx0XHRmcmFnbWVudF9mcm9tX3RyZWUoY2hpbGRyZW4sIGVsZW1lbnQudGFnTmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRmcmFnbWVudC5hcHBlbmQoZWxlbWVudCk7XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZVN0cnVjdHVyZVtdfSBzdHJ1Y3R1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21fdHJlZShzdHJ1Y3R1cmUsIGZsYWdzKSB7XG5cdHZhciBpc19mcmFnbWVudCA9IChmbGFncyAmIFRFTVBMQVRFX0ZSQUdNRU5UKSAhPT0gMDtcblx0dmFyIHVzZV9pbXBvcnRfbm9kZSA9IChmbGFncyAmIFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHtOb2RlfSAqL1xuXHR2YXIgbm9kZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdFx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cblx0XHRpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBucyA9XG5cdFx0XHRcdChmbGFncyAmIFRFTVBMQVRFX1VTRV9TVkcpICE9PSAwXG5cdFx0XHRcdFx0PyBOQU1FU1BBQ0VfU1ZHXG5cdFx0XHRcdFx0OiAoZmxhZ3MgJiBURU1QTEFURV9VU0VfTUFUSE1MKSAhPT0gMFxuXHRcdFx0XHRcdFx0PyBOQU1FU1BBQ0VfTUFUSE1MXG5cdFx0XHRcdFx0XHQ6IHVuZGVmaW5lZDtcblxuXHRcdFx0bm9kZSA9IGZyYWdtZW50X2Zyb21fdHJlZShzdHJ1Y3R1cmUsIG5zKTtcblx0XHRcdGlmICghaXNfZnJhZ21lbnQpIG5vZGUgPSAvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpO1xuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoXG5cdFx0XHR1c2VfaW1wb3J0X25vZGUgfHwgaXNfZmlyZWZveCA/IGRvY3VtZW50LmltcG9ydE5vZGUobm9kZSwgdHJ1ZSkgOiBub2RlLmNsb25lTm9kZSh0cnVlKVxuXHRcdCk7XG5cblx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdHZhciBzdGFydCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGNsb25lKSk7XG5cdFx0XHR2YXIgZW5kID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjbG9uZS5sYXN0Q2hpbGQpO1xuXG5cdFx0XHRhc3NpZ25fbm9kZXMoc3RhcnQsIGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhjbG9uZSwgY2xvbmUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbG9uZTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IEVsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aF9zY3JpcHQoZm4pIHtcblx0cmV0dXJuICgpID0+IHJ1bl9zY3JpcHRzKGZuKCkpO1xufVxuXG4vKipcbiAqIENyZWF0aW5nIGEgZG9jdW1lbnQgZnJhZ21lbnQgZnJvbSBIVE1MIHRoYXQgY29udGFpbnMgc2NyaXB0IHRhZ3Mgd2lsbCBub3QgZXhlY3V0ZVxuICogdGhlIHNjcmlwdHMuIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgc2NyaXB0IHRhZ3Mgd2l0aCBuZXcgb25lcyBzbyB0aGF0IHRoZXkgYXJlIGV4ZWN1dGVkLlxuICogQHBhcmFtIHtFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBOb2RlW119XG4gKi9cbmZ1bmN0aW9uIHJ1bl9zY3JpcHRzKG5vZGUpIHtcblx0Ly8gc2NyaXB0cyB3ZXJlIFNTUidkLCBpbiB3aGljaCBjYXNlIHRoZXkgd2lsbCBydW5cblx0aWYgKGh5ZHJhdGluZykgcmV0dXJuIG5vZGU7XG5cblx0Y29uc3QgaXNfZnJhZ21lbnQgPSBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuXHRjb25zdCBzY3JpcHRzID1cblx0XHQvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSkudGFnTmFtZSA9PT0gJ1NDUklQVCdcblx0XHRcdD8gWy8qKiBAdHlwZSB7SFRNTFNjcmlwdEVsZW1lbnR9ICovIChub2RlKV1cblx0XHRcdDogbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcblx0Y29uc3QgZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHRmb3IgKGNvbnN0IHNjcmlwdCBvZiBzY3JpcHRzKSB7XG5cdFx0Y29uc3QgY2xvbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRmb3IgKHZhciBhdHRyaWJ1dGUgb2Ygc2NyaXB0LmF0dHJpYnV0ZXMpIHtcblx0XHRcdGNsb25lLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcblx0XHR9XG5cblx0XHRjbG9uZS50ZXh0Q29udGVudCA9IHNjcmlwdC50ZXh0Q29udGVudDtcblxuXHRcdC8vIFRoZSBzY3JpcHQgaGFzIGNoYW5nZWQgLSBpZiBpdCdzIGF0IHRoZSBlZGdlcywgdGhlIGVmZmVjdCBub3cgcG9pbnRzIGF0IGRlYWQgbm9kZXNcblx0XHRpZiAoaXNfZnJhZ21lbnQgPyBub2RlLmZpcnN0Q2hpbGQgPT09IHNjcmlwdCA6IG5vZGUgPT09IHNjcmlwdCkge1xuXHRcdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID0gY2xvbmU7XG5cdFx0fVxuXHRcdGlmIChpc19mcmFnbWVudCA/IG5vZGUubGFzdENoaWxkID09PSBzY3JpcHQgOiBub2RlID09PSBzY3JpcHQpIHtcblx0XHRcdGVmZmVjdC5ub2Rlc19lbmQgPSBjbG9uZTtcblx0XHR9XG5cblx0XHRzY3JpcHQucmVwbGFjZVdpdGgoY2xvbmUpO1xuXHR9XG5cdHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIERvbid0IG1hcmsgdGhpcyBhcyBzaWRlLWVmZmVjdC1mcmVlLCBoeWRyYXRpb24gbmVlZHMgdG8gd2FsayBhbGwgbm9kZXNcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dCh2YWx1ZSA9ICcnKSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0dmFyIHQgPSBjcmVhdGVfdGV4dCh2YWx1ZSArICcnKTtcblx0XHRhc3NpZ25fbm9kZXModCwgdCk7XG5cdFx0cmV0dXJuIHQ7XG5cdH1cblxuXHR2YXIgbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHRpZiAobm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG5cdFx0Ly8gaWYgYW4ge2V4cHJlc3Npb259IGlzIGVtcHR5IGR1cmluZyBTU1IsIHdlIG5lZWQgdG8gaW5zZXJ0IGFuIGVtcHR5IHRleHQgbm9kZVxuXHRcdG5vZGUuYmVmb3JlKChub2RlID0gY3JlYXRlX3RleHQoKSkpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUobm9kZSk7XG5cdH1cblxuXHRhc3NpZ25fbm9kZXMobm9kZSwgbm9kZSk7XG5cdHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZW1wbGF0ZU5vZGUgfCBEb2N1bWVudEZyYWdtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWVudCgpIHtcblx0Ly8gd2UncmUgbm90IGRlbGVnYXRpbmcgdG8gYHRlbXBsYXRlYCBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBudWxsKTtcblx0XHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xuXHR9XG5cblx0dmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdHZhciBzdGFydCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpO1xuXHR2YXIgYW5jaG9yID0gY3JlYXRlX3RleHQoKTtcblx0ZnJhZy5hcHBlbmQoc3RhcnQsIGFuY2hvcik7XG5cblx0YXNzaWduX25vZGVzKHN0YXJ0LCBhbmNob3IpO1xuXG5cdHJldHVybiBmcmFnO1xufVxuXG4vKipcbiAqIEFzc2lnbiB0aGUgY3JlYXRlZCAob3IgaW4gaHlkcmF0aW9uIG1vZGUsIHRyYXZlcnNlZCkgZG9tIGVsZW1lbnRzIHRvIHRoZSBjdXJyZW50IGJsb2NrXG4gKiBhbmQgaW5zZXJ0IHRoZSBlbGVtZW50cyBpbnRvIHRoZSBkb20gKGluIGNsaWVudCBtb2RlKS5cbiAqIEBwYXJhbSB7VGV4dCB8IENvbW1lbnQgfCBFbGVtZW50fSBhbmNob3JcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudCB8IEVsZW1lbnR9IGRvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kKGFuY2hvciwgZG9tKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHR2YXIgZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblx0XHQvLyBXaGVuIGh5ZHJhdGluZyBhbmQgb3V0ZXIgY29tcG9uZW50IGFuZCBhbiBpbm5lciBjb21wb25lbnQgaXMgYXN5bmMsIGkuZS4gYmxvY2tlZCBvbiBhIHByb21pc2UsXG5cdFx0Ly8gdGhlbiBieSB0aGUgdGltZSB0aGUgaW5uZXIgcmVzb2x2ZXMgd2UgaGF2ZSBhbHJlYWR5IGFkdmFuY2VkIHRvIHRoZSBlbmQgb2YgdGhlIGh5ZHJhdGVkIG5vZGVzXG5cdFx0Ly8gb2YgdGhlIHBhcmVudCBjb21wb25lbnQuIENoZWNrIGZvciBkZWZpbmVkIGZvciB0aGF0IHJlYXNvbiB0byBhdm9pZCByZXdpbmRpbmcgdGhlIHBhcmVudCdzIGVuZCBtYXJrZXIuXG5cdFx0aWYgKChlZmZlY3QuZiAmIEVGRkVDVF9SQU4pID09PSAwIHx8IGVmZmVjdC5ub2Rlc19lbmQgPT09IG51bGwpIHtcblx0XHRcdGVmZmVjdC5ub2Rlc19lbmQgPSBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChhbmNob3IgPT09IG51bGwpIHtcblx0XHQvLyBlZGdlIGNhc2UgXHUyMDE0IHZvaWQgYDxzdmVsdGU6ZWxlbWVudD5gIHdpdGggY29udGVudFxuXHRcdHJldHVybjtcblx0fVxuXG5cdGFuY2hvci5iZWZvcmUoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZG9tKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIChvciBoeWRyYXRlKSBhbiB1bmlxdWUgVUlEIGZvciB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcHNfaWQoKSB7XG5cdGlmIChcblx0XHRoeWRyYXRpbmcgJiZcblx0XHRoeWRyYXRlX25vZGUgJiZcblx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJlxuXHRcdGh5ZHJhdGVfbm9kZS50ZXh0Q29udGVudD8uc3RhcnRzV2l0aChgJGApXG5cdCkge1xuXHRcdGNvbnN0IGlkID0gaHlkcmF0ZV9ub2RlLnRleHRDb250ZW50LnN1YnN0cmluZygxKTtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0XHRyZXR1cm4gaWQ7XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgd2F5IHdlIGVuc3VyZSB0aGUgaWQgaXMgdW5pcXVlIGV2ZW4gYWNyb3NzIFN2ZWx0ZSBydW50aW1lc1xuXHQod2luZG93Ll9fc3ZlbHRlID8/PSB7fSkudWlkID8/PSAxO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIGBjJHt3aW5kb3cuX19zdmVsdGUudWlkKyt9YDtcbn1cbiIsICIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRUeXBlLCBTdmVsdGVDb21wb25lbnQsIE1vdW50T3B0aW9ucyB9IGZyb20gJy4uLy4uL2luZGV4LmpzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRjbGVhcl90ZXh0X2NvbnRlbnQsXG5cdGNyZWF0ZV90ZXh0LFxuXHRnZXRfZmlyc3RfY2hpbGQsXG5cdGdldF9uZXh0X3NpYmxpbmcsXG5cdGluaXRfb3BlcmF0aW9uc1xufSBmcm9tICcuL2RvbS9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IEhZRFJBVElPTl9FTkQsIEhZRFJBVElPTl9FUlJPUiwgSFlEUkFUSU9OX1NUQVJUIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgcHVzaCwgcG9wLCBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfcm9vdCB9IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlLCBzZXRfaHlkcmF0aW5nIH0gZnJvbSAnLi9kb20vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGFycmF5X2Zyb20gfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWxsX3JlZ2lzdGVyZWRfZXZlbnRzLFxuXHRoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sXG5cdHJvb3RfZXZlbnRfaGFuZGxlc1xufSBmcm9tICcuL2RvbS9lbGVtZW50cy9ldmVudHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi9kb20vdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgaXNfcGFzc2l2ZV9ldmVudCB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IENPTU1FTlRfTk9ERSwgU1RBVEVfU1lNQk9MIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYm91bmRhcnkgfSBmcm9tICcuL2RvbS9ibG9ja3MvYm91bmRhcnkuanMnO1xuXG4vKipcbiAqIFRoaXMgaXMgbm9ybWFsbHkgdHJ1ZSBcdTIwMTQgYmxvY2sgZWZmZWN0cyBzaG91bGQgcnVuIHRoZWlyIGludHJvIHRyYW5zaXRpb25zIFx1MjAxNFxuICogYnV0IGlzIGZhbHNlIGR1cmluZyBoeWRyYXRpb24gKHVubGVzcyBgb3B0aW9ucy5pbnRyb2AgaXMgYHRydWVgKSBhbmRcbiAqIHdoZW4gY3JlYXRpbmcgdGhlIGNoaWxkcmVuIG9mIGEgYDxzdmVsdGU6ZWxlbWVudD5gIHRoYXQganVzdCBjaGFuZ2VkIHRhZ1xuICovXG5leHBvcnQgbGV0IHNob3VsZF9pbnRybyA9IHRydWU7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3Nob3VsZF9pbnRybyh2YWx1ZSkge1xuXHRzaG91bGRfaW50cm8gPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfdGV4dCh0ZXh0LCB2YWx1ZSkge1xuXHQvLyBGb3Igb2JqZWN0cywgd2UgYXBwbHkgc3RyaW5nIGNvZXJjaW9uICh3aGljaCBtaWdodCBtYWtlIHRoaW5ncyBsaWtlICRzdGF0ZSBhcnJheSByZWZlcmVuY2VzIGluIHRoZSB0ZW1wbGF0ZSByZWFjdGl2ZSkgYmVmb3JlIGRpZmZpbmdcblx0dmFyIHN0ciA9IHZhbHVlID09IG51bGwgPyAnJyA6IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSArICcnIDogdmFsdWU7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0aWYgKHN0ciAhPT0gKHRleHQuX190ID8/PSB0ZXh0Lm5vZGVWYWx1ZSkpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0dGV4dC5fX3QgPSBzdHI7XG5cdFx0dGV4dC5ub2RlVmFsdWUgPSBzdHIgKyAnJztcblx0fVxufVxuXG4vKipcbiAqIE1vdW50cyBhIGNvbXBvbmVudCB0byB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCByZXR1cm5zIHRoZSBleHBvcnRzIGFuZCBwb3RlbnRpYWxseSB0aGUgcHJvcHMgKGlmIGNvbXBpbGVkIHdpdGggYGFjY2Vzc29yczogdHJ1ZWApIG9mIHRoZSBjb21wb25lbnQuXG4gKiBUcmFuc2l0aW9ucyB3aWxsIHBsYXkgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciB1bmxlc3MgdGhlIGBpbnRyb2Agb3B0aW9uIGlzIHNldCB0byBgZmFsc2VgLlxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxQcm9wcz4+IHwgQ29tcG9uZW50PFByb3BzLCBFeHBvcnRzLCBhbnk+fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TW91bnRPcHRpb25zPFByb3BzPn0gb3B0aW9uc1xuICogQHJldHVybnMge0V4cG9ydHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb3VudChjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0cmV0dXJuIF9tb3VudChjb21wb25lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEh5ZHJhdGVzIGEgY29tcG9uZW50IG9uIHRoZSBnaXZlbiB0YXJnZXQgYW5kIHJldHVybnMgdGhlIGV4cG9ydHMgYW5kIHBvdGVudGlhbGx5IHRoZSBwcm9wcyAoaWYgY29tcGlsZWQgd2l0aCBgYWNjZXNzb3JzOiB0cnVlYCkgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxQcm9wcz4+IHwgQ29tcG9uZW50PFByb3BzLCBFeHBvcnRzLCBhbnk+fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7e30gZXh0ZW5kcyBQcm9wcyA/IHtcbiAqIFx0XHR0YXJnZXQ6IERvY3VtZW50IHwgRWxlbWVudCB8IFNoYWRvd1Jvb3Q7XG4gKiBcdFx0cHJvcHM/OiBQcm9wcztcbiAqIFx0XHRldmVudHM/OiBSZWNvcmQ8c3RyaW5nLCAoZTogYW55KSA9PiBhbnk+O1xuICogIFx0Y29udGV4dD86IE1hcDxhbnksIGFueT47XG4gKiBcdFx0aW50cm8/OiBib29sZWFuO1xuICogXHRcdHJlY292ZXI/OiBib29sZWFuO1xuICogXHR9IDoge1xuICogXHRcdHRhcmdldDogRG9jdW1lbnQgfCBFbGVtZW50IHwgU2hhZG93Um9vdDtcbiAqIFx0XHRwcm9wczogUHJvcHM7XG4gKiBcdFx0ZXZlbnRzPzogUmVjb3JkPHN0cmluZywgKGU6IGFueSkgPT4gYW55PjtcbiAqICBcdGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+O1xuICogXHRcdGludHJvPzogYm9vbGVhbjtcbiAqIFx0XHRyZWNvdmVyPzogYm9vbGVhbjtcbiAqIFx0fX0gb3B0aW9uc1xuICogQHJldHVybnMge0V4cG9ydHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRpbml0X29wZXJhdGlvbnMoKTtcblx0b3B0aW9ucy5pbnRybyA9IG9wdGlvbnMuaW50cm8gPz8gZmFsc2U7XG5cdGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuXHRjb25zdCB3YXNfaHlkcmF0aW5nID0gaHlkcmF0aW5nO1xuXHRjb25zdCBwcmV2aW91c19oeWRyYXRlX25vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0dHJ5IHtcblx0XHR2YXIgYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQodGFyZ2V0KSk7XG5cdFx0d2hpbGUgKFxuXHRcdFx0YW5jaG9yICYmXG5cdFx0XHQoYW5jaG9yLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgfHwgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKS5kYXRhICE9PSBIWURSQVRJT05fU1RBUlQpXG5cdFx0KSB7XG5cdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoYW5jaG9yKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFhbmNob3IpIHtcblx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHR9XG5cblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKSk7XG5cblx0XHRjb25zdCBpbnN0YW5jZSA9IF9tb3VudChjb21wb25lbnQsIHsgLi4ub3B0aW9ucywgYW5jaG9yIH0pO1xuXG5cdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cblx0XHRyZXR1cm4gLyoqICBAdHlwZSB7RXhwb3J0c30gKi8gKGluc3RhbmNlKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyByZS10aHJvdyBTdmVsdGUgZXJyb3JzIC0gdGhleSBhcmUgY2VydGFpbmx5IG5vdCByZWxhdGVkIHRvIGh5ZHJhdGlvblxuXHRcdGlmIChcblx0XHRcdGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcblx0XHRcdGVycm9yLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLnNvbWUoKGxpbmUpID0+IGxpbmUuc3RhcnRzV2l0aCgnaHR0cHM6Ly9zdmVsdGUuZGV2L2UvJykpXG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdFx0aWYgKGVycm9yICE9PSBIWURSQVRJT05fRVJST1IpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBoeWRyYXRlOiAnLCBlcnJvcik7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMucmVjb3ZlciA9PT0gZmFsc2UpIHtcblx0XHRcdGUuaHlkcmF0aW9uX2ZhaWxlZCgpO1xuXHRcdH1cblxuXHRcdC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGFib3ZlLCB0aGUgb3BlcmF0aW9ucyBtaWdodCBub3QgeWV0IGhhdmUgYmVlbiBpbml0aWFsaXNlZC5cblx0XHRpbml0X29wZXJhdGlvbnMoKTtcblx0XHRjbGVhcl90ZXh0X2NvbnRlbnQodGFyZ2V0KTtcblxuXHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdHJldHVybiBtb3VudChjb21wb25lbnQsIG9wdGlvbnMpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNldF9oeWRyYXRpbmcod2FzX2h5ZHJhdGluZyk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShwcmV2aW91c19oeWRyYXRlX25vZGUpO1xuXHR9XG59XG5cbi8qKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gKi9cbmNvbnN0IGRvY3VtZW50X2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV4cG9ydHNcbiAqIEBwYXJhbSB7Q29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8YW55Pj4gfCBDb21wb25lbnQ8YW55Pn0gQ29tcG9uZW50XG4gKiBAcGFyYW0ge01vdW50T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0V4cG9ydHN9XG4gKi9cbmZ1bmN0aW9uIF9tb3VudChDb21wb25lbnQsIHsgdGFyZ2V0LCBhbmNob3IsIHByb3BzID0ge30sIGV2ZW50cywgY29udGV4dCwgaW50cm8gPSB0cnVlIH0pIHtcblx0aW5pdF9vcGVyYXRpb25zKCk7XG5cblx0LyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cblx0dmFyIHJlZ2lzdGVyZWRfZXZlbnRzID0gbmV3IFNldCgpO1xuXG5cdC8qKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV2ZW50cyAqL1xuXHR2YXIgZXZlbnRfaGFuZGxlID0gKGV2ZW50cykgPT4ge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZXZlbnRfbmFtZSA9IGV2ZW50c1tpXTtcblxuXHRcdFx0aWYgKHJlZ2lzdGVyZWRfZXZlbnRzLmhhcyhldmVudF9uYW1lKSkgY29udGludWU7XG5cdFx0XHRyZWdpc3RlcmVkX2V2ZW50cy5hZGQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdHZhciBwYXNzaXZlID0gaXNfcGFzc2l2ZV9ldmVudChldmVudF9uYW1lKTtcblxuXHRcdFx0Ly8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciB0byBib3RoIHRoZSBjb250YWluZXIgYW5kIHRoZSBkb2N1bWVudC5cblx0XHRcdC8vIFRoZSBjb250YWluZXIgbGlzdGVuZXIgZW5zdXJlcyB3ZSBjYXRjaCBldmVudHMgZnJvbSB3aXRoaW4gaW4gY2FzZVxuXHRcdFx0Ly8gdGhlIG91dGVyIGNvbnRlbnQgc3RvcHMgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LlxuXHRcdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uLCB7IHBhc3NpdmUgfSk7XG5cblx0XHRcdHZhciBuID0gZG9jdW1lbnRfbGlzdGVuZXJzLmdldChldmVudF9uYW1lKTtcblxuXHRcdFx0aWYgKG4gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBUaGUgZG9jdW1lbnQgbGlzdGVuZXIgZW5zdXJlcyB3ZSBjYXRjaCBldmVudHMgdGhhdCBvcmlnaW5hdGUgZnJvbSBlbGVtZW50cyB0aGF0IHdlcmVcblx0XHRcdFx0Ly8gbWFudWFsbHkgbW92ZWQgb3V0c2lkZSBvZiB0aGUgY29udGFpbmVyIChlLmcuIHZpYSBtYW51YWwgcG9ydGFscykuXG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uLCB7IHBhc3NpdmUgfSk7XG5cdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuc2V0KGV2ZW50X25hbWUsIG4gKyAxKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZXZlbnRfaGFuZGxlKGFycmF5X2Zyb20oYWxsX3JlZ2lzdGVyZWRfZXZlbnRzKSk7XG5cdHJvb3RfZXZlbnRfaGFuZGxlcy5hZGQoZXZlbnRfaGFuZGxlKTtcblxuXHQvKiogQHR5cGUge0V4cG9ydHN9ICovXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Igd2lsbCBiZSBkZWZpbmVkIGJlY2F1c2UgdGhlIHJlbmRlciBlZmZlY3QgcnVucyBzeW5jaHJvbm91c2x5XG5cdHZhciBjb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cblx0dmFyIHVubW91bnQgPSBjb21wb25lbnRfcm9vdCgoKSA9PiB7XG5cdFx0dmFyIGFuY2hvcl9ub2RlID0gYW5jaG9yID8/IHRhcmdldC5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblxuXHRcdGJvdW5kYXJ5KFxuXHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChhbmNob3Jfbm9kZSksXG5cdFx0XHR7XG5cdFx0XHRcdHBlbmRpbmc6ICgpID0+IHt9XG5cdFx0XHR9LFxuXHRcdFx0KGFuY2hvcl9ub2RlKSA9PiB7XG5cdFx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdFx0cHVzaCh7fSk7XG5cdFx0XHRcdFx0dmFyIGN0eCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblx0XHRcdFx0XHRjdHguYyA9IGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdFx0Ly8gV2UgY2FuJ3Qgc3ByZWFkIHRoZSBvYmplY3Qgb3IgZWxzZSB3ZSdkIGxvc2UgdGhlIHN0YXRlIHByb3h5IHN0dWZmLCBpZiBpdCBpcyBvbmVcblx0XHRcdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKHByb3BzKS4kJGV2ZW50cyA9IGV2ZW50cztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0XHRhc3NpZ25fbm9kZXMoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChhbmNob3Jfbm9kZSksIG51bGwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2hvdWxkX2ludHJvID0gaW50cm87XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHB1YmxpYyB0eXBpbmdzIGFyZSBub3Qgd2hhdCB0aGUgYWN0dWFsIGZ1bmN0aW9uIGxvb2tzIGxpa2Vcblx0XHRcdFx0Y29tcG9uZW50ID0gQ29tcG9uZW50KGFuY2hvcl9ub2RlLCBwcm9wcykgfHwge307XG5cdFx0XHRcdHNob3VsZF9pbnRybyA9IHRydWU7XG5cblx0XHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkubm9kZXNfZW5kID0gaHlkcmF0ZV9ub2RlO1xuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0aHlkcmF0ZV9ub2RlID09PSBudWxsIHx8XG5cdFx0XHRcdFx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSB8fFxuXHRcdFx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhICE9PSBIWURSQVRJT05fRU5EXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdFx0XHRcdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdFx0cG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAodmFyIGV2ZW50X25hbWUgb2YgcmVnaXN0ZXJlZF9ldmVudHMpIHtcblx0XHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblxuXHRcdFx0XHR2YXIgbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZG9jdW1lbnRfbGlzdGVuZXJzLmdldChldmVudF9uYW1lKSk7XG5cblx0XHRcdFx0aWYgKC0tbiA9PT0gMCkge1xuXHRcdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblx0XHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuZGVsZXRlKGV2ZW50X25hbWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cm9vdF9ldmVudF9oYW5kbGVzLmRlbGV0ZShldmVudF9oYW5kbGUpO1xuXG5cdFx0XHRpZiAoYW5jaG9yX25vZGUgIT09IGFuY2hvcikge1xuXHRcdFx0XHRhbmNob3Jfbm9kZS5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChhbmNob3Jfbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0bW91bnRlZF9jb21wb25lbnRzLnNldChjb21wb25lbnQsIHVubW91bnQpO1xuXHRyZXR1cm4gY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCB3ZXJlIG1vdW50ZWQgb3IgaHlkcmF0ZWQuXG4gKiBVc2VzIGEgYFdlYWtNYXBgIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAqL1xubGV0IG1vdW50ZWRfY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VudGVkIHVzaW5nIGBtb3VudGAgb3IgYGh5ZHJhdGVgLlxuICpcbiAqIFNpbmNlIDUuMTMuMCwgaWYgYG9wdGlvbnMub3V0cm9gIGlzIGB0cnVlYCwgW3RyYW5zaXRpb25zXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdHJhbnNpdGlvbikgd2lsbCBwbGF5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIFJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBhZnRlciB0cmFuc2l0aW9ucyBoYXZlIGNvbXBsZXRlZCBpZiBgb3B0aW9ucy5vdXRyb2AgaXMgdHJ1ZSwgb3IgaW1tZWRpYXRlbHkgb3RoZXJ3aXNlIChwcmlvciB0byA1LjEzLjAsIHJldHVybnMgYHZvaWRgKS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbW91bnQsIHVubW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICogaW1wb3J0IEFwcCBmcm9tICcuL0FwcC5zdmVsdGUnO1xuICpcbiAqIGNvbnN0IGFwcCA9IG1vdW50KEFwcCwgeyB0YXJnZXQ6IGRvY3VtZW50LmJvZHkgfSk7XG4gKlxuICogLy8gbGF0ZXIuLi5cbiAqIHVubW91bnQoYXBwLCB7IG91dHJvOiB0cnVlIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7IG91dHJvPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudChjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0Y29uc3QgZm4gPSBtb3VudGVkX2NvbXBvbmVudHMuZ2V0KGNvbXBvbmVudCk7XG5cblx0aWYgKGZuKSB7XG5cdFx0bW91bnRlZF9jb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xuXHRcdHJldHVybiBmbihvcHRpb25zKTtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHRpZiAoU1RBVEVfU1lNQk9MIGluIGNvbXBvbmVudCkge1xuXHRcdFx0dy5zdGF0ZV9wcm94eV91bm1vdW50KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHcubGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50KCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgU291cmNlLCBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBGSUxFTkFNRSwgSE1SIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vZG9tL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBkZXN0cm95X2VmZmVjdCB9IGZyb20gJy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzb3VyY2UgfSBmcm9tICcuLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgc2V0X3Nob3VsZF9pbnRybyB9IGZyb20gJy4uL3JlbmRlci5qcyc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgeyhhbmNob3I6IENvbW1lbnQsIHByb3BzOiBhbnkpID0+IGFueX0gQ29tcG9uZW50XG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7KCkgPT4gU291cmNlPENvbXBvbmVudD59IGdldF9zb3VyY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhtcihvcmlnaW5hbCwgZ2V0X3NvdXJjZSkge1xuXHQvKipcblx0ICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IGFuY2hvclxuXHQgKiBAcGFyYW0ge2FueX0gcHJvcHNcblx0ICovXG5cdGZ1bmN0aW9uIHdyYXBwZXIoYW5jaG9yLCBwcm9wcykge1xuXHRcdGxldCBpbnN0YW5jZSA9IHt9O1xuXG5cdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovXG5cdFx0bGV0IGVmZmVjdDtcblxuXHRcdGxldCByYW4gPSBmYWxzZTtcblxuXHRcdGJsb2NrKCgpID0+IHtcblx0XHRcdGNvbnN0IHNvdXJjZSA9IGdldF9zb3VyY2UoKTtcblx0XHRcdGNvbnN0IGNvbXBvbmVudCA9IGdldChzb3VyY2UpO1xuXG5cdFx0XHRpZiAoZWZmZWN0KSB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBpbnN0YW5jZSkgZGVsZXRlIGluc3RhbmNlW2tdO1xuXHRcdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRlZmZlY3QgPSBicmFuY2goKCkgPT4ge1xuXHRcdFx0XHQvLyB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZGF0ZWQsIHJlcGxhY2UgaXQgd2l0aG91dCB0cmFuc2l0aW9uc1xuXHRcdFx0XHRpZiAocmFuKSBzZXRfc2hvdWxkX2ludHJvKGZhbHNlKTtcblxuXHRcdFx0XHQvLyBwcmVzZXJ2ZSBnZXR0ZXJzL3NldHRlcnNcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG5cdFx0XHRcdFx0aW5zdGFuY2UsXG5cdFx0XHRcdFx0T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoXG5cdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0XHRuZXcudGFyZ2V0ID8gbmV3IGNvbXBvbmVudChhbmNob3IsIHByb3BzKSA6IGNvbXBvbmVudChhbmNob3IsIHByb3BzKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAocmFuKSBzZXRfc2hvdWxkX2ludHJvKHRydWUpO1xuXHRcdFx0fSk7XG5cdFx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcblxuXHRcdHJhbiA9IHRydWU7XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR3cmFwcGVyW0ZJTEVOQU1FXSA9IG9yaWdpbmFsW0ZJTEVOQU1FXTtcblxuXHQvLyBAdHMtaWdub3JlXG5cdHdyYXBwZXJbSE1SXSA9IHtcblx0XHQvLyBXaGVuIHdlIGFjY2VwdCBhbiB1cGRhdGUsIHdlIHNldCB0aGUgb3JpZ2luYWwgc291cmNlIHRvIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0b3JpZ2luYWwsXG5cdFx0Ly8gVGhlIGBnZXRfc291cmNlYCBwYXJhbWV0ZXIgcmVhZHMgYHdyYXBwZXJbSE1SXS5zb3VyY2VgLCBidXQgaW4gdGhlIGBhY2NlcHRgXG5cdFx0Ly8gZnVuY3Rpb24gd2UgYWx3YXlzIHJlcGxhY2UgaXQgd2l0aCBgcHJldmlvdXNbSE1SXS5zb3VyY2VgLCB3aGljaCBpbiBwcmFjdGljZVxuXHRcdC8vIG1lYW5zIHdlIG9ubHkgZXZlciB1cGRhdGUgdGhlIG9yaWdpbmFsXG5cdFx0c291cmNlOiBzb3VyY2Uob3JpZ2luYWwpXG5cdH07XG5cblx0cmV0dXJuIHdyYXBwZXI7XG59XG4iLCAiLyoqIEB0eXBlZGVmIHt7IGZpbGU6IHN0cmluZywgbGluZTogbnVtYmVyLCBjb2x1bW46IG51bWJlciB9fSBMb2NhdGlvbiAqL1xuXG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvciB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBMRUdBQ1lfUFJPUFMsIFNUQVRFX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IHNhbml0aXplX2xvY2F0aW9uIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIFNldHMgdXAgYSB2YWxpZGF0b3IgdGhhdFxuICogLSB0cmF2ZXJzZXMgdGhlIHBhdGggb2YgYSBwcm9wIHRvIGZpbmQgb3V0IGlmIGl0IGlzIGFsbG93ZWQgdG8gYmUgbXV0YXRlZFxuICogLSBjaGVja3MgdGhhdCB0aGUgYmluZGluZyBjaGFpbiBpcyBub3QgaW50ZXJydXB0ZWRcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9vd25lcnNoaXBfdmFsaWRhdG9yKHByb3BzKSB7XG5cdGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudF9jb250ZXh0Py5mdW5jdGlvbjtcblx0Y29uc3QgcGFyZW50ID0gY29tcG9uZW50X2NvbnRleHQ/LnA/LmZ1bmN0aW9uO1xuXG5cdHJldHVybiB7XG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3Bcblx0XHQgKiBAcGFyYW0ge2FueVtdfSBwYXRoXG5cdFx0ICogQHBhcmFtIHthbnl9IHJlc3VsdFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtblxuXHRcdCAqL1xuXHRcdG11dGF0aW9uOiAocHJvcCwgcGF0aCwgcmVzdWx0LCBsaW5lLCBjb2x1bW4pID0+IHtcblx0XHRcdGNvbnN0IG5hbWUgPSBwYXRoWzBdO1xuXHRcdFx0aWYgKGlzX2JvdW5kX29yX3Vuc2V0KHByb3BzLCBuYW1lKSB8fCAhcGFyZW50KSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8qKiBAdHlwZSB7YW55fSAqL1xuXHRcdFx0bGV0IHZhbHVlID0gcHJvcHM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXRoW2ldXTtcblx0XHRcdFx0aWYgKCF2YWx1ZT8uW1NUQVRFX1NZTUJPTF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGxvY2F0aW9uID0gc2FuaXRpemVfbG9jYXRpb24oYCR7Y29tcG9uZW50W0ZJTEVOQU1FXX06JHtsaW5lfToke2NvbHVtbn1gKTtcblxuXHRcdFx0dy5vd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbihuYW1lLCBsb2NhdGlvbiwgcHJvcCwgcGFyZW50W0ZJTEVOQU1FXSk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge2FueX0ga2V5XG5cdFx0ICogQHBhcmFtIHthbnl9IGNoaWxkX2NvbXBvbmVudFxuXHRcdCAqIEBwYXJhbSB7KCkgPT4gYW55fSB2YWx1ZVxuXHRcdCAqL1xuXHRcdGJpbmRpbmc6IChrZXksIGNoaWxkX2NvbXBvbmVudCwgdmFsdWUpID0+IHtcblx0XHRcdGlmICghaXNfYm91bmRfb3JfdW5zZXQocHJvcHMsIGtleSkgJiYgcGFyZW50ICYmIHZhbHVlKCk/LltTVEFURV9TWU1CT0xdKSB7XG5cdFx0XHRcdHcub3duZXJzaGlwX2ludmFsaWRfYmluZGluZyhcblx0XHRcdFx0XHRjb21wb25lbnRbRklMRU5BTUVdLFxuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRjaGlsZF9jb21wb25lbnRbRklMRU5BTUVdLFxuXHRcdFx0XHRcdHBhcmVudFtGSUxFTkFNRV1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3BfbmFtZVxuICovXG5mdW5jdGlvbiBpc19ib3VuZF9vcl91bnNldChwcm9wcywgcHJvcF9uYW1lKSB7XG5cdC8vIENhbiBiZSB0aGUgY2FzZSB3aGVuIHNvbWVvbmUgZG9lcyBgbW91bnQoQ29tcG9uZW50LCBwcm9wcylgIHdpdGggYGxldCBwcm9wcyA9ICRzdGF0ZSh7Li4ufSlgXG5cdC8vIG9yIGBjcmVhdGVDbGFzc0NvbXBvbmVudChDb21wb25lbnQsIHByb3BzKWBcblx0Y29uc3QgaXNfZW50cnlfcHJvcHMgPSBTVEFURV9TWU1CT0wgaW4gcHJvcHMgfHwgTEVHQUNZX1BST1BTIGluIHByb3BzO1xuXHRyZXR1cm4gKFxuXHRcdCEhZ2V0X2Rlc2NyaXB0b3IocHJvcHMsIHByb3BfbmFtZSk/LnNldCB8fFxuXHRcdChpc19lbnRyeV9wcm9wcyAmJiBwcm9wX25hbWUgaW4gcHJvcHMpIHx8XG5cdFx0IShwcm9wX25hbWUgaW4gcHJvcHMpXG5cdCk7XG59XG4iLCAiaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcblxuLyoqIEBwYXJhbSB7RnVuY3Rpb24gJiB7IFtGSUxFTkFNRV06IHN0cmluZyB9fSB0YXJnZXQgKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja190YXJnZXQodGFyZ2V0KSB7XG5cdGlmICh0YXJnZXQpIHtcblx0XHRlLmNvbXBvbmVudF9hcGlfaW52YWxpZF9uZXcodGFyZ2V0W0ZJTEVOQU1FXSA/PyAnYSBjb21wb25lbnQnLCB0YXJnZXQubmFtZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9hcGkoKSB7XG5cdGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudF9jb250ZXh0Py5mdW5jdGlvbjtcblxuXHQvKiogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCAqL1xuXHRmdW5jdGlvbiBlcnJvcihtZXRob2QpIHtcblx0XHRlLmNvbXBvbmVudF9hcGlfY2hhbmdlZChtZXRob2QsIGNvbXBvbmVudFtGSUxFTkFNRV0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQkZGVzdHJveTogKCkgPT4gZXJyb3IoJyRkZXN0cm95KCknKSxcblx0XHQkb246ICgpID0+IGVycm9yKCckb24oLi4uKScpLFxuXHRcdCRzZXQ6ICgpID0+IGVycm9yKCckc2V0KC4uLiknKVxuXHR9O1xufVxuIiwgImltcG9ydCB7IFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgc25hcHNob3QgfSBmcm9tICcuLi8uLi9zaGFyZWQvY2xvbmUuanMnO1xuaW1wb3J0IHsgZWFnZXJfZWZmZWN0LCByZW5kZXJfZWZmZWN0LCB2YWxpZGF0ZV9lZmZlY3QgfSBmcm9tICcuLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZ2V0X2Vycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Rldi5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnlbXX0gZ2V0X3ZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnNwZWN0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd19zdGFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdChnZXRfdmFsdWUsIGluc3BlY3Rvciwgc2hvd19zdGFjayA9IGZhbHNlKSB7XG5cdHZhbGlkYXRlX2VmZmVjdCgnJGluc3BlY3QnKTtcblxuXHRsZXQgaW5pdGlhbCA9IHRydWU7XG5cdGxldCBlcnJvciA9IC8qKiBAdHlwZSB7YW55fSAqLyAoVU5JTklUSUFMSVpFRCk7XG5cblx0Ly8gSW5zcGVjdCBlZmZlY3RzIHJ1bnMgc3luY2hyb25vdXNseSBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHVzZWZ1bFxuXHQvLyBzdGFjayB0cmFjZXMuIEFzIGEgY29uc2VxdWVuY2UsIHJlYWRpbmcgdGhlIHZhbHVlIG1pZ2h0IHJlc3VsdFxuXHQvLyBpbiBhbiBlcnJvciAoYW4gYCRpbnNwZWN0KG9iamVjdC5wcm9wZXJ0eSlgIHdpbGwgcnVuIGJlZm9yZSB0aGVcblx0Ly8gYHsjaWYgb2JqZWN0fS4uLnsvaWZ9YCB0aGF0IGNvbnRhaW5zIGl0KVxuXHRlYWdlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBnZXRfdmFsdWUoKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNuYXAgPSBzbmFwc2hvdCh2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0dW50cmFjaygoKSA9PiB7XG5cdFx0XHRpZiAoc2hvd19zdGFjaykge1xuXHRcdFx0XHRpbnNwZWN0b3IoLi4uc25hcCk7XG5cblx0XHRcdFx0aWYgKCFpbml0aWFsKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhY2sgPSBnZXRfZXJyb3IoJyRpbnNwZWN0KC4uLiknKTtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG5cdFx0XHRcdFx0aWYgKHN0YWNrKSB7XG5cdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0XHRcdFx0Y29uc29sZS5ncm91cENvbGxhcHNlZCgnc3RhY2sgdHJhY2UnKTtcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhzdGFjayk7XG5cdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0XHRcdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5zcGVjdG9yKGluaXRpYWwgPyAnaW5pdCcgOiAndXBkYXRlJywgLi4uc25hcCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpbml0aWFsID0gZmFsc2U7XG5cdH0pO1xuXG5cdC8vIElmIGFuIGVycm9yIG9jY3Vycywgd2Ugc3RvcmUgaXQgKGFsb25nIHdpdGggaXRzIHN0YWNrIHRyYWNlKS5cblx0Ly8gSWYgdGhlIHJlbmRlciBlZmZlY3Qgc3Vic2VxdWVudGx5IHJ1bnMsIHdlIGxvZyB0aGUgZXJyb3IsXG5cdC8vIGJ1dCBpZiBpdCBkb2Vzbid0IHJ1biBpdCdzIGJlY2F1c2UgdGhlIGAkaW5zcGVjdGAgd2FzXG5cdC8vIGRlc3Ryb3llZCwgbWVhbmluZyB3ZSBkb24ndCBuZWVkIHRvIGJvdGhlclxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gY2FsbCBgZ2V0X3ZhbHVlYCBzbyB0aGF0IHRoaXMgcnVucyBhbG9uZ3NpZGUgdGhlIGluc3BlY3QgZWZmZWN0XG5cdFx0XHRnZXRfdmFsdWUoKTtcblx0XHR9IGNhdGNoIHtcblx0XHRcdC8vIGlnbm9yZVxuXHRcdH1cblxuXHRcdGlmIChlcnJvciAhPT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuXHRcdFx0ZXJyb3IgPSBVTklOSVRJQUxJWkVEO1xuXHRcdH1cblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUsIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2FzeW5jLmpzJztcbmltcG9ydCB7IEJhdGNoLCBjdXJyZW50X2JhdGNoIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmcsXG5cdHNraXBfbm9kZXNcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGdldF9ib3VuZGFyeSB9IGZyb20gJy4vYm91bmRhcnkuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U8dm9pZD4+fSBibG9ja2Vyc1xuICogQHBhcmFtIHtBcnJheTwoKSA9PiBQcm9taXNlPGFueT4+fSBleHByZXNzaW9uc1xuICogQHBhcmFtIHsoYW5jaG9yOiBUZW1wbGF0ZU5vZGUsIC4uLmRlcml2ZWRzOiBWYWx1ZVtdKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXN5bmMobm9kZSwgYmxvY2tlcnMgPSBbXSwgZXhwcmVzc2lvbnMgPSBbXSwgZm4pIHtcblx0dmFyIGJvdW5kYXJ5ID0gZ2V0X2JvdW5kYXJ5KCk7XG5cdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblx0dmFyIGJsb2NraW5nID0gIWJvdW5kYXJ5LmlzX3BlbmRpbmcoKTtcblxuXHRib3VuZGFyeS51cGRhdGVfcGVuZGluZ19jb3VudCgxKTtcblx0YmF0Y2guaW5jcmVtZW50KGJsb2NraW5nKTtcblxuXHR2YXIgd2FzX2h5ZHJhdGluZyA9IGh5ZHJhdGluZztcblxuXHRpZiAod2FzX2h5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXG5cdFx0dmFyIHByZXZpb3VzX2h5ZHJhdGVfbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblx0XHR2YXIgZW5kID0gc2tpcF9ub2RlcyhmYWxzZSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShlbmQpO1xuXHR9XG5cblx0ZmxhdHRlbihibG9ja2VycywgW10sIGV4cHJlc3Npb25zLCAodmFsdWVzKSA9PiB7XG5cdFx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKHByZXZpb3VzX2h5ZHJhdGVfbm9kZSk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIGdldCB2YWx1ZXMgZWFnZXJseSB0byBhdm9pZCBjcmVhdGluZyBibG9ja3MgaWYgdGhleSByZWplY3Rcblx0XHRcdGZvciAoY29uc3QgZCBvZiB2YWx1ZXMpIGdldChkKTtcblxuXHRcdFx0Zm4obm9kZSwgLi4udmFsdWVzKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KC0xKTtcblx0XHRcdGJhdGNoLmRlY3JlbWVudChibG9ja2luZyk7XG5cdFx0fVxuXHR9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gYW5jaG9yXG4gKiBAcGFyYW0gey4uLigoKT0+YW55KVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9zbmlwcGV0X2FyZ3MoYW5jaG9yLCAuLi5hcmdzKSB7XG5cdGlmICh0eXBlb2YgYW5jaG9yICE9PSAnb2JqZWN0JyB8fCAhKGFuY2hvciBpbnN0YW5jZW9mIE5vZGUpKSB7XG5cdFx0ZS5pbnZhbGlkX3NuaXBwZXRfYXJndW1lbnRzKCk7XG5cdH1cblxuXHRmb3IgKGxldCBhcmcgb2YgYXJncykge1xuXHRcdGlmICh0eXBlb2YgYXJnICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRlLmludmFsaWRfc25pcHBldF9hcmd1bWVudHMoKTtcblx0XHR9XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEJhdGNoLCBjdXJyZW50X2JhdGNoIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5pbXBvcnQge1xuXHRicmFuY2gsXG5cdGRlc3Ryb3lfZWZmZWN0LFxuXHRtb3ZlX2VmZmVjdCxcblx0cGF1c2VfZWZmZWN0LFxuXHRyZXN1bWVfZWZmZWN0XG59IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgc2hvdWxkX2RlZmVyX2FwcGVuZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IGVmZmVjdDogRWZmZWN0LCBmcmFnbWVudDogRG9jdW1lbnRGcmFnbWVudCB9fSBCcmFuY2hcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBLZXlcbiAqL1xuZXhwb3J0IGNsYXNzIEJyYW5jaE1hbmFnZXIge1xuXHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi9cblx0YW5jaG9yO1xuXG5cdC8qKiBAdHlwZSB7TWFwPEJhdGNoLCBLZXk+fSAqL1xuXHQjYmF0Y2hlcyA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogTWFwIG9mIGtleXMgdG8gZWZmZWN0cyB0aGF0IGFyZSBjdXJyZW50bHkgcmVuZGVyZWQgaW4gdGhlIERPTS5cblx0ICogVGhlc2UgZWZmZWN0cyBhcmUgdmlzaWJsZSBhbmQgYWN0aXZlbHkgcGFydCBvZiB0aGUgZG9jdW1lbnQgdHJlZS5cblx0ICogRXhhbXBsZTpcblx0ICogYGBgXG5cdCAqIHsjaWYgY29uZGl0aW9ufVxuXHQgKiBcdGZvb1xuXHQgKiB7OmVsc2V9XG5cdCAqIFx0YmFyXG5cdCAqIHsvaWZ9XG5cdCAqIGBgYFxuXHQgKiBDYW4gcmVzdWx0IGluIHRoZSBlbnRyaWVzIGB0cnVlLT5FZmZlY3RgIGFuZCBgZmFsc2UtPkVmZmVjdGBcblx0ICogQHR5cGUge01hcDxLZXksIEVmZmVjdD59XG5cdCAqL1xuXHQjb25zY3JlZW4gPSBuZXcgTWFwKCk7XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gI29uc2NyZWVuIHdpdGggcmVzcGVjdCB0byB0aGUga2V5cywgYnV0IGNvbnRhaW5zIGJyYW5jaGVzIHRoYXQgYXJlIG5vdCB5ZXRcblx0ICogaW4gdGhlIERPTSwgYmVjYXVzZSB0aGVpciBpbnNlcnRpb24gaXMgZGVmZXJyZWQuXG5cdCAqIEB0eXBlIHtNYXA8S2V5LCBCcmFuY2g+fVxuXHQgKi9cblx0I29mZnNjcmVlbiA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogS2V5cyBvZiBlZmZlY3RzIHRoYXQgYXJlIGN1cnJlbnRseSBvdXRyb2luZ1xuXHQgKiBAdHlwZSB7U2V0PEtleT59XG5cdCAqL1xuXHQjb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdG8gcGF1c2UgKGkuZS4gb3V0cm8pIG9uIGNoYW5nZSwgb3IgZGVzdHJveSBpbW1lZGlhdGVseS5cblx0ICogVGhpcyBpcyBuZWNlc3NhcnkgZm9yIGA8c3ZlbHRlOmVsZW1lbnQ+YFxuXHQgKi9cblx0I3RyYW5zaXRpb24gPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gYW5jaG9yXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhbnNpdGlvblxuXHQgKi9cblx0Y29uc3RydWN0b3IoYW5jaG9yLCB0cmFuc2l0aW9uID0gdHJ1ZSkge1xuXHRcdHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuXHRcdHRoaXMuI3RyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHR9XG5cblx0I2NvbW1pdCA9ICgpID0+IHtcblx0XHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAoY3VycmVudF9iYXRjaCk7XG5cblx0XHQvLyBpZiB0aGlzIGJhdGNoIHdhcyBtYWRlIG9ic29sZXRlLCBiYWlsXG5cdFx0aWYgKCF0aGlzLiNiYXRjaGVzLmhhcyhiYXRjaCkpIHJldHVybjtcblxuXHRcdHZhciBrZXkgPSAvKiogQHR5cGUge0tleX0gKi8gKHRoaXMuI2JhdGNoZXMuZ2V0KGJhdGNoKSk7XG5cblx0XHR2YXIgb25zY3JlZW4gPSB0aGlzLiNvbnNjcmVlbi5nZXQoa2V5KTtcblxuXHRcdGlmIChvbnNjcmVlbikge1xuXHRcdFx0Ly8gZWZmZWN0IGlzIGFscmVhZHkgaW4gdGhlIERPTSBcdTIwMTQgYWJvcnQgYW55IGN1cnJlbnQgb3V0cm9cblx0XHRcdHJlc3VtZV9lZmZlY3Qob25zY3JlZW4pO1xuXHRcdFx0dGhpcy4jb3V0cm9pbmcuZGVsZXRlKGtleSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGVmZmVjdCBpcyBjdXJyZW50bHkgb2Zmc2NyZWVuLiBwdXQgaXQgaW4gdGhlIERPTVxuXHRcdFx0dmFyIG9mZnNjcmVlbiA9IHRoaXMuI29mZnNjcmVlbi5nZXQoa2V5KTtcblxuXHRcdFx0aWYgKG9mZnNjcmVlbikge1xuXHRcdFx0XHR0aGlzLiNvbnNjcmVlbi5zZXQoa2V5LCBvZmZzY3JlZW4uZWZmZWN0KTtcblx0XHRcdFx0dGhpcy4jb2Zmc2NyZWVuLmRlbGV0ZShrZXkpO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSB0aGUgYW5jaG9yLi4uXG5cdFx0XHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAob2Zmc2NyZWVuLmZyYWdtZW50Lmxhc3RDaGlsZCkucmVtb3ZlKCk7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGFwcGVuZCB0aGUgZnJhZ21lbnRcblx0XHRcdFx0dGhpcy5hbmNob3IuYmVmb3JlKG9mZnNjcmVlbi5mcmFnbWVudCk7XG5cdFx0XHRcdG9uc2NyZWVuID0gb2Zmc2NyZWVuLmVmZmVjdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IFtiLCBrXSBvZiB0aGlzLiNiYXRjaGVzKSB7XG5cdFx0XHR0aGlzLiNiYXRjaGVzLmRlbGV0ZShiKTtcblxuXHRcdFx0aWYgKGIgPT09IGJhdGNoKSB7XG5cdFx0XHRcdC8vIGtlZXAgdmFsdWVzIGZvciBuZXdlciBiYXRjaGVzXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBvZmZzY3JlZW4gPSB0aGlzLiNvZmZzY3JlZW4uZ2V0KGspO1xuXG5cdFx0XHRpZiAob2Zmc2NyZWVuKSB7XG5cdFx0XHRcdC8vIGZvciBvbGRlciBiYXRjaGVzLCBkZXN0cm95IG9mZnNjcmVlbiBlZmZlY3RzXG5cdFx0XHRcdC8vIGFzIHRoZXkgd2lsbCBuZXZlciBiZSBjb21taXR0ZWRcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3Qob2Zmc2NyZWVuLmVmZmVjdCk7XG5cdFx0XHRcdHRoaXMuI29mZnNjcmVlbi5kZWxldGUoayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gb3V0cm8vZGVzdHJveSBhbGwgb25zY3JlZW4gZWZmZWN0cy4uLlxuXHRcdGZvciAoY29uc3QgW2ssIGVmZmVjdF0gb2YgdGhpcy4jb25zY3JlZW4pIHtcblx0XHRcdC8vIC4uLmV4Y2VwdCB0aGUgb25lIHRoYXQgd2FzIGp1c3QgY29tbWl0dGVkXG5cdFx0XHQvLyAgICBvciB0aG9zZSB0aGF0IGFyZSBhbHJlYWR5IG91dHJvaW5nIChlbHNlIHRoZSB0cmFuc2l0aW9uIGlzIGFib3J0ZWQgYW5kIHRoZSBlZmZlY3QgZGVzdHJveWVkIHJpZ2h0IGF3YXkpXG5cdFx0XHRpZiAoayA9PT0ga2V5IHx8IHRoaXMuI291dHJvaW5nLmhhcyhrKSkgY29udGludWU7XG5cblx0XHRcdGNvbnN0IG9uX2Rlc3Ryb3kgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHRoaXMuI2JhdGNoZXMudmFsdWVzKCkpO1xuXG5cdFx0XHRcdGlmIChrZXlzLmluY2x1ZGVzKGspKSB7XG5cdFx0XHRcdFx0Ly8ga2VlcCB0aGUgZWZmZWN0IG9mZnNjcmVlbiwgYXMgYW5vdGhlciBiYXRjaCB3aWxsIG5lZWQgaXRcblx0XHRcdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdFx0bW92ZV9lZmZlY3QoZWZmZWN0LCBmcmFnbWVudCk7XG5cblx0XHRcdFx0XHRmcmFnbWVudC5hcHBlbmQoY3JlYXRlX3RleHQoKSk7IC8vIFRPRE8gY2FuIHdlIGF2b2lkIHRoaXM/XG5cblx0XHRcdFx0XHR0aGlzLiNvZmZzY3JlZW4uc2V0KGssIHsgZWZmZWN0LCBmcmFnbWVudCB9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy4jb3V0cm9pbmcuZGVsZXRlKGspO1xuXHRcdFx0XHR0aGlzLiNvbnNjcmVlbi5kZWxldGUoayk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodGhpcy4jdHJhbnNpdGlvbiB8fCAhb25zY3JlZW4pIHtcblx0XHRcdFx0dGhpcy4jb3V0cm9pbmcuYWRkKGspO1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZWZmZWN0LCBvbl9kZXN0cm95LCBmYWxzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbl9kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0JhdGNofSBiYXRjaFxuXHQgKi9cblx0I2Rpc2NhcmQgPSAoYmF0Y2gpID0+IHtcblx0XHR0aGlzLiNiYXRjaGVzLmRlbGV0ZShiYXRjaCk7XG5cblx0XHRjb25zdCBrZXlzID0gQXJyYXkuZnJvbSh0aGlzLiNiYXRjaGVzLnZhbHVlcygpKTtcblxuXHRcdGZvciAoY29uc3QgW2ssIGJyYW5jaF0gb2YgdGhpcy4jb2Zmc2NyZWVuKSB7XG5cdFx0XHRpZiAoIWtleXMuaW5jbHVkZXMoaykpIHtcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoYnJhbmNoLmVmZmVjdCk7XG5cdFx0XHRcdHRoaXMuI29mZnNjcmVlbi5kZWxldGUoayk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FueX0ga2V5XG5cdCAqIEBwYXJhbSB7bnVsbCB8ICgodGFyZ2V0OiBUZW1wbGF0ZU5vZGUpID0+IHZvaWQpfSBmblxuXHQgKi9cblx0ZW5zdXJlKGtleSwgZm4pIHtcblx0XHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAoY3VycmVudF9iYXRjaCk7XG5cdFx0dmFyIGRlZmVyID0gc2hvdWxkX2RlZmVyX2FwcGVuZCgpO1xuXG5cdFx0aWYgKGZuICYmICF0aGlzLiNvbnNjcmVlbi5oYXMoa2V5KSAmJiAhdGhpcy4jb2Zmc2NyZWVuLmhhcyhrZXkpKSB7XG5cdFx0XHRpZiAoZGVmZXIpIHtcblx0XHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gY3JlYXRlX3RleHQoKTtcblxuXHRcdFx0XHRmcmFnbWVudC5hcHBlbmQodGFyZ2V0KTtcblxuXHRcdFx0XHR0aGlzLiNvZmZzY3JlZW4uc2V0KGtleSwge1xuXHRcdFx0XHRcdGVmZmVjdDogYnJhbmNoKCgpID0+IGZuKHRhcmdldCkpLFxuXHRcdFx0XHRcdGZyYWdtZW50XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy4jb25zY3JlZW4uc2V0KFxuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRicmFuY2goKCkgPT4gZm4odGhpcy5hbmNob3IpKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuI2JhdGNoZXMuc2V0KGJhdGNoLCBrZXkpO1xuXG5cdFx0aWYgKGRlZmVyKSB7XG5cdFx0XHRmb3IgKGNvbnN0IFtrLCBlZmZlY3RdIG9mIHRoaXMuI29uc2NyZWVuKSB7XG5cdFx0XHRcdGlmIChrID09PSBrZXkpIHtcblx0XHRcdFx0XHRiYXRjaC5za2lwcGVkX2VmZmVjdHMuZGVsZXRlKGVmZmVjdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YmF0Y2guc2tpcHBlZF9lZmZlY3RzLmFkZChlZmZlY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoY29uc3QgW2ssIGJyYW5jaF0gb2YgdGhpcy4jb2Zmc2NyZWVuKSB7XG5cdFx0XHRcdGlmIChrID09PSBrZXkpIHtcblx0XHRcdFx0XHRiYXRjaC5za2lwcGVkX2VmZmVjdHMuZGVsZXRlKGJyYW5jaC5lZmZlY3QpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJhdGNoLnNraXBwZWRfZWZmZWN0cy5hZGQoYnJhbmNoLmVmZmVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YmF0Y2gub25jb21taXQodGhpcy4jY29tbWl0KTtcblx0XHRcdGJhdGNoLm9uZGlzY2FyZCh0aGlzLiNkaXNjYXJkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHR0aGlzLmFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy4jY29tbWl0KCk7XG5cdFx0fVxuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTb3VyY2UsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBpc19wcm9taXNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGJsb2NrIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGludGVybmFsX3NldCwgbXV0YWJsZV9zb3VyY2UsIHNvdXJjZSB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGluZyxcblx0c2tpcF9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgSFlEUkFUSU9OX1NUQVJUX0VMU0UsIFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgaXNfcnVuZXMgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IEJhdGNoLCBmbHVzaFN5bmMsIGlzX2ZsdXNoaW5nX3N5bmMgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcbmltcG9ydCB7IEJyYW5jaE1hbmFnZXIgfSBmcm9tICcuL2JyYW5jaGVzLmpzJztcbmltcG9ydCB7IGNhcHR1cmUsIHVuc2V0X2NvbnRleHQgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2FzeW5jLmpzJztcblxuY29uc3QgUEVORElORyA9IDA7XG5jb25zdCBUSEVOID0gMTtcbmNvbnN0IENBVENIID0gMjtcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgUEVORElORyB8IHR5cGVvZiBUSEVOIHwgdHlwZW9mIENBVENIfSBBd2FpdFN0YXRlICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygoKSA9PiBhbnkpfSBnZXRfaW5wdXRcbiAqIEBwYXJhbSB7bnVsbCB8ICgoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gcGVuZGluZ19mblxuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IE5vZGUsIHZhbHVlOiBTb3VyY2U8Vj4pID0+IHZvaWQpfSB0aGVuX2ZuXG4gKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogTm9kZSwgZXJyb3I6IHVua25vd24pID0+IHZvaWQpfSBjYXRjaF9mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdF9ibG9jayhub2RlLCBnZXRfaW5wdXQsIHBlbmRpbmdfZm4sIHRoZW5fZm4sIGNhdGNoX2ZuKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBydW5lcyA9IGlzX3J1bmVzKCk7XG5cblx0dmFyIHYgPSAvKiogQHR5cGUge1Z9ICovIChVTklOSVRJQUxJWkVEKTtcblx0dmFyIHZhbHVlID0gcnVuZXMgPyBzb3VyY2UodikgOiBtdXRhYmxlX3NvdXJjZSh2LCBmYWxzZSwgZmFsc2UpO1xuXHR2YXIgZXJyb3IgPSBydW5lcyA/IHNvdXJjZSh2KSA6IG11dGFibGVfc291cmNlKHYsIGZhbHNlLCBmYWxzZSk7XG5cblx0dmFyIGJyYW5jaGVzID0gbmV3IEJyYW5jaE1hbmFnZXIobm9kZSk7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdHZhciBpbnB1dCA9IGdldF9pbnB1dCgpO1xuXHRcdHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcblxuXHRcdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGVyZSB3YXMgYSBoeWRyYXRpb24gbWlzbWF0Y2guIE5lZWRzIHRvIGJlIGEgYGxldGAgb3IgZWxzZSBpdCBpc24ndCB0cmVlc2hha2VuIG91dCAqL1xuXHRcdC8vIEB0cy1pZ25vcmUgY29lcmNpbmcgYG5vZGVgIHRvIGEgYENvbW1lbnRgIGNhdXNlcyBUeXBlU2NyaXB0IGFuZCBQcmV0dGllciB0byBmaWdodFxuXHRcdGxldCBtaXNtYXRjaCA9IGh5ZHJhdGluZyAmJiBpc19wcm9taXNlKGlucHV0KSA9PT0gKG5vZGUuZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0UpO1xuXG5cdFx0aWYgKG1pc21hdGNoKSB7XG5cdFx0XHQvLyBIeWRyYXRpb24gbWlzbWF0Y2g6IHJlbW92ZSBldmVyeXRoaW5nIGluc2lkZSB0aGUgYW5jaG9yIGFuZCBzdGFydCBmcmVzaFxuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShza2lwX25vZGVzKCkpO1xuXHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzX3Byb21pc2UoaW5wdXQpKSB7XG5cdFx0XHR2YXIgcmVzdG9yZSA9IGNhcHR1cmUoKTtcblx0XHRcdHZhciByZXNvbHZlZCA9IGZhbHNlO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgcmVzb2x2ZSA9IChmbikgPT4ge1xuXHRcdFx0XHRpZiAoZGVzdHJveWVkKSByZXR1cm47XG5cblx0XHRcdFx0cmVzb2x2ZWQgPSB0cnVlO1xuXHRcdFx0XHQvLyBXZSBkb24ndCB3YW50IHRvIHJlc3RvcmUgdGhlIHByZXZpb3VzIGJhdGNoIGhlcmU7IHsjYXdhaXR9IGJsb2NrcyBkb24ndCBmb2xsb3cgdGhlIGFzeW5jIGxvZ2ljXG5cdFx0XHRcdC8vIHdlIGhhdmUgZWxzZXdoZXJlLCBpbnN0ZWFkIHBlbmRpbmcvcmVzb2x2ZS9mYWlsIHN0YXRlcyBhcmUgZWFjaCB0aGVpciBvd24gYmF0Y2ggc28gdG8gc3BlYWsuXG5cdFx0XHRcdHJlc3RvcmUoZmFsc2UpO1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGJhdGNoLCBzaW5jZSB0aGUgYnJhbmNoIG1hbmFnZXIgZXhwZWN0cyBvbmUgdG8gZXhpc3Rcblx0XHRcdFx0QmF0Y2guZW5zdXJlKCk7XG5cblx0XHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRcdC8vIGByZXN0b3JlKClgIGNvdWxkIHNldCBgaHlkcmF0aW5nYCB0byBgdHJ1ZWAsIHdoaWNoIHdlIHZlcnkgbXVjaFxuXHRcdFx0XHRcdC8vIGRvbid0IHdhbnQgXHUyMDE0IHdlIHdhbnQgdG8gcmVzdG9yZSBldmVyeXRoaW5nIF9leGNlcHRfIHRoaXNcblx0XHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm4oKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHR1bnNldF9jb250ZXh0KCk7XG5cblx0XHRcdFx0XHQvLyB3aXRob3V0IHRoaXMsIHRoZSBET00gZG9lcyBub3QgdXBkYXRlIHVudGlsIHR3byB0aWNrcyBhZnRlciB0aGUgcHJvbWlzZVxuXHRcdFx0XHRcdC8vIHJlc29sdmVzLCB3aGljaCBpcyB1bmV4cGVjdGVkIGJlaGF2aW91ciAoYW5kIHNvbWV3aGF0IGlya3NvbWUgdG8gdGVzdClcblx0XHRcdFx0XHRpZiAoIWlzX2ZsdXNoaW5nX3N5bmMpIGZsdXNoU3luYygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRpbnB1dC50aGVuKFxuXHRcdFx0XHQodikgPT4ge1xuXHRcdFx0XHRcdHJlc29sdmUoKCkgPT4ge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxfc2V0KHZhbHVlLCB2KTtcblx0XHRcdFx0XHRcdGJyYW5jaGVzLmVuc3VyZShUSEVOLCB0aGVuX2ZuICYmICgodGFyZ2V0KSA9PiB0aGVuX2ZuKHRhcmdldCwgdmFsdWUpKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdChlKSA9PiB7XG5cdFx0XHRcdFx0cmVzb2x2ZSgoKSA9PiB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbF9zZXQoZXJyb3IsIGUpO1xuXHRcdFx0XHRcdFx0YnJhbmNoZXMuZW5zdXJlKFRIRU4sIGNhdGNoX2ZuICYmICgodGFyZ2V0KSA9PiBjYXRjaF9mbih0YXJnZXQsIGVycm9yKSkpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWNhdGNoX2ZuKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIG5vIGNhdGNoIGJsb2NrIGV4aXN0c1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvci52O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdGJyYW5jaGVzLmVuc3VyZShQRU5ESU5HLCBwZW5kaW5nX2ZuKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBtaWNyb3Rhc2sgYmVmb3JlIGNoZWNraW5nIGlmIHdlIHNob3VsZCBzaG93IHRoZSBwZW5kaW5nIHN0YXRlIGFzXG5cdFx0XHRcdC8vIHRoZSBwcm9taXNlIG1pZ2h0IGhhdmUgcmVzb2x2ZWQgYnkgdGhlblxuXHRcdFx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoIXJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0YnJhbmNoZXMuZW5zdXJlKFBFTkRJTkcsIHBlbmRpbmdfZm4pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aW50ZXJuYWxfc2V0KHZhbHVlLCBpbnB1dCk7XG5cdFx0XHRicmFuY2hlcy5lbnN1cmUoVEhFTiwgdGhlbl9mbiAmJiAoKHRhcmdldCkgPT4gdGhlbl9mbih0YXJnZXQsIHZhbHVlKSkpO1xuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGRlc3Ryb3llZCA9IHRydWU7XG5cdFx0fTtcblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRpbmcsXG5cdHJlYWRfaHlkcmF0aW9uX2luc3RydWN0aW9uLFxuXHRza2lwX25vZGVzLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBibG9jayB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBIWURSQVRJT05fU1RBUlRfRUxTRSB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBCcmFuY2hNYW5hZ2VyIH0gZnJvbSAnLi9icmFuY2hlcy5qcyc7XG5cbi8vIFRPRE8gcmVpbnN0YXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC8xNTI1MFxuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geyhicmFuY2g6IChmbjogKGFuY2hvcjogTm9kZSkgPT4gdm9pZCwgZmxhZz86IGJvb2xlYW4pID0+IHZvaWQpID0+IHZvaWR9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbHNlaWZdIFRydWUgaWYgdGhpcyBpcyBhbiBgezplbHNlIGlmIC4uLn1gIGJsb2NrIHJhdGhlciB0aGFuIGFuIGB7I2lmIC4uLn1gLCBhcyB0aGF0IGFmZmVjdHMgd2hpY2ggdHJhbnNpdGlvbnMgYXJlIGNvbnNpZGVyZWQgJ2xvY2FsJ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZl9ibG9jayhub2RlLCBmbiwgZWxzZWlmID0gZmFsc2UpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGJyYW5jaGVzID0gbmV3IEJyYW5jaE1hbmFnZXIobm9kZSk7XG5cdHZhciBmbGFncyA9IGVsc2VpZiA/IEVGRkVDVF9UUkFOU1BBUkVOVCA6IDA7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uLFxuXHQgKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9IGZuXG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVfYnJhbmNoKGNvbmRpdGlvbiwgZm4pIHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRjb25zdCBpc19lbHNlID0gcmVhZF9oeWRyYXRpb25faW5zdHJ1Y3Rpb24obm9kZSkgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRpZiAoY29uZGl0aW9uID09PSBpc19lbHNlKSB7XG5cdFx0XHRcdC8vIEh5ZHJhdGlvbiBtaXNtYXRjaDogcmVtb3ZlIGV2ZXJ5dGhpbmcgaW5zaWRlIHRoZSBhbmNob3IgYW5kIHN0YXJ0IGZyZXNoLlxuXHRcdFx0XHQvLyBUaGlzIGNvdWxkIGhhcHBlbiB3aXRoIGB7I2lmIGJyb3dzZXJ9Li4uey9pZn1gLCBmb3IgZXhhbXBsZVxuXHRcdFx0XHR2YXIgYW5jaG9yID0gc2tpcF9ub2RlcygpO1xuXG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0XHRcdFx0YnJhbmNoZXMuYW5jaG9yID0gYW5jaG9yO1xuXG5cdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRicmFuY2hlcy5lbnN1cmUoY29uZGl0aW9uLCBmbik7XG5cdFx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJyYW5jaGVzLmVuc3VyZShjb25kaXRpb24sIGZuKTtcblx0fVxuXG5cdGJsb2NrKCgpID0+IHtcblx0XHR2YXIgaGFzX2JyYW5jaCA9IGZhbHNlO1xuXG5cdFx0Zm4oKGZuLCBmbGFnID0gdHJ1ZSkgPT4ge1xuXHRcdFx0aGFzX2JyYW5jaCA9IHRydWU7XG5cdFx0XHR1cGRhdGVfYnJhbmNoKGZsYWcsIGZuKTtcblx0XHR9KTtcblxuXHRcdGlmICghaGFzX2JyYW5jaCkge1xuXHRcdFx0dXBkYXRlX2JyYW5jaChmYWxzZSwgbnVsbCk7XG5cdFx0fVxuXHR9LCBmbGFncyk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgaXNfcnVuZXMgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGJsb2NrIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IEJyYW5jaE1hbmFnZXIgfSBmcm9tICcuL2JyYW5jaGVzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZ2V0X2tleVxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlKSA9PiBUZW1wbGF0ZU5vZGUgfCB2b2lkfSByZW5kZXJfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24ga2V5KG5vZGUsIGdldF9rZXksIHJlbmRlcl9mbikge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYnJhbmNoZXMgPSBuZXcgQnJhbmNoTWFuYWdlcihub2RlKTtcblxuXHR2YXIgbGVnYWN5ID0gIWlzX3J1bmVzKCk7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdHZhciBrZXkgPSBnZXRfa2V5KCk7XG5cblx0XHQvLyBrZXkgYmxvY2tzIGluIFN2ZWx0ZSA8NSBoYWQgc3R1cGlkIHNlbWFudGljc1xuXHRcdGlmIChsZWdhY3kgJiYga2V5ICE9PSBudWxsICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRrZXkgPSAvKiogQHR5cGUge1Z9ICovICh7fSk7XG5cdFx0fVxuXG5cdFx0YnJhbmNoZXMuZW5zdXJlKGtleSwgcmVuZGVyX2ZuKTtcblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGdldF9maXJzdF9jaGlsZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnQgfCBTVkdHRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsoKSA9PiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBnZXRfc3R5bGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNzc19wcm9wcyhlbGVtZW50LCBnZXRfc3R5bGVzKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGVsZW1lbnQpKSk7XG5cdH1cblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgc3R5bGVzID0gZ2V0X3N0eWxlcygpO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuXHRcdFx0dmFyIHZhbHVlID0gc3R5bGVzW2tleV07XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBGSUxFTkFNRSwgSFlEUkFUSU9OX0VSUk9SIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHJlbW92ZV9lZmZlY3RfZG9tLCB0ZW1wbGF0ZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZywgc2V0X2h5ZHJhdGVfbm9kZSB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sIH0gZnJvbSAnLi4vcmVjb25jaWxlci5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uLy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGhhc2gsIHNhbml0aXplX2xvY2F0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGdldF9maXJzdF9jaGlsZCwgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBzZXJ2ZXJfaGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrX2hhc2goZWxlbWVudCwgc2VydmVyX2hhc2gsIHZhbHVlKSB7XG5cdGlmICghc2VydmVyX2hhc2ggfHwgc2VydmVyX2hhc2ggPT09IGhhc2goU3RyaW5nKHZhbHVlID8/ICcnKSkpIHJldHVybjtcblxuXHRsZXQgbG9jYXRpb247XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRjb25zdCBsb2MgPSBlbGVtZW50Ll9fc3ZlbHRlX21ldGE/LmxvYztcblx0aWYgKGxvYykge1xuXHRcdGxvY2F0aW9uID0gYG5lYXIgJHtsb2MuZmlsZX06JHtsb2MubGluZX06JHtsb2MuY29sdW1ufWA7XG5cdH0gZWxzZSBpZiAoZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uPy5bRklMRU5BTUVdKSB7XG5cdFx0bG9jYXRpb24gPSBgaW4gJHtkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb25bRklMRU5BTUVdfWA7XG5cdH1cblxuXHR3Lmh5ZHJhdGlvbl9odG1sX2NoYW5nZWQoc2FuaXRpemVfbG9jYXRpb24obG9jYXRpb24pKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBUZXh0IHwgQ29tbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGdldF92YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc3ZnXVxuICogQHBhcmFtIHtib29sZWFufSBbbWF0aG1sXVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodG1sKG5vZGUsIGdldF92YWx1ZSwgc3ZnID0gZmFsc2UsIG1hdGhtbCA9IGZhbHNlLCBza2lwX3dhcm5pbmcgPSBmYWxzZSkge1xuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHR2YXIgdmFsdWUgPSAnJztcblxuXHR0ZW1wbGF0ZV9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciBlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdFx0aWYgKHZhbHVlID09PSAodmFsdWUgPSBnZXRfdmFsdWUoKSA/PyAnJykpIHtcblx0XHRcdGlmIChoeWRyYXRpbmcpIGh5ZHJhdGVfbmV4dCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChlZmZlY3Qubm9kZXNfc3RhcnQgIT09IG51bGwpIHtcblx0XHRcdHJlbW92ZV9lZmZlY3RfZG9tKGVmZmVjdC5ub2Rlc19zdGFydCwgLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChlZmZlY3Qubm9kZXNfZW5kKSk7XG5cdFx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPSBlZmZlY3Qubm9kZXNfZW5kID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgPT09ICcnKSByZXR1cm47XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHQvLyBXZSdyZSBkZWxpYmVyYXRlbHkgbm90IHRyeWluZyB0byByZXBhaXIgbWlzbWF0Y2hlcyBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50LFxuXHRcdFx0Ly8gYXMgaXQncyBjb3N0bHkgYW5kIGVycm9yLXByb25lIChhbmQgaXQncyBhbiBlZGdlIGNhc2UgdG8gaGF2ZSBhIG1pc21hdGNoIGFueXdheSlcblx0XHRcdHZhciBoYXNoID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhO1xuXHRcdFx0dmFyIG5leHQgPSBoeWRyYXRlX25leHQoKTtcblx0XHRcdHZhciBsYXN0ID0gbmV4dDtcblxuXHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRuZXh0ICE9PSBudWxsICYmXG5cdFx0XHRcdChuZXh0Lm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgfHwgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobmV4dCkuZGF0YSAhPT0gJycpXG5cdFx0XHQpIHtcblx0XHRcdFx0bGFzdCA9IG5leHQ7XG5cdFx0XHRcdG5leHQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobmV4dCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV4dCA9PT0gbnVsbCkge1xuXHRcdFx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdFx0XHR0aHJvdyBIWURSQVRJT05fRVJST1I7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChERVYgJiYgIXNraXBfd2FybmluZykge1xuXHRcdFx0XHRjaGVja19oYXNoKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5leHQucGFyZW50Tm9kZSksIGhhc2gsIHZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbGFzdCk7XG5cdFx0XHRhbmNob3IgPSBzZXRfaHlkcmF0ZV9ub2RlKG5leHQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBodG1sID0gdmFsdWUgKyAnJztcblx0XHRpZiAoc3ZnKSBodG1sID0gYDxzdmc+JHtodG1sfTwvc3ZnPmA7XG5cdFx0ZWxzZSBpZiAobWF0aG1sKSBodG1sID0gYDxtYXRoPiR7aHRtbH08L21hdGg+YDtcblxuXHRcdC8vIERvbid0IHVzZSBjcmVhdGVfZnJhZ21lbnRfd2l0aF9zY3JpcHRfZnJvbV9odG1sIGhlcmUgYmVjYXVzZSB0aGF0IHdvdWxkIG1lYW4gc2NyaXB0IHRhZ3MgYXJlIGV4ZWN1dGVkLlxuXHRcdC8vIEBodG1sIGlzIGJhc2ljYWxseSBgLmlubmVySFRNTCA9IC4uLmAgYW5kIHRoYXQgZG9lc24ndCBleGVjdXRlIHNjcmlwdHMgZWl0aGVyIGR1ZSB0byBzZWN1cml0eSByZWFzb25zLlxuXHRcdC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudCB8IEVsZW1lbnR9ICovXG5cdFx0dmFyIG5vZGUgPSBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpO1xuXG5cdFx0aWYgKHN2ZyB8fCBtYXRobWwpIHtcblx0XHRcdG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpO1xuXHRcdH1cblxuXHRcdGFzc2lnbl9ub2Rlcyhcblx0XHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKSxcblx0XHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobm9kZS5sYXN0Q2hpbGQpXG5cdFx0KTtcblxuXHRcdGlmIChzdmcgfHwgbWF0aG1sKSB7XG5cdFx0XHR3aGlsZSAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKSB7XG5cdFx0XHRcdGFuY2hvci5iZWZvcmUoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuY2hvci5iZWZvcmUobm9kZSk7XG5cdFx0fVxuXHR9KTtcbn1cbiIsICJpbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtDb21tZW50fSBhbmNob3JcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gJCRwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHNsb3RfcHJvcHNcbiAqIEBwYXJhbSB7bnVsbCB8ICgoYW5jaG9yOiBDb21tZW50KSA9PiB2b2lkKX0gZmFsbGJhY2tfZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsb3QoYW5jaG9yLCAkJHByb3BzLCBuYW1lLCBzbG90X3Byb3BzLCBmYWxsYmFja19mbikge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgc2xvdF9mbiA9ICQkcHJvcHMuJCRzbG90cz8uW25hbWVdO1xuXHQvLyBJbnRlcm9wOiBDYW4gdXNlIHNuaXBwZXRzIHRvIGZpbGwgc2xvdHNcblx0dmFyIGlzX2ludGVyb3AgPSBmYWxzZTtcblx0aWYgKHNsb3RfZm4gPT09IHRydWUpIHtcblx0XHRzbG90X2ZuID0gJCRwcm9wc1tuYW1lID09PSAnZGVmYXVsdCcgPyAnY2hpbGRyZW4nIDogbmFtZV07XG5cdFx0aXNfaW50ZXJvcCA9IHRydWU7XG5cdH1cblxuXHRpZiAoc2xvdF9mbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGZhbGxiYWNrX2ZuICE9PSBudWxsKSB7XG5cdFx0XHRmYWxsYmFja19mbihhbmNob3IpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzbG90X2ZuKGFuY2hvciwgaXNfaW50ZXJvcCA/ICgpID0+IHNsb3RfcHJvcHMgOiBzbG90X3Byb3BzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gcHJvcHNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplX3Nsb3RzKHByb3BzKSB7XG5cdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59ICovXG5cdGNvbnN0IHNhbml0aXplZCA9IHt9O1xuXHRpZiAocHJvcHMuY2hpbGRyZW4pIHNhbml0aXplZC5kZWZhdWx0ID0gdHJ1ZTtcblx0Zm9yIChjb25zdCBrZXkgaW4gcHJvcHMuJCRzbG90cykge1xuXHRcdHNhbml0aXplZFtrZXldID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gc2FuaXRpemVkO1xufVxuIiwgImltcG9ydCB7IGlzX3ZvaWQgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5cbmV4cG9ydCB7IGludmFsaWRfZGVmYXVsdF9zbmlwcGV0IH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSB0YWdfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnX2ZuKSB7XG5cdGNvbnN0IHRhZyA9IHRhZ19mbigpO1xuXHRpZiAodGFnICYmIGlzX3ZvaWQodGFnKSkge1xuXHRcdHcuZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudCh0YWcpO1xuXHR9XG59XG5cbi8qKiBAcGFyYW0geygpID0+IHVua25vd259IHRhZ19mbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudF90YWcodGFnX2ZuKSB7XG5cdGNvbnN0IHRhZyA9IHRhZ19mbigpO1xuXHRjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcblx0aWYgKHRhZyAmJiAhaXNfc3RyaW5nKSB7XG5cdFx0ZS5zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWUoKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG5cdGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRlLnN0b3JlX2ludmFsaWRfc2hhcGUobmFtZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgeyguLi5hcmdzOiBhbnlbXSkgPT4gdW5rbm93bn0gVFxuICogQHBhcmFtIHtUfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudF9zbmlwcGV0X3N0cmluZ2lmaWNhdGlvbihmbikge1xuXHRmbi50b1N0cmluZyA9ICgpID0+IHtcblx0XHRlLnNuaXBwZXRfd2l0aG91dF9yZW5kZXJfdGFnKCk7XG5cdFx0cmV0dXJuICcnO1xuXHR9O1xuXHRyZXR1cm4gZm47XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTbmlwcGV0IH0gZnJvbSAnc3ZlbHRlJyAqL1xuLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBHZXR0ZXJzIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCwgRUxFTUVOVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgYmxvY2ssIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbixcblx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvblxufSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCB9IGZyb20gJy4uL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uLy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGdldF9maXJzdF9jaGlsZCwgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgcHJldmVudF9zbmlwcGV0X3N0cmluZ2lmaWNhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC92YWxpZGF0ZS5qcyc7XG5pbXBvcnQgeyBCcmFuY2hNYW5hZ2VyIH0gZnJvbSAnLi9icmFuY2hlcy5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIHsobm9kZTogVGVtcGxhdGVOb2RlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gU25pcHBldEZuXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBTbmlwcGV0Rm4gfCBudWxsIHwgdW5kZWZpbmVkfSBnZXRfc25pcHBldFxuICogQHBhcmFtIHsoKCkgPT4gYW55KVtdfSBhcmdzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuaXBwZXQobm9kZSwgZ2V0X3NuaXBwZXQsIC4uLmFyZ3MpIHtcblx0dmFyIGJyYW5jaGVzID0gbmV3IEJyYW5jaE1hbmFnZXIobm9kZSk7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdGNvbnN0IHNuaXBwZXQgPSBnZXRfc25pcHBldCgpID8/IG51bGw7XG5cblx0XHRpZiAoREVWICYmIHNuaXBwZXQgPT0gbnVsbCkge1xuXHRcdFx0ZS5pbnZhbGlkX3NuaXBwZXQoKTtcblx0XHR9XG5cblx0XHRicmFuY2hlcy5lbnN1cmUoc25pcHBldCwgc25pcHBldCAmJiAoKGFuY2hvcikgPT4gc25pcHBldChhbmNob3IsIC4uLmFyZ3MpKSk7XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG59XG5cbi8qKlxuICogSW4gZGV2ZWxvcG1lbnQsIHdyYXAgdGhlIHNuaXBwZXQgZnVuY3Rpb24gc28gdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbiwgYW5kIHNvIHRoYXQgdGhlXG4gKiBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0IGlzIHNldCBmb3Igb3duZXJzaGlwIGNoZWNrc1xuICogQHBhcmFtIHthbnl9IGNvbXBvbmVudFxuICogQHBhcmFtIHsobm9kZTogVGVtcGxhdGVOb2RlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBfc25pcHBldChjb21wb25lbnQsIGZuKSB7XG5cdGNvbnN0IHNuaXBwZXQgPSAoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIG5vZGUsIC8qKiBAdHlwZSB7YW55W119ICovIC4uLmFyZ3MpID0+IHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oY29tcG9uZW50KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZm4obm9kZSwgLi4uYXJncyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24ocHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uKTtcblx0XHR9XG5cdH07XG5cblx0cHJldmVudF9zbmlwcGV0X3N0cmluZ2lmaWNhdGlvbihzbmlwcGV0KTtcblxuXHRyZXR1cm4gc25pcHBldDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzbmlwcGV0IHByb2dyYW1tYXRpY2FsbHlcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bltdfSBQYXJhbXNcbiAqIEBwYXJhbSB7KC4uLnBhcmFtczogR2V0dGVyczxQYXJhbXM+KSA9PiB7XG4gKiAgIHJlbmRlcjogKCkgPT4gc3RyaW5nXG4gKiAgIHNldHVwPzogKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHZvaWQgfCAoKCkgPT4gdm9pZClcbiAqIH19IGZuXG4gKiBAcmV0dXJucyB7U25pcHBldDxQYXJhbXM+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF3U25pcHBldChmbikge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSB0eXBlcyBhcmUgYSBsaWVcblx0cmV0dXJuICgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gYW5jaG9yLCAvKiogQHR5cGUge0dldHRlcnM8UGFyYW1zPn0gKi8gLi4ucGFyYW1zKSA9PiB7XG5cdFx0dmFyIHNuaXBwZXQgPSBmbiguLi5wYXJhbXMpO1xuXG5cdFx0LyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuXHRcdHZhciBlbGVtZW50O1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0ZWxlbWVudCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSk7XG5cdFx0XHRoeWRyYXRlX25leHQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGh0bWwgPSBzbmlwcGV0LnJlbmRlcigpLnRyaW0oKTtcblx0XHRcdHZhciBmcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwoaHRtbCk7XG5cdFx0XHRlbGVtZW50ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGZyYWdtZW50KSk7XG5cblx0XHRcdGlmIChERVYgJiYgKGdldF9uZXh0X3NpYmxpbmcoZWxlbWVudCkgIT09IG51bGwgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFKSkge1xuXHRcdFx0XHR3LmludmFsaWRfcmF3X3NuaXBwZXRfcmVuZGVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdGFuY2hvci5iZWZvcmUoZWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzdWx0ID0gc25pcHBldC5zZXR1cD8uKGVsZW1lbnQpO1xuXHRcdGFzc2lnbl9ub2RlcyhlbGVtZW50LCBlbGVtZW50KTtcblxuXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0ZWFyZG93bihyZXN1bHQpO1xuXHRcdH1cblx0fTtcbn1cbiIsICIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSwgRG9tIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGJsb2NrIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IEJyYW5jaE1hbmFnZXIgfSBmcm9tICcuL2JyYW5jaGVzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgUFxuICogQHRlbXBsYXRlIHsocHJvcHM6IFApID0+IHZvaWR9IENcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygpID0+IEN9IGdldF9jb21wb25lbnRcbiAqIEBwYXJhbSB7KGFuY2hvcjogVGVtcGxhdGVOb2RlLCBjb21wb25lbnQ6IEMpID0+IERvbSB8IHZvaWR9IHJlbmRlcl9mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnQobm9kZSwgZ2V0X2NvbXBvbmVudCwgcmVuZGVyX2ZuKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBicmFuY2hlcyA9IG5ldyBCcmFuY2hNYW5hZ2VyKG5vZGUpO1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHR2YXIgY29tcG9uZW50ID0gZ2V0X2NvbXBvbmVudCgpID8/IG51bGw7XG5cdFx0YnJhbmNoZXMuZW5zdXJlKGNvbXBvbmVudCwgY29tcG9uZW50ICYmICgodGFyZ2V0KSA9PiByZW5kZXJfZm4odGFyZ2V0LCBjb21wb25lbnQpKSk7XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBGSUxFTkFNRSwgTkFNRVNQQUNFX1NWRyB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBibG9jaywgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgc2V0X3Nob3VsZF9pbnRybyB9IGZyb20gJy4uLy4uL3JlbmRlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2VhY2hfaXRlbSwgc2V0X2N1cnJlbnRfZWFjaF9pdGVtIH0gZnJvbSAnLi9lYWNoLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBkZXZfc3RhY2sgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5ULCBFTEVNRU5UX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgeyBpc19yYXdfdGV4dF9lbGVtZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQnJhbmNoTWFuYWdlciB9IGZyb20gJy4vYnJhbmNoZXMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Q29tbWVudCB8IEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSBnZXRfdGFnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3N2Z1xuICogQHBhcmFtIHt1bmRlZmluZWQgfCAoKGVsZW1lbnQ6IEVsZW1lbnQsIGFuY2hvcjogTm9kZSB8IG51bGwpID0+IHZvaWQpfSByZW5kZXJfZm4sXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8ICgoKSA9PiBzdHJpbmcpfSBnZXRfbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8IFtudW1iZXIsIG51bWJlcl19IGxvY2F0aW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnQobm9kZSwgZ2V0X3RhZywgaXNfc3ZnLCByZW5kZXJfZm4sIGdldF9uYW1lc3BhY2UsIGxvY2F0aW9uKSB7XG5cdGxldCB3YXNfaHlkcmF0aW5nID0gaHlkcmF0aW5nO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBmaWxlbmFtZSA9IERFViAmJiBsb2NhdGlvbiAmJiBjb21wb25lbnRfY29udGV4dD8uZnVuY3Rpb25bRklMRU5BTUVdO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdHZhciBlbGVtZW50ID0gbnVsbDtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG5cdFx0ZWxlbWVudCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSk7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChoeWRyYXRpbmcgPyBoeWRyYXRlX25vZGUgOiBub2RlKTtcblxuXHQvKipcblx0ICogVGhlIGtleWVkIGB7I2VhY2ggLi4ufWAgaXRlbSBibG9jaywgaWYgYW55LCB0aGF0IHRoaXMgZWxlbWVudCBpcyBpbnNpZGUuXG5cdCAqIFdlIHRyYWNrIHRoaXMgc28gd2UgY2FuIHNldCBpdCB3aGVuIGNoYW5naW5nIHRoZSBlbGVtZW50LCBhbGxvd2luZyBhbnlcblx0ICogYGFuaW1hdGU6YCBkaXJlY3RpdmUgdG8gYmluZCBpdHNlbGYgdG8gdGhlIGNvcnJlY3QgYmxvY2tcblx0ICovXG5cdHZhciBlYWNoX2l0ZW1fYmxvY2sgPSBjdXJyZW50X2VhY2hfaXRlbTtcblxuXHR2YXIgYnJhbmNoZXMgPSBuZXcgQnJhbmNoTWFuYWdlcihhbmNob3IsIGZhbHNlKTtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0Y29uc3QgbmV4dF90YWcgPSBnZXRfdGFnKCkgfHwgbnVsbDtcblx0XHR2YXIgbnMgPSBnZXRfbmFtZXNwYWNlID8gZ2V0X25hbWVzcGFjZSgpIDogaXNfc3ZnIHx8IG5leHRfdGFnID09PSAnc3ZnJyA/IE5BTUVTUEFDRV9TVkcgOiBudWxsO1xuXG5cdFx0aWYgKG5leHRfdGFnID09PSBudWxsKSB7XG5cdFx0XHRicmFuY2hlcy5lbnN1cmUobnVsbCwgbnVsbCk7XG5cdFx0XHRzZXRfc2hvdWxkX2ludHJvKHRydWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGJyYW5jaGVzLmVuc3VyZShuZXh0X3RhZywgKGFuY2hvcikgPT4ge1xuXHRcdFx0Ly8gU2VlIGV4cGxhbmF0aW9uIG9mIGBlYWNoX2l0ZW1fYmxvY2tgIGFib3ZlXG5cdFx0XHR2YXIgcHJldmlvdXNfZWFjaF9pdGVtID0gY3VycmVudF9lYWNoX2l0ZW07XG5cdFx0XHRzZXRfY3VycmVudF9lYWNoX2l0ZW0oZWFjaF9pdGVtX2Jsb2NrKTtcblxuXHRcdFx0aWYgKG5leHRfdGFnKSB7XG5cdFx0XHRcdGVsZW1lbnQgPSBoeWRyYXRpbmdcblx0XHRcdFx0XHQ/IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGVsZW1lbnQpXG5cdFx0XHRcdFx0OiBuc1xuXHRcdFx0XHRcdFx0PyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIG5leHRfdGFnKVxuXHRcdFx0XHRcdFx0OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5leHRfdGFnKTtcblxuXHRcdFx0XHRpZiAoREVWICYmIGxvY2F0aW9uKSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRcdGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcblx0XHRcdFx0XHRcdHBhcmVudDogZGV2X3N0YWNrLFxuXHRcdFx0XHRcdFx0bG9jOiB7XG5cdFx0XHRcdFx0XHRcdGZpbGU6IGZpbGVuYW1lLFxuXHRcdFx0XHRcdFx0XHRsaW5lOiBsb2NhdGlvblswXSxcblx0XHRcdFx0XHRcdFx0Y29sdW1uOiBsb2NhdGlvblsxXVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ25fbm9kZXMoZWxlbWVudCwgZWxlbWVudCk7XG5cblx0XHRcdFx0aWYgKHJlbmRlcl9mbikge1xuXHRcdFx0XHRcdGlmIChoeWRyYXRpbmcgJiYgaXNfcmF3X3RleHRfZWxlbWVudChuZXh0X3RhZykpIHtcblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgaHlkcmF0aW9uIGdsaXRjaGVzXG5cdFx0XHRcdFx0XHRlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSWYgaHlkcmF0aW5nLCB1c2UgdGhlIGV4aXN0aW5nIHNzciBjb21tZW50IGFzIHRoZSBhbmNob3Igc28gdGhhdCB0aGVcblx0XHRcdFx0XHQvLyBpbm5lciBvcGVuIGFuZCBjbG9zZSBtZXRob2RzIGNhbiBwaWNrIHVwIHRoZSBleGlzdGluZyBub2RlcyBjb3JyZWN0bHlcblx0XHRcdFx0XHR2YXIgY2hpbGRfYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChcblx0XHRcdFx0XHRcdGh5ZHJhdGluZyA/IGdldF9maXJzdF9jaGlsZChlbGVtZW50KSA6IGVsZW1lbnQuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSlcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkX2FuY2hvciA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoY2hpbGRfYW5jaG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBgY2hpbGRfYW5jaG9yYCBpcyB1bmRlZmluZWQgaWYgdGhpcyBpcyBhIHZvaWQgZWxlbWVudCwgYnV0IHdlIHN0aWxsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjYWxsIGByZW5kZXJfZm5gIGluIG9yZGVyIHRvIHJ1biBhY3Rpb25zIGV0Yy4gSWYgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQvLyBjb250YWlucyBjaGlsZHJlbiwgaXQncyBhIHVzZXIgZXJyb3IgKHdoaWNoIGlzIHdhcm5lZCBvbiBlbHNld2hlcmUpXG5cdFx0XHRcdFx0Ly8gYW5kIHRoZSBET00gd2lsbCBiZSBzaWxlbnRseSBkaXNjYXJkZWRcblx0XHRcdFx0XHRyZW5kZXJfZm4oZWxlbWVudCwgY2hpbGRfYW5jaG9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHdlIGRvIHRoaXMgYWZ0ZXIgY2FsbGluZyBgcmVuZGVyX2ZuYCBzbyB0aGF0IGNoaWxkIGVmZmVjdHMgZG9uJ3Qgb3ZlcnJpZGUgYG5vZGVzLmVuZGBcblx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBlbGVtZW50O1xuXG5cdFx0XHRcdGFuY2hvci5iZWZvcmUoZWxlbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHNldF9jdXJyZW50X2VhY2hfaXRlbShwcmV2aW91c19lYWNoX2l0ZW0pO1xuXG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHJldmVydCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBhZnRlciB0aGUgZWZmZWN0IGhhcyBiZWVuIGNyZWF0ZWRcblx0XHRzZXRfc2hvdWxkX2ludHJvKHRydWUpO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGlmIChuZXh0X3RhZykge1xuXHRcdFx0XHQvLyBpZiB3ZSdyZSBpbiB0aGlzIGNhbGxiYWNrIGJlY2F1c2Ugd2UncmUgcmUtcnVubmluZyB0aGUgZWZmZWN0LFxuXHRcdFx0XHQvLyBkaXNhYmxlIGludHJvcyAodW5sZXNzIG5vIGVsZW1lbnQgaXMgY3VycmVudGx5IGRpc3BsYXllZClcblx0XHRcdFx0c2V0X3Nob3VsZF9pbnRybyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0c2V0X3Nob3VsZF9pbnRybyh0cnVlKTtcblx0fSk7XG5cblx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlLCBzZXRfaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV90ZXh0LCBnZXRfZmlyc3RfY2hpbGQsIGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGJsb2NrIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IENPTU1FTlRfTk9ERSwgSEVBRF9FRkZFQ1QgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSkgPT4gdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlYWQoaGFzaCwgcmVuZGVyX2ZuKSB7XG5cdC8vIFRoZSBoZWFkIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGZpcnN0IGh5ZHJhdGlvbiBwYXNzIGFuZCBzc3IgY29tbWVudCBub2RlcyBtYXkgc3RpbGwgYmUgcHJlc2VudCxcblx0Ly8gdGhlcmVmb3JlIHdlIG5lZWQgdG8gc2tpcCB0aGF0IHdoZW4gd2UgZGV0ZWN0IHRoYXQgd2UncmUgbm90IGluIGh5ZHJhdGlvbiBtb2RlLlxuXHRsZXQgcHJldmlvdXNfaHlkcmF0ZV9ub2RlID0gbnVsbDtcblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cblx0LyoqIEB0eXBlIHtDb21tZW50IHwgVGV4dH0gKi9cblx0dmFyIGFuY2hvcjtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0cHJldmlvdXNfaHlkcmF0ZV9ub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdFx0dmFyIGhlYWRfYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQoZG9jdW1lbnQuaGVhZCkpO1xuXG5cdFx0Ly8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgaGVhZCBibG9ja3MgaW4gb3VyIGFwcCwgYW5kIHRoZXkgY291bGQgaGF2ZSBiZWVuXG5cdFx0Ly8gcmVuZGVyZWQgaW4gYW4gYXJiaXRyYXJ5IG9yZGVyIFx1MjAxNCBmaW5kIG9uZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgY29tcG9uZW50XG5cdFx0d2hpbGUgKFxuXHRcdFx0aGVhZF9hbmNob3IgIT09IG51bGwgJiZcblx0XHRcdChoZWFkX2FuY2hvci5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFIHx8IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGhlYWRfYW5jaG9yKS5kYXRhICE9PSBoYXNoKVxuXHRcdCkge1xuXHRcdFx0aGVhZF9hbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoaGVhZF9hbmNob3IpKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBjYW4ndCBmaW5kIGFuIG9wZW5pbmcgaHlkcmF0aW9uIG1hcmtlciwgc2tpcCBoeWRyYXRpb24gKHRoaXMgY2FuIGhhcHBlblxuXHRcdC8vIGlmIGEgZnJhbWV3b3JrIHJlbmRlcmVkIGJvZHkgYnV0IG5vdCBoZWFkIGNvbnRlbnQpXG5cdFx0aWYgKGhlYWRfYW5jaG9yID09PSBudWxsKSB7XG5cdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHN0YXJ0ID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKGhlYWRfYW5jaG9yKSk7XG5cdFx0XHRoZWFkX2FuY2hvci5yZW1vdmUoKTsgLy8gaW4gY2FzZSB0aGlzIGNvbXBvbmVudCBpcyByZXBlYXRlZFxuXG5cdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKHN0YXJ0KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSk7XG5cdH1cblxuXHR0cnkge1xuXHRcdGJsb2NrKCgpID0+IHJlbmRlcl9mbihhbmNob3IpLCBIRUFEX0VGRkVDVCk7XG5cdH0gZmluYWxseSB7XG5cdFx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAocHJldmlvdXNfaHlkcmF0ZV9ub2RlKSk7XG5cdFx0fVxuXHR9XG59XG4iLCAiaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyByZWdpc3Rlcl9zdHlsZSB9IGZyb20gJy4uL2Rldi9jc3MuanMnO1xuaW1wb3J0IHsgZWZmZWN0IH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IGFuY2hvclxuICogQHBhcmFtIHt7IGhhc2g6IHN0cmluZywgY29kZTogc3RyaW5nIH19IGNzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyhhbmNob3IsIGNzcykge1xuXHQvLyBVc2UgYHF1ZXVlX21pY3JvX3Rhc2tgIHRvIGVuc3VyZSBgYW5jaG9yYCBpcyBpbiB0aGUgRE9NLCBvdGhlcndpc2UgZ2V0Um9vdE5vZGUoKSB3aWxsIHlpZWxkIHdyb25nIHJlc3VsdHNcblx0ZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgcm9vdCA9IGFuY2hvci5nZXRSb290Tm9kZSgpO1xuXG5cdFx0dmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpLmhvc3Rcblx0XHRcdD8gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdClcblx0XHRcdDogLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHJvb3QpLmhlYWQgPz8gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHJvb3Qub3duZXJEb2N1bWVudCkuaGVhZDtcblxuXHRcdC8vIEFsd2F5cyBxdWVyeWluZyB0aGUgRE9NIGlzIHJvdWdobHkgdGhlIHNhbWUgcGVyZiBhcyBhZGRpdGlvbmFsbHkgY2hlY2tpbmcgZm9yIHByZXNlbmNlIGluIGEgbWFwIGZpcnN0IGFzc3VtaW5nXG5cdFx0Ly8gdGhhdCB5b3UnbGwgZ2V0IGNhY2hlIGhpdHMgaGFsZiBvZiB0aGUgdGltZSwgc28gd2UganVzdCBhbHdheXMgcXVlcnkgdGhlIGRvbSBmb3Igc2ltcGxpY2l0eSBhbmQgY29kZSBzYXZpbmdzLlxuXHRcdGlmICghdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJyMnICsgY3NzLmhhc2gpKSB7XG5cdFx0XHRjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0XHRzdHlsZS5pZCA9IGNzcy5oYXNoO1xuXHRcdFx0c3R5bGUudGV4dENvbnRlbnQgPSBjc3MuY29kZTtcblxuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblxuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRyZWdpc3Rlcl9zdHlsZShjc3MuaGFzaCwgc3R5bGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBBY3Rpb25QYXlsb2FkIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGVmZmVjdCwgcmVuZGVyX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzYWZlX25vdF9lcXVhbCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZXF1YWxpdHkuanMnO1xuaW1wb3J0IHsgZGVlcF9yZWFkX3N0YXRlLCB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFBcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0geyhkb206IEVsZW1lbnQsIHZhbHVlPzogUCkgPT4gQWN0aW9uUGF5bG9hZDxQPn0gYWN0aW9uXG4gKiBAcGFyYW0geygpID0+IFB9IFtnZXRfdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjdGlvbihkb20sIGFjdGlvbiwgZ2V0X3ZhbHVlKSB7XG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHBheWxvYWQgPSB1bnRyYWNrKCgpID0+IGFjdGlvbihkb20sIGdldF92YWx1ZT8uKCkpIHx8IHt9KTtcblxuXHRcdGlmIChnZXRfdmFsdWUgJiYgcGF5bG9hZD8udXBkYXRlKSB7XG5cdFx0XHR2YXIgaW5pdGVkID0gZmFsc2U7XG5cdFx0XHQvKiogQHR5cGUge1B9ICovXG5cdFx0XHR2YXIgcHJldiA9IC8qKiBAdHlwZSB7YW55fSAqLyAoe30pOyAvLyBpbml0aWFsaXplIHdpdGggc29tZXRoaW5nIHNvIGl0J3MgbmV2ZXIgZXF1YWwgb24gZmlyc3QgcnVuXG5cblx0XHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBnZXRfdmFsdWUoKTtcblxuXHRcdFx0XHQvLyBBY3Rpb24ncyB1cGRhdGUgbWV0aG9kIGlzIGNvYXJzZS1ncmFpbmVkLCBpLmUuIHdoZW4gYW55dGhpbmcgaW4gdGhlIHBhc3NlZCB2YWx1ZSBjaGFuZ2VzLCB1cGRhdGUuXG5cdFx0XHRcdC8vIFRoaXMgd29ya3MgaW4gbGVnYWN5IG1vZGUgYmVjYXVzZSBvZiBtdXRhYmxlX3NvdXJjZSBiZWluZyB1cGRhdGVkIGFzIGEgd2hvbGUsIGJ1dCB3aGVuIHVzaW5nICRzdGF0ZVxuXHRcdFx0XHQvLyB0b2dldGhlciB3aXRoIGFjdGlvbnMgYW5kIG11dGF0aW9uLCBpdCB3b3VsZG4ndCBub3RpY2UgdGhlIGNoYW5nZSB3aXRob3V0IGEgZGVlcCByZWFkLlxuXHRcdFx0XHRkZWVwX3JlYWRfc3RhdGUodmFsdWUpO1xuXG5cdFx0XHRcdGlmIChpbml0ZWQgJiYgc2FmZV9ub3RfZXF1YWwocHJldiwgdmFsdWUpKSB7XG5cdFx0XHRcdFx0cHJldiA9IHZhbHVlO1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChwYXlsb2FkLnVwZGF0ZSkodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aW5pdGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAocGF5bG9hZD8uZGVzdHJveSkge1xuXHRcdFx0cmV0dXJuICgpID0+IC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChwYXlsb2FkLmRlc3Ryb3kpKCk7XG5cdFx0fVxuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBicmFuY2gsIGVmZmVjdCwgZGVzdHJveV9lZmZlY3QsIG1hbmFnZWQgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuXG4vLyBUT0RPIGluIDYuMCBvciA3LjAsIHdoZW4gd2UgcmVtb3ZlIGxlZ2FjeSBtb2RlLCB3ZSBjYW4gc2ltcGxpZnkgdGhpcyBieVxuLy8gZ2V0dGluZyByaWQgb2YgdGhlIGJsb2NrL2JyYW5jaCBzdHVmZiBhbmQganVzdCBsZXR0aW5nIHRoZSBlZmZlY3QgcmlwLlxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC8xNTk2MlxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiAobm9kZTogRWxlbWVudCkgPT4gdm9pZH0gZ2V0X2ZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2gobm9kZSwgZ2V0X2ZuKSB7XG5cdC8qKiBAdHlwZSB7ZmFsc2UgfCB1bmRlZmluZWQgfCAoKG5vZGU6IEVsZW1lbnQpID0+IHZvaWQpfSAqL1xuXHR2YXIgZm4gPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZTtcblxuXHRtYW5hZ2VkKCgpID0+IHtcblx0XHRpZiAoZm4gIT09IChmbiA9IGdldF9mbigpKSkge1xuXHRcdFx0aWYgKGUpIHtcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZSk7XG5cdFx0XHRcdGUgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZm4pIHtcblx0XHRcdFx0ZSA9IGJyYW5jaCgoKSA9PiB7XG5cdFx0XHRcdFx0ZWZmZWN0KCgpID0+IC8qKiBAdHlwZSB7KG5vZGU6IEVsZW1lbnQpID0+IHZvaWR9ICovIChmbikobm9kZSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IHRvX2NsYXNzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2F0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtib29sZWFuIHwgbnVtYmVyfSBpc19odG1sXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFtwcmV2X2NsYXNzZXNdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFtuZXh0X2NsYXNzZXNdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj4gfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2xhc3MoZG9tLCBpc19odG1sLCB2YWx1ZSwgaGFzaCwgcHJldl9jbGFzc2VzLCBuZXh0X2NsYXNzZXMpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHR2YXIgcHJldiA9IGRvbS5fX2NsYXNzTmFtZTtcblxuXHRpZiAoXG5cdFx0aHlkcmF0aW5nIHx8XG5cdFx0cHJldiAhPT0gdmFsdWUgfHxcblx0XHRwcmV2ID09PSB1bmRlZmluZWQgLy8gZm9yIGVkZ2UgY2FzZSBvZiBgY2xhc3M9e3VuZGVmaW5lZH1gXG5cdCkge1xuXHRcdHZhciBuZXh0X2NsYXNzX25hbWUgPSB0b19jbGFzcyh2YWx1ZSwgaGFzaCwgbmV4dF9jbGFzc2VzKTtcblxuXHRcdGlmICghaHlkcmF0aW5nIHx8IG5leHRfY2xhc3NfbmFtZSAhPT0gZG9tLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkge1xuXHRcdFx0Ly8gUmVtb3ZpbmcgdGhlIGF0dHJpYnV0ZSB3aGVuIHRoZSB2YWx1ZSBpcyBvbmx5IGFuIGVtcHR5IHN0cmluZyBjYXVzZXNcblx0XHRcdC8vIHBlcmZvcm1hbmNlIGlzc3VlcyB2cyBzaW1wbHkgbWFraW5nIHRoZSBjbGFzc05hbWUgYW4gZW1wdHkgc3RyaW5nLiBTb1xuXHRcdFx0Ly8gd2Ugc2hvdWxkIG9ubHkgcmVtb3ZlIHRoZSBjbGFzcyBpZiB0aGUgdmFsdWUgaXMgbnVsbGlzaFxuXHRcdFx0Ly8gYW5kIHRoZXJlIG5vIGhhc2gvZGlyZWN0aXZlcyA6XG5cdFx0XHRpZiAobmV4dF9jbGFzc19uYW1lID09IG51bGwpIHtcblx0XHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNfaHRtbCkge1xuXHRcdFx0XHRkb20uY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBuZXh0X2NsYXNzX25hbWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0XHRkb20uX19jbGFzc05hbWUgPSB2YWx1ZTtcblx0fSBlbHNlIGlmIChuZXh0X2NsYXNzZXMgJiYgcHJldl9jbGFzc2VzICE9PSBuZXh0X2NsYXNzZXMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gbmV4dF9jbGFzc2VzKSB7XG5cdFx0XHR2YXIgaXNfcHJlc2VudCA9ICEhbmV4dF9jbGFzc2VzW2tleV07XG5cblx0XHRcdGlmIChwcmV2X2NsYXNzZXMgPT0gbnVsbCB8fCBpc19wcmVzZW50ICE9PSAhIXByZXZfY2xhc3Nlc1trZXldKSB7XG5cdFx0XHRcdGRvbS5jbGFzc0xpc3QudG9nZ2xlKGtleSwgaXNfcHJlc2VudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5leHRfY2xhc3Nlcztcbn1cbiIsICJpbXBvcnQgeyB0b19zdHlsZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9hdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBkb21cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gcHJldlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBuZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByaW9yaXR5XVxuICovXG5mdW5jdGlvbiB1cGRhdGVfc3R5bGVzKGRvbSwgcHJldiA9IHt9LCBuZXh0LCBwcmlvcml0eSkge1xuXHRmb3IgKHZhciBrZXkgaW4gbmV4dCkge1xuXHRcdHZhciB2YWx1ZSA9IG5leHRba2V5XTtcblxuXHRcdGlmIChwcmV2W2tleV0gIT09IHZhbHVlKSB7XG5cdFx0XHRpZiAobmV4dFtrZXldID09IG51bGwpIHtcblx0XHRcdFx0ZG9tLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb20uc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgcHJpb3JpdHkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHZhbHVlXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT4gfCBbUmVjb3JkPHN0cmluZywgYW55PiwgUmVjb3JkPHN0cmluZywgYW55Pl19IFtwcmV2X3N0eWxlc11cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55PiB8IFtSZWNvcmQ8c3RyaW5nLCBhbnk+LCBSZWNvcmQ8c3RyaW5nLCBhbnk+XX0gW25leHRfc3R5bGVzXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0eWxlKGRvbSwgdmFsdWUsIHByZXZfc3R5bGVzLCBuZXh0X3N0eWxlcykge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBwcmV2ID0gZG9tLl9fc3R5bGU7XG5cblx0aWYgKGh5ZHJhdGluZyB8fCBwcmV2ICE9PSB2YWx1ZSkge1xuXHRcdHZhciBuZXh0X3N0eWxlX2F0dHIgPSB0b19zdHlsZSh2YWx1ZSwgbmV4dF9zdHlsZXMpO1xuXG5cdFx0aWYgKCFoeWRyYXRpbmcgfHwgbmV4dF9zdHlsZV9hdHRyICE9PSBkb20uZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG5cdFx0XHRpZiAobmV4dF9zdHlsZV9hdHRyID09IG51bGwpIHtcblx0XHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gbmV4dF9zdHlsZV9hdHRyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRkb20uX19zdHlsZSA9IHZhbHVlO1xuXHR9IGVsc2UgaWYgKG5leHRfc3R5bGVzKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobmV4dF9zdHlsZXMpKSB7XG5cdFx0XHR1cGRhdGVfc3R5bGVzKGRvbSwgcHJldl9zdHlsZXM/LlswXSwgbmV4dF9zdHlsZXNbMF0pO1xuXHRcdFx0dXBkYXRlX3N0eWxlcyhkb20sIHByZXZfc3R5bGVzPy5bMV0sIG5leHRfc3R5bGVzWzFdLCAnaW1wb3J0YW50Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVwZGF0ZV9zdHlsZXMoZG9tLCBwcmV2X3N0eWxlcywgbmV4dF9zdHlsZXMpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXh0X3N0eWxlcztcbn1cbiIsICJpbXBvcnQgeyBlZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IGlzX2FycmF5IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGN1cnJlbnRfYmF0Y2gsIHByZXZpb3VzX2JhdGNoIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5cbi8qKlxuICogU2VsZWN0cyB0aGUgY29ycmVjdCBvcHRpb24ocykgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoaXMgaXMgYSBtdWx0aXBsZSBzZWxlY3QpXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1vdW50aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nID0gZmFsc2UpIHtcblx0aWYgKHNlbGVjdC5tdWx0aXBsZSkge1xuXHRcdC8vIElmIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBrZWVwIHRoZSBzZWxlY3Rpb24gYXMgaXNcblx0XHRpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm90IGFuIGFycmF5LCB3YXJuIGFuZCBrZWVwIHRoZSBzZWxlY3Rpb24gYXMgaXNcblx0XHRpZiAoIWlzX2FycmF5KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIHcuc2VsZWN0X211bHRpcGxlX2ludmFsaWRfdmFsdWUoKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG5cdFx0Zm9yICh2YXIgb3B0aW9uIG9mIHNlbGVjdC5vcHRpb25zKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5pbmNsdWRlcyhnZXRfb3B0aW9uX3ZhbHVlKG9wdGlvbikpO1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdGZvciAob3B0aW9uIG9mIHNlbGVjdC5vcHRpb25zKSB7XG5cdFx0dmFyIG9wdGlvbl92YWx1ZSA9IGdldF9vcHRpb25fdmFsdWUob3B0aW9uKTtcblx0XHRpZiAoaXMob3B0aW9uX3ZhbHVlLCB2YWx1ZSkpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxuXHR9XG59XG5cbi8qKlxuICogU2VsZWN0cyB0aGUgY29ycmVjdCBvcHRpb24ocykgaWYgYHZhbHVlYCBpcyBnaXZlbixcbiAqIGFuZCB0aGVuIHNldHMgdXAgYSBtdXRhdGlvbiBvYnNlcnZlciB0byBzeW5jIHRoZVxuICogY3VycmVudCBzZWxlY3Rpb24gdG8gdGhlIGRvbSB3aGVuIGl0IGNoYW5nZXMuIFN1Y2hcbiAqIGNoYW5nZXMgY291bGQgZm9yIGV4YW1wbGUgb2NjdXIgd2hlbiBvcHRpb25zIGFyZVxuICogaW5zaWRlIGFuIGAjZWFjaGAgYmxvY2suXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfc2VsZWN0KHNlbGVjdCkge1xuXHR2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHNlbGVjdF9vcHRpb24oc2VsZWN0LCBzZWxlY3QuX192YWx1ZSk7XG5cdFx0Ly8gRGVsaWJlcmF0ZWx5IGRvbid0IHVwZGF0ZSB0aGUgcG90ZW50aWFsIGJpbmRpbmcgdmFsdWUsXG5cdFx0Ly8gdGhlIG1vZGVsIHNob3VsZCBiZSBwcmVzZXJ2ZWQgdW5sZXNzIGV4cGxpY2l0bHkgY2hhbmdlZFxuXHR9KTtcblxuXHRvYnNlcnZlci5vYnNlcnZlKHNlbGVjdCwge1xuXHRcdC8vIExpc3RlbiB0byBvcHRpb24gZWxlbWVudCBjaGFuZ2VzXG5cdFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHRcdHN1YnRyZWU6IHRydWUsIC8vIGJlY2F1c2Ugb2YgPG9wdGdyb3VwPlxuXHRcdC8vIExpc3RlbiB0byBvcHRpb24gZWxlbWVudCB2YWx1ZSBhdHRyaWJ1dGUgY2hhbmdlc1xuXHRcdC8vIChkb2Vzbid0IGdldCBub3RpZmllZCBvZiBzZWxlY3QgdmFsdWUgY2hhbmdlcyxcblx0XHQvLyBiZWNhdXNlIHRoYXQgcHJvcGVydHkgaXMgbm90IHJlZmxlY3RlZCBhcyBhbiBhdHRyaWJ1dGUpXG5cdFx0YXR0cmlidXRlczogdHJ1ZSxcblx0XHRhdHRyaWJ1dGVGaWx0ZXI6IFsndmFsdWUnXVxuXHR9KTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfc2VsZWN0X3ZhbHVlKHNlbGVjdCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIGJhdGNoZXMgPSBuZXcgV2Vha1NldCgpO1xuXHR2YXIgbW91bnRpbmcgPSB0cnVlO1xuXG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoc2VsZWN0LCAnY2hhbmdlJywgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0dmFyIHF1ZXJ5ID0gaXNfcmVzZXQgPyAnW3NlbGVjdGVkXScgOiAnOmNoZWNrZWQnO1xuXHRcdC8qKiBAdHlwZSB7dW5rbm93bn0gKi9cblx0XHR2YXIgdmFsdWU7XG5cblx0XHRpZiAoc2VsZWN0Lm11bHRpcGxlKSB7XG5cdFx0XHR2YWx1ZSA9IFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZ2V0X29wdGlvbl92YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qKiBAdHlwZSB7SFRNTE9wdGlvbkVsZW1lbnQgfCBudWxsfSAqL1xuXHRcdFx0dmFyIHNlbGVjdGVkX29wdGlvbiA9XG5cdFx0XHRcdHNlbGVjdC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSA/P1xuXHRcdFx0XHQvLyB3aWxsIGZhbGwgYmFjayB0byBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uIGlmIG5vIG9wdGlvbiBpcyBzZWxlY3RlZFxuXHRcdFx0XHRzZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uOm5vdChbZGlzYWJsZWRdKScpO1xuXHRcdFx0dmFsdWUgPSBzZWxlY3RlZF9vcHRpb24gJiYgZ2V0X29wdGlvbl92YWx1ZShzZWxlY3RlZF9vcHRpb24pO1xuXHRcdH1cblxuXHRcdHNldCh2YWx1ZSk7XG5cblx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCkge1xuXHRcdFx0YmF0Y2hlcy5hZGQoY3VycmVudF9iYXRjaCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBOZWVkcyB0byBiZSBhbiBlZmZlY3QsIG5vdCBhIHJlbmRlcl9lZmZlY3QsIHNvIHRoYXQgaW4gY2FzZSBvZiBlYWNoIGxvb3BzIHRoZSBsb2dpYyBydW5zIGFmdGVyIHRoZSBlYWNoIGJsb2NrIGhhcyB1cGRhdGVkXG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHRpZiAoc2VsZWN0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG5cdFx0XHQvLyB3ZSBuZWVkIGJvdGgsIGJlY2F1c2UgaW4gbm9uLWFzeW5jIG1vZGUsIHJlbmRlciBlZmZlY3RzIHJ1biBiZWZvcmUgcHJldmlvdXNfYmF0Y2ggaXMgc2V0XG5cdFx0XHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAocHJldmlvdXNfYmF0Y2ggPz8gY3VycmVudF9iYXRjaCk7XG5cblx0XHRcdC8vIERvbid0IHVwZGF0ZSB0aGUgPHNlbGVjdD4gaWYgaXQgaXMgZm9jdXNlZC4gV2UgY2FuIGdldCBoZXJlIGlmLCBmb3IgZXhhbXBsZSxcblx0XHRcdC8vIGFuIHVwZGF0ZSBpcyBkZWZlcnJlZCBiZWNhdXNlIG9mIGFzeW5jIHdvcmsgZGVwZW5kaW5nIG9uIHRoZSBzZWxlY3Q6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gPHNlbGVjdCBiaW5kOnZhbHVlPXtzZWxlY3RlZH0+Li4uPC9zZWxlY3Q+XG5cdFx0XHQvLyA8cD57YXdhaXQgZmluZChzZWxlY3RlZCl9PC9wPlxuXHRcdFx0aWYgKGJhdGNoZXMuaGFzKGJhdGNoKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZyk7XG5cblx0XHQvLyBNb3VudGluZyBhbmQgdmFsdWUgdW5kZWZpbmVkIC0+IHRha2Ugc2VsZWN0aW9uIGZyb20gZG9tXG5cdFx0aWYgKG1vdW50aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdC8qKiBAdHlwZSB7SFRNTE9wdGlvbkVsZW1lbnQgfCBudWxsfSAqL1xuXHRcdFx0dmFyIHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpO1xuXHRcdFx0aWYgKHNlbGVjdGVkX29wdGlvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9vcHRpb25fdmFsdWUoc2VsZWN0ZWRfb3B0aW9uKTtcblx0XHRcdFx0c2V0KHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0c2VsZWN0Ll9fdmFsdWUgPSB2YWx1ZTtcblx0XHRtb3VudGluZyA9IGZhbHNlO1xuXHR9KTtcblxuXHRpbml0X3NlbGVjdChzZWxlY3QpO1xufVxuXG4vKiogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gb3B0aW9uICovXG5mdW5jdGlvbiBnZXRfb3B0aW9uX3ZhbHVlKG9wdGlvbikge1xuXHQvLyBfX3ZhbHVlIG9ubHkgZXhpc3RzIGlmIHRoZSA8b3B0aW9uPiBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGVcblx0aWYgKCdfX3ZhbHVlJyBpbiBvcHRpb24pIHtcblx0XHRyZXR1cm4gb3B0aW9uLl9fdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG9wdGlvbi52YWx1ZTtcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaHlkcmF0aW5nLCBzZXRfaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9ycywgZ2V0X3Byb3RvdHlwZV9vZiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZXZlbnQsIGRlbGVnYXRlIH0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IHsgYWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIsIGF1dG9mb2N1cyB9IGZyb20gJy4vbWlzYy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uLy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IExPQURJTkdfQVRUUl9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBpc19jYXB0dXJlX2V2ZW50LCBjYW5fZGVsZWdhdGVfZXZlbnQsIG5vcm1hbGl6ZV9hdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGdldCxcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBhdHRhY2ggfSBmcm9tICcuL2F0dGFjaG1lbnRzLmpzJztcbmltcG9ydCB7IGNsc3ggfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBzZXRfY2xhc3MgfSBmcm9tICcuL2NsYXNzLmpzJztcbmltcG9ydCB7IHNldF9zdHlsZSB9IGZyb20gJy4vc3R5bGUuanMnO1xuaW1wb3J0IHsgQVRUQUNITUVOVF9LRVksIE5BTUVTUEFDRV9IVE1MLCBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJyYW5jaCwgZGVzdHJveV9lZmZlY3QsIGVmZmVjdCwgbWFuYWdlZCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBpbml0X3NlbGVjdCwgc2VsZWN0X29wdGlvbiB9IGZyb20gJy4vYmluZGluZ3Mvc2VsZWN0LmpzJztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2FzeW5jLmpzJztcblxuZXhwb3J0IGNvbnN0IENMQVNTID0gU3ltYm9sKCdjbGFzcycpO1xuZXhwb3J0IGNvbnN0IFNUWUxFID0gU3ltYm9sKCdzdHlsZScpO1xuXG5jb25zdCBJU19DVVNUT01fRUxFTUVOVCA9IFN5bWJvbCgnaXMgY3VzdG9tIGVsZW1lbnQnKTtcbmNvbnN0IElTX0hUTUwgPSBTeW1ib2woJ2lzIGh0bWwnKTtcblxuLyoqXG4gKiBUaGUgdmFsdWUvY2hlY2tlZCBhdHRyaWJ1dGUgaW4gdGhlIHRlbXBsYXRlIGFjdHVhbGx5IGNvcnJlc3BvbmRzIHRvIHRoZSBkZWZhdWx0VmFsdWUgcHJvcGVydHksIHNvIHdlIG5lZWRcbiAqIHRvIHJlbW92ZSBpdCB1cG9uIGh5ZHJhdGlvbiB0byBhdm9pZCBhIGJ1ZyB3aGVuIHNvbWVvbmUgcmVzZXRzIHRoZSBmb3JtIHZhbHVlLlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVfaW5wdXRfZGVmYXVsdHMoaW5wdXQpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHR2YXIgYWxyZWFkeV9yZW1vdmVkID0gZmFsc2U7XG5cblx0Ly8gV2UgdHJ5IGFuZCByZW1vdmUgdGhlIGRlZmF1bHQgYXR0cmlidXRlcyBsYXRlciwgcmF0aGVyIHRoYW4gc3luYyBkdXJpbmcgaHlkcmF0aW9uLlxuXHQvLyBEb2luZyBpdCBzeW5jIGR1cmluZyBoeWRyYXRpb24gaGFzIGEgbmVnYXRpdmUgaW1wYWN0IG9uIHBlcmZvcm1hbmNlLCBidXQgZGVmZXJyaW5nIHRoZVxuXHQvLyB3b3JrIGluIGFuIGlkbGUgdGFzayBhbGxldmlhdGVzIHRoaXMgZ3JlYXRseS4gSWYgYSBmb3JtIHJlc2V0IGV2ZW50IGNvbWVzIGluIGJlZm9yZVxuXHQvLyB0aGUgaWRsZSBjYWxsYmFjaywgdGhlbiB3ZSBlbnN1cmUgdGhlIGlucHV0IGRlZmF1bHRzIGFyZSBjbGVhcmVkIGp1c3QgYmVmb3JlLlxuXHR2YXIgcmVtb3ZlX2RlZmF1bHRzID0gKCkgPT4ge1xuXHRcdGlmIChhbHJlYWR5X3JlbW92ZWQpIHJldHVybjtcblx0XHRhbHJlYWR5X3JlbW92ZWQgPSB0cnVlO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBhdHRyaWJ1dGVzIGJ1dCBwcmVzZXJ2ZSB0aGUgdmFsdWVzXG5cdFx0aWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuXHRcdFx0dmFyIHZhbHVlID0gaW5wdXQudmFsdWU7XG5cdFx0XHRzZXRfYXR0cmlidXRlKGlucHV0LCAndmFsdWUnLCBudWxsKTtcblx0XHRcdGlucHV0LnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG5cdFx0XHR2YXIgY2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7XG5cdFx0XHRzZXRfYXR0cmlidXRlKGlucHV0LCAnY2hlY2tlZCcsIG51bGwpO1xuXHRcdFx0aW5wdXQuY2hlY2tlZCA9IGNoZWNrZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0aW5wdXQuX19vbl9yID0gcmVtb3ZlX2RlZmF1bHRzO1xuXHRxdWV1ZV9taWNyb190YXNrKHJlbW92ZV9kZWZhdWx0cyk7XG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF92YWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuXHR2YXIgYXR0cmlidXRlcyA9IGdldF9hdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXG5cdGlmIChcblx0XHRhdHRyaWJ1dGVzLnZhbHVlID09PVxuXHRcdFx0KGF0dHJpYnV0ZXMudmFsdWUgPVxuXHRcdFx0XHQvLyB0cmVhdCBudWxsIGFuZCB1bmRlZmluZWQgdGhlIHNhbWUgZm9yIHRoZSBpbml0aWFsIHZhbHVlXG5cdFx0XHRcdHZhbHVlID8/IHVuZGVmaW5lZCkgfHxcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0Ly8gYHByb2dyZXNzYCBlbGVtZW50cyBhbHdheXMgbmVlZCB0aGVpciB2YWx1ZSBzZXQgd2hlbiBpdCdzIGAwYFxuXHRcdChlbGVtZW50LnZhbHVlID09PSB2YWx1ZSAmJiAodmFsdWUgIT09IDAgfHwgZWxlbWVudC5ub2RlTmFtZSAhPT0gJ1BST0dSRVNTJykpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudC52YWx1ZSA9IHZhbHVlID8/ICcnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2hlY2tlZChlbGVtZW50LCBjaGVja2VkKSB7XG5cdHZhciBhdHRyaWJ1dGVzID0gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMuY2hlY2tlZCA9PT1cblx0XHQoYXR0cmlidXRlcy5jaGVja2VkID1cblx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdGNoZWNrZWQgPz8gdW5kZWZpbmVkKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnQuY2hlY2tlZCA9IGNoZWNrZWQ7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYHNlbGVjdGVkYCBhdHRyaWJ1dGUgb24gYW4gYG9wdGlvbmAgZWxlbWVudC5cbiAqIE5vdCBzZXQgdGhyb3VnaCB0aGUgcHJvcGVydHkgYmVjYXVzZSB0aGF0IGRvZXNuJ3QgcmVmbGVjdCB0byB0aGUgRE9NLFxuICogd2hpY2ggbWVhbnMgaXQgd291bGRuJ3QgYmUgdGFrZW4gaW50byBhY2NvdW50IHdoZW4gYSBmb3JtIGlzIHJlc2V0LlxuICogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NlbGVjdGVkKGVsZW1lbnQsIHNlbGVjdGVkKSB7XG5cdGlmIChzZWxlY3RlZCkge1xuXHRcdC8vIFRoZSBzZWxlY3RlZCBvcHRpb24gY291bGQndmUgY2hhbmdlZCB2aWEgdXNlciBzZWxlY3Rpb24sIGFuZFxuXHRcdC8vIHNldHRpbmcgdGhlIHZhbHVlIHdpdGhvdXQgdGhpcyBjaGVjayB3b3VsZCBzZXQgaXQgYmFjay5cblx0XHRpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnJyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RlZCcpO1xuXHR9XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZGVmYXVsdCBjaGVja2VkIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgY2hlY2tlZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGVmYXVsdF9jaGVja2VkKGVsZW1lbnQsIGNoZWNrZWQpIHtcblx0Y29uc3QgZXhpc3RpbmdfdmFsdWUgPSBlbGVtZW50LmNoZWNrZWQ7XG5cdGVsZW1lbnQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xuXHRlbGVtZW50LmNoZWNrZWQgPSBleGlzdGluZ192YWx1ZTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkZWZhdWx0IHZhbHVlIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgdmFsdWUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZWZhdWx0X3ZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG5cdGNvbnN0IGV4aXN0aW5nX3ZhbHVlID0gZWxlbWVudC52YWx1ZTtcblx0ZWxlbWVudC5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcblx0ZWxlbWVudC52YWx1ZSA9IGV4aXN0aW5nX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlLCBza2lwX3dhcm5pbmcpIHtcblx0dmFyIGF0dHJpYnV0ZXMgPSBnZXRfYXR0cmlidXRlcyhlbGVtZW50KTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YXR0cmlidXRlc1thdHRyaWJ1dGVdID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblxuXHRcdGlmIChcblx0XHRcdGF0dHJpYnV0ZSA9PT0gJ3NyYycgfHxcblx0XHRcdGF0dHJpYnV0ZSA9PT0gJ3NyY3NldCcgfHxcblx0XHRcdChhdHRyaWJ1dGUgPT09ICdocmVmJyAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSAnTElOSycpXG5cdFx0KSB7XG5cdFx0XHRpZiAoIXNraXBfd2FybmluZykge1xuXHRcdFx0XHRjaGVja19zcmNfaW5fZGV2X2h5ZHJhdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlID8/ICcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgcmVzZXQgdGhlc2UgYXR0cmlidXRlcywgdGhleSB3b3VsZCByZXN1bHQgaW4gYW5vdGhlciBuZXR3b3JrIHJlcXVlc3QsIHdoaWNoIHdlIHdhbnQgdG8gYXZvaWQuXG5cdFx0XHQvLyBXZSBhc3N1bWUgdGhleSBhcmUgdGhlIHNhbWUgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlciBhcyBjaGVja2luZyBpZiB0aGV5IGFyZSBlcXVhbCBpcyBleHBlbnNpdmVcblx0XHRcdC8vICh3ZSBjYW4ndCBqdXN0IGNvbXBhcmUgdGhlIHN0cmluZ3MgYXMgdGhleSBjYW4gYmUgZGlmZmVyZW50IGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIgYnV0IHJlc3VsdCBpbiB0aGVcblx0XHRcdC8vIHNhbWUgdXJsLCBzbyB3ZSB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBoaWRkZW4gYW5jaG9yIGVsZW1lbnRzIHRvIGNvbXBhcmUgdGhlbSlcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHRpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWUpKSByZXR1cm47XG5cblx0aWYgKGF0dHJpYnV0ZSA9PT0gJ2xvYWRpbmcnKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnRbTE9BRElOR19BVFRSX1NZTUJPTF0gPSB2YWx1ZTtcblx0fVxuXG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIGdldF9zZXR0ZXJzKGVsZW1lbnQpLmluY2x1ZGVzKGF0dHJpYnV0ZSkpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZWxlbWVudFthdHRyaWJ1dGVdID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfeGxpbmtfYXR0cmlidXRlKGRvbSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRkb20uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHQvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHNldHRpbmcgY3VzdG9tIGVsZW1lbnQgcHJvcHMsIHdoaWNoIGNhblxuXHQvLyBpbnZva2UgbGlmZWN5Y2xlIG1ldGhvZHMgb24gb3RoZXIgY3VzdG9tIGVsZW1lbnRzLCBkb2VzIG5vdCBhbHNvXG5cdC8vIGFzc29jaWF0ZSB0aG9zZSBsaWZlY3ljbGUgbWV0aG9kcyB3aXRoIHRoZSBjdXJyZW50IGFjdGl2ZSByZWFjdGlvblxuXHQvLyBvciBlZmZlY3Rcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHQvLyBJZiB3ZSdyZSBoeWRyYXRpbmcgYnV0IHRoZSBjdXN0b20gZWxlbWVudCBpcyBmcm9tIFN2ZWx0ZSwgYW5kIGl0IGFscmVhZHkgc2NhZmZvbGRlZCxcblx0Ly8gdGhlbiBpdCBtaWdodCBydW4gYmxvY2sgbG9naWMgaW4gaHlkcmF0aW9uIG1vZGUsIHdoaWNoIHdlIGhhdmUgdG8gcHJldmVudC5cblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0fVxuXG5cdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdHNldF9hY3RpdmVfZWZmZWN0KG51bGwpO1xuXG5cdHRyeSB7XG5cdFx0aWYgKFxuXHRcdFx0Ly8gYHN0eWxlYCBzaG91bGQgdXNlIGBzZXRfYXR0cmlidXRlYCByYXRoZXIgdGhhbiB0aGUgc2V0dGVyXG5cdFx0XHRwcm9wICE9PSAnc3R5bGUnICYmXG5cdFx0XHQvLyBEb24ndCBjb21wdXRlIHNldHRlcnMgZm9yIGN1c3RvbSBlbGVtZW50cyB3aGlsZSB0aGV5IGFyZW4ndCByZWdpc3RlcmVkIHlldCxcblx0XHRcdC8vIGJlY2F1c2UgZHVyaW5nIHRoZWlyIHVwZ3JhZGUvaW5zdGFudGlhdGlvbiB0aGV5IG1pZ2h0IGFkZCBtb3JlIHNldHRlcnMuXG5cdFx0XHQvLyBJbnN0ZWFkLCBmYWxsIGJhY2sgdG8gYSBzaW1wbGUgXCJhbiBvYmplY3QsIHRoZW4gc2V0IGFzIHByb3BlcnR5XCIgaGV1cmlzdGljLlxuXHRcdFx0KHNldHRlcnNfY2FjaGUuaGFzKG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpIHx8IG5vZGUubm9kZU5hbWUpIHx8XG5cdFx0XHQvLyBjdXN0b21FbGVtZW50cyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiBicm93c2VyIGV4dGVuc2lvbiBjb250ZXh0c1xuXHRcdFx0IWN1c3RvbUVsZW1lbnRzIHx8XG5cdFx0XHRjdXN0b21FbGVtZW50cy5nZXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdD8gZ2V0X3NldHRlcnMobm9kZSkuaW5jbHVkZXMocHJvcClcblx0XHRcdFx0OiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuXHRcdCkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0bm9kZVtwcm9wXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBXZSBkaWQgZ2V0dGVycyBldGMgY2hlY2tzIGFscmVhZHksIHN0cmluZ2lmeSBiZWZvcmUgcGFzc2luZyB0byBzZXRfYXR0cmlidXRlXG5cdFx0XHQvLyB0byBlbnN1cmUgaXQgZG9lc24ndCBpbnZva2UgdGhlIHNhbWUgbG9naWMgYWdhaW4sIGFuZCBwb3RlbnRpYWxseSBwb3B1bGF0aW5nXG5cdFx0XHQvLyB0aGUgc2V0dGVycyBjYWNoZSB0b28gZWFybHkuXG5cdFx0XHRzZXRfYXR0cmlidXRlKG5vZGUsIHByb3AsIHZhbHVlID09IG51bGwgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSkpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHRcdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFNwcmVhZHMgYXR0cmlidXRlcyBvbnRvIGEgRE9NIGVsZW1lbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGN1cnJlbnRseSBzZXQgYXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT4gfCB1bmRlZmluZWR9IHByZXZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55Pn0gbmV4dCBOZXcgYXR0cmlidXRlcyAtIHRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGlzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtjc3NfaGFzaF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZF9yZW1vdmVfZGVmYXVsdHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMoXG5cdGVsZW1lbnQsXG5cdHByZXYsXG5cdG5leHQsXG5cdGNzc19oYXNoLFxuXHRzaG91bGRfcmVtb3ZlX2RlZmF1bHRzID0gZmFsc2UsXG5cdHNraXBfd2FybmluZyA9IGZhbHNlXG4pIHtcblx0aWYgKGh5ZHJhdGluZyAmJiBzaG91bGRfcmVtb3ZlX2RlZmF1bHRzICYmIGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuXHRcdHZhciBpbnB1dCA9IC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi8gKGVsZW1lbnQpO1xuXHRcdHZhciBhdHRyaWJ1dGUgPSBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnID8gJ2RlZmF1bHRDaGVja2VkJyA6ICdkZWZhdWx0VmFsdWUnO1xuXG5cdFx0aWYgKCEoYXR0cmlidXRlIGluIG5leHQpKSB7XG5cdFx0XHRyZW1vdmVfaW5wdXRfZGVmYXVsdHMoaW5wdXQpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCk7XG5cblx0dmFyIGlzX2N1c3RvbV9lbGVtZW50ID0gYXR0cmlidXRlc1tJU19DVVNUT01fRUxFTUVOVF07XG5cdHZhciBwcmVzZXJ2ZV9hdHRyaWJ1dGVfY2FzZSA9ICFhdHRyaWJ1dGVzW0lTX0hUTUxdO1xuXG5cdC8vIElmIHdlJ3JlIGh5ZHJhdGluZyBidXQgdGhlIGN1c3RvbSBlbGVtZW50IGlzIGZyb20gU3ZlbHRlLCBhbmQgaXQgYWxyZWFkeSBzY2FmZm9sZGVkLFxuXHQvLyB0aGVuIGl0IG1pZ2h0IHJ1biBibG9jayBsb2dpYyBpbiBoeWRyYXRpb24gbW9kZSwgd2hpY2ggd2UgaGF2ZSB0byBwcmV2ZW50LlxuXHRsZXQgaXNfaHlkcmF0aW5nX2N1c3RvbV9lbGVtZW50ID0gaHlkcmF0aW5nICYmIGlzX2N1c3RvbV9lbGVtZW50O1xuXHRpZiAoaXNfaHlkcmF0aW5nX2N1c3RvbV9lbGVtZW50KSB7XG5cdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdH1cblxuXHR2YXIgY3VycmVudCA9IHByZXYgfHwge307XG5cdHZhciBpc19vcHRpb25fZWxlbWVudCA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09QVElPTic7XG5cblx0Zm9yICh2YXIga2V5IGluIHByZXYpIHtcblx0XHRpZiAoIShrZXkgaW4gbmV4dCkpIHtcblx0XHRcdG5leHRba2V5XSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG5leHQuY2xhc3MpIHtcblx0XHRuZXh0LmNsYXNzID0gY2xzeChuZXh0LmNsYXNzKTtcblx0fSBlbHNlIGlmIChjc3NfaGFzaCB8fCBuZXh0W0NMQVNTXSkge1xuXHRcdG5leHQuY2xhc3MgPSBudWxsOyAvKiBmb3JjZSBjYWxsIHRvIHNldF9jbGFzcygpICovXG5cdH1cblxuXHRpZiAobmV4dFtTVFlMRV0pIHtcblx0XHRuZXh0LnN0eWxlID8/PSBudWxsOyAvKiBmb3JjZSBjYWxsIHRvIHNldF9zdHlsZSgpICovXG5cdH1cblxuXHR2YXIgc2V0dGVycyA9IGdldF9zZXR0ZXJzKGVsZW1lbnQpO1xuXG5cdC8vIHNpbmNlIGtleSBpcyBjYXB0dXJlZCB3ZSB1c2UgY29uc3Rcblx0Zm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuXHRcdC8vIGxldCBpbnN0ZWFkIG9mIHZhciBiZWNhdXNlIHJlZmVyZW5jZWQgaW4gYSBjbG9zdXJlXG5cdFx0bGV0IHZhbHVlID0gbmV4dFtrZXldO1xuXG5cdFx0Ly8gVXAgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gZG8gdGhpcyBmb3IgdGhlIGluaXRpYWwgdmFsdWUsIHRvbywgZXZlbiBpZiBpdCdzIHVuZGVmaW5lZCxcblx0XHQvLyBhbmQgdGhpcyB3b3VsZG4ndCBiZSByZWFjaGVkIGluIGNhc2Ugb2YgdW5kZWZpbmVkIGJlY2F1c2Ugb2YgdGhlIGVxdWFsaXR5IGNoZWNrIGJlbG93XG5cdFx0aWYgKGlzX29wdGlvbl9lbGVtZW50ICYmIGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHQvLyBUaGUgPG9wdGlvbj4gZWxlbWVudCBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIHJlbW92aW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgbWVhbnNcblx0XHRcdC8vIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHRleHQgY29udGVudCBvZiB0aGUgb3B0aW9uIGVsZW1lbnQsIGFuZCBzZXR0aW5nIHRoZSB2YWx1ZVxuXHRcdFx0Ly8gdG8gbnVsbCBvciB1bmRlZmluZWQgbWVhbnMgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgc3RyaW5nIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIuXG5cdFx0XHQvLyBUbyBhbGlnbiB3aXRoIGhvdyB3ZSBoYW5kbGUgdGhpcyBjYXNlIGluIG5vbi1zcHJlYWQtc2NlbmFyaW9zLCB0aGlzIGxvZ2ljIGlzIG5lZWRlZC5cblx0XHRcdC8vIFRoZXJlJ3MgYSBzdXBlci1lZGdlLWNhc2UgYnVnIGhlcmUgdGhhdCBpcyBsZWZ0IGluIGluIGZhdm9yIG9mIHNtYWxsZXIgY29kZSBzaXplOlxuXHRcdFx0Ly8gQmVjYXVzZSBvZiB0aGUgXCJzZXQgbWlzc2luZyBwcm9wcyB0byBudWxsXCIgbG9naWMgYWJvdmUsIHdlIGNhbid0IGRpZmZlcmVudGlhdGVcblx0XHRcdC8vIGJldHdlZW4gYSBtaXNzaW5nIHZhbHVlIGFuZCBhbiBleHBsaWNpdGx5IHNldCB2YWx1ZSBvZiBudWxsIG9yIHVuZGVmaW5lZC4gVGhhdCBtZWFuc1xuXHRcdFx0Ly8gdGhhdCBvbmNlIHNldCwgdGhlIHZhbHVlIGF0dHJpYnV0ZSBvZiBhbiA8b3B0aW9uPiBlbGVtZW50IGNhbid0IGJlIHJlbW92ZWQuIFRoaXMgaXNcblx0XHRcdC8vIGEgdmVyeSByYXJlIGVkZ2UgY2FzZSwgYW5kIHJlbW92aW5nIHRoZSBhdHRyaWJ1dGUgYWx0b2dldGhlciBpc24ndCBwb3NzaWJsZSBlaXRoZXJcblx0XHRcdC8vIGZvciB0aGUgPG9wdGlvbiB2YWx1ZT17dW5kZWZpbmVkfT4gY2FzZSwgc28gd2UncmUgbm90IGxvc2luZyBhbnkgZnVuY3Rpb25hbGl0eSBoZXJlLlxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IGVsZW1lbnQuX192YWx1ZSA9ICcnO1xuXHRcdFx0Y3VycmVudFtrZXldID0gdmFsdWU7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG5cdFx0XHR2YXIgaXNfaHRtbCA9IGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cdFx0XHRzZXRfY2xhc3MoZWxlbWVudCwgaXNfaHRtbCwgdmFsdWUsIGNzc19oYXNoLCBwcmV2Py5bQ0xBU1NdLCBuZXh0W0NMQVNTXSk7XG5cdFx0XHRjdXJyZW50W2tleV0gPSB2YWx1ZTtcblx0XHRcdGN1cnJlbnRbQ0xBU1NdID0gbmV4dFtDTEFTU107XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG5cdFx0XHRzZXRfc3R5bGUoZWxlbWVudCwgdmFsdWUsIHByZXY/LltTVFlMRV0sIG5leHRbU1RZTEVdKTtcblx0XHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y3VycmVudFtTVFlMRV0gPSBuZXh0W1NUWUxFXTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhciBwcmV2X3ZhbHVlID0gY3VycmVudFtrZXldO1xuXG5cdFx0Ly8gU2tpcCBpZiB2YWx1ZSBpcyB1bmNoYW5nZWQsIHVubGVzcyBpdCdzIGB1bmRlZmluZWRgIGFuZCB0aGUgZWxlbWVudCBzdGlsbCBoYXMgdGhlIGF0dHJpYnV0ZVxuXHRcdGlmICh2YWx1ZSA9PT0gcHJldl92YWx1ZSAmJiAhKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoa2V5KSkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXG5cdFx0dmFyIHByZWZpeCA9IGtleVswXSArIGtleVsxXTsgLy8gdGhpcyBpcyBmYXN0ZXIgdGhhbiBrZXkuc2xpY2UoMCwgMilcblx0XHRpZiAocHJlZml4ID09PSAnJCQnKSBjb250aW51ZTtcblxuXHRcdGlmIChwcmVmaXggPT09ICdvbicpIHtcblx0XHRcdC8qKiBAdHlwZSB7eyBjYXB0dXJlPzogdHJ1ZSB9fSAqL1xuXHRcdFx0Y29uc3Qgb3B0cyA9IHt9O1xuXHRcdFx0Y29uc3QgZXZlbnRfaGFuZGxlX2tleSA9ICckJCcgKyBrZXk7XG5cdFx0XHRsZXQgZXZlbnRfbmFtZSA9IGtleS5zbGljZSgyKTtcblx0XHRcdHZhciBkZWxlZ2F0ZWQgPSBjYW5fZGVsZWdhdGVfZXZlbnQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdGlmIChpc19jYXB0dXJlX2V2ZW50KGV2ZW50X25hbWUpKSB7XG5cdFx0XHRcdGV2ZW50X25hbWUgPSBldmVudF9uYW1lLnNsaWNlKDAsIC03KTtcblx0XHRcdFx0b3B0cy5jYXB0dXJlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZWxlZ2F0ZWQgJiYgcHJldl92YWx1ZSkge1xuXHRcdFx0XHQvLyBMaXN0ZW5pbmcgdG8gc2FtZSBldmVudCBidXQgZGlmZmVyZW50IGhhbmRsZXIgLT4gb3VyIGhhbmRsZSBmdW5jdGlvbiBiZWxvdyB0YWtlcyBjYXJlIG9mIHRoaXNcblx0XHRcdFx0Ly8gSWYgd2Ugd2VyZSB0byByZW1vdmUgYW5kIGFkZCBsaXN0ZW5lcnMgaW4gdGhpcyBjYXNlLCBpdCBjb3VsZCBoYXBwZW4gdGhhdCB0aGUgZXZlbnQgaXMgXCJzd2FsbG93ZWRcIlxuXHRcdFx0XHQvLyAodGhlIGJyb3dzZXIgc2VlbXMgdG8gbm90IGtub3cgeWV0IHRoYXQgYSBuZXcgb25lIGV4aXN0cyBub3cpIGFuZCBkb2Vzbid0IHJlYWNoIHRoZSBoYW5kbGVyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzExOTAzXG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSBjb250aW51ZTtcblxuXHRcdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgY3VycmVudFtldmVudF9oYW5kbGVfa2V5XSwgb3B0cyk7XG5cdFx0XHRcdGN1cnJlbnRbZXZlbnRfaGFuZGxlX2tleV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIWRlbGVnYXRlZCkge1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIEB0aGlzIHthbnl9XG5cdFx0XHRcdFx0ICogQHBhcmFtIHtFdmVudH0gZXZ0XG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlKGV2dCkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFtrZXldLmNhbGwodGhpcywgZXZ0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50W2V2ZW50X2hhbmRsZV9rZXldID0gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGVsZW1lbnQsIGhhbmRsZSwgb3B0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGVsZW1lbnRbYF9fJHtldmVudF9uYW1lfWBdID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVsZWdhdGUoW2V2ZW50X25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W2BfXyR7ZXZlbnRfbmFtZX1gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0Ly8gYXZvaWQgdXNpbmcgdGhlIHNldHRlclxuXHRcdFx0c2V0X2F0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ2F1dG9mb2N1cycpIHtcblx0XHRcdGF1dG9mb2N1cygvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZWxlbWVudCksIEJvb2xlYW4odmFsdWUpKTtcblx0XHR9IGVsc2UgaWYgKCFpc19jdXN0b21fZWxlbWVudCAmJiAoa2V5ID09PSAnX192YWx1ZScgfHwgKGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSAhPSBudWxsKSkpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgV2UncmUgbm90IHJ1bm5pbmcgdGhpcyBmb3IgY3VzdG9tIGVsZW1lbnRzIGJlY2F1c2UgX192YWx1ZSBpcyBhY3R1YWxseVxuXHRcdFx0Ly8gaG93IExpdCBzdG9yZXMgdGhlIGN1cnJlbnQgdmFsdWUgb24gdGhlIGVsZW1lbnQsIGFuZCBtZXNzaW5nIHdpdGggdGhhdCB3b3VsZCBicmVhayB0aGluZ3MuXG5cdFx0XHRlbGVtZW50LnZhbHVlID0gZWxlbWVudC5fX3ZhbHVlID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzZWxlY3RlZCcgJiYgaXNfb3B0aW9uX2VsZW1lbnQpIHtcblx0XHRcdHNldF9zZWxlY3RlZCgvKiogQHR5cGUge0hUTUxPcHRpb25FbGVtZW50fSAqLyAoZWxlbWVudCksIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5hbWUgPSBrZXk7XG5cdFx0XHRpZiAoIXByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlKSB7XG5cdFx0XHRcdG5hbWUgPSBub3JtYWxpemVfYXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaXNfZGVmYXVsdCA9IG5hbWUgPT09ICdkZWZhdWx0VmFsdWUnIHx8IG5hbWUgPT09ICdkZWZhdWx0Q2hlY2tlZCc7XG5cblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsICYmICFpc19jdXN0b21fZWxlbWVudCAmJiAhaXNfZGVmYXVsdCkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzW2tleV0gPSBudWxsO1xuXG5cdFx0XHRcdGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdjaGVja2VkJykge1xuXHRcdFx0XHRcdC8vIHJlbW92aW5nIHZhbHVlL2NoZWNrZWQgYWxzbyByZW1vdmVzIGRlZmF1bHRWYWx1ZS9kZWZhdWx0Q2hlY2tlZCBcdTIwMTQgcHJlc2VydmVcblx0XHRcdFx0XHRsZXQgaW5wdXQgPSAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovIChlbGVtZW50KTtcblx0XHRcdFx0XHRjb25zdCB1c2VfZGVmYXVsdCA9IHByZXYgPT09IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJykge1xuXHRcdFx0XHRcdFx0bGV0IHByZXZpb3VzID0gaW5wdXQuZGVmYXVsdFZhbHVlO1xuXHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0aW5wdXQuZGVmYXVsdFZhbHVlID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRpbnB1dC52YWx1ZSA9IGlucHV0Ll9fdmFsdWUgPSB1c2VfZGVmYXVsdCA/IHByZXZpb3VzIDogbnVsbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGV0IHByZXZpb3VzID0gaW5wdXQuZGVmYXVsdENoZWNrZWQ7XG5cdFx0XHRcdFx0XHRpbnB1dC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0aW5wdXQuY2hlY2tlZCA9IHVzZV9kZWZhdWx0ID8gcHJldmlvdXMgOiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aXNfZGVmYXVsdCB8fFxuXHRcdFx0XHQoc2V0dGVycy5pbmNsdWRlcyhuYW1lKSAmJiAoaXNfY3VzdG9tX2VsZW1lbnQgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykpXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdC8vIHJlbW92ZSBpdCBmcm9tIGF0dHJpYnV0ZXMncyBjYWNoZVxuXHRcdFx0XHRpZiAobmFtZSBpbiBhdHRyaWJ1dGVzKSBhdHRyaWJ1dGVzW25hbWVdID0gVU5JTklUSUFMSVpFRDtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHNldF9hdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUsIHNraXBfd2FybmluZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzX2h5ZHJhdGluZ19jdXN0b21fZWxlbWVudCkge1xuXHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IGVsZW1lbnRcbiAqIEBwYXJhbSB7KC4uLmV4cHJlc3Npb25zOiBhbnkpID0+IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT59IGZuXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IGFueT59IHN5bmNcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gUHJvbWlzZTxhbnk+Pn0gYXN5bmNcbiAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZTx2b2lkPj59IGJsb2NrZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2Nzc19oYXNoXVxuICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkX3JlbW92ZV9kZWZhdWx0c11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHJpYnV0ZV9lZmZlY3QoXG5cdGVsZW1lbnQsXG5cdGZuLFxuXHRzeW5jID0gW10sXG5cdGFzeW5jID0gW10sXG5cdGJsb2NrZXJzID0gW10sXG5cdGNzc19oYXNoLFxuXHRzaG91bGRfcmVtb3ZlX2RlZmF1bHRzID0gZmFsc2UsXG5cdHNraXBfd2FybmluZyA9IGZhbHNlXG4pIHtcblx0ZmxhdHRlbihibG9ja2Vycywgc3luYywgYXN5bmMsICh2YWx1ZXMpID0+IHtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT4gfCB1bmRlZmluZWR9ICovXG5cdFx0dmFyIHByZXYgPSB1bmRlZmluZWQ7XG5cblx0XHQvKiogQHR5cGUge1JlY29yZDxzeW1ib2wsIEVmZmVjdD59ICovXG5cdFx0dmFyIGVmZmVjdHMgPSB7fTtcblxuXHRcdHZhciBpc19zZWxlY3QgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnU0VMRUNUJztcblx0XHR2YXIgaW5pdGVkID0gZmFsc2U7XG5cblx0XHRtYW5hZ2VkKCgpID0+IHtcblx0XHRcdHZhciBuZXh0ID0gZm4oLi4udmFsdWVzLm1hcChnZXQpKTtcblx0XHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55Pn0gKi9cblx0XHRcdHZhciBjdXJyZW50ID0gc2V0X2F0dHJpYnV0ZXMoXG5cdFx0XHRcdGVsZW1lbnQsXG5cdFx0XHRcdHByZXYsXG5cdFx0XHRcdG5leHQsXG5cdFx0XHRcdGNzc19oYXNoLFxuXHRcdFx0XHRzaG91bGRfcmVtb3ZlX2RlZmF1bHRzLFxuXHRcdFx0XHRza2lwX3dhcm5pbmdcblx0XHRcdCk7XG5cblx0XHRcdGlmIChpbml0ZWQgJiYgaXNfc2VsZWN0ICYmICd2YWx1ZScgaW4gbmV4dCkge1xuXHRcdFx0XHRzZWxlY3Rfb3B0aW9uKC8qKiBAdHlwZSB7SFRNTFNlbGVjdEVsZW1lbnR9ICovIChlbGVtZW50KSwgbmV4dC52YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IHN5bWJvbCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGVmZmVjdHMpKSB7XG5cdFx0XHRcdGlmICghbmV4dFtzeW1ib2xdKSBkZXN0cm95X2VmZmVjdChlZmZlY3RzW3N5bWJvbF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBzeW1ib2wgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuZXh0KSkge1xuXHRcdFx0XHR2YXIgbiA9IG5leHRbc3ltYm9sXTtcblxuXHRcdFx0XHRpZiAoc3ltYm9sLmRlc2NyaXB0aW9uID09PSBBVFRBQ0hNRU5UX0tFWSAmJiAoIXByZXYgfHwgbiAhPT0gcHJldltzeW1ib2xdKSkge1xuXHRcdFx0XHRcdGlmIChlZmZlY3RzW3N5bWJvbF0pIGRlc3Ryb3lfZWZmZWN0KGVmZmVjdHNbc3ltYm9sXSk7XG5cdFx0XHRcdFx0ZWZmZWN0c1tzeW1ib2xdID0gYnJhbmNoKCgpID0+IGF0dGFjaChlbGVtZW50LCAoKSA9PiBuKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50W3N5bWJvbF0gPSBuO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmV2ID0gY3VycmVudDtcblx0XHR9KTtcblxuXHRcdGlmIChpc19zZWxlY3QpIHtcblx0XHRcdHZhciBzZWxlY3QgPSAvKiogQHR5cGUge0hUTUxTZWxlY3RFbGVtZW50fSAqLyAoZWxlbWVudCk7XG5cblx0XHRcdGVmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdHNlbGVjdF9vcHRpb24oc2VsZWN0LCAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT59ICovIChwcmV2KS52YWx1ZSwgdHJ1ZSk7XG5cdFx0XHRcdGluaXRfc2VsZWN0KHNlbGVjdCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpbml0ZWQgPSB0cnVlO1xuXHR9KTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldF9hdHRyaWJ1dGVzKGVsZW1lbnQpIHtcblx0cmV0dXJuIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj59ICoqLyAoXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnQuX19hdHRyaWJ1dGVzID8/PSB7XG5cdFx0XHRbSVNfQ1VTVE9NX0VMRU1FTlRdOiBlbGVtZW50Lm5vZGVOYW1lLmluY2x1ZGVzKCctJyksXG5cdFx0XHRbSVNfSFRNTF06IGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0VfSFRNTFxuXHRcdH1cblx0KTtcbn1cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBzdHJpbmdbXT59ICovXG52YXIgc2V0dGVyc19jYWNoZSA9IG5ldyBNYXAoKTtcblxuLyoqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAqL1xuZnVuY3Rpb24gZ2V0X3NldHRlcnMoZWxlbWVudCkge1xuXHR2YXIgY2FjaGVfa2V5ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgZWxlbWVudC5ub2RlTmFtZTtcblx0dmFyIHNldHRlcnMgPSBzZXR0ZXJzX2NhY2hlLmdldChjYWNoZV9rZXkpO1xuXHRpZiAoc2V0dGVycykgcmV0dXJuIHNldHRlcnM7XG5cdHNldHRlcnNfY2FjaGUuc2V0KGNhY2hlX2tleSwgKHNldHRlcnMgPSBbXSkpO1xuXG5cdHZhciBkZXNjcmlwdG9ycztcblx0dmFyIHByb3RvID0gZWxlbWVudDsgLy8gSW4gdGhlIGNhc2Ugb2YgY3VzdG9tIGVsZW1lbnRzIHRoZXJlIG1pZ2h0IGJlIHNldHRlcnMgb24gdGhlIGluc3RhbmNlXG5cdHZhciBlbGVtZW50X3Byb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG5cblx0Ly8gU3RvcCBhdCBFbGVtZW50LCBmcm9tIHRoZXJlIG9uIHRoZXJlJ3Mgb25seSB1bm5lY2Vzc2FyeSBzZXR0ZXJzIHdlJ3JlIG5vdCBpbnRlcmVzdGVkIGluXG5cdC8vIERvIG5vdCB1c2UgY29udHJ1Y3Rvci5uYW1lIGhlcmUgYXMgdGhhdCdzIHVucmVsaWFibGUgaW4gc29tZSBicm93c2VyIGVudmlyb25tZW50c1xuXHR3aGlsZSAoZWxlbWVudF9wcm90byAhPT0gcHJvdG8pIHtcblx0XHRkZXNjcmlwdG9ycyA9IGdldF9kZXNjcmlwdG9ycyhwcm90byk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZGVzY3JpcHRvcnMpIHtcblx0XHRcdGlmIChkZXNjcmlwdG9yc1trZXldLnNldCkge1xuXHRcdFx0XHRzZXR0ZXJzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwcm90byA9IGdldF9wcm90b3R5cGVfb2YocHJvdG8pO1xuXHR9XG5cblx0cmV0dXJuIHNldHRlcnM7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBjaGVja19zcmNfaW5fZGV2X2h5ZHJhdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdGlmICghREVWKSByZXR1cm47XG5cdGlmIChhdHRyaWJ1dGUgPT09ICdzcmNzZXQnICYmIHNyY3NldF91cmxfZXF1YWwoZWxlbWVudCwgdmFsdWUpKSByZXR1cm47XG5cdGlmIChzcmNfdXJsX2VxdWFsKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgPz8gJycsIHZhbHVlKSkgcmV0dXJuO1xuXG5cdHcuaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkKFxuXHRcdGF0dHJpYnV0ZSxcblx0XHRlbGVtZW50Lm91dGVySFRNTC5yZXBsYWNlKGVsZW1lbnQuaW5uZXJIVE1MLCBlbGVtZW50LmlubmVySFRNTCAmJiAnLi4uJyksXG5cdFx0U3RyaW5nKHZhbHVlKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50X3NyY1xuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuXHRpZiAoZWxlbWVudF9zcmMgPT09IHVybCkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBuZXcgVVJMKGVsZW1lbnRfc3JjLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmID09PSBuZXcgVVJMKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkuaHJlZjtcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXQgKi9cbmZ1bmN0aW9uIHNwbGl0X3NyY3NldChzcmNzZXQpIHtcblx0cmV0dXJuIHNyY3NldC5zcGxpdCgnLCcpLm1hcCgoc3JjKSA9PiBzcmMudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTb3VyY2VFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNyY3NldFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNyY3NldF91cmxfZXF1YWwoZWxlbWVudCwgc3Jjc2V0KSB7XG5cdHZhciBlbGVtZW50X3VybHMgPSBzcGxpdF9zcmNzZXQoZWxlbWVudC5zcmNzZXQpO1xuXHR2YXIgdXJscyA9IHNwbGl0X3NyY3NldChzcmNzZXQpO1xuXG5cdHJldHVybiAoXG5cdFx0dXJscy5sZW5ndGggPT09IGVsZW1lbnRfdXJscy5sZW5ndGggJiZcblx0XHR1cmxzLmV2ZXJ5KFxuXHRcdFx0KFt1cmwsIHdpZHRoXSwgaSkgPT5cblx0XHRcdFx0d2lkdGggPT09IGVsZW1lbnRfdXJsc1tpXVsxXSAmJlxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRlc3QgYm90aCB3YXlzIGJlY2F1c2UgVml0ZSB3aWxsIGNyZWF0ZSBhbiBhIGZ1bGwgVVJMIHdpdGhcblx0XHRcdFx0Ly8gYG5ldyBVUkwoYXNzZXQsIGltcG9ydC5tZXRhLnVybCkuaHJlZmAgZm9yIHRoZSBjbGllbnQgd2hlbiBgYmFzZTogJy4vJ2AsIGFuZCB0aGVcblx0XHRcdFx0Ly8gcmVsYXRpdmUgVVJMcyBpbnNpZGUgc3Jjc2V0IGFyZSBub3QgYXV0b21hdGljYWxseSByZXNvbHZlZCB0byBhYnNvbHV0ZSBVUkxzIGJ5XG5cdFx0XHRcdC8vIGJyb3dzZXJzIChpbiBjb250cmFzdCB0byBpbWcuc3JjKS4gVGhpcyBtZWFucyBib3RoIFNTUiBhbmQgRE9NIGNvZGUgY291bGRcblx0XHRcdFx0Ly8gY29udGFpbiByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxzLlxuXHRcdFx0XHQoc3JjX3VybF9lcXVhbChlbGVtZW50X3VybHNbaV1bMF0sIHVybCkgfHwgc3JjX3VybF9lcXVhbCh1cmwsIGVsZW1lbnRfdXJsc1tpXVswXSkpXG5cdFx0KVxuXHQpO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgUmFmIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuXG5pbXBvcnQgeyBCUk9XU0VSIH0gZnJvbSAnZXNtLWVudic7XG5cbmNvbnN0IG5vdyA9IEJST1dTRVIgPyAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSA6ICgpID0+IERhdGUubm93KCk7XG5cbi8qKiBAdHlwZSB7UmFmfSAqL1xuZXhwb3J0IGNvbnN0IHJhZiA9IHtcblx0Ly8gZG9uJ3QgYWNjZXNzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBlYWdlcmx5IG91dHNpZGUgbWV0aG9kXG5cdC8vIHRoaXMgYWxsb3dzIGJhc2ljIHRlc3Rpbmcgb2YgdXNlciBjb2RlIHdpdGhvdXQgSlNET01cblx0Ly8gYnVuZGVyIHdpbGwgZXZhbCBhbmQgcmVtb3ZlIHRlcm5hcnkgd2hlbiB0aGUgdXNlcidzIGFwcCBpcyBidWlsdFxuXHR0aWNrOiAvKiogQHBhcmFtIHthbnl9IF8gKi8gKF8pID0+IChCUk9XU0VSID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogbm9vcCkoXyksXG5cdG5vdzogKCkgPT4gbm93KCksXG5cdHRhc2tzOiBuZXcgU2V0KClcbn07XG4iLCAiLyoqIEBpbXBvcnQgeyBUYXNrQ2FsbGJhY2ssIFRhc2ssIFRhc2tFbnRyeSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyByYWYgfSBmcm9tICcuL3RpbWluZy5qcyc7XG5cbi8vIFRPRE8gbW92ZSB0aGlzIGludG8gdGltaW5nLmpzIHdoZXJlIGl0IHByb2JhYmx5IGJlbG9uZ3NcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcnVuX3Rhc2tzKCkge1xuXHQvLyB1c2UgYHJhZi5ub3coKWAgaW5zdGVhZCBvZiB0aGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbGJhY2sgYXJndW1lbnQsIGJlY2F1c2Vcblx0Ly8gb3RoZXJ3aXNlIHRoaW5ncyBjYW4gZ2V0IHdvbmt5IGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC8xNDU0MVxuXHRjb25zdCBub3cgPSByYWYubm93KCk7XG5cblx0cmFmLnRhc2tzLmZvckVhY2goKHRhc2spID0+IHtcblx0XHRpZiAoIXRhc2suYyhub3cpKSB7XG5cdFx0XHRyYWYudGFza3MuZGVsZXRlKHRhc2spO1xuXHRcdFx0dGFzay5mKCk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAocmFmLnRhc2tzLnNpemUgIT09IDApIHtcblx0XHRyYWYudGljayhydW5fdGFza3MpO1xuXHR9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqIEBwYXJhbSB7VGFza0NhbGxiYWNrfSBjYWxsYmFja1xuICogQHJldHVybnMge1Rhc2t9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG5cdC8qKiBAdHlwZSB7VGFza0VudHJ5fSAqL1xuXHRsZXQgdGFzaztcblxuXHRpZiAocmFmLnRhc2tzLnNpemUgPT09IDApIHtcblx0XHRyYWYudGljayhydW5fdGFza3MpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRwcm9taXNlOiBuZXcgUHJvbWlzZSgoZnVsZmlsbCkgPT4ge1xuXHRcdFx0cmFmLnRhc2tzLmFkZCgodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSkpO1xuXHRcdH0pLFxuXHRcdGFib3J0KCkge1xuXHRcdFx0cmFmLnRhc2tzLmRlbGV0ZSh0YXNrKTtcblx0XHR9XG5cdH07XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBBbmltYXRlRm4sIEFuaW1hdGlvbiwgQW5pbWF0aW9uQ29uZmlnLCBFYWNoSXRlbSwgRWZmZWN0LCBUcmFuc2l0aW9uRm4sIFRyYW5zaXRpb25NYW5hZ2VyIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IG5vb3AsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGVmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBsb29wIH0gZnJvbSAnLi4vLi4vbG9vcC5qcyc7XG5pbXBvcnQgeyBzaG91bGRfaW50cm8gfSBmcm9tICcuLi8uLi9yZW5kZXIuanMnO1xuaW1wb3J0IHsgY3VycmVudF9lYWNoX2l0ZW0gfSBmcm9tICcuLi9ibG9ja3MvZWFjaC5qcyc7XG5pbXBvcnQgeyBUUkFOU0lUSU9OX0dMT0JBTCwgVFJBTlNJVElPTl9JTiwgVFJBTlNJVElPTl9PVVQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQkxPQ0tfRUZGRUNULCBFRkZFQ1RfUkFOLCBFRkZFQ1RfVFJBTlNQQVJFTlQgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQgfSBmcm9tICcuL2JpbmRpbmdzL3NoYXJlZC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geydpbnRyb3N0YXJ0JyB8ICdpbnRyb2VuZCcgfCAnb3V0cm9zdGFydCcgfCAnb3V0cm9lbmQnfSB0eXBlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgdHlwZSkge1xuXHR3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSkpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByb3BlcnR5IHRvIHRoZSBjYW1lbC1jYXNlIGZvcm1hdCBleHBlY3RlZCBieSBFbGVtZW50LmFuaW1hdGUoKSwgS2V5ZnJhbWVFZmZlY3QoKSwgYW5kIEtleWZyYW1lRWZmZWN0LnNldEtleWZyYW1lcygpLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjc3NfcHJvcGVydHlfdG9fY2FtZWxjYXNlKHN0eWxlKSB7XG5cdC8vIGluIGNvbXBsaWFuY2Ugd2l0aCBzcGVjXG5cdGlmIChzdHlsZSA9PT0gJ2Zsb2F0JykgcmV0dXJuICdjc3NGbG9hdCc7XG5cdGlmIChzdHlsZSA9PT0gJ29mZnNldCcpIHJldHVybiAnY3NzT2Zmc2V0JztcblxuXHQvLyBkbyBub3QgcmVuYW1lIGN1c3RvbSBAcHJvcGVydGllc1xuXHRpZiAoc3R5bGUuc3RhcnRzV2l0aCgnLS0nKSkgcmV0dXJuIHN0eWxlO1xuXG5cdGNvbnN0IHBhcnRzID0gc3R5bGUuc3BsaXQoJy0nKTtcblx0aWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRzWzBdO1xuXHRyZXR1cm4gKFxuXHRcdHBhcnRzWzBdICtcblx0XHRwYXJ0c1xuXHRcdFx0LnNsaWNlKDEpXG5cdFx0XHQubWFwKC8qKiBAcGFyYW0ge2FueX0gd29yZCAqLyAod29yZCkgPT4gd29yZFswXS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSlcblx0XHRcdC5qb2luKCcnKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NcbiAqIEByZXR1cm5zIHtLZXlmcmFtZX1cbiAqL1xuZnVuY3Rpb24gY3NzX3RvX2tleWZyYW1lKGNzcykge1xuXHQvKiogQHR5cGUge0tleWZyYW1lfSAqL1xuXHRjb25zdCBrZXlmcmFtZSA9IHt9O1xuXHRjb25zdCBwYXJ0cyA9IGNzcy5zcGxpdCgnOycpO1xuXHRmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcblx0XHRjb25zdCBbcHJvcGVydHksIHZhbHVlXSA9IHBhcnQuc3BsaXQoJzonKTtcblx0XHRpZiAoIXByb3BlcnR5IHx8IHZhbHVlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuXG5cdFx0Y29uc3QgZm9ybWF0dGVkX3Byb3BlcnR5ID0gY3NzX3Byb3BlcnR5X3RvX2NhbWVsY2FzZShwcm9wZXJ0eS50cmltKCkpO1xuXHRcdGtleWZyYW1lW2Zvcm1hdHRlZF9wcm9wZXJ0eV0gPSB2YWx1ZS50cmltKCk7XG5cdH1cblx0cmV0dXJuIGtleWZyYW1lO1xufVxuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHQgKi9cbmNvbnN0IGxpbmVhciA9ICh0KSA9PiB0O1xuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUga2V5ZWQgYHsjZWFjaCAuLi59YCBibG9ja3MgKGFzIGAkLmFuaW1hdGlvbiguLi4pYCkuIFRoaXMgY3JlYXRlcyBhbiBhbmltYXRpb24gbWFuYWdlclxuICogYW5kIGF0dGFjaGVzIGl0IHRvIHRoZSBibG9jaywgc28gdGhhdCBtb3ZlcyBjYW4gYmUgYW5pbWF0ZWQgZm9sbG93aW5nIHJlY29uY2lsaWF0aW9uLlxuICogQHRlbXBsYXRlIFBcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsoKSA9PiBBbmltYXRlRm48UCB8IHVuZGVmaW5lZD59IGdldF9mblxuICogQHBhcmFtIHsoKCkgPT4gUCkgfCBudWxsfSBnZXRfcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmltYXRpb24oZWxlbWVudCwgZ2V0X2ZuLCBnZXRfcGFyYW1zKSB7XG5cdHZhciBpdGVtID0gLyoqIEB0eXBlIHtFYWNoSXRlbX0gKi8gKGN1cnJlbnRfZWFjaF9pdGVtKTtcblxuXHQvKiogQHR5cGUge0RPTVJlY3R9ICovXG5cdHZhciBmcm9tO1xuXG5cdC8qKiBAdHlwZSB7RE9NUmVjdH0gKi9cblx0dmFyIHRvO1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgYW5pbWF0aW9uO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IHsgcG9zaXRpb246IHN0cmluZywgd2lkdGg6IHN0cmluZywgaGVpZ2h0OiBzdHJpbmcsIHRyYW5zZm9ybTogc3RyaW5nIH19ICovXG5cdHZhciBvcmlnaW5hbF9zdHlsZXMgPSBudWxsO1xuXG5cdGl0ZW0uYSA/Pz0ge1xuXHRcdGVsZW1lbnQsXG5cdFx0bWVhc3VyZSgpIHtcblx0XHRcdGZyb20gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fSxcblx0XHRhcHBseSgpIHtcblx0XHRcdGFuaW1hdGlvbj8uYWJvcnQoKTtcblxuXHRcdFx0dG8gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZnJvbS5sZWZ0ICE9PSB0by5sZWZ0IHx8XG5cdFx0XHRcdGZyb20ucmlnaHQgIT09IHRvLnJpZ2h0IHx8XG5cdFx0XHRcdGZyb20udG9wICE9PSB0by50b3AgfHxcblx0XHRcdFx0ZnJvbS5ib3R0b20gIT09IHRvLmJvdHRvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IG9wdGlvbnMgPSBnZXRfZm4oKSh0aGlzLmVsZW1lbnQsIHsgZnJvbSwgdG8gfSwgZ2V0X3BhcmFtcz8uKCkpO1xuXG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGUodGhpcy5lbGVtZW50LCBvcHRpb25zLCB1bmRlZmluZWQsIDEsICgpID0+IHtcblx0XHRcdFx0XHRhbmltYXRpb24/LmFib3J0KCk7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGZpeCgpIHtcblx0XHRcdC8vIElmIGFuIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHJ1bm5pbmcsIHRyYW5zZm9ybWluZyB0aGUgZWxlbWVudCBpcyBsaWtlbHkgdG8gZmFpbCxcblx0XHRcdC8vIGJlY2F1c2UgdGhlIHN0eWxlcyBhcHBsaWVkIGJ5IHRoZSBhbmltYXRpb24gdGFrZSBwcmVjZWRlbmNlLiBJbiB0aGUgY2FzZSBvZiBjcm9zc2ZhZGUsXG5cdFx0XHQvLyB0aGF0IG1lYW5zIHRoZSBgdHJhbnNsYXRlKC4uLilgIG9mIHRoZSBjcm9zc2ZhZGUgdHJhbnNpdGlvbiBvdmVycnVsZXMgdGhlIGB0cmFuc2xhdGUoLi4uKWBcblx0XHRcdC8vIHdlIHdvdWxkIGFwcGx5IGJlbG93LCBsZWFkaW5nIHRvIHRoZSBlbGVtZW50IGp1bXBpbmcgc29tZXdoZXJlIHRvIHRoZSB0b3AgbGVmdC5cblx0XHRcdGlmIChlbGVtZW50LmdldEFuaW1hdGlvbnMoKS5sZW5ndGgpIHJldHVybjtcblxuXHRcdFx0Ly8gSXQncyBpbXBvcnRhbnQgdG8gZGVzdHJ1Y3R1cmUgdGhlc2UgdG8gZ2V0IGZpeGVkIHZhbHVlcyAtIHRoZSBvYmplY3QgaXRzZWxmIGhhcyBnZXR0ZXJzLFxuXHRcdFx0Ly8gYW5kIGNoYW5naW5nIHRoZSBzdHlsZSB0byAnYWJzb2x1dGUnIGNhbiBmb3IgZXhhbXBsZSBpbmZsdWVuY2UgdGhlIHdpZHRoLlxuXHRcdFx0dmFyIHsgcG9zaXRpb24sIHdpZHRoLCBoZWlnaHQgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cblx0XHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlO1xuXG5cdFx0XHRcdG9yaWdpbmFsX3N0eWxlcyA9IHtcblx0XHRcdFx0XHRwb3NpdGlvbjogc3R5bGUucG9zaXRpb24sXG5cdFx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuXHRcdFx0XHRcdHRyYW5zZm9ybTogc3R5bGUudHJhbnNmb3JtXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRcdHZhciB0byA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0aWYgKGZyb20ubGVmdCAhPT0gdG8ubGVmdCB8fCBmcm9tLnRvcCAhPT0gdG8udG9wKSB7XG5cdFx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtmcm9tLmxlZnQgLSB0by5sZWZ0fXB4LCAke2Zyb20udG9wIC0gdG8udG9wfXB4KWA7XG5cdFx0XHRcdFx0c3R5bGUudHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID8gYCR7c3R5bGUudHJhbnNmb3JtfSAke3RyYW5zZm9ybX1gIDogdHJhbnNmb3JtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR1bmZpeCgpIHtcblx0XHRcdGlmIChvcmlnaW5hbF9zdHlsZXMpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9ICovIChlbGVtZW50KS5zdHlsZTtcblxuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9IG9yaWdpbmFsX3N0eWxlcy5wb3NpdGlvbjtcblx0XHRcdFx0c3R5bGUud2lkdGggPSBvcmlnaW5hbF9zdHlsZXMud2lkdGg7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IG9yaWdpbmFsX3N0eWxlcy5oZWlnaHQ7XG5cdFx0XHRcdHN0eWxlLnRyYW5zZm9ybSA9IG9yaWdpbmFsX3N0eWxlcy50cmFuc2Zvcm07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIGluIHRoZSBjYXNlIG9mIGEgYDxzdmVsdGU6ZWxlbWVudD5gLCBpdCdzIHBvc3NpYmxlIGZvciBgJC5hbmltYXRpb24oLi4uKWAgdG8gYmUgY2FsbGVkXG5cdC8vIHdoZW4gYW4gYW5pbWF0aW9uIG1hbmFnZXIgYWxyZWFkeSBleGlzdHMsIGlmIHRoZSB0YWcgY2hhbmdlcy4gaW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvXG5cdC8vIHN3YXAgb3V0IHRoZSBlbGVtZW50IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG1hbmFnZXIsIGluIGNhc2UgaXQgaGFwcGVuZWQgYXQgdGhlIHNhbWVcblx0Ly8gbW9tZW50IGFzIGEgcmVjb25jaWxpYXRpb25cblx0aXRlbS5hLmVsZW1lbnQgPSBlbGVtZW50O1xufVxuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUgYmxvY2sgZWZmZWN0cyBhcyBgJC50cmFuc2l0aW9uKC4uLilgLiBUaGlzIGNyZWF0ZXMgYSB0cmFuc2l0aW9uIG1hbmFnZXIgYW5kXG4gKiBhdHRhY2hlcyBpdCB0byB0aGUgY3VycmVudCBlZmZlY3QgXHUyMDE0IGxhdGVyLCBpbnNpZGUgYHBhdXNlX2VmZmVjdGAgYW5kIGByZXN1bWVfZWZmZWN0YCwgd2VcbiAqIHVzZSB0aGlzIHRvIGNyZWF0ZSBgaW50cm9gIGFuZCBgb3V0cm9gIHRyYW5zaXRpb25zLlxuICogQHRlbXBsYXRlIFBcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsoKSA9PiBUcmFuc2l0aW9uRm48UCB8IHVuZGVmaW5lZD59IGdldF9mblxuICogQHBhcmFtIHsoKCkgPT4gUCkgfCBudWxsfSBnZXRfcGFyYW1zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb24oZmxhZ3MsIGVsZW1lbnQsIGdldF9mbiwgZ2V0X3BhcmFtcykge1xuXHR2YXIgaXNfaW50cm8gPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX0lOKSAhPT0gMDtcblx0dmFyIGlzX291dHJvID0gKGZsYWdzICYgVFJBTlNJVElPTl9PVVQpICE9PSAwO1xuXHR2YXIgaXNfYm90aCA9IGlzX2ludHJvICYmIGlzX291dHJvO1xuXHR2YXIgaXNfZ2xvYmFsID0gKGZsYWdzICYgVFJBTlNJVElPTl9HTE9CQUwpICE9PSAwO1xuXG5cdC8qKiBAdHlwZSB7J2luJyB8ICdvdXQnIHwgJ2JvdGgnfSAqL1xuXHR2YXIgZGlyZWN0aW9uID0gaXNfYm90aCA/ICdib3RoJyA6IGlzX2ludHJvID8gJ2luJyA6ICdvdXQnO1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uQ29uZmlnIHwgKChvcHRzOiB7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIH0pID0+IEFuaW1hdGlvbkNvbmZpZykgfCB1bmRlZmluZWR9ICovXG5cdHZhciBjdXJyZW50X29wdGlvbnM7XG5cblx0dmFyIGluZXJ0ID0gZWxlbWVudC5pbmVydDtcblxuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgb3ZlcmZsb3cgc3R5bGUsIHN0YXNoZWQgc28gd2UgY2FuIHJldmVydCBjaGFuZ2VzIGR1cmluZyB0aGUgdHJhbnNpdGlvblxuXHQgKiB0aGF0IGFyZSBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgPDE4IGJ1Z1xuXHQgKiBUT0RPIDYuMCByZW1vdmUgdGhpcywgaWYgb2xkZXIgdmVyc2lvbnMgb2YgU2FmYXJpIGhhdmUgZGllZCBvdXQgZW5vdWdoXG5cdCAqL1xuXHR2YXIgb3ZlcmZsb3cgPSBlbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgaW50cm87XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBvdXRybztcblxuXHRmdW5jdGlvbiBnZXRfb3B0aW9ucygpIHtcblx0XHRyZXR1cm4gd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KCgpID0+IHtcblx0XHRcdC8vIElmIGEgdHJhbnNpdGlvbiBpcyBzdGlsbCBvbmdvaW5nLCB3ZSB1c2UgdGhlIGV4aXN0aW5nIG9wdGlvbnMgcmF0aGVyIHRoYW4gZ2VuZXJhdGluZ1xuXHRcdFx0Ly8gbmV3IG9uZXMuIFRoaXMgZW5zdXJlcyB0aGF0IHJldmVyc2libGUgdHJhbnNpdGlvbnMgcmV2ZXJzZSBzbW9vdGhseSwgcmF0aGVyIHRoYW5cblx0XHRcdC8vIGp1bXBpbmcgdG8gYSBuZXcgc3BvdCBiZWNhdXNlIChmb3IgZXhhbXBsZSkgYSBkaWZmZXJlbnQgYGR1cmF0aW9uYCB3YXMgdXNlZFxuXHRcdFx0cmV0dXJuIChjdXJyZW50X29wdGlvbnMgPz89IGdldF9mbigpKGVsZW1lbnQsIGdldF9wYXJhbXM/LigpID8/IC8qKiBAdHlwZSB7UH0gKi8gKHt9KSwge1xuXHRcdFx0XHRkaXJlY3Rpb25cblx0XHRcdH0pKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7VHJhbnNpdGlvbk1hbmFnZXJ9ICovXG5cdHZhciB0cmFuc2l0aW9uID0ge1xuXHRcdGlzX2dsb2JhbCxcblx0XHRpbigpIHtcblx0XHRcdGVsZW1lbnQuaW5lcnQgPSBpbmVydDtcblxuXHRcdFx0aWYgKCFpc19pbnRybykge1xuXHRcdFx0XHRvdXRybz8uYWJvcnQoKTtcblx0XHRcdFx0b3V0cm8/LnJlc2V0Py4oKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzX291dHJvKSB7XG5cdFx0XHRcdC8vIGlmIHdlIGludHJvIHRoZW4gb3V0cm8gdGhlbiBpbnRybyBhZ2Fpbiwgd2Ugd2FudCB0byBhYm9ydCB0aGUgZmlyc3QgaW50cm8sXG5cdFx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmlkaXJlY3Rpb25hbCB0cmFuc2l0aW9uXG5cdFx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnaW50cm9zdGFydCcpO1xuXG5cdFx0XHRpbnRybyA9IGFuaW1hdGUoZWxlbWVudCwgZ2V0X29wdGlvbnMoKSwgb3V0cm8sIDEsICgpID0+IHtcblx0XHRcdFx0ZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgJ2ludHJvZW5kJyk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHdlIGNhbmNlbCB0aGUgYW5pbWF0aW9uIHRvIHByZXZlbnQgbGVha2luZ1xuXHRcdFx0XHRpbnRybz8uYWJvcnQoKTtcblx0XHRcdFx0aW50cm8gPSBjdXJyZW50X29wdGlvbnMgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0ZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRvdXQoZm4pIHtcblx0XHRcdGlmICghaXNfb3V0cm8pIHtcblx0XHRcdFx0Zm4/LigpO1xuXHRcdFx0XHRjdXJyZW50X29wdGlvbnMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbWVudC5pbmVydCA9IHRydWU7XG5cblx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdvdXRyb3N0YXJ0Jyk7XG5cblx0XHRcdG91dHJvID0gYW5pbWF0ZShlbGVtZW50LCBnZXRfb3B0aW9ucygpLCBpbnRybywgMCwgKCkgPT4ge1xuXHRcdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnb3V0cm9lbmQnKTtcblx0XHRcdFx0Zm4/LigpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRzdG9wOiAoKSA9PiB7XG5cdFx0XHRpbnRybz8uYWJvcnQoKTtcblx0XHRcdG91dHJvPy5hYm9ydCgpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgZSA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0KGUudHJhbnNpdGlvbnMgPz89IFtdKS5wdXNoKHRyYW5zaXRpb24pO1xuXG5cdC8vIGlmIHRoaXMgaXMgYSBsb2NhbCB0cmFuc2l0aW9uLCB3ZSBvbmx5IHdhbnQgdG8gcnVuIGl0IGlmIHRoZSBwYXJlbnQgKGJyYW5jaCkgZWZmZWN0J3Ncblx0Ly8gcGFyZW50IChibG9jaykgZWZmZWN0IGlzIHdoZXJlIHRoZSBzdGF0ZSBjaGFuZ2UgaGFwcGVuZWQuIHdlIGNhbiBkZXRlcm1pbmUgdGhhdCBieVxuXHQvLyBsb29raW5nIGF0IHdoZXRoZXIgdGhlIGJsb2NrIGVmZmVjdCBpcyBjdXJyZW50bHkgaW5pdGlhbGl6aW5nXG5cdGlmIChpc19pbnRybyAmJiBzaG91bGRfaW50cm8pIHtcblx0XHR2YXIgcnVuID0gaXNfZ2xvYmFsO1xuXG5cdFx0aWYgKCFydW4pIHtcblx0XHRcdHZhciBibG9jayA9IC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi8gKGUucGFyZW50KTtcblxuXHRcdFx0Ly8gc2tpcCBvdmVyIHRyYW5zcGFyZW50IGJsb2NrcyAoZS5nLiBzbmlwcGV0cywgZWxzZS1pZiBibG9ja3MpXG5cdFx0XHR3aGlsZSAoYmxvY2sgJiYgKGJsb2NrLmYgJiBFRkZFQ1RfVFJBTlNQQVJFTlQpICE9PSAwKSB7XG5cdFx0XHRcdHdoaWxlICgoYmxvY2sgPSBibG9jay5wYXJlbnQpKSB7XG5cdFx0XHRcdFx0aWYgKChibG9jay5mICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cnVuID0gIWJsb2NrIHx8IChibG9jay5mICYgRUZGRUNUX1JBTikgIT09IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHJ1bikge1xuXHRcdFx0ZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0dW50cmFjaygoKSA9PiB0cmFuc2l0aW9uLmluKCkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgYW4gZWxlbWVudCwgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7QW5pbWF0aW9uQ29uZmlnIHwgKChvcHRzOiB7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIH0pID0+IEFuaW1hdGlvbkNvbmZpZyl9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSBjb3VudGVycGFydCBUaGUgY29ycmVzcG9uZGluZyBpbnRyby9vdXRybyB0byB0aGlzIG91dHJvL2ludHJvXG4gKiBAcGFyYW0ge251bWJlcn0gdDIgVGhlIHRhcmdldCBgdGAgdmFsdWUgXHUyMDE0IGAxYCBmb3IgaW50cm8sIGAwYCBmb3Igb3V0cm9cbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBvbl9maW5pc2ggQ2FsbGVkIGFmdGVyIHN1Y2Nlc3NmdWxseSBjb21wbGV0aW5nIHRoZSBhbmltYXRpb25cbiAqIEByZXR1cm5zIHtBbmltYXRpb259XG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoZWxlbWVudCwgb3B0aW9ucywgY291bnRlcnBhcnQsIHQyLCBvbl9maW5pc2gpIHtcblx0dmFyIGlzX2ludHJvID0gdDIgPT09IDE7XG5cblx0aWYgKGlzX2Z1bmN0aW9uKG9wdGlvbnMpKSB7XG5cdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgYSBkZWZlcnJlZCB0cmFuc2l0aW9uIChzdWNoIGFzIGBjcm9zc2ZhZGVgKSwgYG9wdGlvbmAgd2lsbCBiZVxuXHRcdC8vIGEgZnVuY3Rpb24gcmF0aGVyIHRoYW4gYW4gYEFuaW1hdGlvbkNvbmZpZ2AuIFdlIG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uXG5cdFx0Ly8gb25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQuLi5cblx0XHQvKiogQHR5cGUge0FuaW1hdGlvbn0gKi9cblx0XHR2YXIgYTtcblx0XHR2YXIgYWJvcnRlZCA9IGZhbHNlO1xuXG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAoYWJvcnRlZCkgcmV0dXJuO1xuXHRcdFx0dmFyIG8gPSBvcHRpb25zKHsgZGlyZWN0aW9uOiBpc19pbnRybyA/ICdpbicgOiAnb3V0JyB9KTtcblx0XHRcdGEgPSBhbmltYXRlKGVsZW1lbnQsIG8sIGNvdW50ZXJwYXJ0LCB0Miwgb25fZmluaXNoKTtcblx0XHR9KTtcblxuXHRcdC8vIC4uLmJ1dCB3ZSB3YW50IHRvIGRvIHNvIHdpdGhvdXQgdXNpbmcgYGFzeW5jYC9gYXdhaXRgIGV2ZXJ5d2hlcmUsIHNvXG5cdFx0Ly8gd2UgcmV0dXJuIGEgZmFjYWRlIHRoYXQgYWxsb3dzIGV2ZXJ5dGhpbmcgdG8gcmVtYWluIHN5bmNocm9ub3VzXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFib3J0OiAoKSA9PiB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHRhPy5hYm9ydCgpO1xuXHRcdFx0fSxcblx0XHRcdGRlYWN0aXZhdGU6ICgpID0+IGEuZGVhY3RpdmF0ZSgpLFxuXHRcdFx0cmVzZXQ6ICgpID0+IGEucmVzZXQoKSxcblx0XHRcdHQ6ICgpID0+IGEudCgpXG5cdFx0fTtcblx0fVxuXG5cdGNvdW50ZXJwYXJ0Py5kZWFjdGl2YXRlKCk7XG5cblx0aWYgKCFvcHRpb25zPy5kdXJhdGlvbikge1xuXHRcdG9uX2ZpbmlzaCgpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFib3J0OiBub29wLFxuXHRcdFx0ZGVhY3RpdmF0ZTogbm9vcCxcblx0XHRcdHJlc2V0OiBub29wLFxuXHRcdFx0dDogKCkgPT4gdDJcblx0XHR9O1xuXHR9XG5cblx0Y29uc3QgeyBkZWxheSA9IDAsIGNzcywgdGljaywgZWFzaW5nID0gbGluZWFyIH0gPSBvcHRpb25zO1xuXG5cdHZhciBrZXlmcmFtZXMgPSBbXTtcblxuXHRpZiAoaXNfaW50cm8gJiYgY291bnRlcnBhcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmICh0aWNrKSB7XG5cdFx0XHR0aWNrKDAsIDEpOyAvLyBUT0RPIHB1dCBpbiBuZXN0ZWQgZWZmZWN0LCB0byBhdm9pZCBpbnRlcmxlYXZlZCByZWFkcy93cml0ZXM/XG5cdFx0fVxuXG5cdFx0aWYgKGNzcykge1xuXHRcdFx0dmFyIHN0eWxlcyA9IGNzc190b19rZXlmcmFtZShjc3MoMCwgMSkpO1xuXHRcdFx0a2V5ZnJhbWVzLnB1c2goc3R5bGVzLCBzdHlsZXMpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBnZXRfdCA9ICgpID0+IDEgLSB0MjtcblxuXHQvLyBjcmVhdGUgYSBkdW1teSBhbmltYXRpb24gdGhhdCBsYXN0cyBhcyBsb25nIGFzIHRoZSBkZWxheSAoYnV0IHdpdGggd2hhdGV2ZXIgZGV2dG9vbHNcblx0Ly8gbXVsdGlwbGllciBpcyBpbiBlZmZlY3QpLiBpbiB0aGUgY29tbW9uIGNhc2UgdGhhdCBpdCBpcyBgMGAsIHdlIGtlZXAgaXQgYW55d2F5IHNvIHRoYXRcblx0Ly8gdGhlIENTUyBrZXlmcmFtZXMgYXJlbid0IGNyZWF0ZWQgdW50aWwgdGhlIERPTSBpcyB1cGRhdGVkXG5cdC8vXG5cdC8vIGZpbGwgZm9yd2FyZHMgdG8gcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIHJlbmRlcmluZyB3aXRob3V0IHN0eWxlcyBhcHBsaWVkXG5cdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8xNDczMlxuXHR2YXIgYW5pbWF0aW9uID0gZWxlbWVudC5hbmltYXRlKGtleWZyYW1lcywgeyBkdXJhdGlvbjogZGVsYXksIGZpbGw6ICdmb3J3YXJkcycgfSk7XG5cblx0YW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuXHRcdC8vIHJlbW92ZSBkdW1teSBhbmltYXRpb24gZnJvbSB0aGUgc3RhY2sgdG8gcHJldmVudCBjb25mbGljdCB3aXRoIG1haW4gYW5pbWF0aW9uXG5cdFx0YW5pbWF0aW9uLmNhbmNlbCgpO1xuXG5cdFx0Ly8gZm9yIGJpZGlyZWN0aW9uYWwgdHJhbnNpdGlvbnMsIHdlIHN0YXJ0IGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24sXG5cdFx0Ly8gcmF0aGVyIHRoYW4gZG9pbmcgYSBmdWxsIGludHJvL291dHJvXG5cdFx0dmFyIHQxID0gY291bnRlcnBhcnQ/LnQoKSA/PyAxIC0gdDI7XG5cdFx0Y291bnRlcnBhcnQ/LmFib3J0KCk7XG5cblx0XHR2YXIgZGVsdGEgPSB0MiAtIHQxO1xuXHRcdHZhciBkdXJhdGlvbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAob3B0aW9ucy5kdXJhdGlvbikgKiBNYXRoLmFicyhkZWx0YSk7XG5cdFx0dmFyIGtleWZyYW1lcyA9IFtdO1xuXG5cdFx0aWYgKGR1cmF0aW9uID4gMCkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGV0aGVyIG9yIG5vdCB0aGUgQ1NTIGluY2x1ZGVzIGBvdmVyZmxvdzogaGlkZGVuYCwgaW4gd2hpY2ggY2FzZSB3ZSBuZWVkIHRvXG5cdFx0XHQgKiBhZGQgaXQgYXMgYW4gaW5saW5lIHN0eWxlIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIDwxOCBidWdcblx0XHRcdCAqIFRPRE8gNi4wIHJlbW92ZSB0aGlzLCBpZiBwb3NzaWJsZVxuXHRcdFx0ICovXG5cdFx0XHR2YXIgbmVlZHNfb3ZlcmZsb3dfaGlkZGVuID0gZmFsc2U7XG5cblx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0dmFyIG4gPSBNYXRoLmNlaWwoZHVyYXRpb24gLyAoMTAwMCAvIDYwKSk7IC8vIGBuYCBtdXN0IGJlIGFuIGludGVnZXIsIG9yIHdlIHJpc2sgbWlzc2luZyB0aGUgYHQyYCB2YWx1ZVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkgKz0gMSkge1xuXHRcdFx0XHRcdHZhciB0ID0gdDEgKyBkZWx0YSAqIGVhc2luZyhpIC8gbik7XG5cdFx0XHRcdFx0dmFyIHN0eWxlcyA9IGNzc190b19rZXlmcmFtZShjc3ModCwgMSAtIHQpKTtcblx0XHRcdFx0XHRrZXlmcmFtZXMucHVzaChzdHlsZXMpO1xuXG5cdFx0XHRcdFx0bmVlZHNfb3ZlcmZsb3dfaGlkZGVuIHx8PSBzdHlsZXMub3ZlcmZsb3cgPT09ICdoaWRkZW4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZWVkc19vdmVyZmxvd19oaWRkZW4pIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cdFx0XHR9XG5cblx0XHRcdGdldF90ID0gKCkgPT4ge1xuXHRcdFx0XHR2YXIgdGltZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn0gKi8gKGFuaW1hdGlvbikuY3VycmVudFRpbWVcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRyZXR1cm4gdDEgKyBkZWx0YSAqIGVhc2luZyh0aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRpY2spIHtcblx0XHRcdFx0bG9vcCgoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGFuaW1hdGlvbi5wbGF5U3RhdGUgIT09ICdydW5uaW5nJykgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0dmFyIHQgPSBnZXRfdCgpO1xuXHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFuaW1hdGlvbiA9IGVsZW1lbnQuYW5pbWF0ZShrZXlmcmFtZXMsIHsgZHVyYXRpb24sIGZpbGw6ICdmb3J3YXJkcycgfSk7XG5cblx0XHRhbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB7XG5cdFx0XHRnZXRfdCA9ICgpID0+IHQyO1xuXHRcdFx0dGljaz8uKHQyLCAxIC0gdDIpO1xuXHRcdFx0b25fZmluaXNoKCk7XG5cdFx0fTtcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdGFib3J0OiAoKSA9PiB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi5jYW5jZWwoKTtcblx0XHRcdFx0Ly8gVGhpcyBwcmV2ZW50cyBtZW1vcnkgbGVha3MgaW4gQ2hyb21pdW1cblx0XHRcdFx0YW5pbWF0aW9uLmVmZmVjdCA9IG51bGw7XG5cdFx0XHRcdC8vIFRoaXMgcHJldmVudHMgb25maW5pc2ggdG8gYmUgbGF1bmNoZWQgYWZ0ZXIgY2FuY2VsKCksXG5cdFx0XHRcdC8vIHdoaWNoIGNhbiBoYXBwZW4gaW4gc29tZSByYXJlIGNhc2VzXG5cdFx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8xMzY4MVxuXHRcdFx0XHRhbmltYXRpb24ub25maW5pc2ggPSBub29wO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVhY3RpdmF0ZTogKCkgPT4ge1xuXHRcdFx0b25fZmluaXNoID0gbm9vcDtcblx0XHR9LFxuXHRcdHJlc2V0OiAoKSA9PiB7XG5cdFx0XHRpZiAodDIgPT09IDApIHtcblx0XHRcdFx0dGljaz8uKDEsIDApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dDogKCkgPT4gZ2V0X3QoKVxuXHR9O1xufVxuIiwgImltcG9ydCB7IGxpc3RlbiB9IGZyb20gJy4vc2hhcmVkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyhhY3RpdmVFbGVtZW50OiBFbGVtZW50IHwgbnVsbCkgPT4gdm9pZH0gdXBkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfYWN0aXZlX2VsZW1lbnQodXBkYXRlKSB7XG5cdGxpc3Rlbihkb2N1bWVudCwgWydmb2N1c2luJywgJ2ZvY3Vzb3V0J10sIChldmVudCkgPT4ge1xuXHRcdGlmIChldmVudCAmJiBldmVudC50eXBlID09PSAnZm9jdXNvdXQnICYmIC8qKiBAdHlwZSB7Rm9jdXNFdmVudH0gKi8gKGV2ZW50KS5yZWxhdGVkVGFyZ2V0KSB7XG5cdFx0XHQvLyBUaGUgdGVzdHMgc3RpbGwgcGFzcyBpZiB3ZSByZW1vdmUgdGhpcywgYmVjYXVzZSBvZiBKU0RPTSBsaW1pdGF0aW9ucywgYnV0IGl0IGlzIG5lY2Vzc2FyeVxuXHRcdFx0Ly8gdG8gYXZvaWQgdGVtcG9yYXJpbHkgcmVzZXR0aW5nIHRvIGBkb2N1bWVudC5ib2R5YFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHVwZGF0ZShkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBCYXRjaCB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IHJlbmRlcl9lZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uLy4uLy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi8uLi90YXNrLmpzJztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uLy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyB0aWNrLCB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpc19ydW5lcyB9IGZyb20gJy4uLy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgY3VycmVudF9iYXRjaCwgcHJldmlvdXNfYmF0Y2ggfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3ZhbHVlKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgYmF0Y2hlcyA9IG5ldyBXZWFrU2V0KCk7XG5cblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChpbnB1dCwgJ2lucHV0JywgYXN5bmMgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0aWYgKERFViAmJiBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7XG5cdFx0XHQvLyBUT0RPIHNob3VsZCB0aGlzIGhhcHBlbiBpbiBwcm9kIHRvbz9cblx0XHRcdGUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0dmFyIHZhbHVlID0gaXNfcmVzZXQgPyBpbnB1dC5kZWZhdWx0VmFsdWUgOiBpbnB1dC52YWx1ZTtcblx0XHR2YWx1ZSA9IGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpID8gdG9fbnVtYmVyKHZhbHVlKSA6IHZhbHVlO1xuXHRcdHNldCh2YWx1ZSk7XG5cblx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCkge1xuXHRcdFx0YmF0Y2hlcy5hZGQoY3VycmVudF9iYXRjaCk7XG5cdFx0fVxuXG5cdFx0Ly8gQmVjYXVzZSBgeyNlYWNoIC4uLn1gIGJsb2NrcyB3b3JrIGJ5IHVwZGF0aW5nIHNvdXJjZXMgaW5zaWRlIHRoZSBmbHVzaCxcblx0XHQvLyB3ZSBuZWVkIHRvIHdhaXQgYSB0aWNrIGJlZm9yZSBjaGVja2luZyB0byBzZWUgaWYgd2Ugc2hvdWxkIGZvcmNpYmx5XG5cdFx0Ly8gdXBkYXRlIHRoZSBpbnB1dCBhbmQgcmVzZXQgdGhlIHNlbGVjdGlvbiBzdGF0ZVxuXHRcdGF3YWl0IHRpY2soKTtcblxuXHRcdC8vIFJlc3BlY3QgYW55IHZhbGlkYXRpb24gaW4gYWNjZXNzb3JzXG5cdFx0aWYgKHZhbHVlICE9PSAodmFsdWUgPSBnZXQoKSkpIHtcblx0XHRcdHZhciBzdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuXHRcdFx0dmFyIGVuZCA9IGlucHV0LnNlbGVjdGlvbkVuZDtcblx0XHRcdHZhciBsZW5ndGggPSBpbnB1dC52YWx1ZS5sZW5ndGg7XG5cblx0XHRcdC8vIHRoZSB2YWx1ZSBpcyBjb2VyY2VkIG9uIGFzc2lnbm1lbnRcblx0XHRcdGlucHV0LnZhbHVlID0gdmFsdWUgPz8gJyc7XG5cblx0XHRcdC8vIFJlc3RvcmUgc2VsZWN0aW9uXG5cdFx0XHRpZiAoZW5kICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhciBuZXdfbGVuZ3RoID0gaW5wdXQudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHQvLyBJZiBjdXJzb3Igd2FzIGF0IGVuZCBhbmQgbmV3IGlucHV0IGlzIGxvbmdlciwgbW92ZSBjdXJzb3IgdG8gbmV3IGVuZFxuXHRcdFx0XHRpZiAoc3RhcnQgPT09IGVuZCAmJiBlbmQgPT09IGxlbmd0aCAmJiBuZXdfbGVuZ3RoID4gbGVuZ3RoKSB7XG5cdFx0XHRcdFx0aW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBuZXdfbGVuZ3RoO1xuXHRcdFx0XHRcdGlucHV0LnNlbGVjdGlvbkVuZCA9IG5ld19sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHRpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIG5ld19sZW5ndGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLFxuXHRcdC8vIHRoZW4gdXNlIHRoZSB1cGRhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0KGh5ZHJhdGluZyAmJiBpbnB1dC5kZWZhdWx0VmFsdWUgIT09IGlucHV0LnZhbHVlKSB8fFxuXHRcdC8vIElmIGRlZmF1bHRWYWx1ZSBpcyBzZXQsIHRoZW4gdmFsdWUgPT0gZGVmYXVsdFZhbHVlXG5cdFx0Ly8gVE9ETyBTdmVsdGUgNjogcmVtb3ZlIGlucHV0LnZhbHVlIGNoZWNrIGFuZCBzZXQgdG8gZW1wdHkgc3RyaW5nP1xuXHRcdCh1bnRyYWNrKGdldCkgPT0gbnVsbCAmJiBpbnB1dC52YWx1ZSlcblx0KSB7XG5cdFx0c2V0KGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpID8gdG9fbnVtYmVyKGlucHV0LnZhbHVlKSA6IGlucHV0LnZhbHVlKTtcblxuXHRcdGlmIChjdXJyZW50X2JhdGNoICE9PSBudWxsKSB7XG5cdFx0XHRiYXRjaGVzLmFkZChjdXJyZW50X2JhdGNoKTtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRpZiAoREVWICYmIGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWUoKTtcblx0XHR9XG5cblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblxuXHRcdGlmIChpbnB1dCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuXHRcdFx0Ly8gd2UgbmVlZCBib3RoLCBiZWNhdXNlIGluIG5vbi1hc3luYyBtb2RlLCByZW5kZXIgZWZmZWN0cyBydW4gYmVmb3JlIHByZXZpb3VzX2JhdGNoIGlzIHNldFxuXHRcdFx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKHByZXZpb3VzX2JhdGNoID8/IGN1cnJlbnRfYmF0Y2gpO1xuXG5cdFx0XHQvLyBOZXZlciByZXdyaXRlIHRoZSBjb250ZW50cyBvZiBhIGZvY3VzZWQgaW5wdXQuIFdlIGNhbiBnZXQgaGVyZSBpZiwgZm9yIGV4YW1wbGUsXG5cdFx0XHQvLyBhbiB1cGRhdGUgaXMgZGVmZXJyZWQgYmVjYXVzZSBvZiBhc3luYyB3b3JrIGRlcGVuZGluZyBvbiB0aGUgaW5wdXQ6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gPGlucHV0IGJpbmQ6dmFsdWU9e3F1ZXJ5fT5cblx0XHRcdC8vIDxwPnthd2FpdCBmaW5kKHF1ZXJ5KX08L3A+XG5cdFx0XHRpZiAoYmF0Y2hlcy5oYXMoYmF0Y2gpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgJiYgdmFsdWUgPT09IHRvX251bWJlcihpbnB1dC52YWx1ZSkpIHtcblx0XHRcdC8vIGhhbmRsZXMgMCB2cyAwMCBjYXNlIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvOTk1OSlcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoaW5wdXQudHlwZSA9PT0gJ2RhdGUnICYmICF2YWx1ZSAmJiAhaW5wdXQudmFsdWUpIHtcblx0XHRcdC8vIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSB0ZW1wb3JhcmlseSBpbnZhbGlkIGRhdGUgaXMgc2V0ICh3aGlsZSB0eXBpbmcsIGZvciBleGFtcGxlIHdpdGggYSBsZWFkaW5nIDAgZm9yIHRoZSBkYXkpXG5cdFx0XHQvLyBhbmQgcHJldmVudHMgdGhpcyBzdGF0ZSBmcm9tIGNsZWFyaW5nIHRoZSBvdGhlciBwYXJ0cyBvZiB0aGUgZGF0ZSBpbnB1dCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzc4OTcpXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZG9uJ3Qgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgaWYgaXQncyB0aGUgc2FtZSB0byBhbGxvd1xuXHRcdC8vIG1pbmxlbmd0aCB0byB3b3JrIHByb3Blcmx5XG5cdFx0aWYgKHZhbHVlICE9PSBpbnB1dC52YWx1ZSkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdmFsdWUgaXMgY29lcmNlZCBvbiBhc3NpZ25tZW50XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlID8/ICcnO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKiBAdHlwZSB7U2V0PEhUTUxJbnB1dEVsZW1lbnRbXT59ICovXG5jb25zdCBwZW5kaW5nID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudFtdfSBpbnB1dHNcbiAqIEBwYXJhbSB7bnVsbCB8IFtudW1iZXJdfSBncm91cF9pbmRleFxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9ncm91cChpbnB1dHMsIGdyb3VwX2luZGV4LCBpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIGlzX2NoZWNrYm94ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdjaGVja2JveCc7XG5cdHZhciBiaW5kaW5nX2dyb3VwID0gaW5wdXRzO1xuXG5cdC8vIG5lZWRzIHRvIGJlIGxldCBvciByZWxhdGVkIGNvZGUgaXNuJ3QgdHJlZXNoYWtlbiBvdXQgaWYgaXQncyBhbHdheXMgZmFsc2Vcblx0bGV0IGh5ZHJhdGlvbl9taXNtYXRjaCA9IGZhbHNlO1xuXG5cdGlmIChncm91cF9pbmRleCAhPT0gbnVsbCkge1xuXHRcdGZvciAodmFyIGluZGV4IG9mIGdyb3VwX2luZGV4KSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRiaW5kaW5nX2dyb3VwID0gYmluZGluZ19ncm91cFtpbmRleF0gPz89IFtdO1xuXHRcdH1cblx0fVxuXG5cdGJpbmRpbmdfZ3JvdXAucHVzaChpbnB1dCk7XG5cblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChcblx0XHRpbnB1dCxcblx0XHQnY2hhbmdlJyxcblx0XHQoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR2YXIgdmFsdWUgPSBpbnB1dC5fX3ZhbHVlO1xuXG5cdFx0XHRpZiAoaXNfY2hlY2tib3gpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfYmluZGluZ19ncm91cF92YWx1ZShiaW5kaW5nX2dyb3VwLCB2YWx1ZSwgaW5wdXQuY2hlY2tlZCk7XG5cdFx0XHR9XG5cblx0XHRcdHNldCh2YWx1ZSk7XG5cdFx0fSxcblx0XHQvLyBUT0RPIGJldHRlciBkZWZhdWx0IHZhbHVlIGhhbmRsaW5nXG5cdFx0KCkgPT4gc2V0KGlzX2NoZWNrYm94ID8gW10gOiBudWxsKVxuXHQpO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLCB0aGVuIHVzZSB0aGUgdXBkYXRlIHZhbHVlXG5cdFx0Ly8gZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHRpZiAoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRDaGVja2VkICE9PSBpbnB1dC5jaGVja2VkKSB7XG5cdFx0XHRoeWRyYXRpb25fbWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBbXTtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGlucHV0LmNoZWNrZWQgPSB2YWx1ZS5pbmNsdWRlcyhpbnB1dC5fX3ZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0aW5wdXQuY2hlY2tlZCA9IGlzKGlucHV0Ll9fdmFsdWUsIHZhbHVlKTtcblx0XHR9XG5cdH0pO1xuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHR2YXIgaW5kZXggPSBiaW5kaW5nX2dyb3VwLmluZGV4T2YoaW5wdXQpO1xuXG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0YmluZGluZ19ncm91cC5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKCFwZW5kaW5nLmhhcyhiaW5kaW5nX2dyb3VwKSkge1xuXHRcdHBlbmRpbmcuYWRkKGJpbmRpbmdfZ3JvdXApO1xuXG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHQvLyBuZWNlc3NhcnkgdG8gbWFpbnRhaW4gYmluZGluZyBncm91cCBvcmRlciBpbiBhbGwgaW5zZXJ0aW9uIHNjZW5hcmlvc1xuXHRcdFx0YmluZGluZ19ncm91cC5zb3J0KChhLCBiKSA9PiAoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSA9PT0gNCA/IC0xIDogMSkpO1xuXHRcdFx0cGVuZGluZy5kZWxldGUoYmluZGluZ19ncm91cCk7XG5cdFx0fSk7XG5cdH1cblxuXHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW9uX21pc21hdGNoKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cblx0XHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGJpbmRpbmdfZ3JvdXAsIHZhbHVlLCBpbnB1dC5jaGVja2VkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoeWRyYXRpb25faW5wdXQgPSBiaW5kaW5nX2dyb3VwLmZpbmQoKGlucHV0KSA9PiBpbnB1dC5jaGVja2VkKTtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHR2YWx1ZSA9IGh5ZHJhdGlvbl9pbnB1dD8uX192YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0c2V0KHZhbHVlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfY2hlY2tlZChpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChpbnB1dCwgJ2NoYW5nZScsIChpc19yZXNldCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGlzX3Jlc2V0ID8gaW5wdXQuZGVmYXVsdENoZWNrZWQgOiBpbnB1dC5jaGVja2VkO1xuXHRcdHNldCh2YWx1ZSk7XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZSB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdChoeWRyYXRpbmcgJiYgaW5wdXQuZGVmYXVsdENoZWNrZWQgIT09IGlucHV0LmNoZWNrZWQpIHx8XG5cdFx0Ly8gSWYgZGVmYXVsdENoZWNrZWQgaXMgc2V0LCB0aGVuIGNoZWNrZWQgPT0gZGVmYXVsdENoZWNrZWRcblx0XHR1bnRyYWNrKGdldCkgPT0gbnVsbFxuXHQpIHtcblx0XHRzZXQoaW5wdXQuY2hlY2tlZCk7XG5cdH1cblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblx0XHRpbnB1dC5jaGVja2VkID0gQm9vbGVhbih2YWx1ZSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0FycmF5PEhUTUxJbnB1dEVsZW1lbnQ+fSBncm91cFxuICogQHBhcmFtIHtWfSBfX3ZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWRcbiAqIEByZXR1cm5zIHtWW119XG4gKi9cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG5cdC8qKiBAdHlwZSB7U2V0PFY+fSAqL1xuXHR2YXIgdmFsdWUgPSBuZXcgU2V0KCk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChncm91cFtpXS5jaGVja2VkKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFjaGVja2VkKSB7XG5cdFx0dmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkge1xuXHR2YXIgdHlwZSA9IGlucHV0LnR5cGU7XG5cdHJldHVybiB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAncmFuZ2UnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiBGaWxlTGlzdCB8IG51bGx9IGdldFxuICogQHBhcmFtIHsodmFsdWU6IEZpbGVMaXN0IHwgbnVsbCkgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ZpbGVzKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGlucHV0LCAnY2hhbmdlJywgKCkgPT4ge1xuXHRcdHNldChpbnB1dC5maWxlcyk7XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHRoeWRyYXRpbmcgJiZcblx0XHRpbnB1dC5maWxlc1xuXHQpIHtcblx0XHRzZXQoaW5wdXQuZmlsZXMpO1xuXHR9XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aW5wdXQuZmlsZXMgPSBnZXQoKTtcblx0fSk7XG59XG4iLCAiaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCwgZWZmZWN0LCB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBsaXN0ZW4gfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5cbi8qKiBAcGFyYW0ge1RpbWVSYW5nZXN9IHJhbmdlcyAqL1xuZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG5cdHZhciBhcnJheSA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0YXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcblx0fVxuXG5cdHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoKSA9PiBudW1iZXIgfCB1bmRlZmluZWR9IGdldFxuICogQHBhcmFtIHsodmFsdWU6IG51bWJlcikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfY3VycmVudF90aW1lKG1lZGlhLCBnZXQsIHNldCA9IGdldCkge1xuXHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0dmFyIHJhZl9pZDtcblx0LyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cdHZhciB2YWx1ZTtcblxuXHQvLyBJZGVhbGx5LCBsaXN0ZW5pbmcgdG8gdGltZXVwZGF0ZSB3b3VsZCBiZSBlbm91Z2gsIGJ1dCBpdCBmaXJlcyB0b28gaW5mcmVxdWVudGx5IGZvciB0aGUgY3VycmVudFRpbWVcblx0Ly8gYmluZGluZywgd2hpY2ggaXMgd2h5IHdlIHVzZSBhIHJhZiBsb29wLCB0b28uIFdlIGFkZGl0aW9uYWxseSBzdGlsbCBsaXN0ZW4gdG8gdGltZXVwZGF0ZSBiZWNhdXNlXG5cdC8vIHRoZSB1c2VyIGNvdWxkIGJlIHNjcnViYmluZyB0aHJvdWdoIHRoZSB2aWRlbyB1c2luZyB0aGUgbmF0aXZlIGNvbnRyb2xzIHdoZW4gdGhlIG1lZGlhIGlzIHBhdXNlZC5cblx0dmFyIGNhbGxiYWNrID0gKCkgPT4ge1xuXHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZl9pZCk7XG5cblx0XHRpZiAoIW1lZGlhLnBhdXNlZCkge1xuXHRcdFx0cmFmX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcblx0XHR9XG5cblx0XHR2YXIgbmV4dF92YWx1ZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuXHRcdGlmICh2YWx1ZSAhPT0gbmV4dF92YWx1ZSkge1xuXHRcdFx0c2V0KCh2YWx1ZSA9IG5leHRfdmFsdWUpKTtcblx0XHR9XG5cdH07XG5cblx0cmFmX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcblx0bWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIGNhbGxiYWNrKTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgbmV4dF92YWx1ZSA9IE51bWJlcihnZXQoKSk7XG5cblx0XHRpZiAodmFsdWUgIT09IG5leHRfdmFsdWUgJiYgIWlzTmFOKC8qKiBAdHlwZSB7YW55fSAqLyAobmV4dF92YWx1ZSkpKSB7XG5cdFx0XHRtZWRpYS5jdXJyZW50VGltZSA9IHZhbHVlID0gbmV4dF92YWx1ZTtcblx0XHR9XG5cdH0pO1xuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHRjYW5jZWxBbmltYXRpb25GcmFtZShyYWZfaWQpO1xuXHRcdG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCBjYWxsYmFjayk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geyhhcnJheTogQXJyYXk8eyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlciB9PikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2J1ZmZlcmVkKG1lZGlhLCBzZXQpIHtcblx0LyoqIEB0eXBlIHt7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyOyB9W119ICovXG5cdHZhciBjdXJyZW50O1xuXG5cdC8vIGBidWZmZXJlZGAgY2FuIHVwZGF0ZSB3aXRob3V0IGVtaXR0aW5nIGFueSBldmVudCwgc28gd2UgY2hlY2sgaXQgb24gdmFyaW91cyBldmVudHMuXG5cdC8vIEJ5IHNwZWNzLCBgYnVmZmVyZWRgIGFsd2F5cyByZXR1cm5zIGEgbmV3IG9iamVjdCwgc28gd2UgaGF2ZSB0byBjb21wYXJlIGRlZXBseS5cblx0bGlzdGVuKG1lZGlhLCBbJ2xvYWRlZG1ldGFkYXRhJywgJ3Byb2dyZXNzJywgJ3RpbWV1cGRhdGUnLCAnc2Vla2luZyddLCAoKSA9PiB7XG5cdFx0dmFyIHJhbmdlcyA9IG1lZGlhLmJ1ZmZlcmVkO1xuXG5cdFx0aWYgKFxuXHRcdFx0IWN1cnJlbnQgfHxcblx0XHRcdGN1cnJlbnQubGVuZ3RoICE9PSByYW5nZXMubGVuZ3RoIHx8XG5cdFx0XHRjdXJyZW50LnNvbWUoKHJhbmdlLCBpKSA9PiByYW5nZXMuc3RhcnQoaSkgIT09IHJhbmdlLnN0YXJ0IHx8IHJhbmdlcy5lbmQoaSkgIT09IHJhbmdlLmVuZClcblx0XHQpIHtcblx0XHRcdGN1cnJlbnQgPSB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpO1xuXHRcdFx0c2V0KGN1cnJlbnQpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KGFycmF5OiBBcnJheTx7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyIH0+KSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfc2Vla2FibGUobWVkaWEsIHNldCkge1xuXHRsaXN0ZW4obWVkaWEsIFsnbG9hZGVkbWV0YWRhdGEnXSwgKCkgPT4gc2V0KHRpbWVfcmFuZ2VzX3RvX2FycmF5KG1lZGlhLnNlZWthYmxlKSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geyhhcnJheTogQXJyYXk8eyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlciB9PikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3BsYXllZChtZWRpYSwgc2V0KSB7XG5cdGxpc3RlbihtZWRpYSwgWyd0aW1ldXBkYXRlJ10sICgpID0+IHNldCh0aW1lX3Jhbmdlc190b19hcnJheShtZWRpYS5wbGF5ZWQpKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KHNlZWtpbmc6IGJvb2xlYW4pID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9zZWVraW5nKG1lZGlhLCBzZXQpIHtcblx0bGlzdGVuKG1lZGlhLCBbJ3NlZWtpbmcnLCAnc2Vla2VkJ10sICgpID0+IHNldChtZWRpYS5zZWVraW5nKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KHNlZWtpbmc6IGJvb2xlYW4pID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9lbmRlZChtZWRpYSwgc2V0KSB7XG5cdGxpc3RlbihtZWRpYSwgWyd0aW1ldXBkYXRlJywgJ2VuZGVkJ10sICgpID0+IHNldChtZWRpYS5lbmRlZCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geyhyZWFkeV9zdGF0ZTogbnVtYmVyKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcmVhZHlfc3RhdGUobWVkaWEsIHNldCkge1xuXHRsaXN0ZW4oXG5cdFx0bWVkaWEsXG5cdFx0Wydsb2FkZWRtZXRhZGF0YScsICdsb2FkZWRkYXRhJywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAncGxheWluZycsICd3YWl0aW5nJywgJ2VtcHRpZWQnXSxcblx0XHQoKSA9PiBzZXQobWVkaWEucmVhZHlTdGF0ZSlcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoKSA9PiBudW1iZXIgfCB1bmRlZmluZWR9IGdldFxuICogQHBhcmFtIHsocGxheWJhY2tfcmF0ZTogbnVtYmVyKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcGxheWJhY2tfcmF0ZShtZWRpYSwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0Ly8gTmVlZHMgdG8gaGFwcGVuIGFmdGVyIGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50byB0aGUgZG9tICh3aGljaCBpcyBndWFyYW50ZWVkIGJ5IHVzaW5nIGVmZmVjdCksXG5cdC8vIGVsc2UgcGxheWJhY2sgd2lsbCBiZSBzZXQgYmFjayB0byAxIGJ5IHRoZSBicm93c2VyXG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gTnVtYmVyKGdldCgpKTtcblxuXHRcdGlmICh2YWx1ZSAhPT0gbWVkaWEucGxheWJhY2tSYXRlICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdG1lZGlhLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gU3RhcnQgbGlzdGVuaW5nIHRvIHJhdGVjaGFuZ2UgZXZlbnRzIGFmdGVyIHRoZSBlbGVtZW50IGlzIGluc2VydGVkIGludG8gdGhlIGRvbSxcblx0Ly8gZWxzZSBwbGF5YmFjayB3aWxsIGJlIHNldCB0byAxIGJ5IHRoZSBicm93c2VyXG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0bGlzdGVuKG1lZGlhLCBbJ3JhdGVjaGFuZ2UnXSwgKCkgPT4ge1xuXHRcdFx0c2V0KG1lZGlhLnBsYXliYWNrUmF0ZSk7XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geygpID0+IGJvb2xlYW4gfCB1bmRlZmluZWR9IGdldFxuICogQHBhcmFtIHsocGF1c2VkOiBib29sZWFuKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcGF1c2VkKG1lZGlhLCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgcGF1c2VkID0gZ2V0KCk7XG5cblx0dmFyIHVwZGF0ZSA9ICgpID0+IHtcblx0XHRpZiAocGF1c2VkICE9PSBtZWRpYS5wYXVzZWQpIHtcblx0XHRcdHNldCgocGF1c2VkID0gbWVkaWEucGF1c2VkKSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIElmIHNvbWVvbmUgc3dpdGNoZXMgdGhlIHNyYyB3aGlsZSBtZWRpYSBpcyBwbGF5aW5nLCB0aGUgcGxheWVyIHdpbGwgcGF1c2UuXG5cdC8vIExpc3RlbiB0byB0aGUgY2FucGxheSBldmVudCB0byBnZXQgbm90aWZpZWQgb2YgdGhpcyBzaXR1YXRpb24uXG5cdGxpc3RlbihtZWRpYSwgWydwbGF5JywgJ3BhdXNlJywgJ2NhbnBsYXknXSwgdXBkYXRlLCBwYXVzZWQgPT0gbnVsbCk7XG5cblx0Ly8gTmVlZHMgdG8gYmUgYW4gZWZmZWN0IHRvIGVuc3VyZSBtZWRpYSBlbGVtZW50IGlzIG1vdW50ZWQ6IGVsc2UsIGlmIHBhdXNlZCBpcyBgZmFsc2VgIChpLmUuIHNob3VsZCBwbGF5IHJpZ2h0IGF3YXkpXG5cdC8vIGEgXCJUaGUgcGxheSgpIHJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgbmV3IGxvYWQgcmVxdWVzdFwiIGVycm9yIHdvdWxkIGJlIHRocm93biBiZWNhdXNlIHRoZSByZXNvdXJjZSBpc24ndCBsb2FkZWQgeWV0LlxuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdGlmICgocGF1c2VkID0gISFnZXQoKSkgIT09IG1lZGlhLnBhdXNlZCkge1xuXHRcdFx0aWYgKHBhdXNlZCkge1xuXHRcdFx0XHRtZWRpYS5wYXVzZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWVkaWEucGxheSgpLmNhdGNoKCgpID0+IHtcblx0XHRcdFx0XHRzZXQoKHBhdXNlZCA9IHRydWUpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoKSA9PiBudW1iZXIgfCB1bmRlZmluZWR9IGdldFxuICogQHBhcmFtIHsodm9sdW1lOiBudW1iZXIpID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF92b2x1bWUobWVkaWEsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBjYWxsYmFjayA9ICgpID0+IHtcblx0XHRzZXQobWVkaWEudm9sdW1lKTtcblx0fTtcblxuXHRpZiAoZ2V0KCkgPT0gbnVsbCkge1xuXHRcdGNhbGxiYWNrKCk7XG5cdH1cblxuXHRsaXN0ZW4obWVkaWEsIFsndm9sdW1lY2hhbmdlJ10sIGNhbGxiYWNrLCBmYWxzZSk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gTnVtYmVyKGdldCgpKTtcblxuXHRcdGlmICh2YWx1ZSAhPT0gbWVkaWEudm9sdW1lICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdG1lZGlhLnZvbHVtZSA9IHZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KCkgPT4gYm9vbGVhbiB8IHVuZGVmaW5lZH0gZ2V0XG4gKiBAcGFyYW0geyhtdXRlZDogYm9vbGVhbikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX211dGVkKG1lZGlhLCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgY2FsbGJhY2sgPSAoKSA9PiB7XG5cdFx0c2V0KG1lZGlhLm11dGVkKTtcblx0fTtcblxuXHRpZiAoZ2V0KCkgPT0gbnVsbCkge1xuXHRcdGNhbGxiYWNrKCk7XG5cdH1cblxuXHRsaXN0ZW4obWVkaWEsIFsndm9sdW1lY2hhbmdlJ10sIGNhbGxiYWNrLCBmYWxzZSk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gISFnZXQoKTtcblxuXHRcdGlmIChtZWRpYS5tdXRlZCAhPT0gdmFsdWUpIG1lZGlhLm11dGVkID0gdmFsdWU7XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IGxpc3RlbiB9IGZyb20gJy4vc2hhcmVkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyhvbmxpbmU6IGJvb2xlYW4pID0+IHZvaWR9IHVwZGF0ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX29ubGluZSh1cGRhdGUpIHtcblx0bGlzdGVuKHdpbmRvdywgWydvbmxpbmUnLCAnb2ZmbGluZSddLCAoKSA9PiB7XG5cdFx0dXBkYXRlKG5hdmlnYXRvci5vbkxpbmUpO1xuXHR9KTtcbn1cbiIsICJpbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvciB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8qKlxuICogTWFrZXMgYW4gYGV4cG9ydGBlZCAobm9uLXByb3ApIHZhcmlhYmxlIGF2YWlsYWJsZSBvbiB0aGUgYCQkcHJvcHNgIG9iamVjdFxuICogc28gdGhhdCBjb25zdW1lcnMgY2FuIGRvIGBiaW5kOnhgIG9uIHRoZSBjb21wb25lbnQuXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcHJvcChwcm9wcywgcHJvcCwgdmFsdWUpIHtcblx0dmFyIGRlc2MgPSBnZXRfZGVzY3JpcHRvcihwcm9wcywgcHJvcCk7XG5cblx0aWYgKGRlc2MgJiYgZGVzYy5zZXQpIHtcblx0XHRwcm9wc1twcm9wXSA9IHZhbHVlO1xuXHRcdHRlYXJkb3duKCgpID0+IHtcblx0XHRcdHByb3BzW3Byb3BdID0gbnVsbDtcblx0XHR9KTtcblx0fVxufVxuIiwgImltcG9ydCB7IGVmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uLy4uLy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIFJlc2l6ZSBvYnNlcnZlciBzaW5nbGV0b24uXG4gKiBPbmUgbGlzdGVuZXIgcGVyIGVsZW1lbnQgb25seSFcbiAqIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZy9ibGluay1kZXYvYy96Nmllbk9OVWI1QS9tL0Y1LVZjVVp0QkFBSlxuICovXG5jbGFzcyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB7XG5cdC8qKiAqL1xuXHQjbGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuXHQvKiogQHR5cGUge1Jlc2l6ZU9ic2VydmVyIHwgdW5kZWZpbmVkfSAqL1xuXHQjb2JzZXJ2ZXI7XG5cblx0LyoqIEB0eXBlIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9ICovXG5cdCNvcHRpb25zO1xuXG5cdC8qKiBAc3RhdGljICovXG5cdHN0YXRpYyBlbnRyaWVzID0gbmV3IFdlYWtNYXAoKTtcblxuXHQvKiogQHBhcmFtIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9IG9wdGlvbnMgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0geyhlbnRyeTogUmVzaXplT2JzZXJ2ZXJFbnRyeSkgPT4gYW55fSBsaXN0ZW5lclxuXHQgKi9cblx0b2JzZXJ2ZShlbGVtZW50LCBsaXN0ZW5lcikge1xuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGVsZW1lbnQpIHx8IG5ldyBTZXQoKTtcblx0XHRsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcblxuXHRcdHRoaXMuI2xpc3RlbmVycy5zZXQoZWxlbWVudCwgbGlzdGVuZXJzKTtcblx0XHR0aGlzLiNnZXRPYnNlcnZlcigpLm9ic2VydmUoZWxlbWVudCwgdGhpcy4jb3B0aW9ucyk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuI2xpc3RlbmVycy5nZXQoZWxlbWVudCk7XG5cdFx0XHRsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcblxuXHRcdFx0aWYgKGxpc3RlbmVycy5zaXplID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuI2xpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG5cdFx0XHRcdC8qKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJ9ICovICh0aGlzLiNvYnNlcnZlcikudW5vYnNlcnZlKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQjZ2V0T2JzZXJ2ZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuI29ic2VydmVyID8/XG5cdFx0XHQodGhpcy4jb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoXG5cdFx0XHRcdC8qKiBAcGFyYW0ge2FueX0gZW50cmllcyAqLyAoZW50cmllcykgPT4ge1xuXHRcdFx0XHRcdGZvciAodmFyIGVudHJ5IG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRcdFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMuc2V0KGVudHJ5LnRhcmdldCwgZW50cnkpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzLmdldChlbnRyeS50YXJnZXQpIHx8IFtdKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyKGVudHJ5KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCkpXG5cdFx0KTtcblx0fVxufVxuXG52YXIgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2NvbnRlbnQtYm94J1xufSk7XG5cbnZhciByZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdib3JkZXItYm94J1xufSk7XG5cbnZhciByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCdcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsnY29udGVudFJlY3QnIHwgJ2NvbnRlbnRCb3hTaXplJyB8ICdib3JkZXJCb3hTaXplJyB8ICdkZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplJ30gdHlwZVxuICogQHBhcmFtIHsoZW50cnk6IGtleW9mIFJlc2l6ZU9ic2VydmVyRW50cnkpID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9yZXNpemVfb2JzZXJ2ZXIoZWxlbWVudCwgdHlwZSwgc2V0KSB7XG5cdHZhciBvYnNlcnZlciA9XG5cdFx0dHlwZSA9PT0gJ2NvbnRlbnRSZWN0JyB8fCB0eXBlID09PSAnY29udGVudEJveFNpemUnXG5cdFx0XHQ/IHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveFxuXHRcdFx0OiB0eXBlID09PSAnYm9yZGVyQm94U2l6ZSdcblx0XHRcdFx0PyByZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveFxuXHRcdFx0XHQ6IHJlc2l6ZV9vYnNlcnZlcl9kZXZpY2VfcGl4ZWxfY29udGVudF9ib3g7XG5cblx0dmFyIHVuc3ViID0gb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCAvKiogQHBhcmFtIHthbnl9IGVudHJ5ICovIChlbnRyeSkgPT4gc2V0KGVudHJ5W3R5cGVdKSk7XG5cdHRlYXJkb3duKHVuc3ViKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geydjbGllbnRXaWR0aCcgfCAnY2xpZW50SGVpZ2h0JyB8ICdvZmZzZXRXaWR0aCcgfCAnb2Zmc2V0SGVpZ2h0J30gdHlwZVxuICogQHBhcmFtIHsoc2l6ZTogbnVtYmVyKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZWxlbWVudF9zaXplKGVsZW1lbnQsIHR5cGUsIHNldCkge1xuXHR2YXIgdW5zdWIgPSByZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveC5vYnNlcnZlKGVsZW1lbnQsICgpID0+IHNldChlbGVtZW50W3R5cGVdKSk7XG5cblx0ZWZmZWN0KCgpID0+IHtcblx0XHQvLyBUaGUgdXBkYXRlIGNvdWxkIGNvbnRhaW4gcmVhZHMgd2hpY2ggc2hvdWxkIGJlIGlnbm9yZWRcblx0XHR1bnRyYWNrKCgpID0+IHNldChlbGVtZW50W3R5cGVdKSk7XG5cdFx0cmV0dXJuIHVuc3ViO1xuXHR9KTtcbn1cbiIsICJpbXBvcnQgeyBTVEFURV9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBlZmZlY3QsIHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uLy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uLy4uL3Rhc2suanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBib3VuZF92YWx1ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50X29yX2NvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzX2JvdW5kX3RoaXMoYm91bmRfdmFsdWUsIGVsZW1lbnRfb3JfY29tcG9uZW50KSB7XG5cdHJldHVybiAoXG5cdFx0Ym91bmRfdmFsdWUgPT09IGVsZW1lbnRfb3JfY29tcG9uZW50IHx8IGJvdW5kX3ZhbHVlPy5bU1RBVEVfU1lNQk9MXSA9PT0gZWxlbWVudF9vcl9jb21wb25lbnRcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gZWxlbWVudF9vcl9jb21wb25lbnRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duLCAuLi5wYXJ0czogdW5rbm93bltdKSA9PiB2b2lkfSB1cGRhdGVcbiAqIEBwYXJhbSB7KC4uLnBhcnRzOiB1bmtub3duW10pID0+IHVua25vd259IGdldF92YWx1ZVxuICogQHBhcmFtIHsoKSA9PiB1bmtub3duW119IFtnZXRfcGFydHNdIFNldCBpZiB0aGUgdGhpcyBiaW5kaW5nIGlzIHVzZWQgaW5zaWRlIGFuIGVhY2ggYmxvY2ssXG4gKiBcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybnMgYWxsIHRoZSBwYXJ0cyBvZiB0aGUgZWFjaCBibG9jayBjb250ZXh0IHRoYXQgYXJlIHVzZWQgaW4gdGhlIGV4cHJlc3Npb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF90aGlzKGVsZW1lbnRfb3JfY29tcG9uZW50ID0ge30sIHVwZGF0ZSwgZ2V0X3ZhbHVlLCBnZXRfcGFydHMpIHtcblx0ZWZmZWN0KCgpID0+IHtcblx0XHQvKiogQHR5cGUge3Vua25vd25bXX0gKi9cblx0XHR2YXIgb2xkX3BhcnRzO1xuXG5cdFx0LyoqIEB0eXBlIHt1bmtub3duW119ICovXG5cdFx0dmFyIHBhcnRzO1xuXG5cdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvbGRfcGFydHMgPSBwYXJ0cztcblx0XHRcdC8vIFdlIG9ubHkgdHJhY2sgY2hhbmdlcyB0byB0aGUgcGFydHMsIG5vdCB0aGUgdmFsdWUgaXRzZWxmIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlcnVucy5cblx0XHRcdHBhcnRzID0gZ2V0X3BhcnRzPy4oKSB8fCBbXTtcblxuXHRcdFx0dW50cmFjaygoKSA9PiB7XG5cdFx0XHRcdGlmIChlbGVtZW50X29yX2NvbXBvbmVudCAhPT0gZ2V0X3ZhbHVlKC4uLnBhcnRzKSkge1xuXHRcdFx0XHRcdHVwZGF0ZShlbGVtZW50X29yX2NvbXBvbmVudCwgLi4ucGFydHMpO1xuXHRcdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gZWZmZWN0IHJlcnVuIChjYXVzZTogZWFjaCBibG9jayBjb250ZXh0IGNoYW5nZXMpLCB0aGVuIG51bGxpZnkgdGhlIGJpbmRpbmcgYXRcblx0XHRcdFx0XHQvLyB0aGUgcHJldmlvdXMgcG9zaXRpb24gaWYgaXQgaXNuJ3QgYWxyZWFkeSB0YWtlbiBvdmVyIGJ5IGEgZGlmZmVyZW50IGVmZmVjdC5cblx0XHRcdFx0XHRpZiAob2xkX3BhcnRzICYmIGlzX2JvdW5kX3RoaXMoZ2V0X3ZhbHVlKC4uLm9sZF9wYXJ0cyksIGVsZW1lbnRfb3JfY29tcG9uZW50KSkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKG51bGwsIC4uLm9sZF9wYXJ0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHQvLyBXZSBjYW5ub3QgdXNlIGVmZmVjdHMgaW4gdGhlIHRlYXJkb3duIHBoYXNlLCB3ZSB3ZSB1c2UgYSBtaWNyb3Rhc2sgaW5zdGVhZC5cblx0XHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0XHRpZiAocGFydHMgJiYgaXNfYm91bmRfdGhpcyhnZXRfdmFsdWUoLi4ucGFydHMpLCBlbGVtZW50X29yX2NvbXBvbmVudCkpIHtcblx0XHRcdFx0XHR1cGRhdGUobnVsbCwgLi4ucGFydHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudF9vcl9jb21wb25lbnQ7XG59XG4iLCAiaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbGlzdGVuIH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7J2lubmVySFRNTCcgfCAndGV4dENvbnRlbnQnIHwgJ2lubmVyVGV4dCd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2NvbnRlbnRfZWRpdGFibGUocHJvcGVydHksIGVsZW1lbnQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHNldChlbGVtZW50W3Byb3BlcnR5XSk7XG5cdH0pO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXG5cdFx0aWYgKGVsZW1lbnRbcHJvcGVydHldICE9PSB2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHR2YXIgbm9uX251bGxfdmFsdWUgPSBlbGVtZW50W3Byb3BlcnR5XTtcblx0XHRcdFx0c2V0KG5vbl9udWxsX3ZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0ZWxlbWVudFtwcm9wZXJ0eV0gPSB2YWx1ZSArICcnO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IFtnZXRdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcHJvcGVydHkocHJvcGVydHksIGV2ZW50X25hbWUsIGVsZW1lbnQsIHNldCwgZ2V0KSB7XG5cdHZhciBoYW5kbGVyID0gKCkgPT4ge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRzZXQoZWxlbWVudFtwcm9wZXJ0eV0pO1xuXHR9O1xuXG5cdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVyKTtcblxuXHRpZiAoZ2V0KSB7XG5cdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRlbGVtZW50W3Byb3BlcnR5XSA9IGdldCgpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGhhbmRsZXIoKTtcblx0fVxuXG5cdC8vIEB0cy1pZ25vcmVcblx0aWYgKGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkgfHwgZWxlbWVudCA9PT0gd2luZG93IHx8IGVsZW1lbnQgPT09IGRvY3VtZW50KSB7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZXIpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ZvY3VzZWQoZWxlbWVudCwgc2V0KSB7XG5cdGxpc3RlbihlbGVtZW50LCBbJ2ZvY3VzJywgJ2JsdXInXSwgKCkgPT4ge1xuXHRcdHNldChlbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcblx0fSk7XG59XG4iLCAiaW1wb3J0IHsgZWZmZWN0LCByZW5kZXJfZWZmZWN0LCB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBsaXN0ZW4sIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vc2hhcmVkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gdHlwZVxuICogQHBhcmFtIHsoKSA9PiBudW1iZXJ9IGdldFxuICogQHBhcmFtIHsodmFsdWU6IG51bWJlcikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfd2luZG93X3Njcm9sbCh0eXBlLCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgaXNfc2Nyb2xsaW5nX3ggPSB0eXBlID09PSAneCc7XG5cblx0dmFyIHRhcmdldF9oYW5kbGVyID0gKCkgPT5cblx0XHR3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0c2Nyb2xsaW5nID0gdHJ1ZTtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFyLCAxMDApOyAvLyBUT0RPIHVzZSBzY3JvbGxlbmQgZXZlbnQgaWYgc3VwcG9ydGVkIChvciB3aGVuIHN1cHBvcnRlZCBldmVyeXdoZXJlPylcblxuXHRcdFx0c2V0KHdpbmRvd1tpc19zY3JvbGxpbmdfeCA/ICdzY3JvbGxYJyA6ICdzY3JvbGxZJ10pO1xuXHRcdH0pO1xuXG5cdGFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRhcmdldF9oYW5kbGVyLCB7XG5cdFx0cGFzc2l2ZTogdHJ1ZVxuXHR9KTtcblxuXHR2YXIgc2Nyb2xsaW5nID0gZmFsc2U7XG5cblx0LyoqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pn0gKi9cblx0dmFyIHRpbWVvdXQ7XG5cdHZhciBjbGVhciA9ICgpID0+IHtcblx0XHRzY3JvbGxpbmcgPSBmYWxzZTtcblx0fTtcblx0dmFyIGZpcnN0ID0gdHJ1ZTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgbGF0ZXN0X3ZhbHVlID0gZ2V0KCk7XG5cdFx0Ly8gRG9uJ3Qgc2Nyb2xsIHRvIHRoZSBpbml0aWFsIHZhbHVlIGZvciBhY2Nlc3NpYmlsaXR5IHJlYXNvbnNcblx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmICghc2Nyb2xsaW5nICYmIGxhdGVzdF92YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRzY3JvbGxpbmcgPSB0cnVlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdFx0aWYgKGlzX3Njcm9sbGluZ194KSB7XG5cdFx0XHRcdHNjcm9sbFRvKGxhdGVzdF92YWx1ZSwgd2luZG93LnNjcm9sbFkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2Nyb2xsVG8od2luZG93LnNjcm9sbFgsIGxhdGVzdF92YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhciwgMTAwKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIEJyb3dzZXJzIGRvbid0IGZpcmUgdGhlIHNjcm9sbCBldmVudCBmb3IgdGhlIGluaXRpYWwgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gc2Nyb2xsIHN0eWxlIGlzbid0IHNldCB0byBzbW9vdGhcblx0ZWZmZWN0KHRhcmdldF9oYW5kbGVyKTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGFyZ2V0X2hhbmRsZXIpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geydpbm5lcldpZHRoJyB8ICdpbm5lckhlaWdodCcgfCAnb3V0ZXJXaWR0aCcgfCAnb3V0ZXJIZWlnaHQnfSB0eXBlXG4gKiBAcGFyYW0geyhzaXplOiBudW1iZXIpID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF93aW5kb3dfc2l6ZSh0eXBlLCBzZXQpIHtcblx0bGlzdGVuKHdpbmRvdywgWydyZXNpemUnXSwgKCkgPT4gd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KCgpID0+IHNldCh3aW5kb3dbdHlwZV0pKSk7XG59XG4iLCAiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyB1c2VyX3ByZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgb24gfSBmcm9tICcuLi9lbGVtZW50cy9ldmVudHMuanMnO1xuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgdHJ1c3RlZGAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdGlmIChldmVudC5pc1RydXN0ZWQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBzZWxmYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBzdG9wUHJvcGFnYXRpb25gIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgb25jZWAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0dmFyIHJhbiA9IGZhbHNlO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdGlmIChyYW4pIHJldHVybjtcblx0XHRyYW4gPSB0cnVlO1xuXG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25gIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgcHJldmVudERlZmF1bHRgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHBhc3NpdmVgIGV2ZW50IG1vZGlmaWVyLCBpbXBsZW1lbnRlZCBhcyBhbiBhY3Rpb25cbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge1tldmVudDogc3RyaW5nLCBoYW5kbGVyOiAoKSA9PiBFdmVudExpc3RlbmVyXX0gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFzc2l2ZShub2RlLCBbZXZlbnQsIGhhbmRsZXJdKSB7XG5cdHVzZXJfcHJlX2VmZmVjdCgoKSA9PiB7XG5cdFx0cmV0dXJuIG9uKG5vZGUsIGV2ZW50LCBoYW5kbGVyKCkgPz8gbm9vcCwge1xuXHRcdFx0cGFzc2l2ZTogdHJ1ZVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYG5vbnBhc3NpdmVgIGV2ZW50IG1vZGlmaWVyLCBpbXBsZW1lbnRlZCBhcyBhbiBhY3Rpb25cbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge1tldmVudDogc3RyaW5nLCBoYW5kbGVyOiAoKSA9PiBFdmVudExpc3RlbmVyXX0gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ucGFzc2l2ZShub2RlLCBbZXZlbnQsIGhhbmRsZXJdKSB7XG5cdHVzZXJfcHJlX2VmZmVjdCgoKSA9PiB7XG5cdFx0cmV0dXJuIG9uKG5vZGUsIGV2ZW50LCBoYW5kbGVyKCkgPz8gbm9vcCwge1xuXHRcdFx0cGFzc2l2ZTogZmFsc2Vcblx0XHR9KTtcblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0TGVnYWN5IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJ1biwgcnVuX2FsbCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgZGVyaXZlZCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgdXNlcl9wcmVfZWZmZWN0LCB1c2VyX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBkZWVwX3JlYWRfc3RhdGUsIGdldCwgdW50cmFjayB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIExlZ2FjeS1tb2RlIG9ubHk6IENhbGwgYG9uTW91bnRgIGNhbGxiYWNrcyBhbmQgc2V0IHVwIGBiZWZvcmVVcGRhdGVgL2BhZnRlclVwZGF0ZWAgZWZmZWN0c1xuICogQHBhcmFtIHtib29sZWFufSBbaW1tdXRhYmxlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChpbW11dGFibGUgPSBmYWxzZSkge1xuXHRjb25zdCBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdGNvbnN0IGNhbGxiYWNrcyA9IGNvbnRleHQubC51O1xuXHRpZiAoIWNhbGxiYWNrcykgcmV0dXJuO1xuXG5cdGxldCBwcm9wcyA9ICgpID0+IGRlZXBfcmVhZF9zdGF0ZShjb250ZXh0LnMpO1xuXG5cdGlmIChpbW11dGFibGUpIHtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cdFx0bGV0IHByZXYgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovICh7fSk7XG5cblx0XHQvLyBJbiBsZWdhY3kgaW1tdXRhYmxlIG1vZGUsIGJlZm9yZS9hZnRlclVwZGF0ZSBvbmx5IGZpcmUgaWYgdGhlIG9iamVjdCBpZGVudGl0eSBvZiBhIHByb3AgY2hhbmdlc1xuXHRcdGNvbnN0IGQgPSBkZXJpdmVkKCgpID0+IHtcblx0XHRcdGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGNvbnRleHQucztcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG5cdFx0XHRcdGlmIChwcm9wc1trZXldICE9PSBwcmV2W2tleV0pIHtcblx0XHRcdFx0XHRwcmV2W2tleV0gPSBwcm9wc1trZXldO1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hhbmdlZCkgdmVyc2lvbisrO1xuXHRcdFx0cmV0dXJuIHZlcnNpb247XG5cdFx0fSk7XG5cblx0XHRwcm9wcyA9ICgpID0+IGdldChkKTtcblx0fVxuXG5cdC8vIGJlZm9yZVVwZGF0ZVxuXHRpZiAoY2FsbGJhY2tzLmIubGVuZ3RoKSB7XG5cdFx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKTtcblx0XHRcdHJ1bl9hbGwoY2FsbGJhY2tzLmIpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gb25Nb3VudCAobXVzdCBydW4gYmVmb3JlIGFmdGVyVXBkYXRlKVxuXHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3QgZm5zID0gdW50cmFjaygoKSA9PiBjYWxsYmFja3MubS5tYXAocnVuKSk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRmbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0Ly8gYWZ0ZXJVcGRhdGVcblx0aWYgKGNhbGxiYWNrcy5hLmxlbmd0aCkge1xuXHRcdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKTtcblx0XHRcdHJ1bl9hbGwoY2FsbGJhY2tzLmEpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogSW52b2tlIHRoZSBnZXR0ZXIgb2YgYWxsIHNpZ25hbHMgYXNzb2NpYXRlZCB3aXRoIGEgY29tcG9uZW50XG4gKiBzbyB0aGV5IGNhbiBiZSByZWdpc3RlcmVkIHRvIHRoZSBlZmZlY3QgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgaW4uXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRMZWdhY3l9IGNvbnRleHRcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBwcm9wc1xuICovXG5mdW5jdGlvbiBvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcykge1xuXHRpZiAoY29udGV4dC5sLnMpIHtcblx0XHRmb3IgKGNvbnN0IHNpZ25hbCBvZiBjb250ZXh0LmwucykgZ2V0KHNpZ25hbCk7XG5cdH1cblxuXHRwcm9wcygpO1xufVxuIiwgImltcG9ydCB7IHNldCwgc291cmNlIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIFVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgaW1wb3J0cyBtYXkgYmUgcmVhY3RpdmUgaW4gbGVnYWN5IG1vZGUuIEluIHRoYXQgY2FzZSxcbiAqIHRoZXkgc2hvdWxkIGJlIHVzaW5nIGByZWFjdGl2ZV9pbXBvcnRgIGFzIHBhcnQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWN0aXZlX2ltcG9ydChmbikge1xuXHR2YXIgcyA9IHNvdXJjZSgwKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRzZXQocywgZ2V0KHMpICsgMSk7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXQocyk7XG5cdFx0XHRyZXR1cm4gZm4oKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHRoaXMge2FueX1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICQkcHJvcHNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZV9ldmVudCgkJHByb3BzLCBldmVudCkge1xuXHR2YXIgZXZlbnRzID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbltdIHwgRnVuY3Rpb24+fSAqLyAoJCRwcm9wcy4kJGV2ZW50cyk/Lltcblx0XHRldmVudC50eXBlXG5cdF07XG5cblx0dmFyIGNhbGxiYWNrcyA9IGlzX2FycmF5KGV2ZW50cykgPyBldmVudHMuc2xpY2UoKSA6IGV2ZW50cyA9PSBudWxsID8gW10gOiBbZXZlbnRzXTtcblxuXHRmb3IgKHZhciBmbiBvZiBjYWxsYmFja3MpIHtcblx0XHQvLyBQcmVzZXJ2ZSBcInRoaXNcIiBjb250ZXh0XG5cdFx0Zm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH1cbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNpbXVsYXRlIGAkb25gIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIHdoZW4gYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpID09PSA0YFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRfY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9sZWdhY3lfZXZlbnRfbGlzdGVuZXIoJCRwcm9wcywgZXZlbnRfbmFtZSwgZXZlbnRfY2FsbGJhY2spIHtcblx0JCRwcm9wcy4kJGV2ZW50cyB8fD0ge307XG5cdCQkcHJvcHMuJCRldmVudHNbZXZlbnRfbmFtZV0gfHw9IFtdO1xuXHQkJHByb3BzLiQkZXZlbnRzW2V2ZW50X25hbWVdLnB1c2goZXZlbnRfY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFVzZWQgdG8gc2ltdWxhdGUgYCRzZXRgIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIHdoZW4gYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpID09PSA0YC5cbiAqIE5lZWRzIGNvbXBvbmVudCBhY2Nlc3NvcnMgc28gdGhhdCBpdCBjYW4gY2FsbCB0aGUgc2V0dGVyIG9mIHRoZSBwcm9wLiBUaGVyZWZvcmUgZG9lc24ndFxuICogd29yayBmb3IgdXBkYXRpbmcgcHJvcHMgaW4gYCQkcHJvcHNgIG9yIGAkJHJlc3RQcm9wc2AuXG4gKiBAdGhpcyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gJCRuZXdfcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9sZWdhY3lfcHJvcHMoJCRuZXdfcHJvcHMpIHtcblx0Zm9yICh2YXIga2V5IGluICQkbmV3X3Byb3BzKSB7XG5cdFx0aWYgKGtleSBpbiB0aGlzKSB7XG5cdFx0XHR0aGlzW2tleV0gPSAkJG5ld19wcm9wc1trZXldO1xuXHRcdH1cblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgUmVhZGFibGUsIFN0YXJ0U3RvcE5vdGlmaWVyLCBTdWJzY3JpYmVyLCBVbnN1YnNjcmliZXIsIFVwZGF0ZXIsIFdyaXRhYmxlIH0gZnJvbSAnLi4vcHVibGljLmpzJyAqL1xuLyoqIEBpbXBvcnQgeyBTdG9yZXMsIFN0b3Jlc1ZhbHVlcywgU3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlIH0gZnJvbSAnLi4vcHJpdmF0ZS5qcycgKi9cbmltcG9ydCB7IG5vb3AsIHJ1bl9hbGwgfSBmcm9tICcuLi8uLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgc2FmZV9ub3RfZXF1YWwgfSBmcm9tICcuLi8uLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgeyBzdWJzY3JpYmVfdG9fc3RvcmUgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQHR5cGUge0FycmF5PFN1YnNjcmliZUludmFsaWRhdGVUdXBsZTxhbnk+IHwgYW55Pn1cbiAqL1xuY29uc3Qgc3Vic2NyaWJlcl9xdWV1ZSA9IFtdO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtTdGFydFN0b3BOb3RpZmllcjxUPn0gW3N0YXJ0XVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGUodmFsdWUsIHN0YXJ0KSB7XG5cdHJldHVybiB7XG5cdFx0c3Vic2NyaWJlOiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQpLnN1YnNjcmliZVxuXHR9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBXcml0YWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgYm90aCB1cGRhdGluZyBhbmQgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7V3JpdGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7XG5cdC8qKiBAdHlwZSB7VW5zdWJzY3JpYmVyIHwgbnVsbH0gKi9cblx0bGV0IHN0b3AgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7U2V0PFN1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPj59ICovXG5cdGNvbnN0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R9IG5ld192YWx1ZVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHNldChuZXdfdmFsdWUpIHtcblx0XHRpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0aWYgKHN0b3ApIHtcblx0XHRcdFx0Ly8gc3RvcmUgaXMgcmVhZHlcblx0XHRcdFx0Y29uc3QgcnVuX3F1ZXVlID0gIXN1YnNjcmliZXJfcXVldWUubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHN1YnNjcmliZXIgb2Ygc3Vic2NyaWJlcnMpIHtcblx0XHRcdFx0XHRzdWJzY3JpYmVyWzFdKCk7XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHN1YnNjcmliZXIsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVuX3F1ZXVlKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlW2ldWzBdKHN1YnNjcmliZXJfcXVldWVbaSArIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBkYXRlcjxUPn0gZm5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGUoZm4pIHtcblx0XHRzZXQoZm4oLyoqIEB0eXBlIHtUfSAqLyAodmFsdWUpKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTdWJzY3JpYmVyPFQ+fSBydW5cblx0ICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbaW52YWxpZGF0ZV1cblx0ICogQHJldHVybnMge1Vuc3Vic2NyaWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShydW4sIGludmFsaWRhdGUgPSBub29wKSB7XG5cdFx0LyoqIEB0eXBlIHtTdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGU8VD59ICovXG5cdFx0Y29uc3Qgc3Vic2NyaWJlciA9IFtydW4sIGludmFsaWRhdGVdO1xuXHRcdHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcblx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMSkge1xuXHRcdFx0c3RvcCA9IHN0YXJ0KHNldCwgdXBkYXRlKSB8fCBub29wO1xuXHRcdH1cblx0XHRydW4oLyoqIEB0eXBlIHtUfSAqLyAodmFsdWUpKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0c3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXHRcdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDAgJiYgc3RvcCkge1xuXHRcdFx0XHRzdG9wKCk7XG5cdFx0XHRcdHN0b3AgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0cmV0dXJuIHsgc2V0LCB1cGRhdGUsIHN1YnNjcmliZSB9O1xufVxuXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFN0b3Jlc1ZhbHVlczxTPiwgc2V0OiAodmFsdWU6IFQpID0+IHZvaWQsIHVwZGF0ZTogKGZuOiBVcGRhdGVyPFQ+KSA9PiB2b2lkKSA9PiBVbnN1YnNjcmliZXIgfCB2b2lkfSBmblxuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV1cbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuLyoqXG4gKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxuICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7U3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHsodmFsdWVzOiBTdG9yZXNWYWx1ZXM8Uz4pID0+IFR9IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG4vKipcbiAqIEB0ZW1wbGF0ZSB7U3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChzdG9yZXMsIGZuLCBpbml0aWFsX3ZhbHVlKSB7XG5cdGNvbnN0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG5cdC8qKiBAdHlwZSB7QXJyYXk8UmVhZGFibGU8YW55Pj59ICovXG5cdGNvbnN0IHN0b3Jlc19hcnJheSA9IHNpbmdsZSA/IFtzdG9yZXNdIDogc3RvcmVzO1xuXHRpZiAoIXN0b3Jlc19hcnJheS5ldmVyeShCb29sZWFuKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZGVyaXZlZCgpIGV4cGVjdHMgc3RvcmVzIGFzIGlucHV0LCBnb3QgYSBmYWxzeSB2YWx1ZScpO1xuXHR9XG5cdGNvbnN0IGF1dG8gPSBmbi5sZW5ndGggPCAyO1xuXHRyZXR1cm4gcmVhZGFibGUoaW5pdGlhbF92YWx1ZSwgKHNldCwgdXBkYXRlKSA9PiB7XG5cdFx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHQvKiogQHR5cGUge1RbXX0gKi9cblx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRsZXQgcGVuZGluZyA9IDA7XG5cdFx0bGV0IGNsZWFudXAgPSBub29wO1xuXHRcdGNvbnN0IHN5bmMgPSAoKSA9PiB7XG5cdFx0XHRpZiAocGVuZGluZykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBmbihzaW5nbGUgPyB2YWx1ZXNbMF0gOiB2YWx1ZXMsIHNldCwgdXBkYXRlKTtcblx0XHRcdGlmIChhdXRvKSB7XG5cdFx0XHRcdHNldChyZXN1bHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xlYW51cCA9IHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicgPyByZXN1bHQgOiBub29wO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgdW5zdWJzY3JpYmVycyA9IHN0b3Jlc19hcnJheS5tYXAoKHN0b3JlLCBpKSA9PlxuXHRcdFx0c3Vic2NyaWJlX3RvX3N0b3JlKFxuXHRcdFx0XHRzdG9yZSxcblx0XHRcdFx0KHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dmFsdWVzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0cGVuZGluZyAmPSB+KDEgPDwgaSk7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0ZWQpIHtcblx0XHRcdFx0XHRcdHN5bmMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCgpID0+IHtcblx0XHRcdFx0XHRwZW5kaW5nIHw9IDEgPDwgaTtcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdCk7XG5cdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0c3luYygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuXHRcdFx0cnVuX2FsbCh1bnN1YnNjcmliZXJzKTtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdC8vIFdlIG5lZWQgdG8gc2V0IHRoaXMgdG8gZmFsc2UgYmVjYXVzZSBjYWxsYmFja3MgY2FuIHN0aWxsIGhhcHBlbiBkZXNwaXRlIGhhdmluZyB1bnN1YnNjcmliZWQ6XG5cdFx0XHQvLyBDYWxsYmFja3MgbWlnaHQgYWxyZWFkeSBiZSBwbGFjZWQgaW4gdGhlIHF1ZXVlIHdoaWNoIGRvZXNuJ3Qga25vdyBpdCBzaG91bGQgbm8gbG9uZ2VyXG5cdFx0XHQvLyBpbnZva2UgdGhpcyBkZXJpdmVkIHN0b3JlLlxuXHRcdFx0c3RhcnRlZCA9IGZhbHNlO1xuXHRcdH07XG5cdH0pO1xufVxuXG4vKipcbiAqIFRha2VzIGEgc3RvcmUgYW5kIHJldHVybnMgYSBuZXcgb25lIGRlcml2ZWQgZnJvbSB0aGUgb2xkIG9uZSB0aGF0IGlzIHJlYWRhYmxlLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlPFQ+fSBzdG9yZSAgLSBzdG9yZSB0byBtYWtlIHJlYWRvbmx5XG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkb25seShzdG9yZSkge1xuXHRyZXR1cm4ge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBpIHN1c3BlY3QgdGhlIGJpbmQgaXMgdW5uZWNlc3Nhcnlcblx0XHRzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZS5iaW5kKHN0b3JlKVxuXHR9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIGEgc3RvcmUgYnkgc3Vic2NyaWJpbmcgYW5kIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJpbmcuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UmVhZGFibGU8VD59IHN0b3JlXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzdG9yZSkge1xuXHRsZXQgdmFsdWU7XG5cdHN1YnNjcmliZV90b19zdG9yZShzdG9yZSwgKF8pID0+ICh2YWx1ZSA9IF8pKSgpO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiB2YWx1ZTtcbn1cbiIsICIvKiogQGltcG9ydCB7IFN0b3JlUmVmZXJlbmNlc0NvbnRhaW5lciB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IFN0b3JlIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IHN1YnNjcmliZV90b19zdG9yZSB9IGZyb20gJy4uLy4uLy4uL3N0b3JlL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldCBhcyBnZXRfc3RvcmUgfSBmcm9tICcuLi8uLi8uLi9zdG9yZS9zaGFyZWQvaW5kZXguanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBub29wIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbXV0YWJsZV9zb3VyY2UsIHNldCB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvcCBjdXJyZW50bHkgYmVpbmcgcmVhZCBpcyBhIHN0b3JlIGJpbmRpbmcsIGFzIGluXG4gKiBgPENoaWxkIGJpbmQ6eD17JHl9IC8+YC4gSWYgaXQgaXMsIHdlIHRyZWF0IHRoZSBwcm9wIGFzIG11dGFibGUgZXZlbiBpblxuICogcnVuZXMgbW9kZSwgYW5kIHNraXAgYGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCB2YWxpZGF0aW9uXG4gKi9cbmxldCBpc19zdG9yZV9iaW5kaW5nID0gZmFsc2U7XG5cbmxldCBJU19VTk1PVU5URUQgPSBTeW1ib2woKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgc3RvcmUuIElmIHRoZSBzdG9yZSBpc24ndCBzdWJzY3JpYmVkIHRvIHlldCwgaXQgd2lsbCBjcmVhdGUgYSBwcm94eVxuICogc2lnbmFsIHRoYXQgd2lsbCBiZSB1cGRhdGVkIHdoZW4gdGhlIHN0b3JlIGlzLiBUaGUgc3RvcmUgcmVmZXJlbmNlcyBjb250YWluZXIgaXMgbmVlZGVkIHRvXG4gKiB0cmFjayByZWFzc2lnbm1lbnRzIHRvIHN0b3JlcyBhbmQgdG8gdHJhY2sgdGhlIGNvcnJlY3QgY29tcG9uZW50IGNvbnRleHQuXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTdG9yZTxWPiB8IG51bGwgfCB1bmRlZmluZWR9IHN0b3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICogQHBhcmFtIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9IHN0b3Jlc1xuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9nZXQoc3RvcmUsIHN0b3JlX25hbWUsIHN0b3Jlcykge1xuXHRjb25zdCBlbnRyeSA9IChzdG9yZXNbc3RvcmVfbmFtZV0gPz89IHtcblx0XHRzdG9yZTogbnVsbCxcblx0XHRzb3VyY2U6IG11dGFibGVfc291cmNlKHVuZGVmaW5lZCksXG5cdFx0dW5zdWJzY3JpYmU6IG5vb3Bcblx0fSk7XG5cblx0aWYgKERFVikge1xuXHRcdGVudHJ5LnNvdXJjZS5sYWJlbCA9IHN0b3JlX25hbWU7XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IHRoYXQgc2V0dXAgdGhpcyBpcyBhbHJlYWR5IHVubW91bnRlZCB3ZSBkb24ndCB3YW50IHRvIHJlZ2lzdGVyIGEgc3Vic2NyaXB0aW9uXG5cdGlmIChlbnRyeS5zdG9yZSAhPT0gc3RvcmUgJiYgIShJU19VTk1PVU5URUQgaW4gc3RvcmVzKSkge1xuXHRcdGVudHJ5LnVuc3Vic2NyaWJlKCk7XG5cdFx0ZW50cnkuc3RvcmUgPSBzdG9yZSA/PyBudWxsO1xuXG5cdFx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHRcdGVudHJ5LnNvdXJjZS52ID0gdW5kZWZpbmVkOyAvLyBzZWUgc3luY2hyb25vdXMgY2FsbGJhY2sgY29tbWVudCBiZWxvd1xuXHRcdFx0ZW50cnkudW5zdWJzY3JpYmUgPSBub29wO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaXNfc3luY2hyb25vdXNfY2FsbGJhY2sgPSB0cnVlO1xuXG5cdFx0XHRlbnRyeS51bnN1YnNjcmliZSA9IHN1YnNjcmliZV90b19zdG9yZShzdG9yZSwgKHYpID0+IHtcblx0XHRcdFx0aWYgKGlzX3N5bmNocm9ub3VzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGZpcnN0IHVwZGF0ZXMgdG8gdGhlIHN0b3JlIHZhbHVlIChwb3NzaWJseSBtdWx0aXBsZSBvZiB0aGVtKSBhcmUgc3luY2hyb25vdXNseVxuXHRcdFx0XHRcdC8vIGluc2lkZSBhIGRlcml2ZWQsIHdlIHdpbGwgaGl0IHRoZSBgc3RhdGVfdW5zYWZlX211dGF0aW9uYCBlcnJvciBpZiB3ZSBgc2V0YCB0aGUgdmFsdWVcblx0XHRcdFx0XHRlbnRyeS5zb3VyY2UudiA9IHY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2V0KGVudHJ5LnNvdXJjZSwgdik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpc19zeW5jaHJvbm91c19jYWxsYmFjayA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgdGhhdCBzZXR1cCB0aGlzIHN0b3JlcyBpcyBhbHJlYWR5IHVubW91bnRlZCB0aGUgc291cmNlIHdpbGwgYmUgb3V0IG9mIHN5bmNcblx0Ly8gc28gd2UganVzdCB1c2UgdGhlIGBnZXRgIGZvciB0aGUgc3RvcmVzLCBsZXNzIHBlcmZvcm1hbnQgYnV0IGl0IGF2b2lkcyB0byBjcmVhdGUgYSBtZW1vcnkgbGVha1xuXHQvLyBhbmQgaXQgd2lsbCBrZWVwIHRoZSB2YWx1ZSBjb25zaXN0ZW50XG5cdGlmIChzdG9yZSAmJiBJU19VTk1PVU5URUQgaW4gc3RvcmVzKSB7XG5cdFx0cmV0dXJuIGdldF9zdG9yZShzdG9yZSk7XG5cdH1cblxuXHRyZXR1cm4gZ2V0KGVudHJ5LnNvdXJjZSk7XG59XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGlmIGl0J3Mgbm90IHRoZSBzYW1lIGFzIHRoZSBvbmUgaW4gdGhlIHN0b3JlIHJlZmVyZW5jZXMgY29udGFpbmVyLlxuICogV2UgbmVlZCB0aGlzIGluIGFkZGl0aW9uIHRvIGBzdG9yZV9nZXRgIGJlY2F1c2Ugc29tZW9uZSBjb3VsZCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgYnV0XG4gKiB0aGVuIG5ldmVyIHN1YnNjcmliZSB0byB0aGUgbmV3IG9uZSAoaWYgYW55KSwgY2F1c2luZyB0aGUgc3Vic2NyaXB0aW9uIHRvIHN0YXkgb3BlbiB3cm9uZ2Z1bGx5LlxuICogQHBhcmFtIHtTdG9yZTxhbnk+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV91bnN1YihzdG9yZSwgc3RvcmVfbmFtZSwgc3RvcmVzKSB7XG5cdC8qKiBAdHlwZSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyWycnXSB8IHVuZGVmaW5lZH0gKi9cblx0bGV0IGVudHJ5ID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXG5cdGlmIChlbnRyeSAmJiBlbnRyeS5zdG9yZSAhPT0gc3RvcmUpIHtcblx0XHQvLyBEb24ndCByZXNldCBzdG9yZSB5ZXQsIHNvIHRoYXQgc3RvcmVfZ2V0IGFib3ZlIGNhbiByZXN1YnNjcmliZSB0byBuZXcgc3RvcmUgaWYgbmVjZXNzYXJ5XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUoKTtcblx0XHRlbnRyeS51bnN1YnNjcmliZSA9IG5vb3A7XG5cdH1cblxuXHRyZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbmV3IHZhbHVlIG9mIGEgc3RvcmUgYW5kIHJldHVybnMgdGhhdCB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1N0b3JlPFY+fSBzdG9yZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9zZXQoc3RvcmUsIHZhbHVlKSB7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZV9zdG9yZShzdG9yZXMsIHN0b3JlX25hbWUpIHtcblx0dmFyIGVudHJ5ID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXHRpZiAoZW50cnkuc3RvcmUgIT09IG51bGwpIHtcblx0XHRzdG9yZV9zZXQoZW50cnkuc3RvcmUsIGVudHJ5LnNvdXJjZS52KTtcblx0fVxufVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlcyBmcm9tIGFsbCBhdXRvLXN1YnNjcmliZWQgc3RvcmVzIG9uIGRlc3Ryb3lcbiAqIEByZXR1cm5zIHtbU3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyLCAoKT0+dm9pZF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cF9zdG9yZXMoKSB7XG5cdC8qKiBAdHlwZSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSAqL1xuXHRjb25zdCBzdG9yZXMgPSB7fTtcblxuXHRmdW5jdGlvbiBjbGVhbnVwKCkge1xuXHRcdHRlYXJkb3duKCgpID0+IHtcblx0XHRcdGZvciAodmFyIHN0b3JlX25hbWUgaW4gc3RvcmVzKSB7XG5cdFx0XHRcdGNvbnN0IHJlZiA9IHN0b3Jlc1tzdG9yZV9uYW1lXTtcblx0XHRcdFx0cmVmLnVuc3Vic2NyaWJlKCk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVfcHJvcGVydHkoc3RvcmVzLCBJU19VTk1PVU5URUQsIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdHZhbHVlOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBbc3RvcmVzLCBjbGVhbnVwXTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgc3RvcmUgd2l0aCBhIG5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RvcmU8Vj59IHN0b3JlICB0aGUgc3RvcmUgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gZXhwcmVzc2lvbiAgdGhlIGV4cHJlc3Npb24gdGhhdCBtdXRhdGVzIHRoZSBzdG9yZVxuICogQHBhcmFtIHtWfSBuZXdfdmFsdWUgIHRoZSBuZXcgc3RvcmUgdmFsdWVcbiAqIEB0ZW1wbGF0ZSBWXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9tdXRhdGUoc3RvcmUsIGV4cHJlc3Npb24sIG5ld192YWx1ZSkge1xuXHRzdG9yZS5zZXQobmV3X3ZhbHVlKTtcblx0cmV0dXJuIGV4cHJlc3Npb247XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdG9yZTxudW1iZXI+fSBzdG9yZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0b3JlX3ZhbHVlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3N0b3JlKHN0b3JlLCBzdG9yZV92YWx1ZSwgZCA9IDEpIHtcblx0c3RvcmUuc2V0KHN0b3JlX3ZhbHVlICsgZCk7XG5cdHJldHVybiBzdG9yZV92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlPG51bWJlcj59IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RvcmVfdmFsdWVcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlX3N0b3JlKHN0b3JlLCBzdG9yZV92YWx1ZSwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBzdG9yZV92YWx1ZSArIGQ7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgaW5zaWRlIHByb3AgZ2V0dGVycyB0byBjb21tdW5pY2F0ZSB0aGF0IHRoZSBwcm9wIGlzIGEgc3RvcmUgYmluZGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya19zdG9yZV9iaW5kaW5nKCkge1xuXHRpc19zdG9yZV9iaW5kaW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdHVwbGUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBgZm4oKWAgcmVhZHMgYSBwcm9wIHRoYXQgaXMgYSBzdG9yZSBiaW5kaW5nLlxuICogVXNlZCB0byBwcmV2ZW50IGBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWAgdmFsaWRhdGlvbiBmYWxzZSBwb3NpdGl2ZXMgYW5kXG4gKiBlbnN1cmUgdGhhdCB0aGVzZSBwcm9wcyBhcmUgdHJlYXRlZCBhcyBtdXRhYmxlIGV2ZW4gaW4gcnVuZXMgbW9kZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqIEByZXR1cm5zIHtbVCwgYm9vbGVhbl19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlX3N0b3JlX2JpbmRpbmcoZm4pIHtcblx0dmFyIHByZXZpb3VzX2lzX3N0b3JlX2JpbmRpbmcgPSBpc19zdG9yZV9iaW5kaW5nO1xuXG5cdHRyeSB7XG5cdFx0aXNfc3RvcmVfYmluZGluZyA9IGZhbHNlO1xuXHRcdHJldHVybiBbZm4oKSwgaXNfc3RvcmVfYmluZGluZ107XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfc3RvcmVfYmluZGluZyA9IHByZXZpb3VzX2lzX3N0b3JlX2JpbmRpbmc7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgU291cmNlIH0gZnJvbSAnLi90eXBlcy5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0UFJPUFNfSVNfQklOREFCTEUsXG5cdFBST1BTX0lTX0lNTVVUQUJMRSxcblx0UFJPUFNfSVNfTEFaWV9JTklUSUFMLFxuXHRQUk9QU19JU19SVU5FUyxcblx0UFJPUFNfSVNfVVBEQVRFRFxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHNldCwgc291cmNlLCB1cGRhdGUgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZGVyaXZlZCwgZGVyaXZlZF9zYWZlX2VxdWFsIH0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRnZXQsXG5cdGlzX2Rlc3Ryb3lpbmdfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0dW50cmFja1xufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFU1RST1lFRCwgTEVHQUNZX1BST1BTLCBTVEFURV9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBwcm94eSB9IGZyb20gJy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IGNhcHR1cmVfc3RvcmVfYmluZGluZyB9IGZyb20gJy4vc3RvcmUuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0geygodmFsdWU/OiBudW1iZXIpID0+IG51bWJlcil9IGZuXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Byb3AoZm4sIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gZm4oKTtcblx0Zm4odmFsdWUgKyBkKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCh2YWx1ZT86IG51bWJlcikgPT4gbnVtYmVyKX0gZm5cbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlX3Byb3AoZm4sIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gZm4oKSArIGQ7XG5cdGZuKHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciByZXN0IHByb3BzIChpLmUuIGBjb25zdCB7IHgsIC4uLnJlc3QgfSA9ICRwcm9wcygpYCkuXG4gKiBJcyBwYXNzZWQgdGhlIGZ1bGwgYCQkcHJvcHNgIG9iamVjdCBhbmQgZXhjbHVkZXMgdGhlIG5hbWVkIHByb3BzLlxuICogQHR5cGUge1Byb3h5SGFuZGxlcjx7IHByb3BzOiBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPiwgZXhjbHVkZTogQXJyYXk8c3RyaW5nIHwgc3ltYm9sPiwgbmFtZT86IHN0cmluZyB9Pn19XG4gKi9cbmNvbnN0IHJlc3RfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRyZXR1cm4gdGFyZ2V0LnByb3BzW2tleV07XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5wcm9wc19yZXN0X3JlYWRvbmx5KGAke3RhcmdldC5uYW1lfS4ke1N0cmluZyhrZXkpfWApO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRpZiAoa2V5IGluIHRhcmdldC5wcm9wcykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdGFyZ2V0LnByb3BzW2tleV1cblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnByb3BzO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnByb3BzKS5maWx0ZXIoKGtleSkgPT4gIXRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGNsdWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RfcHJvcHMocHJvcHMsIGV4Y2x1ZGUsIG5hbWUpIHtcblx0cmV0dXJuIG5ldyBQcm94eShcblx0XHRERVYgPyB7IHByb3BzLCBleGNsdWRlLCBuYW1lLCBvdGhlcjoge30sIHRvX3Byb3h5OiBbXSB9IDogeyBwcm9wcywgZXhjbHVkZSB9LFxuXHRcdHJlc3RfcHJvcHNfaGFuZGxlclxuXHQpO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciBsZWdhY3kgJCRyZXN0UHJvcHMgYW5kICQkcHJvcHNcbiAqIEB0eXBlIHtQcm94eUhhbmRsZXI8eyBwcm9wczogUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4sIGV4Y2x1ZGU6IEFycmF5PHN0cmluZyB8IHN5bWJvbD4sIHNwZWNpYWw6IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsICh2PzogdW5rbm93bikgPT4gdW5rbm93bj4sIHZlcnNpb246IFNvdXJjZTxudW1iZXI+LCBwYXJlbnRfZWZmZWN0OiBFZmZlY3QgfT59fVxuICovXG5jb25zdCBsZWdhY3lfcmVzdF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGdldCh0YXJnZXQudmVyc2lvbik7XG5cdFx0cmV0dXJuIGtleSBpbiB0YXJnZXQuc3BlY2lhbCA/IHRhcmdldC5zcGVjaWFsW2tleV0oKSA6IHRhcmdldC5wcm9wc1trZXldO1xuXHR9LFxuXHRzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG5cdFx0aWYgKCEoa2V5IGluIHRhcmdldC5zcGVjaWFsKSkge1xuXHRcdFx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHRhcmdldC5wYXJlbnRfZWZmZWN0KTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgcHJvcHMgdGhhdCBjYW4gdGVtcG9yYXJpbHkgZ2V0IG91dCBvZiBzeW5jIHdpdGggdGhlIHBhcmVudFxuXHRcdFx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsICh2PzogdW5rbm93bikgPT4gdW5rbm93bj59ICovXG5cdFx0XHRcdHRhcmdldC5zcGVjaWFsW2tleV0gPSBwcm9wKFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGdldCBba2V5XSgpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRhcmdldC5wcm9wc1trZXldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtzdHJpbmd9ICovIChrZXkpLFxuXHRcdFx0XHRcdFBST1BTX0lTX1VQREFURURcblx0XHRcdFx0KTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGFyZ2V0LnNwZWNpYWxba2V5XSh2YWx1ZSk7XG5cdFx0dXBkYXRlKHRhcmdldC52ZXJzaW9uKTsgLy8gJCRwcm9wcyBpcyBjb2Fyc2UtZ3JhaW5lZDogd2hlbiAkJHByb3BzLnggaXMgdXBkYXRlZCwgdXNhZ2VzIG9mICQkcHJvcHMueSBldGMgYXJlIGFsc28gcmVydW5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRpZiAoa2V5IGluIHRhcmdldC5wcm9wcykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdGFyZ2V0LnByb3BzW2tleV1cblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuXHRcdC8vIFN2ZWx0ZSA0IGFsbG93ZWQgZm9yIGRlbGV0aW9ucyBvbiAkJHJlc3RQcm9wc1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm4gdHJ1ZTtcblx0XHR0YXJnZXQuZXhjbHVkZS5wdXNoKGtleSk7XG5cdFx0dXBkYXRlKHRhcmdldC52ZXJzaW9uKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0aGFzKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4ga2V5IGluIHRhcmdldC5wcm9wcztcblx0fSxcblx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRyZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldC5wcm9wcykuZmlsdGVyKChrZXkpID0+ICF0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKTtcblx0fVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gZXhjbHVkZVxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHVua25vd24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3Jlc3RfcHJvcHMocHJvcHMsIGV4Y2x1ZGUpIHtcblx0cmV0dXJuIG5ldyBQcm94eShcblx0XHR7XG5cdFx0XHRwcm9wcyxcblx0XHRcdGV4Y2x1ZGUsXG5cdFx0XHRzcGVjaWFsOiB7fSxcblx0XHRcdHZlcnNpb246IHNvdXJjZSgwKSxcblx0XHRcdC8vIFRPRE8gdGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gdHJhY2sgY29tcG9uZW50XG5cdFx0XHQvLyBkZXN0cnVjdGlvbiBpbnNpZGUgYHByb3BgLCBiZWNhdXNlIG9mIGBiaW5kOnRoaXNgLCBidXQgaXRcblx0XHRcdC8vIHNlZW1zIGxpa2VseSB0aGF0IHdlIGNhbiBzaW1wbGlmeSBgYmluZDp0aGlzYCBpbnN0ZWFkXG5cdFx0XHRwYXJlbnRfZWZmZWN0OiAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpXG5cdFx0fSxcblx0XHRsZWdhY3lfcmVzdF9wcm9wc19oYW5kbGVyXG5cdCk7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIHNwcmVhZCBwcm9wcy4gSGFuZGxlcyB0aGUgaW5jb21pbmcgYXJyYXkgb2YgcHJvcHNcbiAqIHRoYXQgbG9va3MgbGlrZSBgKCkgPT4geyBkeW5hbWljOiBwcm9wcyB9LCB7IHN0YXRpYzogcHJvcCB9LCAuLmAgYW5kIHdyYXBzXG4gKiB0aGVtIHNvIHRoYXQgdGhlIHdob2xlIHRoaW5nIGlzIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGFzIHRoZSBgJCRwcm9wc2AgYXJndW1lbnQuXG4gKiBAdHlwZSB7UHJveHlIYW5kbGVyPHsgcHJvcHM6IEFycmF5PFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+IHwgKCgpID0+IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+KT4gfT59fVxuICovXG5jb25zdCBzcHJlYWRfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0bGV0IGkgPSB0YXJnZXQucHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGxldCBwID0gdGFyZ2V0LnByb3BzW2ldO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiBwICE9PSBudWxsICYmIGtleSBpbiBwKSByZXR1cm4gcFtrZXldO1xuXHRcdH1cblx0fSxcblx0c2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuXHRcdGxldCBpID0gdGFyZ2V0LnByb3BzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRsZXQgcCA9IHRhcmdldC5wcm9wc1tpXTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGNvbnN0IGRlc2MgPSBnZXRfZGVzY3JpcHRvcihwLCBrZXkpO1xuXHRcdFx0aWYgKGRlc2MgJiYgZGVzYy5zZXQpIHtcblx0XHRcdFx0ZGVzYy5zZXQodmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRsZXQgaSA9IHRhcmdldC5wcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bGV0IHAgPSB0YXJnZXQucHJvcHNbaV07XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAodHlwZW9mIHAgPT09ICdvYmplY3QnICYmIHAgIT09IG51bGwgJiYga2V5IGluIHApIHtcblx0XHRcdFx0Y29uc3QgZGVzY3JpcHRvciA9IGdldF9kZXNjcmlwdG9yKHAsIGtleSk7XG5cdFx0XHRcdGlmIChkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRcdC8vIFByZXZlbnQgYSBcIk5vbi1jb25maWd1cmFiaWxpdHkgUmVwb3J0IEVycm9yXCI6IFRoZSB0YXJnZXQgaXMgYW4gYXJyYXksIGl0IGRvZXNcblx0XHRcdFx0XHQvLyBub3QgYWN0dWFsbHkgY29udGFpbiB0aGlzIHByb3BlcnR5LiBJZiBpdCBpcyBub3cgZGVzY3JpYmVkIGFzIG5vbi1jb25maWd1cmFibGUsXG5cdFx0XHRcdFx0Ly8gdGhlIHByb3h5IHRocm93cyBhIHZhbGlkYXRpb24gZXJyb3IuIFNldHRpbmcgaXQgdG8gdHJ1ZSBhdm9pZHMgdGhhdC5cblx0XHRcdFx0XHRkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHQvLyBUbyBwcmV2ZW50IGEgZmFsc2UgcG9zaXRpdmUgYGlzX2VudHJ5X3Byb3BzYCBpbiB0aGUgYHByb3BgIGZ1bmN0aW9uXG5cdFx0aWYgKGtleSA9PT0gU1RBVEVfU1lNQk9MIHx8IGtleSA9PT0gTEVHQUNZX1BST1BTKSByZXR1cm4gZmFsc2U7XG5cblx0XHRmb3IgKGxldCBwIG9mIHRhcmdldC5wcm9wcykge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKHAgIT0gbnVsbCAmJiBrZXkgaW4gcCkgcmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nIHwgc3ltYm9sPn0gKi9cblx0XHRjb25zdCBrZXlzID0gW107XG5cblx0XHRmb3IgKGxldCBwIG9mIHRhcmdldC5wcm9wcykge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKCFwKSBjb250aW51ZTtcblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gcCkge1xuXHRcdFx0XHRpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkga2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocCkpIHtcblx0XHRcdFx0aWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIGtleXMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBrZXlzO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCAoKCkgPT4gUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPn0gcHJvcHNcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWRfcHJvcHMoLi4ucHJvcHMpIHtcblx0cmV0dXJuIG5ldyBQcm94eSh7IHByb3BzIH0sIHNwcmVhZF9wcm9wc19oYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBzeW5jaHJvbml6aW5nIGEgcG9zc2libHkgYm91bmQgcHJvcCB3aXRoIHRoZSBpbm5lciBjb21wb25lbnQgc3RhdGUuXG4gKiBJdCBpcyB1c2VkIHdoZW5ldmVyIHRoZSBjb21waWxlciBzZWVzIHRoYXQgdGhlIGNvbXBvbmVudCB3cml0ZXMgdG8gdGhlIHByb3AsIG9yIHdoZW4gaXQgaGFzIGEgZGVmYXVsdCBwcm9wX3ZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7ViB8ICgoKSA9PiBWKX0gW2ZhbGxiYWNrXVxuICogQHJldHVybnMgeygoKSA9PiBWIHwgKChhcmc6IFYpID0+IFYpIHwgKChhcmc6IFYsIG11dGF0aW9uOiBib29sZWFuKSA9PiBWKSl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wKHByb3BzLCBrZXksIGZsYWdzLCBmYWxsYmFjaykge1xuXHR2YXIgcnVuZXMgPSAhbGVnYWN5X21vZGVfZmxhZyB8fCAoZmxhZ3MgJiBQUk9QU19JU19SVU5FUykgIT09IDA7XG5cdHZhciBiaW5kYWJsZSA9IChmbGFncyAmIFBST1BTX0lTX0JJTkRBQkxFKSAhPT0gMDtcblx0dmFyIGxhenkgPSAoZmxhZ3MgJiBQUk9QU19JU19MQVpZX0lOSVRJQUwpICE9PSAwO1xuXG5cdHZhciBmYWxsYmFja192YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKGZhbGxiYWNrKTtcblx0dmFyIGZhbGxiYWNrX2RpcnR5ID0gdHJ1ZTtcblxuXHR2YXIgZ2V0X2ZhbGxiYWNrID0gKCkgPT4ge1xuXHRcdGlmIChmYWxsYmFja19kaXJ0eSkge1xuXHRcdFx0ZmFsbGJhY2tfZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0ZmFsbGJhY2tfdmFsdWUgPSBsYXp5XG5cdFx0XHRcdD8gdW50cmFjaygvKiogQHR5cGUgeygpID0+IFZ9ICovIChmYWxsYmFjaykpXG5cdFx0XHRcdDogLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxsYmFja192YWx1ZTtcblx0fTtcblxuXHQvKiogQHR5cGUgeygodjogVikgPT4gdm9pZCkgfCB1bmRlZmluZWR9ICovXG5cdHZhciBzZXR0ZXI7XG5cblx0aWYgKGJpbmRhYmxlKSB7XG5cdFx0Ly8gQ2FuIGJlIHRoZSBjYXNlIHdoZW4gc29tZW9uZSBkb2VzIGBtb3VudChDb21wb25lbnQsIHByb3BzKWAgd2l0aCBgbGV0IHByb3BzID0gJHN0YXRlKHsuLi59KWBcblx0XHQvLyBvciBgY3JlYXRlQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50LCBwcm9wcylgXG5cdFx0dmFyIGlzX2VudHJ5X3Byb3BzID0gU1RBVEVfU1lNQk9MIGluIHByb3BzIHx8IExFR0FDWV9QUk9QUyBpbiBwcm9wcztcblxuXHRcdHNldHRlciA9XG5cdFx0XHRnZXRfZGVzY3JpcHRvcihwcm9wcywga2V5KT8uc2V0ID8/XG5cdFx0XHQoaXNfZW50cnlfcHJvcHMgJiYga2V5IGluIHByb3BzID8gKHYpID0+IChwcm9wc1trZXldID0gdikgOiB1bmRlZmluZWQpO1xuXHR9XG5cblx0dmFyIGluaXRpYWxfdmFsdWU7XG5cdHZhciBpc19zdG9yZV9zdWIgPSBmYWxzZTtcblxuXHRpZiAoYmluZGFibGUpIHtcblx0XHRbaW5pdGlhbF92YWx1ZSwgaXNfc3RvcmVfc3ViXSA9IGNhcHR1cmVfc3RvcmVfYmluZGluZygoKSA9PiAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKSk7XG5cdH0gZWxzZSB7XG5cdFx0aW5pdGlhbF92YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHByb3BzW2tleV0pO1xuXHR9XG5cblx0aWYgKGluaXRpYWxfdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBmYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aW5pdGlhbF92YWx1ZSA9IGdldF9mYWxsYmFjaygpO1xuXG5cdFx0aWYgKHNldHRlcikge1xuXHRcdFx0aWYgKHJ1bmVzKSBlLnByb3BzX2ludmFsaWRfdmFsdWUoa2V5KTtcblx0XHRcdHNldHRlcihpbml0aWFsX3ZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHQvKiogQHR5cGUgeygpID0+IFZ9ICovXG5cdHZhciBnZXR0ZXI7XG5cblx0aWYgKHJ1bmVzKSB7XG5cdFx0Z2V0dGVyID0gKCkgPT4ge1xuXHRcdFx0dmFyIHZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSk7XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGdldF9mYWxsYmFjaygpO1xuXHRcdFx0ZmFsbGJhY2tfZGlydHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Z2V0dGVyID0gKCkgPT4ge1xuXHRcdFx0dmFyIHZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSk7XG5cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIGluIGxlZ2FjeSBtb2RlLCB3ZSBkb24ndCByZXZlcnQgdG8gdGhlIGZhbGxiYWNrIHZhbHVlXG5cdFx0XHRcdC8vIGlmIHRoZSBwcm9wIGdvZXMgZnJvbSBkZWZpbmVkIHRvIHVuZGVmaW5lZC4gVGhlIGVhc2llc3Rcblx0XHRcdFx0Ly8gd2F5IHRvIG1vZGVsIHRoaXMgaXMgdG8gbWFrZSB0aGUgZmFsbGJhY2sgdW5kZWZpbmVkXG5cdFx0XHRcdC8vIGFzIHNvb24gYXMgdGhlIHByb3AgaGFzIGEgdmFsdWVcblx0XHRcdFx0ZmFsbGJhY2tfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovICh1bmRlZmluZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGZhbGxiYWNrX3ZhbHVlIDogdmFsdWU7XG5cdFx0fTtcblx0fVxuXG5cdC8vIHByb3AgaXMgbmV2ZXIgd3JpdHRlbiB0byBcdTIwMTQgd2Ugb25seSBuZWVkIGEgZ2V0dGVyXG5cdGlmIChydW5lcyAmJiAoZmxhZ3MgJiBQUk9QU19JU19VUERBVEVEKSA9PT0gMCkge1xuXHRcdHJldHVybiBnZXR0ZXI7XG5cdH1cblxuXHQvLyBwcm9wIGlzIHdyaXR0ZW4gdG8sIGJ1dCB0aGUgcGFyZW50IGNvbXBvbmVudCBoYWQgYGJpbmQ6Zm9vYCB3aGljaFxuXHQvLyBtZWFucyB3ZSBjYW4ganVzdCBjYWxsIGAkJHByb3BzLmZvbyA9IHZhbHVlYCBkaXJlY3RseVxuXHRpZiAoc2V0dGVyKSB7XG5cdFx0dmFyIGxlZ2FjeV9wYXJlbnQgPSBwcm9wcy4kJGxlZ2FjeTtcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoXG5cdFx0XHRmdW5jdGlvbiAoLyoqIEB0eXBlIHtWfSAqLyB2YWx1ZSwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBtdXRhdGlvbikge1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHQvLyBXZSBkb24ndCB3YW50IHRvIG5vdGlmeSBpZiB0aGUgdmFsdWUgd2FzIG11dGF0ZWQgYW5kIHRoZSBwYXJlbnQgaXMgaW4gcnVuZXMgbW9kZS5cblx0XHRcdFx0XHQvLyBJbiB0aGF0IGNhc2UgdGhlIHN0YXRlIHByb3h5IChpZiBpdCBleGlzdHMpIHNob3VsZCB0YWtlIGNhcmUgb2YgdGhlIG5vdGlmaWNhdGlvbi5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcGFyZW50IGlzIG5vdCBpbiBydW5lcyBtb2RlLCB3ZSBuZWVkIHRvIG5vdGlmeSBvbiBtdXRhdGlvbiwgdG9vLCB0aGF0IHRoZSBwcm9wXG5cdFx0XHRcdFx0Ly8gaGFzIGNoYW5nZWQgYmVjYXVzZSB0aGUgcGFyZW50IHdpbGwgbm90IGJlIGFibGUgdG8gZGV0ZWN0IHRoZSBjaGFuZ2Ugb3RoZXJ3aXNlLlxuXHRcdFx0XHRcdGlmICghcnVuZXMgfHwgIW11dGF0aW9uIHx8IGxlZ2FjeV9wYXJlbnQgfHwgaXNfc3RvcmVfc3ViKSB7XG5cdFx0XHRcdFx0XHQvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyAoc2V0dGVyKShtdXRhdGlvbiA/IGdldHRlcigpIDogdmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBnZXR0ZXIoKTtcblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cblx0Ly8gRWl0aGVyIHByb3AgaXMgd3JpdHRlbiB0bywgYnV0IHRoZXJlJ3Mgbm8gYmluZGluZywgd2hpY2ggbWVhbnMgd2Vcblx0Ly8gY3JlYXRlIGEgZGVyaXZlZCB0aGF0IHdlIGNhbiB3cml0ZSB0byBsb2NhbGx5LlxuXHQvLyBPciB3ZSBhcmUgaW4gbGVnYWN5IG1vZGUgd2hlcmUgd2UgYWx3YXlzIGNyZWF0ZSBhIGRlcml2ZWQgdG8gcmVwbGljYXRlIHRoYXRcblx0Ly8gU3ZlbHRlIDQgZGlkIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgd2hlbiBhIHByaW1pdGl2ZSB2YWx1ZSB3YXMgdXBkYXRlZCB0byB0aGUgc2FtZSB2YWx1ZS5cblx0dmFyIG92ZXJyaWRkZW4gPSBmYWxzZTtcblxuXHR2YXIgZCA9ICgoZmxhZ3MgJiBQUk9QU19JU19JTU1VVEFCTEUpICE9PSAwID8gZGVyaXZlZCA6IGRlcml2ZWRfc2FmZV9lcXVhbCkoKCkgPT4ge1xuXHRcdG92ZXJyaWRkZW4gPSBmYWxzZTtcblx0XHRyZXR1cm4gZ2V0dGVyKCk7XG5cdH0pO1xuXG5cdGlmIChERVYpIHtcblx0XHRkLmxhYmVsID0ga2V5O1xuXHR9XG5cblx0Ly8gQ2FwdHVyZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBpdCdzIGJpbmRhYmxlXG5cdGlmIChiaW5kYWJsZSkgZ2V0KGQpO1xuXG5cdHZhciBwYXJlbnRfZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHRyZXR1cm4gLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoXG5cdFx0ZnVuY3Rpb24gKC8qKiBAdHlwZSB7YW55fSAqLyB2YWx1ZSwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBtdXRhdGlvbikge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnN0IG5ld192YWx1ZSA9IG11dGF0aW9uID8gZ2V0KGQpIDogcnVuZXMgJiYgYmluZGFibGUgPyBwcm94eSh2YWx1ZSkgOiB2YWx1ZTtcblxuXHRcdFx0XHRzZXQoZCwgbmV3X3ZhbHVlKTtcblx0XHRcdFx0b3ZlcnJpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0aWYgKGZhbGxiYWNrX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRmYWxsYmFja192YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIFx1MjAxNCBhdm9pZCByZWNhbGN1bGF0aW5nIHRoZSBkZXJpdmVkIGlmIHdlJ3JlIGluIGFcblx0XHRcdC8vIHRlYXJkb3duIGZ1bmN0aW9uIGFuZCB0aGUgcHJvcCB3YXMgb3ZlcnJpZGRlbiBsb2NhbGx5LCBvciB0aGVcblx0XHRcdC8vIGNvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQgKHRoaXMgbGF0dGVyIHBhcnQgaXMgbmVjZXNzYXJ5XG5cdFx0XHQvLyBiZWNhdXNlIGBiaW5kOnRoaXNgIGNhbiByZWFkIHByb3BzIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzXG5cdFx0XHQvLyBiZWVuIGRlc3Ryb3llZC4gVE9ETyBzaW1wbGlmeSBgYmluZDp0aGlzYFxuXHRcdFx0aWYgKChpc19kZXN0cm95aW5nX2VmZmVjdCAmJiBvdmVycmlkZGVuKSB8fCAocGFyZW50X2VmZmVjdC5mICYgREVTVFJPWUVEKSAhPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gZC52O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2V0KGQpO1xuXHRcdH1cblx0KTtcbn1cbiIsICJpbXBvcnQgeyBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gfSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBGSUxFTkFNRSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyByZW5kZXJfZWZmZWN0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGNhcHR1cmVfc3RvcmVfYmluZGluZyB9IGZyb20gJy4vcmVhY3Rpdml0eS9zdG9yZS5qcyc7XG5pbXBvcnQgeyBydW5fYWZ0ZXJfYmxvY2tlcnMgfSBmcm9tICcuL3JlYWN0aXZpdHkvYXN5bmMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0geyhpdGVtOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHN0cmluZ30ga2V5X2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjb2xsZWN0aW9uLCBrZXlfZm4pIHtcblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcblx0XHRjb25zdCBtYXliZV9hcnJheSA9IGNvbGxlY3Rpb24oKTtcblx0XHRjb25zdCBhcnJheSA9IGlzX2FycmF5KG1heWJlX2FycmF5KVxuXHRcdFx0PyBtYXliZV9hcnJheVxuXHRcdFx0OiBtYXliZV9hcnJheSA9PSBudWxsXG5cdFx0XHRcdD8gW11cblx0XHRcdFx0OiBBcnJheS5mcm9tKG1heWJlX2FycmF5KTtcblx0XHRjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qga2V5ID0ga2V5X2ZuKGFycmF5W2ldLCBpKTtcblx0XHRcdGlmIChrZXlzLmhhcyhrZXkpKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBTdHJpbmcoa2V5cy5nZXQoa2V5KSk7XG5cdFx0XHRcdGNvbnN0IGIgPSBTdHJpbmcoaSk7XG5cblx0XHRcdFx0LyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuXHRcdFx0XHRsZXQgayA9IFN0cmluZyhrZXkpO1xuXHRcdFx0XHRpZiAoay5zdGFydHNXaXRoKCdbb2JqZWN0ICcpKSBrID0gbnVsbDtcblxuXHRcdFx0XHRlLmVhY2hfa2V5X2R1cGxpY2F0ZShhLCBiLCBrKTtcblx0XHRcdH1cblx0XHRcdGtleXMuc2V0KGtleSwgaSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluZGluZ1xuICogQHBhcmFtIHtBcnJheTxQcm9taXNlPHZvaWQ+Pn0gYmxvY2tlcnNcbiAqIEBwYXJhbSB7KCkgPT4gUmVjb3JkPHN0cmluZywgYW55Pn0gZ2V0X29iamVjdFxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGdldF9wcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2JpbmRpbmcoYmluZGluZywgYmxvY2tlcnMsIGdldF9vYmplY3QsIGdldF9wcm9wZXJ0eSwgbGluZSwgY29sdW1uKSB7XG5cdHJ1bl9hZnRlcl9ibG9ja2VycyhibG9ja2VycywgKCkgPT4ge1xuXHRcdHZhciB3YXJuZWQgPSBmYWxzZTtcblxuXHRcdHZhciBmaWxlbmFtZSA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbj8uW0ZJTEVOQU1FXTtcblxuXHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0aWYgKHdhcm5lZCkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgW29iamVjdCwgaXNfc3RvcmVfc3ViXSA9IGNhcHR1cmVfc3RvcmVfYmluZGluZyhnZXRfb2JqZWN0KTtcblxuXHRcdFx0aWYgKGlzX3N0b3JlX3N1YikgcmV0dXJuO1xuXG5cdFx0XHR2YXIgcHJvcGVydHkgPSBnZXRfcHJvcGVydHkoKTtcblxuXHRcdFx0dmFyIHJhbiA9IGZhbHNlO1xuXG5cdFx0XHQvLyBieSBtYWtpbmcgdGhlIChwb3NzaWJseSBmYWxzZSwgYnV0IGl0IHdvdWxkIGJlIGFuIGV4dHJlbWUgZWRnZSBjYXNlKSBhc3N1bXB0aW9uXG5cdFx0XHQvLyB0aGF0IGEgZ2V0dGVyIGhhcyBhIGNvcnJlc3BvbmRpbmcgc2V0dGVyLCB3ZSBjYW4gZGV0ZXJtaW5lIGlmIGEgcHJvcGVydHkgaXNcblx0XHRcdC8vIHJlYWN0aXZlIGJ5IHNlZWluZyBpZiB0aGlzIGVmZmVjdCBoYXMgZGVwZW5kZW5jaWVzXG5cdFx0XHR2YXIgZWZmZWN0ID0gcmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdGlmIChyYW4pIHJldHVybjtcblxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0XHRvYmplY3RbcHJvcGVydHldO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJhbiA9IHRydWU7XG5cblx0XHRcdGlmIChlZmZlY3QuZGVwcyA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgbG9jYXRpb24gPSBgJHtmaWxlbmFtZX06JHtsaW5lfToke2NvbHVtbn1gO1xuXHRcdFx0XHR3LmJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlKGJpbmRpbmcsIGxvY2F0aW9uKTtcblxuXHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnN0cnVjdG9yT3B0aW9ucywgQ29tcG9uZW50VHlwZSwgU3ZlbHRlQ29tcG9uZW50LCBDb21wb25lbnQgfSBmcm9tICdzdmVsdGUnICovXG5pbXBvcnQgeyBESVJUWSwgTEVHQUNZX1BST1BTLCBNQVlCRV9ESVJUWSB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgdXNlcl9wcmVfZWZmZWN0IH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBtdXRhYmxlX3NvdXJjZSwgc2V0IH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlLCBtb3VudCwgdW5tb3VudCB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9yZW5kZXIuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCwgZ2V0LCBzZXRfc2lnbmFsX3N0YXR1cyB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9ydW50aW1lLmpzJztcbmltcG9ydCB7IGZsdXNoU3luYyB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2JhdGNoLmpzJztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgaXNfYXJyYXkgfSBmcm9tICcuLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvZXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9jb250ZXh0LmpzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZyB9IGZyb20gJy4uL2ludGVybmFsL2ZsYWdzL2luZGV4LmpzJztcblxuLyoqXG4gKiBUYWtlcyB0aGUgc2FtZSBvcHRpb25zIGFzIGEgU3ZlbHRlIDQgY29tcG9uZW50IGFuZCB0aGUgY29tcG9uZW50IGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgU3ZlbHRlIDQgY29tcGF0aWJsZSBjb21wb25lbnQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoaXMgb25seSBhcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiB0byBtaWdyYXRlIHlvdXIgaW1wZXJhdGl2ZSBjb21wb25lbnQgY29kZSB0byBTdmVsdGUgNS5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV4cG9ydHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXZlbnRzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFNsb3RzXG4gKlxuICogQHBhcmFtIHtDb21wb25lbnRDb25zdHJ1Y3Rvck9wdGlvbnM8UHJvcHM+ICYge1xuICogXHRjb21wb25lbnQ6IENvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzLCBFdmVudHMsIFNsb3RzPj4gfCBDb21wb25lbnQ8UHJvcHM+O1xuICogfX0gb3B0aW9uc1xuICogQHJldHVybnMge1N2ZWx0ZUNvbXBvbmVudDxQcm9wcywgRXZlbnRzLCBTbG90cz4gJiBFeHBvcnRzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xhc3NDb21wb25lbnQob3B0aW9ucykge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yICQkcHJvcF9kZWYgZXRjIGFyZSBub3QgYWN0dWFsbHkgZGVmaW5lZFxuXHRyZXR1cm4gbmV3IFN2ZWx0ZTRDb21wb25lbnQob3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGFrZXMgdGhlIGNvbXBvbmVudCBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIFN2ZWx0ZSA0IGNvbXBhdGlibGUgY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGlzIG9ubHkgYXMgYSB0ZW1wb3Jhcnkgc29sdXRpb24gdG8gbWlncmF0ZSB5b3VyIGltcGVyYXRpdmUgY29tcG9uZW50IGNvZGUgdG8gU3ZlbHRlIDUuXG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV2ZW50c1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBTbG90c1xuICpcbiAqIEBwYXJhbSB7U3ZlbHRlQ29tcG9uZW50PFByb3BzLCBFdmVudHMsIFNsb3RzPiB8IENvbXBvbmVudDxQcm9wcz59IGNvbXBvbmVudFxuICogQHJldHVybnMge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzLCBFdmVudHMsIFNsb3RzPiAmIEV4cG9ydHM+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciAkJHByb3BfZGVmIGV0YyBhcmUgbm90IGFjdHVhbGx5IGRlZmluZWRcblx0cmV0dXJuIGNsYXNzIGV4dGVuZHMgU3ZlbHRlNENvbXBvbmVudCB7XG5cdFx0LyoqIEBwYXJhbSB7YW55fSBvcHRpb25zICovXG5cdFx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdFx0c3VwZXIoe1xuXHRcdFx0XHRjb21wb25lbnQsXG5cdFx0XHRcdC4uLm9wdGlvbnNcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHVzaW5nIHRoZSBjb21wb25lbnQgYXMgYm90aCBhIGNsYXNzIGFuZCBmdW5jdGlvbiBkdXJpbmcgdGhlIHRyYW5zaXRpb24gcGVyaW9kXG4gKiBAdHlwZWRlZiAge3tuZXcgKG86IENvbXBvbmVudENvbnN0cnVjdG9yT3B0aW9ucyk6IFN2ZWx0ZUNvbXBvbmVudDsoLi4uYXJnczogUGFyYW1ldGVyczxDb21wb25lbnQ8UmVjb3JkPHN0cmluZywgYW55Pj4+KTogUmV0dXJuVHlwZTxDb21wb25lbnQ8UmVjb3JkPHN0cmluZywgYW55PiwgUmVjb3JkPHN0cmluZywgYW55Pj4+O319IExlZ2FjeUNvbXBvbmVudFR5cGVcbiAqL1xuXG5jbGFzcyBTdmVsdGU0Q29tcG9uZW50IHtcblx0LyoqIEB0eXBlIHthbnl9ICovXG5cdCNldmVudHM7XG5cblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuXHQjaW5zdGFuY2U7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Q29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zICYge1xuXHQgKiAgY29tcG9uZW50OiBhbnk7XG5cdCAqIH19IG9wdGlvbnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR2YXIgc291cmNlcyA9IG5ldyBNYXAoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nIHwgc3ltYm9sfSBrZXlcblx0XHQgKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG5cdFx0ICovXG5cdFx0dmFyIGFkZF9zb3VyY2UgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdFx0dmFyIHMgPSBtdXRhYmxlX3NvdXJjZSh2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdHNvdXJjZXMuc2V0KGtleSwgcyk7XG5cdFx0XHRyZXR1cm4gcztcblx0XHR9O1xuXG5cdFx0Ly8gUmVwbGljYXRlIGNvYXJzZS1ncmFpbmVkIHByb3BzIHRocm91Z2ggYSBwcm94eSB0aGF0IGhhcyBhIHZlcnNpb24gc291cmNlIGZvclxuXHRcdC8vIGVhY2ggcHJvcGVydHksIHdoaWNoIGlzIGluY3JlbWVudGVkIG9uIHVwZGF0ZXMgdG8gdGhlIHByb3BlcnR5IGl0c2VsZi4gRG8gbm90XG5cdFx0Ly8gdXNlIG91ciAkc3RhdGUgcHJveHkgYmVjYXVzZSB0aGF0IG9uZSBoYXMgZmluZS1ncmFpbmVkIHJlYWN0aXZpdHkuXG5cdFx0Y29uc3QgcHJvcHMgPSBuZXcgUHJveHkoXG5cdFx0XHR7IC4uLihvcHRpb25zLnByb3BzIHx8IHt9KSwgJCRldmVudHM6IHt9IH0sXG5cdFx0XHR7XG5cdFx0XHRcdGdldCh0YXJnZXQsIHByb3ApIHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0KHNvdXJjZXMuZ2V0KHByb3ApID8/IGFkZF9zb3VyY2UocHJvcCwgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKSkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRoYXModGFyZ2V0LCBwcm9wKSB7XG5cdFx0XHRcdFx0Ly8gTmVjZXNzYXJ5IHRvIG5vdCB0aHJvdyBcImludmFsaWQgYmluZGluZ1wiIHZhbGlkYXRpb24gZXJyb3JzIG9uIHRoZSBjb21wb25lbnQgc2lkZVxuXHRcdFx0XHRcdGlmIChwcm9wID09PSBMRUdBQ1lfUFJPUFMpIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0Z2V0KHNvdXJjZXMuZ2V0KHByb3ApID8/IGFkZF9zb3VyY2UocHJvcCwgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKSkpO1xuXHRcdFx0XHRcdHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuXHRcdFx0XHRcdHNldChzb3VyY2VzLmdldChwcm9wKSA/PyBhZGRfc291cmNlKHByb3AsIHZhbHVlKSwgdmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHR0aGlzLiNpbnN0YW5jZSA9IChvcHRpb25zLmh5ZHJhdGUgPyBoeWRyYXRlIDogbW91bnQpKG9wdGlvbnMuY29tcG9uZW50LCB7XG5cdFx0XHR0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LFxuXHRcdFx0YW5jaG9yOiBvcHRpb25zLmFuY2hvcixcblx0XHRcdHByb3BzLFxuXHRcdFx0Y29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuXHRcdFx0aW50cm86IG9wdGlvbnMuaW50cm8gPz8gZmFsc2UsXG5cdFx0XHRyZWNvdmVyOiBvcHRpb25zLnJlY292ZXJcblx0XHR9KTtcblxuXHRcdC8vIFdlIGRvbid0IGZsdXNoU3luYyBmb3IgY3VzdG9tIGVsZW1lbnQgd3JhcHBlcnMgb3IgaWYgdGhlIHVzZXIgZG9lc24ndCB3YW50IGl0LFxuXHRcdC8vIG9yIGlmIHdlJ3JlIGluIGFzeW5jIG1vZGUgc2luY2UgYGZsdXNoU3luYygpYCB3aWxsIGZhaWxcblx0XHRpZiAoIWFzeW5jX21vZGVfZmxhZyAmJiAoIW9wdGlvbnM/LnByb3BzPy4kJGhvc3QgfHwgb3B0aW9ucy5zeW5jID09PSBmYWxzZSkpIHtcblx0XHRcdGZsdXNoU3luYygpO1xuXHRcdH1cblxuXHRcdHRoaXMuI2V2ZW50cyA9IHByb3BzLiQkZXZlbnRzO1xuXG5cdFx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy4jaW5zdGFuY2UpKSB7XG5cdFx0XHRpZiAoa2V5ID09PSAnJHNldCcgfHwga2V5ID09PSAnJGRlc3Ryb3knIHx8IGtleSA9PT0gJyRvbicpIGNvbnRpbnVlO1xuXHRcdFx0ZGVmaW5lX3Byb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHRnZXQoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuI2luc3RhbmNlW2tleV07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKiBAcGFyYW0ge2FueX0gdmFsdWUgKi9cblx0XHRcdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRcdFx0dGhpcy4jaW5zdGFuY2Vba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLiNpbnN0YW5jZS4kc2V0ID0gLyoqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gbmV4dCAqLyAobmV4dCkgPT4ge1xuXHRcdFx0T2JqZWN0LmFzc2lnbihwcm9wcywgbmV4dCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuI2luc3RhbmNlLiRkZXN0cm95ID0gKCkgPT4ge1xuXHRcdFx0dW5tb3VudCh0aGlzLiNpbnN0YW5jZSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHByb3BzICovXG5cdCRzZXQocHJvcHMpIHtcblx0XHR0aGlzLiNpbnN0YW5jZS4kc2V0KHByb3BzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHsoLi4uYXJnczogYW55W10pID0+IGFueX0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge2FueX1cblx0ICovXG5cdCRvbihldmVudCwgY2FsbGJhY2spIHtcblx0XHR0aGlzLiNldmVudHNbZXZlbnRdID0gdGhpcy4jZXZlbnRzW2V2ZW50XSB8fCBbXTtcblxuXHRcdC8qKiBAcGFyYW0ge2FueVtdfSBhcmdzICovXG5cdFx0Y29uc3QgY2IgPSAoLi4uYXJncykgPT4gY2FsbGJhY2suY2FsbCh0aGlzLCAuLi5hcmdzKTtcblx0XHR0aGlzLiNldmVudHNbZXZlbnRdLnB1c2goY2IpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR0aGlzLiNldmVudHNbZXZlbnRdID0gdGhpcy4jZXZlbnRzW2V2ZW50XS5maWx0ZXIoLyoqIEBwYXJhbSB7YW55fSBmbiAqLyAoZm4pID0+IGZuICE9PSBjYik7XG5cdFx0fTtcblx0fVxuXG5cdCRkZXN0cm95KCkge1xuXHRcdHRoaXMuI2luc3RhbmNlLiRkZXN0cm95KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBvbmNlIGltbWVkaWF0ZWx5IG9uIHRoZSBzZXJ2ZXIsIGFuZCB3b3JrcyBsaWtlIGAkZWZmZWN0LnByZWAgb24gdGhlIGNsaWVudC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhpcyBvbmx5IGFzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uIHRvIG1pZ3JhdGUgeW91ciBjb21wb25lbnQgY29kZSB0byBTdmVsdGUgNS5cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuKGZuKSB7XG5cdHVzZXJfcHJlX2VmZmVjdCgoKSA9PiB7XG5cdFx0Zm4oKTtcblx0XHR2YXIgZWZmZWN0ID0gLyoqIEB0eXBlIHtpbXBvcnQoJyNjbGllbnQnKS5FZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblx0XHQvLyBJZiB0aGUgZWZmZWN0IGlzIGltbWVkaWF0ZWx5IG1hZGUgZGlydHkgYWdhaW4sIG1hcmsgaXQgYXMgbWF5YmUgZGlydHkgdG8gZW11bGF0ZSBsZWdhY3kgYmVoYXZpb3VyXG5cdFx0aWYgKChlZmZlY3QuZiAmIERJUlRZKSAhPT0gMCkge1xuXHRcdFx0bGV0IGZpbGVuYW1lID0gXCJhIGZpbGUgKHdlIGNhbid0IGtub3cgd2hpY2ggb25lKVwiO1xuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGZpbGVuYW1lID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uPy5bRklMRU5BTUVdID8/IGZpbGVuYW1lO1xuXHRcdFx0fVxuXHRcdFx0dy5sZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrKGZpbGVuYW1lKTtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgTUFZQkVfRElSVFkpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gbWltaWMgdGhlIG11bHRpcGxlIGxpc3RlbmVycyBhdmFpbGFibGUgaW4gc3ZlbHRlIDRcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJbXX0gaGFuZGxlcnNcbiAqIEByZXR1cm5zIHtFdmVudExpc3RlbmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlcnMoLi4uaGFuZGxlcnMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGNvbnN0IHsgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIH0gPSBldmVudDtcblx0XHRsZXQgc3RvcHBlZCA9IGZhbHNlO1xuXG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuXHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24uY2FsbChldmVudCk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IGVycm9ycyA9IFtdO1xuXG5cdFx0Zm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIGB0aGlzYCBpcyBub3QgdHlwZWRcblx0XHRcdFx0aGFuZGxlcj8uY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGVycm9ycy5wdXNoKGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3RvcHBlZCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGxldCBlcnJvciBvZiBlcnJvcnMpIHtcblx0XHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gY3JlYXRlIGEgYGJ1YmJsZWAgZnVuY3Rpb24gdGhhdCBtaW1pYyB0aGUgYmVoYXZpb3Igb2YgYG9uOmNsaWNrYCB3aXRob3V0IGhhbmRsZXIgYXZhaWxhYmxlIGluIHN2ZWx0ZSA0LlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoaXMgb25seSBhcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiB0byBtaWdyYXRlIHlvdXIgYXV0b21hdGljYWxseSBkZWxlZ2F0ZWQgZXZlbnRzIGluIFN2ZWx0ZSA1LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQnViYmxlcigpIHtcblx0Y29uc3QgYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdGlmIChhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnY3JlYXRlQnViYmxlcicpO1xuXHR9XG5cblx0cmV0dXJuICgvKipAdHlwZSB7c3RyaW5nfSovIHR5cGUpID0+ICgvKipAdHlwZSB7RXZlbnR9Ki8gZXZlbnQpID0+IHtcblx0XHRjb25zdCBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uIHwgRnVuY3Rpb25bXT59ICovIChcblx0XHRcdGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC5zLiQkZXZlbnRzXG5cdFx0KT8uWy8qKiBAdHlwZSB7YW55fSAqLyAodHlwZSldO1xuXG5cdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogW2V2ZW50c107XG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIGNhbGxiYWNrcykge1xuXHRcdFx0XHRmbi5jYWxsKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC54LCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xufVxuXG5leHBvcnQge1xuXHRvbmNlLFxuXHRwcmV2ZW50RGVmYXVsdCxcblx0c2VsZixcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLFxuXHRzdG9wUHJvcGFnYXRpb24sXG5cdHRydXN0ZWQsXG5cdHBhc3NpdmUsXG5cdG5vbnBhc3NpdmVcbn0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvZXZlbnQtbW9kaWZpZXJzLmpzJztcbiIsICJpbXBvcnQgeyBjcmVhdGVDbGFzc0NvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL2xlZ2FjeS9sZWdhY3ktY2xpZW50LmpzJztcbmltcG9ydCB7IGVmZmVjdF9yb290LCByZW5kZXJfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGFwcGVuZCB9IGZyb20gJy4uL3RlbXBsYXRlLmpzJztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgZ2V0X2Rlc2NyaXB0b3IsIG9iamVjdF9rZXlzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmlidXRlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVmbGVjdF1cbiAqIEBwcm9wZXJ0eSB7J1N0cmluZyd8J0Jvb2xlYW4nfCdOdW1iZXInfCdBcnJheSd8J09iamVjdCd9IFt0eXBlXVxuICovXG5cbi8qKiBAdHlwZSB7YW55fSAqL1xubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5cbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcblx0U3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXHRcdC8qKiBUaGUgU3ZlbHRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciAqL1xuXHRcdCQkY3Rvcjtcblx0XHQvKiogU2xvdHMgKi9cblx0XHQkJHM7XG5cdFx0LyoqIEB0eXBlIHthbnl9IFRoZSBTdmVsdGUgY29tcG9uZW50IGluc3RhbmNlICovXG5cdFx0JCRjO1xuXHRcdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgY29ubmVjdGVkICovXG5cdFx0JCRjbiA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gQ29tcG9uZW50IHByb3BzIGRhdGEgKi9cblx0XHQkJGQgPSB7fTtcblx0XHQvKiogYHRydWVgIGlmIGN1cnJlbnRseSBpbiB0aGUgcHJvY2VzcyBvZiByZWZsZWN0aW5nIGNvbXBvbmVudCBwcm9wcyBiYWNrIHRvIGF0dHJpYnV0ZXMgKi9cblx0XHQkJHIgPSBmYWxzZTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IFByb3BzIGRlZmluaXRpb24gKG5hbWUsIHJlZmxlY3RlZCwgdHlwZSBldGMpICovXG5cdFx0JCRwX2QgPSB7fTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3RbXT59IEV2ZW50IGxpc3RlbmVycyAqL1xuXHRcdCQkbCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7TWFwPEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QsIEZ1bmN0aW9uPn0gRXZlbnQgbGlzdGVuZXIgdW5zdWJzY3JpYmUgZnVuY3Rpb25zICovXG5cdFx0JCRsX3UgPSBuZXcgTWFwKCk7XG5cdFx0LyoqIEB0eXBlIHthbnl9IFRoZSBtYW5hZ2VkIHJlbmRlciBlZmZlY3QgZm9yIHJlZmxlY3RpbmcgYXR0cmlidXRlcyAqL1xuXHRcdCQkbWU7XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0geyp9ICQkY29tcG9uZW50Q3RvclxuXHRcdCAqIEBwYXJhbSB7Kn0gJCRzbG90c1xuXHRcdCAqIEBwYXJhbSB7Kn0gdXNlX3NoYWRvd19kb21cblx0XHQgKi9cblx0XHRjb25zdHJ1Y3RvcigkJGNvbXBvbmVudEN0b3IsICQkc2xvdHMsIHVzZV9zaGFkb3dfZG9tKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy4kJGN0b3IgPSAkJGNvbXBvbmVudEN0b3I7XG5cdFx0XHR0aGlzLiQkcyA9ICQkc2xvdHM7XG5cdFx0XHRpZiAodXNlX3NoYWRvd19kb20pIHtcblx0XHRcdFx0dGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0XHQgKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGxpc3RlbmVyXG5cdFx0ICogQHBhcmFtIHtib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuXHRcdCAqL1xuXHRcdGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdC8vIFdlIGNhbid0IGRldGVybWluZSB1cGZyb250IGlmIHRoZSBldmVudCBpcyBhIGN1c3RvbSBldmVudCBvciBub3QsIHNvIHdlIGhhdmUgdG9cblx0XHRcdC8vIGxpc3RlbiB0byBib3RoLiBJZiBzb21lb25lIHVzZXMgYSBjdXN0b20gZXZlbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIGEgcmVndWxhclxuXHRcdFx0Ly8gYnJvd3NlciBldmVudCwgdGhpcyBmaXJlcyB0d2ljZSAtIHdlIGNhbid0IGF2b2lkIHRoYXQuXG5cdFx0XHR0aGlzLiQkbFt0eXBlXSA9IHRoaXMuJCRsW3R5cGVdIHx8IFtdO1xuXHRcdFx0dGhpcy4kJGxbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkYy4kb24odHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHR0aGlzLiQkbF91LnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0fVxuXHRcdFx0c3VwZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0XHQgKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGxpc3RlbmVyXG5cdFx0ICogQHBhcmFtIHtib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuXHRcdCAqL1xuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGxfdS5nZXQobGlzdGVuZXIpO1xuXHRcdFx0XHRpZiAodW5zdWIpIHtcblx0XHRcdFx0XHR1bnN1YigpO1xuXHRcdFx0XHRcdHRoaXMuJCRsX3UuZGVsZXRlKGxpc3RlbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNuID0gdHJ1ZTtcblx0XHRcdGlmICghdGhpcy4kJGMpIHtcblx0XHRcdFx0Ly8gV2Ugd2FpdCBvbmUgdGljayB0byBsZXQgcG9zc2libGUgY2hpbGQgc2xvdCBlbGVtZW50cyBiZSBjcmVhdGVkL21vdW50ZWRcblx0XHRcdFx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNuIHx8IHRoaXMuJCRjKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuXHRcdFx0XHRmdW5jdGlvbiBjcmVhdGVfc2xvdChuYW1lKSB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBhbmNob3Jcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRyZXR1cm4gKGFuY2hvcikgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2xvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Nsb3QnKTtcblx0XHRcdFx0XHRcdGlmIChuYW1lICE9PSAnZGVmYXVsdCcpIHNsb3QubmFtZSA9IG5hbWU7XG5cblx0XHRcdFx0XHRcdGFwcGVuZChhbmNob3IsIHNsb3QpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuXHRcdFx0XHRjb25zdCAkJHNsb3RzID0ge307XG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nX3Nsb3RzID0gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyh0aGlzKTtcblx0XHRcdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMuJCRzKSB7XG5cdFx0XHRcdFx0aWYgKG5hbWUgaW4gZXhpc3Rpbmdfc2xvdHMpIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lID09PSAnZGVmYXVsdCcgJiYgIXRoaXMuJCRkLmNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuJCRkLmNoaWxkcmVuID0gY3JlYXRlX3Nsb3QobmFtZSk7XG5cdFx0XHRcdFx0XHRcdCQkc2xvdHMuZGVmYXVsdCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQkJHNsb3RzW25hbWVdID0gY3JlYXRlX3Nsb3QobmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIHRoaXMuYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdC8vIHRoaXMuJCRkYXRhIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzLmF0dHJpYnV0ZXNcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdGhpcy4kJGdfcChhdHRyaWJ1dGUubmFtZSk7XG5cdFx0XHRcdFx0aWYgKCEobmFtZSBpbiB0aGlzLiQkZCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW25hbWVdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKG5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgdGhpcy4kJHBfZCwgJ3RvUHJvcCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBQb3J0IG92ZXIgcHJvcHMgdGhhdCB3ZXJlIHNldCBwcm9ncmFtbWF0aWNhbGx5IGJlZm9yZSBjZSB3YXMgaW5pdGlhbGl6ZWRcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRpZiAoIShrZXkgaW4gdGhpcy4kJGQpICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldID0gdGhpc1trZXldOyAvLyBkb24ndCB0cmFuc2Zvcm0sIHRoZXNlIHdlcmUgc2V0IHRocm91Z2ggSmF2YVNjcmlwdFxuXHRcdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXNba2V5XTsgLy8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSB0aGF0IHNoYWRvd3MgdGhlIGdldHRlci9zZXR0ZXJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy4kJGMgPSBjcmVhdGVDbGFzc0NvbXBvbmVudCh7XG5cdFx0XHRcdFx0Y29tcG9uZW50OiB0aGlzLiQkY3Rvcixcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMuc2hhZG93Um9vdCB8fCB0aGlzLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHQuLi50aGlzLiQkZCxcblx0XHRcdFx0XHRcdCQkc2xvdHMsXG5cdFx0XHRcdFx0XHQkJGhvc3Q6IHRoaXNcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFJlZmxlY3QgY29tcG9uZW50IHByb3BzIGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0dGhpcy4kJG1lID0gZWZmZWN0X3Jvb3QoKCkgPT4ge1xuXHRcdFx0XHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy4kJHIgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgb2Ygb2JqZWN0X2tleXModGhpcy4kJGMpKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdGhpcy4kJHBfZFtrZXldPy5yZWZsZWN0KSBjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSA9IHRoaXMuJCRjW2tleV07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZV92YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShcblx0XHRcdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiQkcF9kLFxuXHRcdFx0XHRcdFx0XHRcdCd0b0F0dHJpYnV0ZSdcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZV92YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUodGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSB8fCBrZXkpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgfHwga2V5LCBhdHRyaWJ1dGVfdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLiQkciA9IGZhbHNlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IHR5cGUgaW4gdGhpcy4kJGwpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuJCRsW3R5cGVdKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRjLiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHR0aGlzLiQkbF91LnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkbCA9IHt9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFdlIGRvbid0IG5lZWQgdGhpcyB3aGVuIHdvcmtpbmcgd2l0aGluIFN2ZWx0ZSBjb2RlLCBidXQgZm9yIGNvbXBhdGliaWxpdHkgb2YgcGVvcGxlIHVzaW5nIHRoaXMgb3V0c2lkZSBvZiBTdmVsdGVcblx0XHQvLyBhbmQgc2V0dGluZyBhdHRyaWJ1dGVzIHRocm91Z2ggc2V0QXR0cmlidXRlIGV0YywgdGhpcyBpcyBoZWxwZnVsXG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBfb2xkVmFsdWVcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWVcblx0XHQgKi9cblx0XHRhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuJCRyKSByZXR1cm47XG5cdFx0XHRhdHRyID0gdGhpcy4kJGdfcChhdHRyKTtcblx0XHRcdHRoaXMuJCRkW2F0dHJdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKGF0dHIsIG5ld1ZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHR0aGlzLiQkYz8uJHNldCh7IFthdHRyXTogdGhpcy4kJGRbYXR0cl0gfSk7XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSBmYWxzZTtcblx0XHRcdC8vIEluIGEgbWljcm90YXNrLCBiZWNhdXNlIHRoaXMgY291bGQgYmUgYSBtb3ZlIHdpdGhpbiB0aGUgRE9NXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24gJiYgdGhpcy4kJGMpIHtcblx0XHRcdFx0XHR0aGlzLiQkYy4kZGVzdHJveSgpO1xuXHRcdFx0XHRcdHRoaXMuJCRtZSgpO1xuXHRcdFx0XHRcdHRoaXMuJCRjID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlX25hbWVcblx0XHQgKi9cblx0XHQkJGdfcChhdHRyaWJ1dGVfbmFtZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0b2JqZWN0X2tleXModGhpcy4kJHBfZCkuZmluZChcblx0XHRcdFx0XHQoa2V5KSA9PlxuXHRcdFx0XHRcdFx0dGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSA9PT0gYXR0cmlidXRlX25hbWUgfHxcblx0XHRcdFx0XHRcdCghdGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gYXR0cmlidXRlX25hbWUpXG5cdFx0XHRcdCkgfHwgYXR0cmlidXRlX25hbWVcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvblxuICogQHBhcmFtIHsndG9BdHRyaWJ1dGUnIHwgJ3RvUHJvcCd9IFt0cmFuc2Zvcm1dXG4gKi9cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbiwgdHJhbnNmb3JtKSB7XG5cdGNvbnN0IHR5cGUgPSBwcm9wc19kZWZpbml0aW9uW3Byb3BdPy50eXBlO1xuXHR2YWx1ZSA9IHR5cGUgPT09ICdCb29sZWFuJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyA/IHZhbHVlICE9IG51bGwgOiB2YWx1ZTtcblx0aWYgKCF0cmFuc2Zvcm0gfHwgIXByb3BzX2RlZmluaXRpb25bcHJvcF0pIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAndG9BdHRyaWJ1dGUnKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJycgOiBudWxsO1xuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTsgLy8gY29udmVyc2lvbiBhbHJlYWR5IGhhbmRsZWQgYWJvdmVcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAhPSBudWxsID8gK3ZhbHVlIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB0cnVlPn0gKi9cblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG5cdFx0cmVzdWx0Wy8qKiBAdHlwZSB7RWxlbWVudH0gbm9kZSAqLyAobm9kZSkuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogVHVybiBhIFN2ZWx0ZSBjb21wb25lbnQgaW50byBhIGN1c3RvbSBlbGVtZW50LlxuICogQHBhcmFtIHthbnl9IENvbXBvbmVudCAgQSBTdmVsdGUgY29tcG9uZW50IGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IHByb3BzX2RlZmluaXRpb24gIFRoZSBwcm9wcyB0byBvYnNlcnZlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzbG90cyAgVGhlIHNsb3RzIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gZXhwb3J0cyAgRXhwbGljaXRseSBleHBvcnRlZCB2YWx1ZXMsIG90aGVyIHRoYW4gcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlX3NoYWRvd19kb20gIFdoZXRoZXIgdG8gdXNlIHNoYWRvdyBET01cbiAqIEBwYXJhbSB7KGNlOiBuZXcgKCkgPT4gSFRNTEVsZW1lbnQpID0+IG5ldyAoKSA9PiBIVE1MRWxlbWVudH0gW2V4dGVuZF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jdXN0b21fZWxlbWVudChcblx0Q29tcG9uZW50LFxuXHRwcm9wc19kZWZpbml0aW9uLFxuXHRzbG90cyxcblx0ZXhwb3J0cyxcblx0dXNlX3NoYWRvd19kb20sXG5cdGV4dGVuZFxuKSB7XG5cdGxldCBDbGFzcyA9IGNsYXNzIGV4dGVuZHMgU3ZlbHRlRWxlbWVudCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcihDb21wb25lbnQsIHNsb3RzLCB1c2Vfc2hhZG93X2RvbSk7XG5cdFx0XHR0aGlzLiQkcF9kID0gcHJvcHNfZGVmaW5pdGlvbjtcblx0XHR9XG5cdFx0c3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG5cdFx0XHRyZXR1cm4gb2JqZWN0X2tleXMocHJvcHNfZGVmaW5pdGlvbikubWFwKChrZXkpID0+XG5cdFx0XHRcdChwcm9wc19kZWZpbml0aW9uW2tleV0uYXR0cmlidXRlIHx8IGtleSkudG9Mb3dlckNhc2UoKVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG5cdG9iamVjdF9rZXlzKHByb3BzX2RlZmluaXRpb24pLmZvckVhY2goKHByb3ApID0+IHtcblx0XHRkZWZpbmVfcHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBwcm9wLCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkYyAmJiBwcm9wIGluIHRoaXMuJCRjID8gdGhpcy4kJGNbcHJvcF0gOiB0aGlzLiQkZFtwcm9wXTtcblx0XHRcdH0sXG5cdFx0XHRzZXQodmFsdWUpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUocHJvcCwgdmFsdWUsIHByb3BzX2RlZmluaXRpb24pO1xuXHRcdFx0XHR0aGlzLiQkZFtwcm9wXSA9IHZhbHVlO1xuXHRcdFx0XHR2YXIgY29tcG9uZW50ID0gdGhpcy4kJGM7XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudCkge1xuXHRcdFx0XHRcdC8vIC8vIElmIHRoZSBpbnN0YW5jZSBoYXMgYW4gYWNjZXNzb3IsIHVzZSB0aGF0IGluc3RlYWRcblx0XHRcdFx0XHR2YXIgc2V0dGVyID0gZ2V0X2Rlc2NyaXB0b3IoY29tcG9uZW50LCBwcm9wKT8uZ2V0O1xuXG5cdFx0XHRcdFx0aWYgKHNldHRlcikge1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50W3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbXBvbmVudC4kc2V0KHsgW3Byb3BdOiB2YWx1ZSB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGV4cG9ydHMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcblx0XHRkZWZpbmVfcHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBwcm9wZXJ0eSwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGM/Lltwcm9wZXJ0eV07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRpZiAoZXh0ZW5kKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciAtIGFzc2lnbmluZyBoZXJlIGlzIGZpbmVcblx0XHRDbGFzcyA9IGV4dGVuZChDbGFzcyk7XG5cdH1cblx0Q29tcG9uZW50LmVsZW1lbnQgPSAvKiogQHR5cGUge2FueX0gKi8gQ2xhc3M7XG5cdHJldHVybiBDbGFzcztcbn1cbiIsICJpbXBvcnQgeyBTVEFURV9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzbmFwc2hvdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jbG9uZS5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0gIHsuLi5hbnl9IG9iamVjdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZ19pZl9jb250YWluc19zdGF0ZShtZXRob2QsIC4uLm9iamVjdHMpIHtcblx0dW50cmFjaygoKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBoYXNfc3RhdGUgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHRyYW5zZm9ybWVkID0gW107XG5cblx0XHRcdGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdHMpIHtcblx0XHRcdFx0aWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBTVEFURV9TWU1CT0wgaW4gb2JqKSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtZWQucHVzaChzbmFwc2hvdChvYmosIHRydWUpKTtcblx0XHRcdFx0XHRoYXNfc3RhdGUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyYW5zZm9ybWVkLnB1c2gob2JqKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFzX3N0YXRlKSB7XG5cdFx0XHRcdHcuY29uc29sZV9sb2dfc3RhdGUobWV0aG9kKTtcblxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0XHRjb25zb2xlLmxvZygnJWNbc25hcHNob3RdJywgJ2NvbG9yOiBncmV5JywgLi4udHJhbnNmb3JtZWQpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2gge31cblx0fSk7XG5cblx0cmV0dXJuIG9iamVjdHM7XG59XG4iLCAiZXhwb3J0IHsgY3JlYXRlQXR0YWNobWVudEtleSBhcyBhdHRhY2htZW50IH0gZnJvbSAnLi4vLi4vYXR0YWNobWVudHMvaW5kZXguanMnO1xuZXhwb3J0IHsgRklMRU5BTUUsIEhNUiwgTkFNRVNQQUNFX1NWRyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5leHBvcnQgeyBwdXNoLCBwb3AsIGFkZF9zdmVsdGVfbWV0YSB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5leHBvcnQgeyBhc3NpZ24sIGFzc2lnbl9hbmQsIGFzc2lnbl9vciwgYXNzaWduX251bGxpc2ggfSBmcm9tICcuL2Rldi9hc3NpZ24uanMnO1xuZXhwb3J0IHsgY2xlYW51cF9zdHlsZXMgfSBmcm9tICcuL2Rldi9jc3MuanMnO1xuZXhwb3J0IHsgYWRkX2xvY2F0aW9ucyB9IGZyb20gJy4vZGV2L2VsZW1lbnRzLmpzJztcbmV4cG9ydCB7IGhtciB9IGZyb20gJy4vZGV2L2htci5qcyc7XG5leHBvcnQgeyBjcmVhdGVfb3duZXJzaGlwX3ZhbGlkYXRvciB9IGZyb20gJy4vZGV2L293bmVyc2hpcC5qcyc7XG5leHBvcnQgeyBjaGVja190YXJnZXQsIGxlZ2FjeV9hcGkgfSBmcm9tICcuL2Rldi9sZWdhY3kuanMnO1xuZXhwb3J0IHsgdHJhY2UsIHRhZywgdGFnX3Byb3h5IH0gZnJvbSAnLi9kZXYvdHJhY2luZy5qcyc7XG5leHBvcnQgeyBpbnNwZWN0IH0gZnJvbSAnLi9kZXYvaW5zcGVjdC5qcyc7XG5leHBvcnQgeyBhc3luYyB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9hc3luYy5qcyc7XG5leHBvcnQgeyB2YWxpZGF0ZV9zbmlwcGV0X2FyZ3MgfSBmcm9tICcuL2Rldi92YWxpZGF0aW9uLmpzJztcbmV4cG9ydCB7IGF3YWl0X2Jsb2NrIGFzIGF3YWl0IH0gZnJvbSAnLi9kb20vYmxvY2tzL2F3YWl0LmpzJztcbmV4cG9ydCB7IGlmX2Jsb2NrIGFzIGlmIH0gZnJvbSAnLi9kb20vYmxvY2tzL2lmLmpzJztcbmV4cG9ydCB7IGtleSB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9rZXkuanMnO1xuZXhwb3J0IHsgY3NzX3Byb3BzIH0gZnJvbSAnLi9kb20vYmxvY2tzL2Nzcy1wcm9wcy5qcyc7XG5leHBvcnQgeyBpbmRleCwgZWFjaCB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9lYWNoLmpzJztcbmV4cG9ydCB7IGh0bWwgfSBmcm9tICcuL2RvbS9ibG9ja3MvaHRtbC5qcyc7XG5leHBvcnQgeyBzYW5pdGl6ZV9zbG90cywgc2xvdCB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9zbG90LmpzJztcbmV4cG9ydCB7IHNuaXBwZXQsIHdyYXBfc25pcHBldCB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9zbmlwcGV0LmpzJztcbmV4cG9ydCB7IGNvbXBvbmVudCB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9zdmVsdGUtY29tcG9uZW50LmpzJztcbmV4cG9ydCB7IGVsZW1lbnQgfSBmcm9tICcuL2RvbS9ibG9ja3Mvc3ZlbHRlLWVsZW1lbnQuanMnO1xuZXhwb3J0IHsgaGVhZCB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9zdmVsdGUtaGVhZC5qcyc7XG5leHBvcnQgeyBhcHBlbmRfc3R5bGVzIH0gZnJvbSAnLi9kb20vY3NzLmpzJztcbmV4cG9ydCB7IGFjdGlvbiB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2FjdGlvbnMuanMnO1xuZXhwb3J0IHsgYXR0YWNoIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvYXR0YWNobWVudHMuanMnO1xuZXhwb3J0IHtcblx0cmVtb3ZlX2lucHV0X2RlZmF1bHRzLFxuXHRzZXRfYXR0cmlidXRlLFxuXHRhdHRyaWJ1dGVfZWZmZWN0LFxuXHRzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YSxcblx0c2V0X3hsaW5rX2F0dHJpYnV0ZSxcblx0c2V0X3ZhbHVlLFxuXHRzZXRfY2hlY2tlZCxcblx0c2V0X3NlbGVjdGVkLFxuXHRzZXRfZGVmYXVsdF9jaGVja2VkLFxuXHRzZXRfZGVmYXVsdF92YWx1ZSxcblx0Q0xBU1MsXG5cdFNUWUxFXG59IGZyb20gJy4vZG9tL2VsZW1lbnRzL2F0dHJpYnV0ZXMuanMnO1xuZXhwb3J0IHsgc2V0X2NsYXNzIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvY2xhc3MuanMnO1xuZXhwb3J0IHsgYXBwbHksIGV2ZW50LCBkZWxlZ2F0ZSwgcmVwbGF5X2V2ZW50cyB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2V2ZW50cy5qcyc7XG5leHBvcnQgeyBhdXRvZm9jdXMsIHJlbW92ZV90ZXh0YXJlYV9jaGlsZCB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL21pc2MuanMnO1xuZXhwb3J0IHsgc2V0X3N0eWxlIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvc3R5bGUuanMnO1xuZXhwb3J0IHsgYW5pbWF0aW9uLCB0cmFuc2l0aW9uIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvdHJhbnNpdGlvbnMuanMnO1xuZXhwb3J0IHsgYmluZF9hY3RpdmVfZWxlbWVudCB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL2RvY3VtZW50LmpzJztcbmV4cG9ydCB7IGJpbmRfY2hlY2tlZCwgYmluZF9maWxlcywgYmluZF9ncm91cCwgYmluZF92YWx1ZSB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL2lucHV0LmpzJztcbmV4cG9ydCB7XG5cdGJpbmRfYnVmZmVyZWQsXG5cdGJpbmRfY3VycmVudF90aW1lLFxuXHRiaW5kX2VuZGVkLFxuXHRiaW5kX211dGVkLFxuXHRiaW5kX3BhdXNlZCxcblx0YmluZF9wbGF5YmFja19yYXRlLFxuXHRiaW5kX3BsYXllZCxcblx0YmluZF9yZWFkeV9zdGF0ZSxcblx0YmluZF9zZWVrYWJsZSxcblx0YmluZF9zZWVraW5nLFxuXHRiaW5kX3ZvbHVtZVxufSBmcm9tICcuL2RvbS9lbGVtZW50cy9iaW5kaW5ncy9tZWRpYS5qcyc7XG5leHBvcnQgeyBiaW5kX29ubGluZSB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL25hdmlnYXRvci5qcyc7XG5leHBvcnQgeyBiaW5kX3Byb3AgfSBmcm9tICcuL2RvbS9lbGVtZW50cy9iaW5kaW5ncy9wcm9wcy5qcyc7XG5leHBvcnQgeyBiaW5kX3NlbGVjdF92YWx1ZSwgaW5pdF9zZWxlY3QsIHNlbGVjdF9vcHRpb24gfSBmcm9tICcuL2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zZWxlY3QuanMnO1xuZXhwb3J0IHsgYmluZF9lbGVtZW50X3NpemUsIGJpbmRfcmVzaXplX29ic2VydmVyIH0gZnJvbSAnLi9kb20vZWxlbWVudHMvYmluZGluZ3Mvc2l6ZS5qcyc7XG5leHBvcnQgeyBiaW5kX3RoaXMgfSBmcm9tICcuL2RvbS9lbGVtZW50cy9iaW5kaW5ncy90aGlzLmpzJztcbmV4cG9ydCB7XG5cdGJpbmRfY29udGVudF9lZGl0YWJsZSxcblx0YmluZF9wcm9wZXJ0eSxcblx0YmluZF9mb2N1c2VkXG59IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3VuaXZlcnNhbC5qcyc7XG5leHBvcnQgeyBiaW5kX3dpbmRvd19zY3JvbGwsIGJpbmRfd2luZG93X3NpemUgfSBmcm9tICcuL2RvbS9lbGVtZW50cy9iaW5kaW5ncy93aW5kb3cuanMnO1xuZXhwb3J0IHsgaHlkcmF0ZV90ZW1wbGF0ZSwgbmV4dCwgcmVzZXQgfSBmcm9tICcuL2RvbS9oeWRyYXRpb24uanMnO1xuZXhwb3J0IHtcblx0b25jZSxcblx0cHJldmVudERlZmF1bHQsXG5cdHNlbGYsXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbixcblx0c3RvcFByb3BhZ2F0aW9uLFxuXHR0cnVzdGVkXG59IGZyb20gJy4vZG9tL2xlZ2FjeS9ldmVudC1tb2RpZmllcnMuanMnO1xuZXhwb3J0IHsgaW5pdCB9IGZyb20gJy4vZG9tL2xlZ2FjeS9saWZlY3ljbGUuanMnO1xuZXhwb3J0IHtcblx0YWRkX2xlZ2FjeV9ldmVudF9saXN0ZW5lcixcblx0YnViYmxlX2V2ZW50LFxuXHRyZWFjdGl2ZV9pbXBvcnQsXG5cdHVwZGF0ZV9sZWdhY3lfcHJvcHNcbn0gZnJvbSAnLi9kb20vbGVnYWN5L21pc2MuanMnO1xuZXhwb3J0IHtcblx0YXBwZW5kLFxuXHRjb21tZW50LFxuXHRmcm9tX2h0bWwsXG5cdGZyb21fbWF0aG1sLFxuXHRmcm9tX3N2Zyxcblx0ZnJvbV90cmVlLFxuXHR0ZXh0LFxuXHRwcm9wc19pZCxcblx0d2l0aF9zY3JpcHRcbn0gZnJvbSAnLi9kb20vdGVtcGxhdGUuanMnO1xuZXhwb3J0IHtcblx0YXN5bmNfYm9keSxcblx0Zm9yX2F3YWl0X3RyYWNrX3JlYWN0aXZpdHlfbG9zcyxcblx0cnVuLFxuXHRzYXZlLFxuXHR0cmFja19yZWFjdGl2aXR5X2xvc3MsXG5cdHJ1bl9hZnRlcl9ibG9ja2Vyc1xufSBmcm9tICcuL3JlYWN0aXZpdHkvYXN5bmMuanMnO1xuZXhwb3J0IHsgZWFnZXIsIGZsdXNoU3luYyBhcyBmbHVzaCB9IGZyb20gJy4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5leHBvcnQge1xuXHRhc3luY19kZXJpdmVkLFxuXHR1c2VyX2Rlcml2ZWQgYXMgZGVyaXZlZCxcblx0ZGVyaXZlZF9zYWZlX2VxdWFsXG59IGZyb20gJy4vcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyc7XG5leHBvcnQge1xuXHRhYm9ydGVkLFxuXHRlZmZlY3RfdHJhY2tpbmcsXG5cdGVmZmVjdF9yb290LFxuXHRsZWdhY3lfcHJlX2VmZmVjdCxcblx0bGVnYWN5X3ByZV9lZmZlY3RfcmVzZXQsXG5cdHJlbmRlcl9lZmZlY3QsXG5cdHRlbXBsYXRlX2VmZmVjdCxcblx0ZGVmZXJyZWRfdGVtcGxhdGVfZWZmZWN0LFxuXHRlZmZlY3QsXG5cdHVzZXJfZWZmZWN0LFxuXHR1c2VyX3ByZV9lZmZlY3Rcbn0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuZXhwb3J0IHsgbXV0YWJsZV9zb3VyY2UsIG11dGF0ZSwgc2V0LCBzdGF0ZSwgdXBkYXRlLCB1cGRhdGVfcHJlIH0gZnJvbSAnLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuZXhwb3J0IHtcblx0cHJvcCxcblx0cmVzdF9wcm9wcyxcblx0bGVnYWN5X3Jlc3RfcHJvcHMsXG5cdHNwcmVhZF9wcm9wcyxcblx0dXBkYXRlX3ByZV9wcm9wLFxuXHR1cGRhdGVfcHJvcFxufSBmcm9tICcuL3JlYWN0aXZpdHkvcHJvcHMuanMnO1xuZXhwb3J0IHtcblx0aW52YWxpZGF0ZV9zdG9yZSxcblx0c3RvcmVfbXV0YXRlLFxuXHRzZXR1cF9zdG9yZXMsXG5cdHN0b3JlX2dldCxcblx0c3RvcmVfc2V0LFxuXHRzdG9yZV91bnN1Yixcblx0dXBkYXRlX3ByZV9zdG9yZSxcblx0dXBkYXRlX3N0b3JlLFxuXHRtYXJrX3N0b3JlX2JpbmRpbmdcbn0gZnJvbSAnLi9yZWFjdGl2aXR5L3N0b3JlLmpzJztcbmV4cG9ydCB7IGJvdW5kYXJ5LCBwZW5kaW5nIH0gZnJvbSAnLi9kb20vYmxvY2tzL2JvdW5kYXJ5LmpzJztcbmV4cG9ydCB7IGludmFsaWRhdGVfaW5uZXJfc2lnbmFscyB9IGZyb20gJy4vbGVnYWN5LmpzJztcbmV4cG9ydCB7IHNldF90ZXh0IH0gZnJvbSAnLi9yZW5kZXIuanMnO1xuZXhwb3J0IHtcblx0Z2V0LFxuXHRzYWZlX2dldCxcblx0dGljayxcblx0dW50cmFjayxcblx0ZXhjbHVkZV9mcm9tX29iamVjdCxcblx0ZGVlcF9yZWFkLFxuXHRkZWVwX3JlYWRfc3RhdGUsXG5cdGFjdGl2ZV9lZmZlY3Rcbn0gZnJvbSAnLi9ydW50aW1lLmpzJztcbmV4cG9ydCB7IHZhbGlkYXRlX2JpbmRpbmcsIHZhbGlkYXRlX2VhY2hfa2V5cyB9IGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZXhwb3J0IHsgcmFmIH0gZnJvbSAnLi90aW1pbmcuanMnO1xuZXhwb3J0IHsgcHJveHkgfSBmcm9tICcuL3Byb3h5LmpzJztcbmV4cG9ydCB7IGNyZWF0ZV9jdXN0b21fZWxlbWVudCB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2N1c3RvbS1lbGVtZW50LmpzJztcbmV4cG9ydCB7XG5cdGNoaWxkLFxuXHRmaXJzdF9jaGlsZCxcblx0c2libGluZyxcblx0JHdpbmRvdyBhcyB3aW5kb3csXG5cdCRkb2N1bWVudCBhcyBkb2N1bWVudFxufSBmcm9tICcuL2RvbS9vcGVyYXRpb25zLmpzJztcbmV4cG9ydCB7IGF0dHIsIGNsc3ggfSBmcm9tICcuLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5leHBvcnQgeyBzbmFwc2hvdCB9IGZyb20gJy4uL3NoYXJlZC9jbG9uZS5qcyc7XG5leHBvcnQgeyBub29wLCBmYWxsYmFjaywgdG9fYXJyYXkgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuZXhwb3J0IHtcblx0aW52YWxpZF9kZWZhdWx0X3NuaXBwZXQsXG5cdHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudF90YWcsXG5cdHZhbGlkYXRlX3N0b3JlLFxuXHR2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCxcblx0cHJldmVudF9zbmlwcGV0X3N0cmluZ2lmaWNhdGlvblxufSBmcm9tICcuLi9zaGFyZWQvdmFsaWRhdGUuanMnO1xuZXhwb3J0IHsgc3RyaWN0X2VxdWFscywgZXF1YWxzIH0gZnJvbSAnLi9kZXYvZXF1YWxpdHkuanMnO1xuZXhwb3J0IHsgbG9nX2lmX2NvbnRhaW5zX3N0YXRlIH0gZnJvbSAnLi9kZXYvY29uc29sZS1sb2cuanMnO1xuZXhwb3J0IHsgaW52b2tlX2Vycm9yX2JvdW5kYXJ5IH0gZnJvbSAnLi9lcnJvci1oYW5kbGluZy5qcyc7XG4iLCAiaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi9kb20vaHlkcmF0aW9uLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGFibGUoa2V5LCBmbikge1xuXHRpZiAoIWFzeW5jX21vZGVfZmxhZykge1xuXHRcdGUuZXhwZXJpbWVudGFsX2FzeW5jX3JlcXVpcmVkKCdoeWRyYXRhYmxlJyk7XG5cdH1cblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0Y29uc3Qgc3RvcmUgPSB3aW5kb3cuX19zdmVsdGU/Lmg7XG5cblx0XHRpZiAoc3RvcmU/LmhhcyhrZXkpKSB7XG5cdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAoc3RvcmUuZ2V0KGtleSkpO1xuXHRcdH1cblxuXHRcdGlmIChERVYpIHtcblx0XHRcdGUuaHlkcmF0YWJsZV9taXNzaW5nX2J1dF9yZXF1aXJlZChrZXkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3Lmh5ZHJhdGFibGVfbWlzc2luZ19idXRfZXhwZWN0ZWQoa2V5KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZm4oKTtcbn1cbiIsICIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIENvbXBvbmVudENvbnRleHRMZWdhY3kgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL2luZGV4LmpzJyAqL1xuLyoqIEBpbXBvcnQgeyBOb3RGdW5jdGlvbiB9IGZyb20gJy4vaW50ZXJuYWwvdHlwZXMuanMnICovXG5pbXBvcnQgeyBhY3RpdmVfcmVhY3Rpb24sIHVudHJhY2sgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9ydW50aW1lLmpzJztcbmltcG9ydCB7IGlzX2FycmF5IH0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgdXNlcl9lZmZlY3QgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi9pbnRlcm5hbC9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2NvbnRleHQuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbmlmIChERVYpIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG5cdCAqL1xuXHRmdW5jdGlvbiB0aHJvd19ydW5lX2Vycm9yKHJ1bmUpIHtcblx0XHRpZiAoIShydW5lIGluIGdsb2JhbFRoaXMpKSB7XG5cdFx0XHQvLyBUT0RPIGlmIHBlb3BsZSBzdGFydCBhZGp1c3RpbmcgdGhlIFwidGhpcyBjYW4gY29udGFpbiBydW5lc1wiIGNvbmZpZyB0aHJvdWdoIHYtcC1zIG1vcmUsIGFkanVzdCB0aGlzIG1lc3NhZ2Vcblx0XHRcdC8qKiBAdHlwZSB7YW55fSAqL1xuXHRcdFx0bGV0IHZhbHVlOyAvLyBsZXQncyBob3BlIG5vb25lIG1vZGlmaWVzIHRoaXMgZ2xvYmFsLCBidXQgYmVsdHMgYW5kIGJyYWNlc1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIHJ1bmUsIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2V0dGVyLXJldHVyblxuXHRcdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGUucnVuZV9vdXRzaWRlX3N2ZWx0ZShydW5lKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiAodikgPT4ge1xuXHRcdFx0XHRcdHZhbHVlID0gdjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0dGhyb3dfcnVuZV9lcnJvcignJHN0YXRlJyk7XG5cdHRocm93X3J1bmVfZXJyb3IoJyRlZmZlY3QnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGRlcml2ZWQnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGluc3BlY3QnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJHByb3BzJyk7XG5cdHRocm93X3J1bmVfZXJyb3IoJyRiaW5kYWJsZScpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gW2BBYm9ydFNpZ25hbGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydFNpZ25hbCkgdGhhdCBhYm9ydHMgd2hlbiB0aGUgY3VycmVudCBbZGVyaXZlZF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRkZXJpdmVkKSBvciBbZWZmZWN0XShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCkgcmUtcnVucyBvciBpcyBkZXN0cm95ZWQuXG4gKlxuICogTXVzdCBiZSBjYWxsZWQgd2hpbGUgYSBkZXJpdmVkIG9yIGVmZmVjdCBpcyBydW5uaW5nLlxuICpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdD5cbiAqIFx0aW1wb3J0IHsgZ2V0QWJvcnRTaWduYWwgfSBmcm9tICdzdmVsdGUnO1xuICpcbiAqIFx0bGV0IHsgaWQgfSA9ICRwcm9wcygpO1xuICpcbiAqIFx0YXN5bmMgZnVuY3Rpb24gZ2V0RGF0YShpZCkge1xuICogXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9pdGVtcy8ke2lkfWAsIHtcbiAqIFx0XHRcdHNpZ25hbDogZ2V0QWJvcnRTaWduYWwoKVxuICogXHRcdH0pO1xuICpcbiAqIFx0XHRyZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICogXHR9XG4gKlxuICogXHRjb25zdCBkYXRhID0gJGRlcml2ZWQoYXdhaXQgZ2V0RGF0YShpZCkpO1xuICogPC9zY3JpcHQ+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFib3J0U2lnbmFsKCkge1xuXHRpZiAoYWN0aXZlX3JlYWN0aW9uID09PSBudWxsKSB7XG5cdFx0ZS5nZXRfYWJvcnRfc2lnbmFsX291dHNpZGVfcmVhY3Rpb24oKTtcblx0fVxuXG5cdHJldHVybiAoYWN0aXZlX3JlYWN0aW9uLmFjID8/PSBuZXcgQWJvcnRDb250cm9sbGVyKCkpLnNpZ25hbDtcbn1cblxuLyoqXG4gKiBgb25Nb3VudGAsIGxpa2UgW2AkZWZmZWN0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRlZmZlY3QpLCBzY2hlZHVsZXMgYSBmdW5jdGlvbiB0byBydW4gYXMgc29vbiBhcyB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgdG8gdGhlIERPTS5cbiAqIFVubGlrZSBgJGVmZmVjdGAsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBvbmx5IHJ1bnMgb25jZS5cbiAqXG4gKiBJdCBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgdGhlIGNvbXBvbmVudCdzIGluaXRpYWxpc2F0aW9uIChidXQgZG9lc24ndCBuZWVkIHRvIGxpdmUgX2luc2lkZV8gdGhlIGNvbXBvbmVudDtcbiAqIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUpLiBJZiBhIGZ1bmN0aW9uIGlzIHJldHVybmVkIF9zeW5jaHJvbm91c2x5XyBmcm9tIGBvbk1vdW50YCxcbiAqIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogYG9uTW91bnRgIGZ1bmN0aW9ucyBkbyBub3QgcnVuIGR1cmluZyBbc2VydmVyLXNpZGUgcmVuZGVyaW5nXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvc3ZlbHRlLXNlcnZlciNyZW5kZXIpLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IE5vdEZ1bmN0aW9uPFQ+IHwgUHJvbWlzZTxOb3RGdW5jdGlvbjxUPj4gfCAoKCkgPT4gYW55KX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Nb3VudChmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnb25Nb3VudCcpO1xuXHR9XG5cblx0aWYgKGxlZ2FjeV9tb2RlX2ZsYWcgJiYgY29tcG9uZW50X2NvbnRleHQubCAhPT0gbnVsbCkge1xuXHRcdGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb21wb25lbnRfY29udGV4dCkubS5wdXNoKGZuKTtcblx0fSBlbHNlIHtcblx0XHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRjb25zdCBjbGVhbnVwID0gdW50cmFjayhmbik7XG5cdFx0XHRpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHJldHVybiAvKiogQHR5cGUgeygpID0+IHZvaWR9ICovIChjbGVhbnVwKTtcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogT3V0IG9mIGBvbk1vdW50YCwgYGJlZm9yZVVwZGF0ZWAsIGBhZnRlclVwZGF0ZWAgYW5kIGBvbkRlc3Ryb3lgLCB0aGlzIGlzIHRoZVxuICogb25seSBvbmUgdGhhdCBydW5zIGluc2lkZSBhIHNlcnZlci1zaWRlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdvbkRlc3Ryb3knKTtcblx0fVxuXG5cdG9uTW91bnQoKCkgPT4gKCkgPT4gdW50cmFjayhmbikpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBbVD1hbnldXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtUfSBbZGV0YWlsXVxuICogQHBhcmFtIHthbnl9cGFyYW1zXzBcbiAqIEByZXR1cm5zIHtDdXN0b21FdmVudDxUPn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG5cdHJldHVybiBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9sZWdhY3ktb24jQ29tcG9uZW50LWV2ZW50cykuXG4gKiBFdmVudCBkaXNwYXRjaGVycyBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHRha2UgdHdvIGFyZ3VtZW50czogYG5hbWVgIGFuZCBgZGV0YWlsYC5cbiAqXG4gKiBDb21wb25lbnQgZXZlbnRzIGNyZWF0ZWQgd2l0aCBgY3JlYXRlRXZlbnREaXNwYXRjaGVyYCBjcmVhdGUgYVxuICogW0N1c3RvbUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpLlxuICogVGhlc2UgZXZlbnRzIGRvIG5vdCBbYnViYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0xlYXJuL0phdmFTY3JpcHQvQnVpbGRpbmdfYmxvY2tzL0V2ZW50cyNFdmVudF9idWJibGluZ19hbmRfY2FwdHVyZSkuXG4gKiBUaGUgYGRldGFpbGAgYXJndW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIFtDdXN0b21FdmVudC5kZXRhaWxdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9kZXRhaWwpXG4gKiBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YS5cbiAqXG4gKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBjYW4gYmUgdHlwZWQgdG8gbmFycm93IHRoZSBhbGxvd2VkIGV2ZW50IG5hbWVzIGFuZCB0aGUgdHlwZSBvZiB0aGUgYGRldGFpbGAgYXJndW1lbnQ6XG4gKiBgYGB0c1xuICogY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXI8e1xuICogIGxvYWRlZDogbnVsbDsgLy8gZG9lcyBub3QgdGFrZSBhIGRldGFpbCBhcmd1bWVudFxuICogIGNoYW5nZTogc3RyaW5nOyAvLyB0YWtlcyBhIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZywgd2hpY2ggaXMgcmVxdWlyZWRcbiAqICBvcHRpb25hbDogbnVtYmVyIHwgbnVsbDsgLy8gdGFrZXMgYW4gb3B0aW9uYWwgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgbnVtYmVyXG4gKiB9PigpO1xuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGNhbGxiYWNrIHByb3BzIGFuZC9vciB0aGUgYCRob3N0KClgIHJ1bmUgaW5zdGVhZCBcdTIwMTQgc2VlIFttaWdyYXRpb24gZ3VpZGVdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS92NS1taWdyYXRpb24tZ3VpZGUjRXZlbnQtY2hhbmdlcy1Db21wb25lbnQtZXZlbnRzKVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRNYXAgPSBhbnldXG4gKiBAcmV0dXJucyB7RXZlbnREaXNwYXRjaGVyPEV2ZW50TWFwPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcblx0Y29uc3QgYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdGlmIChhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnY3JlYXRlRXZlbnREaXNwYXRjaGVyJyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIFtkZXRhaWxdXG5cdCAqIEBwYXJhbSBbb3B0aW9uc11cblx0ICovXG5cdHJldHVybiAodHlwZSwgZGV0YWlsLCBvcHRpb25zKSA9PiB7XG5cdFx0Y29uc3QgZXZlbnRzID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbiB8IEZ1bmN0aW9uW10+fSAqLyAoXG5cdFx0XHRhY3RpdmVfY29tcG9uZW50X2NvbnRleHQucy4kJGV2ZW50c1xuXHRcdCk/LlsvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpXTtcblxuXHRcdGlmIChldmVudHMpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGlzX2FycmF5KGV2ZW50cykgPyBldmVudHMuc2xpY2UoKSA6IFtldmVudHNdO1xuXHRcdFx0Ly8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuXHRcdFx0Ly8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuXHRcdFx0Y29uc3QgZXZlbnQgPSBjcmVhdGVfY3VzdG9tX2V2ZW50KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGRldGFpbCwgb3B0aW9ucyk7XG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIGNhbGxiYWNrcykge1xuXHRcdFx0XHRmbi5jYWxsKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC54LCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5cbi8vIFRPRE8gbWFyayBiZWZvcmVVcGRhdGUgYW5kIGFmdGVyVXBkYXRlIGFzIGRlcHJlY2F0ZWQgaW4gU3ZlbHRlIDZcblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZCBhZnRlciBhbnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYmVmb3JlIHRoZSBpbml0aWFsIGBvbk1vdW50YC5cbiAqXG4gKiBJbiBydW5lcyBtb2RlIHVzZSBgJGVmZmVjdC5wcmVgIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIFtgJGVmZmVjdC5wcmVgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCMkZWZmZWN0LnByZSkgaW5zdGVhZFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ2JlZm9yZVVwZGF0ZScpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudF9jb250ZXh0LmwgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9sZWdhY3lfb25seSgnYmVmb3JlVXBkYXRlJyk7XG5cdH1cblxuXHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLmIucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YC5cbiAqXG4gKiBJbiBydW5lcyBtb2RlIHVzZSBgJGVmZmVjdGAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2AkZWZmZWN0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRlZmZlY3QpIGluc3RlYWRcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ2FmdGVyVXBkYXRlJyk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX2xlZ2FjeV9vbmx5KCdhZnRlclVwZGF0ZScpO1xuXHR9XG5cblx0aW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbXBvbmVudF9jb250ZXh0KS5hLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIExlZ2FjeS1tb2RlOiBJbml0IGNhbGxiYWNrcyBvYmplY3QgZm9yIG9uTW91bnQvYmVmb3JlVXBkYXRlL2FmdGVyVXBkYXRlXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHR9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbnRleHQpIHtcblx0dmFyIGwgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb250ZXh0KS5sO1xuXHRyZXR1cm4gKGwudSA/Pz0geyBhOiBbXSwgYjogW10sIG06IFtdIH0pO1xufVxuXG5leHBvcnQgeyBmbHVzaFN5bmMsIGZvcmsgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2JhdGNoLmpzJztcbmV4cG9ydCB7XG5cdGNyZWF0ZUNvbnRleHQsXG5cdGdldENvbnRleHQsXG5cdGdldEFsbENvbnRleHRzLFxuXHRoYXNDb250ZXh0LFxuXHRzZXRDb250ZXh0XG59IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2NvbnRleHQuanMnO1xuZXhwb3J0IHsgaHlkcmF0YWJsZSB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2h5ZHJhdGFibGUuanMnO1xuZXhwb3J0IHsgaHlkcmF0ZSwgbW91bnQsIHVubW91bnQgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9yZW5kZXIuanMnO1xuZXhwb3J0IHsgdGljaywgdW50cmFjaywgc2V0dGxlZCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuZXhwb3J0IHsgY3JlYXRlUmF3U25pcHBldCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc25pcHBldC5qcyc7XG4iLCAiLyoqIEBpbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJy4vcHVibGljJyAqL1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uL2luZGV4LWNsaWVudC5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vaW50ZXJuYWwvc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZTxUPiB8IG51bGwgfCB1bmRlZmluZWR9IHN0b3JlXG4gKiBAcGFyYW0geyh2YWx1ZTogVCkgPT4gdm9pZH0gcnVuXG4gKiBAcGFyYW0geyh2YWx1ZTogVCkgPT4gdm9pZH0gW2ludmFsaWRhdGVdXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZV90b19zdG9yZShzdG9yZSwgcnVuLCBpbnZhbGlkYXRlKSB7XG5cdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHJ1bih1bmRlZmluZWQpO1xuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGlmIChpbnZhbGlkYXRlKSBpbnZhbGlkYXRlKHVuZGVmaW5lZCk7XG5cblx0XHRyZXR1cm4gbm9vcDtcblx0fVxuXG5cdC8vIFN2ZWx0ZSBzdG9yZSB0YWtlcyBhIHByaXZhdGUgc2Vjb25kIGFyZ3VtZW50XG5cdC8vIFN0YXJ0U3RvcE5vdGlmaWVyIGNvdWxkIG11dGF0ZSBzdGF0ZSwgYW5kIHdlIHdhbnQgdG8gc2lsZW5jZSB0aGUgY29ycmVzcG9uZGluZyB2YWxpZGF0aW9uIGVycm9yXG5cdGNvbnN0IHVuc3ViID0gdW50cmFjaygoKSA9PlxuXHRcdHN0b3JlLnN1YnNjcmliZShcblx0XHRcdHJ1bixcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGludmFsaWRhdGVcblx0XHQpXG5cdCk7XG5cblx0Ly8gQWxzbyBzdXBwb3J0IFJ4SlNcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGZpeCB0aGlzIGluIHRoZSB0eXBlcz9cblx0cmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuIiwgImltcG9ydCB7IEhZRFJBVElPTl9FTkQsIEhZRFJBVElPTl9TVEFSVCwgSFlEUkFUSU9OX1NUQVJUX0VMU0UgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuXG5leHBvcnQgY29uc3QgQkxPQ0tfT1BFTiA9IGA8IS0tJHtIWURSQVRJT05fU1RBUlR9LS0+YDtcbmV4cG9ydCBjb25zdCBCTE9DS19PUEVOX0VMU0UgPSBgPCEtLSR7SFlEUkFUSU9OX1NUQVJUX0VMU0V9LS0+YDtcbmV4cG9ydCBjb25zdCBCTE9DS19DTE9TRSA9IGA8IS0tJHtIWURSQVRJT05fRU5EfS0tPmA7XG5leHBvcnQgY29uc3QgRU1QVFlfQ09NTUVOVCA9IGA8IS0tLS0+YDtcbiIsICJpbXBvcnQgeyBTVEFMRV9SRUFDVElPTiB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcblxuLyoqIEB0eXBlIHtBYm9ydENvbnRyb2xsZXIgfCBudWxsfSAqL1xubGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gYWJvcnQoKSB7XG5cdGNvbnRyb2xsZXI/LmFib3J0KFNUQUxFX1JFQUNUSU9OKTtcblx0Y29udHJvbGxlciA9IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBYm9ydFNpZ25hbCgpIHtcblx0cmV0dXJuIChjb250cm9sbGVyID8/PSBuZXcgQWJvcnRDb250cm9sbGVyKCkpLnNpZ25hbDtcbn1cbiIsICIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmV4cG9ydCAqICBmcm9tICcuLi9zaGFyZWQvZXJyb3JzLmpzJztcblxuLyoqXG4gKiBUaGUgbm9kZSBBUEkgYEFzeW5jTG9jYWxTdG9yYWdlYCBpcyBub3QgYXZhaWxhYmxlLCBidXQgaXMgcmVxdWlyZWQgdG8gdXNlIGFzeW5jIHNlcnZlciByZW5kZXJpbmcuXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3luY19sb2NhbF9zdG9yYWdlX3VuYXZhaWxhYmxlKCkge1xuXHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYXN5bmNfbG9jYWxfc3RvcmFnZV91bmF2YWlsYWJsZVxcblRoZSBub2RlIEFQSSBcXGBBc3luY0xvY2FsU3RvcmFnZVxcYCBpcyBub3QgYXZhaWxhYmxlLCBidXQgaXMgcmVxdWlyZWQgdG8gdXNlIGFzeW5jIHNlcnZlciByZW5kZXJpbmcuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXN5bmNfbG9jYWxfc3RvcmFnZV91bmF2YWlsYWJsZWApO1xuXG5cdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHR0aHJvdyBlcnJvcjtcbn1cblxuLyoqXG4gKiBFbmNvdW50ZXJlZCBhc3luY2hyb25vdXMgd29yayB3aGlsZSByZW5kZXJpbmcgc3luY2hyb25vdXNseS5cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF3YWl0X2ludmFsaWQoKSB7XG5cdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBhd2FpdF9pbnZhbGlkXFxuRW5jb3VudGVyZWQgYXN5bmNocm9ub3VzIHdvcmsgd2hpbGUgcmVuZGVyaW5nIHN5bmNocm9ub3VzbHkuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXdhaXRfaW52YWxpZGApO1xuXG5cdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHR0aHJvdyBlcnJvcjtcbn1cblxuLyoqXG4gKiBUaGUgYGh0bWxgIHByb3BlcnR5IG9mIHNlcnZlciByZW5kZXIgcmVzdWx0cyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgYGJvZHlgIGluc3RlYWQuXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodG1sX2RlcHJlY2F0ZWQoKSB7XG5cdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBodG1sX2RlcHJlY2F0ZWRcXG5UaGUgXFxgaHRtbFxcYCBwcm9wZXJ0eSBvZiBzZXJ2ZXIgcmVuZGVyIHJlc3VsdHMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFxcYGJvZHlcXGAgaW5zdGVhZC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9odG1sX2RlcHJlY2F0ZWRgKTtcblxuXHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0dGhyb3cgZXJyb3I7XG59XG5cbi8qKlxuICogQXR0ZW1wdGVkIHRvIHNldCBgaHlkcmF0YWJsZWAgd2l0aCBrZXkgYCVrZXklYCB0d2ljZSB3aXRoIGRpZmZlcmVudCB2YWx1ZXMuXG4gKiBcbiAqICVzdGFjayVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja1xuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0YWJsZV9jbG9iYmVyaW5nKGtleSwgc3RhY2spIHtcblx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGh5ZHJhdGFibGVfY2xvYmJlcmluZ1xcbkF0dGVtcHRlZCB0byBzZXQgXFxgaHlkcmF0YWJsZVxcYCB3aXRoIGtleSBcXGAke2tleX1cXGAgdHdpY2Ugd2l0aCBkaWZmZXJlbnQgdmFsdWVzLlxuXG4ke3N0YWNrfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGFibGVfY2xvYmJlcmluZ2ApO1xuXG5cdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHR0aHJvdyBlcnJvcjtcbn1cblxuLyoqXG4gKiBGYWlsZWQgdG8gc2VyaWFsaXplIGBoeWRyYXRhYmxlYCBkYXRhIGZvciBrZXkgYCVrZXklYC5cbiAqIFxuICogYGh5ZHJhdGFibGVgIGNhbiBzZXJpYWxpemUgYW55dGhpbmcgW2B1bmV2YWxgIGZyb20gYGRldmFsdWVgXShodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL3VuZXZhbCkgY2FuLCBwbHVzIFByb21pc2VzLlxuICogXG4gKiBDYXVzZTpcbiAqICVzdGFjayVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja1xuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0YWJsZV9zZXJpYWxpemF0aW9uX2ZhaWxlZChrZXksIHN0YWNrKSB7XG5cdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBoeWRyYXRhYmxlX3NlcmlhbGl6YXRpb25fZmFpbGVkXFxuRmFpbGVkIHRvIHNlcmlhbGl6ZSBcXGBoeWRyYXRhYmxlXFxgIGRhdGEgZm9yIGtleSBcXGAke2tleX1cXGAuXG5cblxcYGh5ZHJhdGFibGVcXGAgY2FuIHNlcmlhbGl6ZSBhbnl0aGluZyBbXFxgdW5ldmFsXFxgIGZyb20gXFxgZGV2YWx1ZVxcYF0oaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS91bmV2YWwpIGNhbiwgcGx1cyBQcm9taXNlcy5cblxuQ2F1c2U6XG4ke3N0YWNrfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGFibGVfc2VyaWFsaXphdGlvbl9mYWlsZWRgKTtcblxuXHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0dGhyb3cgZXJyb3I7XG59XG5cbi8qKlxuICogYCVuYW1lJSguLi4pYCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfZnVuY3Rpb25fdW5hdmFpbGFibGUobmFtZSkge1xuXHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgbGlmZWN5Y2xlX2Z1bmN0aW9uX3VuYXZhaWxhYmxlXFxuXFxgJHtuYW1lfSguLi4pXFxgIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHNlcnZlclxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9mdW5jdGlvbl91bmF2YWlsYWJsZWApO1xuXG5cdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHR0aHJvdyBlcnJvcjtcbn1cblxuLyoqXG4gKiBDb3VsZCBub3QgcmVzb2x2ZSBgcmVuZGVyYCBjb250ZXh0LlxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VydmVyX2NvbnRleHRfcmVxdWlyZWQoKSB7XG5cdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzZXJ2ZXJfY29udGV4dF9yZXF1aXJlZFxcbkNvdWxkIG5vdCByZXNvbHZlIFxcYHJlbmRlclxcYCBjb250ZXh0Llxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3NlcnZlcl9jb250ZXh0X3JlcXVpcmVkYCk7XG5cblx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdHRocm93IGVycm9yO1xufSIsICIvKiogQGltcG9ydCB7IFNTUkNvbnRleHQgfSBmcm9tICcjc2VydmVyJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcblxuLyoqIEB0eXBlIHtTU1JDb250ZXh0IHwgbnVsbH0gKi9cbmV4cG9ydCB2YXIgc3NyX2NvbnRleHQgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtTU1JDb250ZXh0IHwgbnVsbH0gdiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zc3JfY29udGV4dCh2KSB7XG5cdHNzcl9jb250ZXh0ID0gdjtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHJldHVybnMge1soKSA9PiBULCAoY29udGV4dDogVCkgPT4gVF19XG4gKiBAc2luY2UgNS40MC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xuXHRjb25zdCBrZXkgPSB7fTtcblx0cmV0dXJuIFsoKSA9PiBnZXRDb250ZXh0KGtleSksIChjb250ZXh0KSA9PiBzZXRDb250ZXh0KGtleSwgY29udGV4dCldO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG5cdGNvbnN0IGNvbnRleHRfbWFwID0gZ2V0X29yX2luaXRfY29udGV4dF9tYXAoJ2dldENvbnRleHQnKTtcblx0Y29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHtUfSAqLyAoY29udGV4dF9tYXAuZ2V0KGtleSkpO1xuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEBwYXJhbSB7VH0gY29udGV4dFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuXHRnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnc2V0Q29udGV4dCcpLnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG5cdHJldHVybiBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnaGFzQ29udGV4dCcpLmhhcyhrZXkpO1xufVxuXG4vKiogQHJldHVybnMge01hcDxhbnksIGFueT59ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG5cdHJldHVybiBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnZ2V0QWxsQ29udGV4dHMnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge01hcDx1bmtub3duLCB1bmtub3duPn1cbiAqL1xuZnVuY3Rpb24gZ2V0X29yX2luaXRfY29udGV4dF9tYXAobmFtZSkge1xuXHRpZiAoc3NyX2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudChuYW1lKTtcblx0fVxuXG5cdHJldHVybiAoc3NyX2NvbnRleHQuYyA/Pz0gbmV3IE1hcChnZXRfcGFyZW50X2NvbnRleHQoc3NyX2NvbnRleHQpIHx8IHVuZGVmaW5lZCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1c2goZm4pIHtcblx0c3NyX2NvbnRleHQgPSB7IHA6IHNzcl9jb250ZXh0LCBjOiBudWxsLCByOiBudWxsIH07XG5cblx0aWYgKERFVikge1xuXHRcdHNzcl9jb250ZXh0LmZ1bmN0aW9uID0gZm47XG5cdFx0c3NyX2NvbnRleHQuZWxlbWVudCA9IHNzcl9jb250ZXh0LnA/LmVsZW1lbnQ7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcCgpIHtcblx0c3NyX2NvbnRleHQgPSAvKiogQHR5cGUge1NTUkNvbnRleHR9ICovIChzc3JfY29udGV4dCkucDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NTUkNvbnRleHR9IHNzcl9jb250ZXh0XG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0X3BhcmVudF9jb250ZXh0KHNzcl9jb250ZXh0KSB7XG5cdGxldCBwYXJlbnQgPSBzc3JfY29udGV4dC5wO1xuXG5cdHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRjb25zdCBjb250ZXh0X21hcCA9IHBhcmVudC5jO1xuXHRcdGlmIChjb250ZXh0X21hcCAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHRfbWFwO1xuXHRcdH1cblx0XHRwYXJlbnQgPSBwYXJlbnQucDtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFdyYXBzIGFuIGBhd2FpdGAgZXhwcmVzc2lvbiBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGNvbXBvbmVudCBjb250ZXh0IHRoYXQgd2FzXG4gKiBhY3RpdmUgYmVmb3JlIHRoZSBleHByZXNzaW9uIGV2YWx1YXRlZCBjYW4gYmUgcmVhcHBsaWVkIGFmdGVyd2FyZHMgXHUyMDE0XG4gKiBgYXdhaXQgYSArIGIoKWAgYmVjb21lcyBgKGF3YWl0ICQuc2F2ZShhKSkoKSArIGIoKWAsIG1lYW5pbmcgYGIoKWAgd2lsbCBoYXZlIGFjY2Vzc1xuICogdG8gdGhlIGNvbnRleHQgb2YgaXRzIGNvbXBvbmVudC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1Byb21pc2U8VD59IHByb21pc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPCgpID0+IFQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZShwcm9taXNlKSB7XG5cdHZhciBwcmV2aW91c19jb250ZXh0ID0gc3NyX2NvbnRleHQ7XG5cdHZhciB2YWx1ZSA9IGF3YWl0IHByb21pc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRzc3JfY29udGV4dCA9IHByZXZpb3VzX2NvbnRleHQ7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xufVxuIiwgIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbnZhciBib2xkID0gJ2ZvbnQtd2VpZ2h0OiBib2xkJztcbnZhciBub3JtYWwgPSAnZm9udC13ZWlnaHQ6IG5vcm1hbCc7XG5cbi8qKlxuICogQSBgaHlkcmF0YWJsZWAgdmFsdWUgd2l0aCBrZXkgYCVrZXklYCB3YXMgY3JlYXRlZCwgYnV0IGF0IGxlYXN0IHBhcnQgb2YgaXQgd2FzIG5vdCB1c2VkIGR1cmluZyB0aGUgcmVuZGVyLlxuICogXG4gKiBUaGUgYGh5ZHJhdGFibGVgIHdhcyBpbml0aWFsaXplZCBpbjpcbiAqICVzdGFjayVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW5yZXNvbHZlZF9oeWRyYXRhYmxlKGtleSwgc3RhY2spIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGAlY1tzdmVsdGVdIHVucmVzb2x2ZWRfaHlkcmF0YWJsZVxcbiVjQSBcXGBoeWRyYXRhYmxlXFxgIHZhbHVlIHdpdGgga2V5IFxcYCR7a2V5fVxcYCB3YXMgY3JlYXRlZCwgYnV0IGF0IGxlYXN0IHBhcnQgb2YgaXQgd2FzIG5vdCB1c2VkIGR1cmluZyB0aGUgcmVuZGVyLlxuXG5UaGUgXFxgaHlkcmF0YWJsZVxcYCB3YXMgaW5pdGlhbGl6ZWQgaW46XG4ke3N0YWNrfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3VucmVzb2x2ZWRfaHlkcmF0YWJsZWAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3VucmVzb2x2ZWRfaHlkcmF0YWJsZWApO1xuXHR9XG59IiwgIi8vIEB0cy1pZ25vcmUgLS0gd2UgZG9uJ3QgaW5jbHVkZSBub2RlIHR5cGVzIGluIHRoZSBwcm9kdWN0aW9uIGJ1aWxkXG4vKiogQGltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlIH0gZnJvbSAnbm9kZTphc3luY19ob29rcycgKi9cbi8qKiBAaW1wb3J0IHsgUmVuZGVyQ29udGV4dCB9IGZyb20gJyNzZXJ2ZXInICovXG5cbmltcG9ydCB7IGRlZmVycmVkIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuXG4vKiogQHR5cGUge1Byb21pc2U8dm9pZD4gfCBudWxsfSAqL1xubGV0IGN1cnJlbnRfcmVuZGVyID0gbnVsbDtcblxuLyoqIEB0eXBlIHtSZW5kZXJDb250ZXh0IHwgbnVsbH0gKi9cbmxldCBjb250ZXh0ID0gbnVsbDtcblxuLyoqIEByZXR1cm5zIHtSZW5kZXJDb250ZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9yZW5kZXJfY29udGV4dCgpIHtcblx0Y29uc3Qgc3RvcmUgPSBjb250ZXh0ID8/IGFscz8uZ2V0U3RvcmUoKTtcblxuXHRpZiAoIXN0b3JlKSB7XG5cdFx0ZS5zZXJ2ZXJfY29udGV4dF9yZXF1aXJlZCgpO1xuXHR9XG5cblx0cmV0dXJuIHN0b3JlO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFByb21pc2U8VD59IGZuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdpdGhfcmVuZGVyX2NvbnRleHQoZm4pIHtcblx0Y29udGV4dCA9IHtcblx0XHRoeWRyYXRhYmxlOiB7XG5cdFx0XHRsb29rdXA6IG5ldyBNYXAoKSxcblx0XHRcdGNvbXBhcmlzb25zOiBbXSxcblx0XHRcdHVucmVzb2x2ZWRfcHJvbWlzZXM6IG5ldyBNYXAoKVxuXHRcdH1cblx0fTtcblxuXHRpZiAoaW5fd2ViY29udGFpbmVyKCkpIHtcblx0XHRjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGRlZmVycmVkKCk7XG5cdFx0Y29uc3QgcHJldmlvdXNfcmVuZGVyID0gY3VycmVudF9yZW5kZXI7XG5cdFx0Y3VycmVudF9yZW5kZXIgPSBwcm9taXNlO1xuXHRcdGF3YWl0IHByZXZpb3VzX3JlbmRlcjtcblx0XHRyZXR1cm4gZm4oKS5maW5hbGx5KHJlc29sdmUpO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAoYWxzID09PSBudWxsKSB7XG5cdFx0XHRlLmFzeW5jX2xvY2FsX3N0b3JhZ2VfdW5hdmFpbGFibGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFscy5ydW4oY29udGV4dCwgZm4pO1xuXHR9IGZpbmFsbHkge1xuXHRcdGNvbnRleHQgPSBudWxsO1xuXHR9XG59XG5cbi8qKiBAdHlwZSB7QXN5bmNMb2NhbFN0b3JhZ2U8UmVuZGVyQ29udGV4dCB8IG51bGw+IHwgbnVsbH0gKi9cbmxldCBhbHMgPSBudWxsO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdF9yZW5kZXJfY29udGV4dCgpIHtcblx0aWYgKGFscyAhPT0gbnVsbCkgcmV0dXJuO1xuXHR0cnkge1xuXHRcdC8vIEB0cy1pZ25vcmUgLS0gd2UgZG9uJ3QgaW5jbHVkZSBub2RlIHR5cGVzIGluIHRoZSBwcm9kdWN0aW9uIGJ1aWxkXG5cdFx0Y29uc3QgeyBBc3luY0xvY2FsU3RvcmFnZSB9ID0gYXdhaXQgaW1wb3J0KCdub2RlOmFzeW5jX2hvb2tzJyk7XG5cdFx0YWxzID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlKCk7XG5cdH0gY2F0Y2gge31cbn1cblxuLy8gdGhpcyBoYXMgdG8gYmUgYSBmdW5jdGlvbiBiZWNhdXNlIHJvbGx1cCB3b24ndCB0cmVlc2hha2UgaXQgaWYgaXQncyBhIGNvbnN0YW50XG5mdW5jdGlvbiBpbl93ZWJjb250YWluZXIoKSB7XG5cdC8vIEB0cy1pZ25vcmUgLS0gdGhpcyB3aWxsIGZhaWwgd2hlbiB3ZSBydW4gdHlwZWNoZWNrIGJlY2F1c2Ugd2UgZXhjbHVkZSBub2RlIHR5cGVzXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuL3ByZWZlci1nbG9iYWwvcHJvY2Vzc1xuXHRyZXR1cm4gISFnbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy53ZWJjb250YWluZXI7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdzdmVsdGUnICovXG4vKiogQGltcG9ydCB7IEh5ZHJhdGFibGVDb250ZXh0LCBSZW5kZXJPdXRwdXQsIFNTUkNvbnRleHQsIFN5bmNSZW5kZXJPdXRwdXQgfSBmcm9tICcuL3R5cGVzLmpzJyAqL1xuLyoqIEBpbXBvcnQgeyBNYXliZVByb21pc2UgfSBmcm9tICcjc2hhcmVkJyAqL1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgYWJvcnQgfSBmcm9tICcuL2Fib3J0LXNpZ25hbC5qcyc7XG5pbXBvcnQgeyBwb3AsIHB1c2gsIHNldF9zc3JfY29udGV4dCwgc3NyX2NvbnRleHQsIHNhdmUgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgQkxPQ0tfQ0xPU0UsIEJMT0NLX09QRU4gfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBhdHRyaWJ1dGVzIH0gZnJvbSAnLi9pbmRleC5qcyc7XG5pbXBvcnQgeyBnZXRfcmVuZGVyX2NvbnRleHQsIHdpdGhfcmVuZGVyX2NvbnRleHQsIGluaXRfcmVuZGVyX2NvbnRleHQgfSBmcm9tICcuL3JlbmRlci1jb250ZXh0LmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKiogQHR5cGVkZWYgeydoZWFkJyB8ICdib2R5J30gUmVuZGVyZXJUeXBlICovXG4vKiogQHR5cGVkZWYge3sgW2tleSBpbiBSZW5kZXJlclR5cGVdOiBzdHJpbmcgfX0gQWNjdW11bGF0ZWRDb250ZW50ICovXG5cbi8qKlxuICogQHR5cGVkZWYge3N0cmluZyB8IFJlbmRlcmVyfSBSZW5kZXJlckl0ZW1cbiAqL1xuXG4vKipcbiAqIFJlbmRlcmVycyBhcmUgYmFzaWNhbGx5IGEgdHJlZSBvZiBgc3RyaW5nIHwgUmVuZGVyZXJgcywgd2hlcmUgZWFjaCBgUmVuZGVyZXJgIGluIHRoZSB0cmVlIHJlcHJlc2VudHNcbiAqIHdvcmsgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGNvbXBsZXRlZC4gQSByZW5kZXJlciBjYW4gYmUge0BsaW5rIGNvbGxlY3R9ZWQgdG8gYWdncmVnYXRlIHRoZVxuICogY29udGVudCBmcm9tIGl0c2VsZiBhbmQgYWxsIG9mIGl0cyBjaGlsZHJlbiwgYnV0IHRoaXMgd2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGNoaWxkcmVuIGFyZVxuICogcGVyZm9ybWluZyBhc3luY2hyb25vdXMgd29yay4gVG8gYXN5bmNocm9ub3VzbHkgY29sbGVjdCBhIHJlbmRlcmVyLCBqdXN0IGBhd2FpdGAgaXQuXG4gKlxuICogVGhlIGBzdHJpbmdgIHZhbHVlcyB3aXRoaW4gYSByZW5kZXJlciBhcmUgYWx3YXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUge0BsaW5rIHR5cGV9IG9mIHRoYXQgcmVuZGVyZXIuIFRvIHN3aXRjaCB0eXBlcyxcbiAqIGNhbGwge0BsaW5rIGNoaWxkfSB3aXRoIGEgZGlmZmVyZW50IGB0eXBlYCBhcmd1bWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIHtcblx0LyoqXG5cdCAqIFRoZSBjb250ZW50cyBvZiB0aGUgcmVuZGVyZXIuXG5cdCAqIEB0eXBlIHtSZW5kZXJlckl0ZW1bXX1cblx0ICovXG5cdCNvdXQgPSBbXTtcblxuXHQvKipcblx0ICogQW55IGBvbkRlc3Ryb3lgIGNhbGxiYWNrcyByZWdpc3RlcmVkIGR1cmluZyBleGVjdXRpb24gb2YgdGhpcyByZW5kZXJlci5cblx0ICogQHR5cGUgeygoKSA9PiB2b2lkKVtdIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0I29uX2Rlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhpcyByZW5kZXJlciBpcyBhIGNvbXBvbmVudCBib2R5LlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICovXG5cdCNpc19jb21wb25lbnRfYm9keSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgdHlwZSBvZiBzdHJpbmcgY29udGVudCB0aGF0IHRoaXMgcmVuZGVyZXIgaXMgYWNjdW11bGF0aW5nLlxuXHQgKiBAdHlwZSB7UmVuZGVyZXJUeXBlfVxuXHQgKi9cblx0dHlwZTtcblxuXHQvKiogQHR5cGUge1JlbmRlcmVyIHwgdW5kZWZpbmVkfSAqL1xuXHQjcGFyZW50O1xuXG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXMgd29yayBhc3NvY2lhdGVkIHdpdGggdGhpcyByZW5kZXJlclxuXHQgKiBAdHlwZSB7UHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZH1cblx0ICovXG5cdHByb21pc2UgPSB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFN0YXRlIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29udGVudCB0cmVlIGFzIGEgd2hvbGUuXG5cdCAqIEl0IHdpbGwgYmUgcmUtZXhwb3NlZCwgdW5jb3BpZWQsIG9uIGFsbCBjaGlsZHJlbi5cblx0ICogQHR5cGUge1NTUlN0YXRlfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdGdsb2JhbDtcblxuXHQvKipcblx0ICogU3RhdGUgdGhhdCBpcyBsb2NhbCB0byB0aGUgYnJhbmNoIGl0IGlzIGRlY2xhcmVkIGluLlxuXHQgKiBJdCB3aWxsIGJlIHNoYWxsb3ctY29waWVkIHRvIGFsbCBjaGlsZHJlbi5cblx0ICpcblx0ICogQHR5cGUge3sgc2VsZWN0X3ZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQgfX1cblx0ICovXG5cdGxvY2FsO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NTUlN0YXRlfSBnbG9iYWxcblx0ICogQHBhcmFtIHtSZW5kZXJlciB8IHVuZGVmaW5lZH0gW3BhcmVudF1cblx0ICovXG5cdGNvbnN0cnVjdG9yKGdsb2JhbCwgcGFyZW50KSB7XG5cdFx0dGhpcy4jcGFyZW50ID0gcGFyZW50O1xuXG5cdFx0dGhpcy5nbG9iYWwgPSBnbG9iYWw7XG5cdFx0dGhpcy5sb2NhbCA9IHBhcmVudCA/IHsgLi4ucGFyZW50LmxvY2FsIH0gOiB7IHNlbGVjdF92YWx1ZTogdW5kZWZpbmVkIH07XG5cdFx0dGhpcy50eXBlID0gcGFyZW50ID8gcGFyZW50LnR5cGUgOiAnYm9keSc7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHsocmVuZGVyZXI6IFJlbmRlcmVyKSA9PiB2b2lkfSBmblxuXHQgKi9cblx0aGVhZChmbikge1xuXHRcdGNvbnN0IGhlYWQgPSBuZXcgUmVuZGVyZXIodGhpcy5nbG9iYWwsIHRoaXMpO1xuXHRcdGhlYWQudHlwZSA9ICdoZWFkJztcblxuXHRcdHRoaXMuI291dC5wdXNoKGhlYWQpO1xuXHRcdGhlYWQuY2hpbGQoZm4pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZTx2b2lkPj59IGJsb2NrZXJzXG5cdCAqIEBwYXJhbSB7KHJlbmRlcmVyOiBSZW5kZXJlcikgPT4gdm9pZH0gZm5cblx0ICovXG5cdGFzeW5jX2Jsb2NrKGJsb2NrZXJzLCBmbikge1xuXHRcdHRoaXMuI291dC5wdXNoKEJMT0NLX09QRU4pO1xuXHRcdHRoaXMuYXN5bmMoYmxvY2tlcnMsIGZuKTtcblx0XHR0aGlzLiNvdXQucHVzaChCTE9DS19DTE9TRSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtBcnJheTxQcm9taXNlPHZvaWQ+Pn0gYmxvY2tlcnNcblx0ICogQHBhcmFtIHsocmVuZGVyZXI6IFJlbmRlcmVyKSA9PiB2b2lkfSBmblxuXHQgKi9cblx0YXN5bmMoYmxvY2tlcnMsIGZuKSB7XG5cdFx0bGV0IGNhbGxiYWNrID0gZm47XG5cblx0XHRpZiAoYmxvY2tlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29uc3QgY29udGV4dCA9IHNzcl9jb250ZXh0O1xuXG5cdFx0XHRjYWxsYmFjayA9IChyZW5kZXJlcikgPT4ge1xuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoYmxvY2tlcnMpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHByZXZpb3VzX2NvbnRleHQgPSBzc3JfY29udGV4dDtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRzZXRfc3NyX2NvbnRleHQoY29udGV4dCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4ocmVuZGVyZXIpO1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRzZXRfc3NyX2NvbnRleHQocHJldmlvdXNfY29udGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dGhpcy5jaGlsZChjYWxsYmFjayk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtBcnJheTwoKSA9PiB2b2lkPn0gdGh1bmtzXG5cdCAqL1xuXHRydW4odGh1bmtzKSB7XG5cdFx0Y29uc3QgY29udGV4dCA9IHNzcl9jb250ZXh0O1xuXG5cdFx0bGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGh1bmtzWzBdKCkpO1xuXHRcdGNvbnN0IHByb21pc2VzID0gW3Byb21pc2VdO1xuXG5cdFx0Zm9yIChjb25zdCBmbiBvZiB0aHVua3Muc2xpY2UoMSkpIHtcblx0XHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBwcmV2aW91c19jb250ZXh0ID0gc3NyX2NvbnRleHQ7XG5cdFx0XHRcdHNldF9zc3JfY29udGV4dChjb250ZXh0KTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBmbigpO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdHNldF9zc3JfY29udGV4dChwcmV2aW91c19jb250ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb21pc2VzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGNoaWxkIHJlbmRlcmVyLiBUaGUgY2hpbGQgcmVuZGVyZXIgaW5oZXJpdHMgdGhlIHN0YXRlIGZyb20gdGhlIHBhcmVudCxcblx0ICogYnV0IGhhcyBpdHMgb3duIGNvbnRlbnQuXG5cdCAqIEBwYXJhbSB7KHJlbmRlcmVyOiBSZW5kZXJlcikgPT4gTWF5YmVQcm9taXNlPHZvaWQ+fSBmblxuXHQgKi9cblx0Y2hpbGQoZm4pIHtcblx0XHRjb25zdCBjaGlsZCA9IG5ldyBSZW5kZXJlcih0aGlzLmdsb2JhbCwgdGhpcyk7XG5cdFx0dGhpcy4jb3V0LnB1c2goY2hpbGQpO1xuXG5cdFx0Y29uc3QgcGFyZW50ID0gc3NyX2NvbnRleHQ7XG5cblx0XHRzZXRfc3NyX2NvbnRleHQoe1xuXHRcdFx0Li4uc3NyX2NvbnRleHQsXG5cdFx0XHRwOiBwYXJlbnQsXG5cdFx0XHRjOiBudWxsLFxuXHRcdFx0cjogY2hpbGRcblx0XHR9KTtcblxuXHRcdGNvbnN0IHJlc3VsdCA9IGZuKGNoaWxkKTtcblxuXHRcdHNldF9zc3JfY29udGV4dChwYXJlbnQpO1xuXG5cdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdGlmIChjaGlsZC5nbG9iYWwubW9kZSA9PT0gJ3N5bmMnKSB7XG5cdFx0XHRcdGUuYXdhaXRfaW52YWxpZCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8ganVzdCB0byBhdm9pZCB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zIC0tIHdlJ2xsIGVuZCB1cCB0aHJvd2luZyBpbiBgY29sbGVjdF9hc3luY2AgaWYgc29tZXRoaW5nIGZhaWxzXG5cdFx0XHRyZXN1bHQuY2F0Y2goKCkgPT4ge30pO1xuXHRcdFx0Y2hpbGQucHJvbWlzZSA9IHJlc3VsdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2hpbGQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgY29tcG9uZW50IHJlbmRlcmVyLiBUaGUgY29tcG9uZW50IHJlbmRlcmVyIGluaGVyaXRzIHRoZSBzdGF0ZSBmcm9tIHRoZSBwYXJlbnQsXG5cdCAqIGJ1dCBoYXMgaXRzIG93biBjb250ZW50LiBJdCBpcyB0cmVhdGVkIGFzIGFuIG9yZGVyaW5nIGJvdW5kYXJ5IGZvciBvbmRlc3Ryb3kgY2FsbGJhY2tzLlxuXHQgKiBAcGFyYW0geyhyZW5kZXJlcjogUmVuZGVyZXIpID0+IE1heWJlUHJvbWlzZTx2b2lkPn0gZm5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBvbmVudF9mbl1cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjb21wb25lbnQoZm4sIGNvbXBvbmVudF9mbikge1xuXHRcdHB1c2goY29tcG9uZW50X2ZuKTtcblx0XHRjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGQoZm4pO1xuXHRcdGNoaWxkLiNpc19jb21wb25lbnRfYm9keSA9IHRydWU7XG5cdFx0cG9wKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBhdHRyc1xuXHQgKiBAcGFyYW0geyhyZW5kZXJlcjogUmVuZGVyZXIpID0+IHZvaWR9IGZuXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbY3NzX2hhc2hdXG5cdCAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj4gfCB1bmRlZmluZWR9IFtjbGFzc2VzXVxuXHQgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9IFtzdHlsZXNdXG5cdCAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBbZmxhZ3NdXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0c2VsZWN0KGF0dHJzLCBmbiwgY3NzX2hhc2gsIGNsYXNzZXMsIHN0eWxlcywgZmxhZ3MpIHtcblx0XHRjb25zdCB7IHZhbHVlLCAuLi5zZWxlY3RfYXR0cnMgfSA9IGF0dHJzO1xuXG5cdFx0dGhpcy5wdXNoKGA8c2VsZWN0JHthdHRyaWJ1dGVzKHNlbGVjdF9hdHRycywgY3NzX2hhc2gsIGNsYXNzZXMsIHN0eWxlcywgZmxhZ3MpfT5gKTtcblx0XHR0aGlzLmNoaWxkKChyZW5kZXJlcikgPT4ge1xuXHRcdFx0cmVuZGVyZXIubG9jYWwuc2VsZWN0X3ZhbHVlID0gdmFsdWU7XG5cdFx0XHRmbihyZW5kZXJlcik7XG5cdFx0fSk7XG5cdFx0dGhpcy5wdXNoKCc8L3NlbGVjdD4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGF0dHJzXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8ICgocmVuZGVyZXI6IFJlbmRlcmVyKSA9PiB2b2lkKX0gYm9keVxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2Nzc19oYXNoXVxuXHQgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+IHwgdW5kZWZpbmVkfSBbY2xhc3Nlc11cblx0ICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkfSBbc3R5bGVzXVxuXHQgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gW2ZsYWdzXVxuXHQgKi9cblx0b3B0aW9uKGF0dHJzLCBib2R5LCBjc3NfaGFzaCwgY2xhc3Nlcywgc3R5bGVzLCBmbGFncykge1xuXHRcdHRoaXMuI291dC5wdXNoKGA8b3B0aW9uJHthdHRyaWJ1dGVzKGF0dHJzLCBjc3NfaGFzaCwgY2xhc3Nlcywgc3R5bGVzLCBmbGFncyl9YCk7XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuXHRcdCAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7eyBoZWFkPzogc3RyaW5nLCBib2R5OiBhbnkgfX0gY29udGVudFxuXHRcdCAqL1xuXHRcdGNvbnN0IGNsb3NlID0gKHJlbmRlcmVyLCB2YWx1ZSwgeyBoZWFkLCBib2R5IH0pID0+IHtcblx0XHRcdGlmICgndmFsdWUnIGluIGF0dHJzKSB7XG5cdFx0XHRcdHZhbHVlID0gYXR0cnMudmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSA9PT0gdGhpcy5sb2NhbC5zZWxlY3RfdmFsdWUpIHtcblx0XHRcdFx0cmVuZGVyZXIuI291dC5wdXNoKCcgc2VsZWN0ZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0cmVuZGVyZXIuI291dC5wdXNoKGA+JHtib2R5fTwvb3B0aW9uPmApO1xuXG5cdFx0XHQvLyBzdXBlciBlZGdlIGNhc2UsIGJ1dCBtYXkgYXMgd2VsbCBoYW5kbGUgaXRcblx0XHRcdGlmIChoZWFkKSB7XG5cdFx0XHRcdHJlbmRlcmVyLmhlYWQoKGNoaWxkKSA9PiBjaGlsZC5wdXNoKGhlYWQpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKHR5cGVvZiBib2R5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLmNoaWxkKChyZW5kZXJlcikgPT4ge1xuXHRcdFx0XHRjb25zdCByID0gbmV3IFJlbmRlcmVyKHRoaXMuZ2xvYmFsLCB0aGlzKTtcblx0XHRcdFx0Ym9keShyKTtcblxuXHRcdFx0XHRpZiAodGhpcy5nbG9iYWwubW9kZSA9PT0gJ2FzeW5jJykge1xuXHRcdFx0XHRcdHJldHVybiByLiNjb2xsZWN0X2NvbnRlbnRfYXN5bmMoKS50aGVuKChjb250ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRjbG9zZShyZW5kZXJlciwgY29udGVudC5ib2R5LnJlcGxhY2VBbGwoJzwhLS0tLT4nLCAnJyksIGNvbnRlbnQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSByLiNjb2xsZWN0X2NvbnRlbnQoKTtcblx0XHRcdFx0XHRjbG9zZShyZW5kZXJlciwgY29udGVudC5ib2R5LnJlcGxhY2VBbGwoJzwhLS0tLT4nLCAnJyksIGNvbnRlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2xvc2UodGhpcywgYm9keSwgeyBib2R5IH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0geyhyZW5kZXJlcjogUmVuZGVyZXIpID0+IHZvaWR9IGZuXG5cdCAqL1xuXHR0aXRsZShmbikge1xuXHRcdGNvbnN0IHBhdGggPSB0aGlzLmdldF9wYXRoKCk7XG5cblx0XHQvKiogQHBhcmFtIHtzdHJpbmd9IGhlYWQgKi9cblx0XHRjb25zdCBjbG9zZSA9IChoZWFkKSA9PiB7XG5cdFx0XHR0aGlzLmdsb2JhbC5zZXRfdGl0bGUoaGVhZCwgcGF0aCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuY2hpbGQoKHJlbmRlcmVyKSA9PiB7XG5cdFx0XHRjb25zdCByID0gbmV3IFJlbmRlcmVyKHJlbmRlcmVyLmdsb2JhbCwgcmVuZGVyZXIpO1xuXHRcdFx0Zm4ocik7XG5cblx0XHRcdGlmIChyZW5kZXJlci5nbG9iYWwubW9kZSA9PT0gJ2FzeW5jJykge1xuXHRcdFx0XHRyZXR1cm4gci4jY29sbGVjdF9jb250ZW50X2FzeW5jKCkudGhlbigoY29udGVudCkgPT4ge1xuXHRcdFx0XHRcdGNsb3NlKGNvbnRlbnQuaGVhZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IHIuI2NvbGxlY3RfY29udGVudCgpO1xuXHRcdFx0XHRjbG9zZShjb250ZW50LmhlYWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgKCgpID0+IFByb21pc2U8c3RyaW5nPil9IGNvbnRlbnRcblx0ICovXG5cdHB1c2goY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5jaGlsZChhc3luYyAocmVuZGVyZXIpID0+IHJlbmRlcmVyLnB1c2goYXdhaXQgY29udGVudCgpKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuI291dC5wdXNoKGNvbnRlbnQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG5cdCAqL1xuXHRvbl9kZXN0cm95KGZuKSB7XG5cdFx0KHRoaXMuI29uX2Rlc3Ryb3kgPz89IFtdKS5wdXNoKGZuKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRnZXRfcGF0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jcGFyZW50ID8gWy4uLnRoaXMuI3BhcmVudC5nZXRfcGF0aCgpLCB0aGlzLiNwYXJlbnQuI291dC5pbmRleE9mKHRoaXMpXSA6IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBkZXByZWNhdGVkIHRoaXMgaXMgbmVlZGVkIGZvciBsZWdhY3kgY29tcG9uZW50IGJpbmRpbmdzXG5cdCAqL1xuXHRjb3B5KCkge1xuXHRcdGNvbnN0IGNvcHkgPSBuZXcgUmVuZGVyZXIodGhpcy5nbG9iYWwsIHRoaXMuI3BhcmVudCk7XG5cdFx0Y29weS4jb3V0ID0gdGhpcy4jb3V0Lm1hcCgoaXRlbSkgPT4gKGl0ZW0gaW5zdGFuY2VvZiBSZW5kZXJlciA/IGl0ZW0uY29weSgpIDogaXRlbSkpO1xuXHRcdGNvcHkucHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblx0XHRyZXR1cm4gY29weTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlbmRlcmVyfSBvdGhlclxuXHQgKiBAZGVwcmVjYXRlZCB0aGlzIGlzIG5lZWRlZCBmb3IgbGVnYWN5IGNvbXBvbmVudCBiaW5kaW5nc1xuXHQgKi9cblx0c3Vic3VtZShvdGhlcikge1xuXHRcdGlmICh0aGlzLmdsb2JhbC5tb2RlICE9PSBvdGhlci5nbG9iYWwubW9kZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcImludmFyaWFudDogQSByZW5kZXJlciBjYW5ub3Qgc3dpdGNoIG1vZGVzLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIHRoZXJlJ3MgYSBjb21waWxlciBidWcuIEZpbGUgYW4gaXNzdWUhXCJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5sb2NhbCA9IG90aGVyLmxvY2FsO1xuXHRcdHRoaXMuI291dCA9IG90aGVyLiNvdXQubWFwKChpdGVtKSA9PiB7XG5cdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIFJlbmRlcmVyKSB7XG5cdFx0XHRcdGl0ZW0uc3Vic3VtZShpdGVtKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH0pO1xuXHRcdHRoaXMucHJvbWlzZSA9IG90aGVyLnByb21pc2U7XG5cdFx0dGhpcy50eXBlID0gb3RoZXIudHlwZTtcblx0fVxuXG5cdGdldCBsZW5ndGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI291dC5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogT25seSBhdmFpbGFibGUgb24gdGhlIHNlcnZlciBhbmQgd2hlbiBjb21waWxpbmcgd2l0aCB0aGUgYHNlcnZlcmAgb3B0aW9uLlxuXHQgKiBUYWtlcyBhIGNvbXBvbmVudCBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgYm9keWAgYW5kIGBoZWFkYCBwcm9wZXJ0aWVzIG9uIGl0LCB3aGljaCB5b3UgY2FuIHVzZSB0byBwb3B1bGF0ZSB0aGUgSFRNTCB3aGVuIHNlcnZlci1yZW5kZXJpbmcgeW91ciBhcHAuXG5cdCAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcblx0ICogQHBhcmFtIHtDb21wb25lbnQ8UHJvcHM+fSBjb21wb25lbnRcblx0ICogQHBhcmFtIHt7IHByb3BzPzogT21pdDxQcm9wcywgJyQkc2xvdHMnIHwgJyQkZXZlbnRzJz47IGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+OyBpZFByZWZpeD86IHN0cmluZyB9fSBbb3B0aW9uc11cblx0ICogQHJldHVybnMge1JlbmRlck91dHB1dH1cblx0ICovXG5cdHN0YXRpYyByZW5kZXIoY29tcG9uZW50LCBvcHRpb25zID0ge30pIHtcblx0XHQvKiogQHR5cGUge0FjY3VtdWxhdGVkQ29udGVudCB8IHVuZGVmaW5lZH0gKi9cblx0XHRsZXQgc3luYztcblx0XHQvKiogQHR5cGUge1Byb21pc2U8QWNjdW11bGF0ZWRDb250ZW50PiB8IHVuZGVmaW5lZH0gKi9cblx0XHRsZXQgYXN5bmM7XG5cblx0XHRjb25zdCByZXN1bHQgPSAvKiogQHR5cGUge1JlbmRlck91dHB1dH0gKi8gKHt9KTtcblx0XHQvLyBtYWtpbmcgdGhlc2UgcHJvcGVydGllcyBub24tZW51bWVyYWJsZSBzbyB0aGF0IGNvbnNvbGUubG9nZ2luZ1xuXHRcdC8vIGRvZXNuJ3QgdHJpZ2dlciBhIHN5bmMgcmVuZGVyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVzdWx0LCB7XG5cdFx0XHRodG1sOiB7XG5cdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiAoc3luYyA/Pz0gUmVuZGVyZXIuI3JlbmRlcihjb21wb25lbnQsIG9wdGlvbnMpKS5ib2R5O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGVhZDoge1xuXHRcdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gKHN5bmMgPz89IFJlbmRlcmVyLiNyZW5kZXIoY29tcG9uZW50LCBvcHRpb25zKSkuaGVhZDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJvZHk6IHtcblx0XHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIChzeW5jID8/PSBSZW5kZXJlci4jcmVuZGVyKGNvbXBvbmVudCwgb3B0aW9ucykpLmJvZHk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0aGVuOiB7XG5cdFx0XHRcdHZhbHVlOlxuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIHRoaXMgaXMgbm90IHR5cGUtc2FmZSwgYnV0IGhvbmVzdGx5IGl0J3MgdGhlIGJlc3QgSSBjYW4gZG8gcmlnaHQgbm93LCBhbmQgaXQncyBhIHN0cmFpZ2h0Zm9yd2FyZCBmdW5jdGlvbi5cblx0XHRcdFx0XHQgKlxuXHRcdFx0XHRcdCAqIEB0ZW1wbGF0ZSBUUmVzdWx0MVxuXHRcdFx0XHRcdCAqIEB0ZW1wbGF0ZSBbVFJlc3VsdDI9bmV2ZXJdXG5cdFx0XHRcdFx0ICogQHBhcmFtIHsgKHZhbHVlOiBTeW5jUmVuZGVyT3V0cHV0KSA9PiBUUmVzdWx0MSB9IG9uZnVsZmlsbGVkXG5cdFx0XHRcdFx0ICogQHBhcmFtIHsgKHJlYXNvbjogdW5rbm93bikgPT4gVFJlc3VsdDIgfSBvbnJlamVjdGVkXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0KG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIWFzeW5jX21vZGVfZmxhZykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCByZXN1bHQgPSAoc3luYyA/Pz0gUmVuZGVyZXIuI3JlbmRlcihjb21wb25lbnQsIG9wdGlvbnMpKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgdXNlcl9yZXN1bHQgPSBvbmZ1bGZpbGxlZCh7XG5cdFx0XHRcdFx0XHRcdFx0aGVhZDogcmVzdWx0LmhlYWQsXG5cdFx0XHRcdFx0XHRcdFx0Ym9keTogcmVzdWx0LmJvZHksXG5cdFx0XHRcdFx0XHRcdFx0aHRtbDogcmVzdWx0LmJvZHlcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodXNlcl9yZXN1bHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YXN5bmMgPz89IGluaXRfcmVuZGVyX2NvbnRleHQoKS50aGVuKCgpID0+XG5cdFx0XHRcdFx0XHRcdHdpdGhfcmVuZGVyX2NvbnRleHQoKCkgPT4gUmVuZGVyZXIuI3JlbmRlcl9hc3luYyhjb21wb25lbnQsIG9wdGlvbnMpKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiBhc3luYy50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ2h0bWwnLCB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cblx0XHRcdFx0XHRcdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGUuaHRtbF9kZXByZWNhdGVkKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG9uZnVsZmlsbGVkKC8qKiBAdHlwZSB7U3luY1JlbmRlck91dHB1dH0gKi8gKHJlc3VsdCkpO1xuXHRcdFx0XHRcdFx0fSwgb25yZWplY3RlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb2xsZWN0IGFsbCBvZiB0aGUgYG9uRGVzdHJveWAgY2FsbGJhY2tzIHJlZ2lzdGVyZWQgZHVyaW5nIHJlbmRlcmluZy4gSW4gYW4gYXN5bmMgY29udGV4dCwgdGhpcyBpcyBvbmx5IHNhZmUgdG8gY2FsbFxuXHQgKiBhZnRlciBhd2FpdGluZyBgY29sbGVjdF9hc3luY2AuXG5cdCAqXG5cdCAqIENoaWxkIHJlbmRlcmVycyBhcmUgXCJwb3JvdXNcIiBhbmQgZG9uJ3QgYWZmZWN0IGV4ZWN1dGlvbiBvcmRlciwgYnV0IGNvbXBvbmVudCBib2R5IHJlbmRlcmVyc1xuXHQgKiBjcmVhdGUgb3JkZXJpbmcgYm91bmRhcmllcy4gV2l0aGluIGEgcmVuZGVyZXIsIGNhbGxiYWNrcyBydW4gaW4gb3JkZXIgdW50aWwgaGl0dGluZyBhIGNvbXBvbmVudCBib3VuZGFyeS5cblx0ICogQHJldHVybnMge0l0ZXJhYmxlPCgpID0+IHZvaWQ+fVxuXHQgKi9cblx0KiNjb2xsZWN0X29uX2Rlc3Ryb3koKSB7XG5cdFx0Zm9yIChjb25zdCBjb21wb25lbnQgb2YgdGhpcy4jdHJhdmVyc2VfY29tcG9uZW50cygpKSB7XG5cdFx0XHR5aWVsZCogY29tcG9uZW50LiNjb2xsZWN0X29uZGVzdHJveSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhIGRlcHRoLWZpcnN0IHNlYXJjaCBvZiByZW5kZXJlcnMsIHlpZWxkaW5nIHRoZSBkZWVwZXN0IGNvbXBvbmVudHMgZmlyc3QsIHRoZW4gYWRkaXRpb25hbCBjb21wb25lbnRzIGFzIHdlIGJhY2t0cmFjayB1cCB0aGUgdHJlZS5cblx0ICogQHJldHVybnMge0l0ZXJhYmxlPFJlbmRlcmVyPn1cblx0ICovXG5cdCojdHJhdmVyc2VfY29tcG9uZW50cygpIHtcblx0XHRmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuI291dCkge1xuXHRcdFx0aWYgKHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0eWllbGQqIGNoaWxkLiN0cmF2ZXJzZV9jb21wb25lbnRzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0aGlzLiNpc19jb21wb25lbnRfYm9keSkge1xuXHRcdFx0eWllbGQgdGhpcztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge0l0ZXJhYmxlPCgpID0+IHZvaWQ+fVxuXHQgKi9cblx0KiNjb2xsZWN0X29uZGVzdHJveSgpIHtcblx0XHRpZiAodGhpcy4jb25fZGVzdHJveSkge1xuXHRcdFx0Zm9yIChjb25zdCBmbiBvZiB0aGlzLiNvbl9kZXN0cm95KSB7XG5cdFx0XHRcdHlpZWxkIGZuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuI291dCkge1xuXHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgUmVuZGVyZXIgJiYgIWNoaWxkLiNpc19jb21wb25lbnRfYm9keSkge1xuXHRcdFx0XHR5aWVsZCogY2hpbGQuI2NvbGxlY3Rfb25kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlciBhIGNvbXBvbmVudC4gVGhyb3dzIGlmIGFueSBvZiB0aGUgY2hpbGRyZW4gYXJlIHBlcmZvcm1pbmcgYXN5bmNocm9ub3VzIHdvcmsuXG5cdCAqXG5cdCAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcblx0ICogQHBhcmFtIHtDb21wb25lbnQ8UHJvcHM+fSBjb21wb25lbnRcblx0ICogQHBhcmFtIHt7IHByb3BzPzogT21pdDxQcm9wcywgJyQkc2xvdHMnIHwgJyQkZXZlbnRzJz47IGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+OyBpZFByZWZpeD86IHN0cmluZyB9fSBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtBY2N1bXVsYXRlZENvbnRlbnR9XG5cdCAqL1xuXHRzdGF0aWMgI3JlbmRlcihjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgcHJldmlvdXNfY29udGV4dCA9IHNzcl9jb250ZXh0O1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCByZW5kZXJlciA9IFJlbmRlcmVyLiNvcGVuX3JlbmRlcignc3luYycsIGNvbXBvbmVudCwgb3B0aW9ucyk7XG5cblx0XHRcdGNvbnN0IGNvbnRlbnQgPSByZW5kZXJlci4jY29sbGVjdF9jb250ZW50KCk7XG5cdFx0XHRyZXR1cm4gUmVuZGVyZXIuI2Nsb3NlX3JlbmRlcihjb250ZW50LCByZW5kZXJlcik7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRzZXRfc3NyX2NvbnRleHQocHJldmlvdXNfY29udGV4dCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlciBhIGNvbXBvbmVudC5cblx0ICpcblx0ICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuXHQgKiBAcGFyYW0ge0NvbXBvbmVudDxQcm9wcz59IGNvbXBvbmVudFxuXHQgKiBAcGFyYW0ge3sgcHJvcHM/OiBPbWl0PFByb3BzLCAnJCRzbG90cycgfCAnJCRldmVudHMnPjsgY29udGV4dD86IE1hcDxhbnksIGFueT47IGlkUHJlZml4Pzogc3RyaW5nIH19IG9wdGlvbnNcblx0ICogQHJldHVybnMge1Byb21pc2U8QWNjdW11bGF0ZWRDb250ZW50Pn1cblx0ICovXG5cdHN0YXRpYyBhc3luYyAjcmVuZGVyX2FzeW5jKGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRcdGNvbnN0IHByZXZpb3VzX2NvbnRleHQgPSBzc3JfY29udGV4dDtcblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCByZW5kZXJlciA9IFJlbmRlcmVyLiNvcGVuX3JlbmRlcignYXN5bmMnLCBjb21wb25lbnQsIG9wdGlvbnMpO1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHJlbmRlcmVyLiNjb2xsZWN0X2NvbnRlbnRfYXN5bmMoKTtcblx0XHRcdGNvbnN0IGh5ZHJhdGFibGVzID0gYXdhaXQgcmVuZGVyZXIuI2NvbGxlY3RfaHlkcmF0YWJsZXMoKTtcblx0XHRcdGlmIChoeWRyYXRhYmxlcyAhPT0gbnVsbCkge1xuXHRcdFx0XHRjb250ZW50LmhlYWQgPSBoeWRyYXRhYmxlcyArIGNvbnRlbnQuaGVhZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBSZW5kZXJlci4jY2xvc2VfcmVuZGVyKGNvbnRlbnQsIHJlbmRlcmVyKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X3Nzcl9jb250ZXh0KHByZXZpb3VzX2NvbnRleHQpO1xuXHRcdFx0YWJvcnQoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ29sbGVjdCBhbGwgb2YgdGhlIGNvZGUgZnJvbSB0aGUgYG91dGAgYXJyYXkgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIHJlc29sdmluZyB0byBhIHN0cmluZy5cblx0ICogQHBhcmFtIHtBY2N1bXVsYXRlZENvbnRlbnR9IGNvbnRlbnRcblx0ICogQHJldHVybnMge0FjY3VtdWxhdGVkQ29udGVudH1cblx0ICovXG5cdCNjb2xsZWN0X2NvbnRlbnQoY29udGVudCA9IHsgaGVhZDogJycsIGJvZHk6ICcnIH0pIHtcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jb3V0KSB7XG5cdFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGNvbnRlbnRbdGhpcy50eXBlXSArPSBpdGVtO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgUmVuZGVyZXIpIHtcblx0XHRcdFx0aXRlbS4jY29sbGVjdF9jb250ZW50KGNvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbGxlY3QgYWxsIG9mIHRoZSBjb2RlIGZyb20gdGhlIGBvdXRgIGFycmF5IGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7QWNjdW11bGF0ZWRDb250ZW50fSBjb250ZW50XG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPEFjY3VtdWxhdGVkQ29udGVudD59XG5cdCAqL1xuXHRhc3luYyAjY29sbGVjdF9jb250ZW50X2FzeW5jKGNvbnRlbnQgPSB7IGhlYWQ6ICcnLCBib2R5OiAnJyB9KSB7XG5cdFx0YXdhaXQgdGhpcy5wcm9taXNlO1xuXG5cdFx0Ly8gbm8gZGFuZ2VyIHRvIHNlcXVlbnRpYWxseSBhd2FpdGluZyBzdHVmZiBpbiBoZXJlOyBhbGwgb2YgdGhlIHdvcmsgaXMgYWxyZWFkeSBraWNrZWQgb2ZmXG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI291dCkge1xuXHRcdFx0aWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRjb250ZW50W3RoaXMudHlwZV0gKz0gaXRlbTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIFJlbmRlcmVyKSB7XG5cdFx0XHRcdGF3YWl0IGl0ZW0uI2NvbGxlY3RfY29udGVudF9hc3luYyhjb250ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGFzeW5jICNjb2xsZWN0X2h5ZHJhdGFibGVzKCkge1xuXHRcdGNvbnN0IGN0eCA9IGdldF9yZW5kZXJfY29udGV4dCgpLmh5ZHJhdGFibGU7XG5cblx0XHRmb3IgKGNvbnN0IFtfLCBrZXldIG9mIGN0eC51bnJlc29sdmVkX3Byb21pc2VzKSB7XG5cdFx0XHQvLyB0aGlzIGlzIGEgcHJvYmxlbSAtLSBpdCBtZWFucyB3ZSd2ZSBmaW5pc2hlZCB0aGUgcmVuZGVyIGJ1dCB3ZSdyZSBzdGlsbCB3YWl0aW5nIG9uIGEgcHJvbWlzZSB0byByZXNvbHZlIHNvIHdlIGNhblxuXHRcdFx0Ly8gc2VyaWFsaXplIGl0LCBzbyB3ZSdyZSBibG9ja2luZyB0aGUgcmVzcG9uc2Ugb24gdXNlbGVzcyBjb250ZW50LlxuXHRcdFx0dy51bnJlc29sdmVkX2h5ZHJhdGFibGUoa2V5LCBjdHgubG9va3VwLmdldChrZXkpPy5zdGFjayA/PyAnPG1pc3Npbmcgc3RhY2sgdHJhY2U+Jyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBjb21wYXJpc29uIG9mIGN0eC5jb21wYXJpc29ucykge1xuXHRcdFx0Ly8gdGhlc2UgcmVqZWN0IGlmIHRoZXJlJ3MgYSBtaXNtYXRjaFxuXHRcdFx0YXdhaXQgY29tcGFyaXNvbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXdhaXQgUmVuZGVyZXIuI2h5ZHJhdGFibGVfYmxvY2soY3R4KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG5cdCAqIEBwYXJhbSB7J3N5bmMnIHwgJ2FzeW5jJ30gbW9kZVxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnc3ZlbHRlJykuQ29tcG9uZW50PFByb3BzPn0gY29tcG9uZW50XG5cdCAqIEBwYXJhbSB7eyBwcm9wcz86IE9taXQ8UHJvcHMsICckJHNsb3RzJyB8ICckJGV2ZW50cyc+OyBjb250ZXh0PzogTWFwPGFueSwgYW55PjsgaWRQcmVmaXg/OiBzdHJpbmcgfX0gb3B0aW9uc1xuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9XG5cdCAqL1xuXHRzdGF0aWMgI29wZW5fcmVuZGVyKG1vZGUsIGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRcdGNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKFxuXHRcdFx0bmV3IFNTUlN0YXRlKG1vZGUsIG9wdGlvbnMuaWRQcmVmaXggPyBvcHRpb25zLmlkUHJlZml4ICsgJy0nIDogJycpXG5cdFx0KTtcblxuXHRcdHJlbmRlcmVyLnB1c2goQkxPQ0tfT1BFTik7XG5cblx0XHRpZiAob3B0aW9ucy5jb250ZXh0KSB7XG5cdFx0XHRwdXNoKCk7XG5cdFx0XHQvKiogQHR5cGUge1NTUkNvbnRleHR9ICovIChzc3JfY29udGV4dCkuYyA9IG9wdGlvbnMuY29udGV4dDtcblx0XHRcdC8qKiBAdHlwZSB7U1NSQ29udGV4dH0gKi8gKHNzcl9jb250ZXh0KS5yID0gcmVuZGVyZXI7XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGNvbXBvbmVudChyZW5kZXJlciwgb3B0aW9ucy5wcm9wcyA/PyB7fSk7XG5cblx0XHRpZiAob3B0aW9ucy5jb250ZXh0KSB7XG5cdFx0XHRwb3AoKTtcblx0XHR9XG5cblx0XHRyZW5kZXJlci5wdXNoKEJMT0NLX0NMT1NFKTtcblxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FjY3VtdWxhdGVkQ29udGVudH0gY29udGVudFxuXHQgKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuXHQgKi9cblx0c3RhdGljICNjbG9zZV9yZW5kZXIoY29udGVudCwgcmVuZGVyZXIpIHtcblx0XHRmb3IgKGNvbnN0IGNsZWFudXAgb2YgcmVuZGVyZXIuI2NvbGxlY3Rfb25fZGVzdHJveSgpKSB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0fVxuXG5cdFx0bGV0IGhlYWQgPSBjb250ZW50LmhlYWQgKyByZW5kZXJlci5nbG9iYWwuZ2V0X3RpdGxlKCk7XG5cdFx0bGV0IGJvZHkgPSBjb250ZW50LmJvZHk7XG5cblx0XHRmb3IgKGNvbnN0IHsgaGFzaCwgY29kZSB9IG9mIHJlbmRlcmVyLmdsb2JhbC5jc3MpIHtcblx0XHRcdGhlYWQgKz0gYDxzdHlsZSBpZD1cIiR7aGFzaH1cIj4ke2NvZGV9PC9zdHlsZT5gO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRoZWFkLFxuXHRcdFx0Ym9keVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtIeWRyYXRhYmxlQ29udGV4dH0gY3R4XG5cdCAqL1xuXHRzdGF0aWMgYXN5bmMgI2h5ZHJhdGFibGVfYmxvY2soY3R4KSB7XG5cdFx0aWYgKGN0eC5sb29rdXAuc2l6ZSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IGVudHJpZXMgPSBbXTtcblx0XHRsZXQgaGFzX3Byb21pc2VzID0gZmFsc2U7XG5cblx0XHRmb3IgKGNvbnN0IFtrLCB2XSBvZiBjdHgubG9va3VwKSB7XG5cdFx0XHRpZiAodi5wcm9taXNlcykge1xuXHRcdFx0XHRoYXNfcHJvbWlzZXMgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHAgb2Ygdi5wcm9taXNlcykgYXdhaXQgcDtcblx0XHRcdH1cblxuXHRcdFx0ZW50cmllcy5wdXNoKGBbJHtKU09OLnN0cmluZ2lmeShrKX0sJHt2LnNlcmlhbGl6ZWR9XWApO1xuXHRcdH1cblxuXHRcdGxldCBwcmVsdWRlID0gYGNvbnN0IGggPSAod2luZG93Ll9fc3ZlbHRlID8/PSB7fSkuaCA/Pz0gbmV3IE1hcCgpO2A7XG5cblx0XHRpZiAoaGFzX3Byb21pc2VzKSB7XG5cdFx0XHRwcmVsdWRlID0gYGNvbnN0IHIgPSAodikgPT4gUHJvbWlzZS5yZXNvbHZlKHYpO1xuXHRcdFx0XHQke3ByZWx1ZGV9YDtcblx0XHR9XG5cblx0XHQvLyBUT0RPIGNzcCAtLSBoYXZlIGRpc2N1c3NlZCBidXQgbm90IGltcGxlbWVudGVkXG5cdFx0cmV0dXJuIGBcblx0XHQ8c2NyaXB0PlxuXHRcdFx0e1xuXHRcdFx0XHQke3ByZWx1ZGV9XG5cblx0XHRcdFx0Zm9yIChjb25zdCBbaywgdl0gb2YgW1xuXHRcdFx0XHRcdCR7ZW50cmllcy5qb2luKCcsXFxuXFx0XFx0XFx0XFx0XFx0Jyl9XG5cdFx0XHRcdF0pIHtcblx0XHRcdFx0XHRoLnNldChrLCB2KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdDwvc2NyaXB0PmA7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFNTUlN0YXRlIHtcblx0LyoqIEByZWFkb25seSBAdHlwZSB7J3N5bmMnIHwgJ2FzeW5jJ30gKi9cblx0bW9kZTtcblxuXHQvKiogQHJlYWRvbmx5IEB0eXBlIHsoKSA9PiBzdHJpbmd9ICovXG5cdHVpZDtcblxuXHQvKiogQHJlYWRvbmx5IEB0eXBlIHtTZXQ8eyBoYXNoOiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9Pn0gKi9cblx0Y3NzID0gbmV3IFNldCgpO1xuXG5cdC8qKiBAdHlwZSB7eyBwYXRoOiBudW1iZXJbXSwgdmFsdWU6IHN0cmluZyB9fSAqL1xuXHQjdGl0bGUgPSB7IHBhdGg6IFtdLCB2YWx1ZTogJycgfTtcblxuXHQvKipcblx0ICogQHBhcmFtIHsnc3luYycgfCAnYXN5bmMnfSBtb2RlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbaWRfcHJlZml4XVxuXHQgKi9cblx0Y29uc3RydWN0b3IobW9kZSwgaWRfcHJlZml4ID0gJycpIHtcblx0XHR0aGlzLm1vZGUgPSBtb2RlO1xuXG5cdFx0bGV0IHVpZCA9IDE7XG5cdFx0dGhpcy51aWQgPSAoKSA9PiBgJHtpZF9wcmVmaXh9cyR7dWlkKyt9YDtcblx0fVxuXG5cdGdldF90aXRsZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdGl0bGUudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybXMgYSBkZXB0aC1maXJzdCAobGV4aWNvZ3JhcGhpYykgY29tcGFyaXNvbiB1c2luZyB0aGUgcGF0aC4gUmVqZWN0cyBzZXRzXG5cdCAqIGZyb20gZWFybGllciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBjdXJyZW50IHZhbHVlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gcGF0aFxuXHQgKi9cblx0c2V0X3RpdGxlKHZhbHVlLCBwYXRoKSB7XG5cdFx0Y29uc3QgY3VycmVudCA9IHRoaXMuI3RpdGxlLnBhdGg7XG5cblx0XHRsZXQgaSA9IDA7XG5cdFx0bGV0IGwgPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgY3VycmVudC5sZW5ndGgpO1xuXG5cdFx0Ly8gc2tpcCBpZGVudGljYWwgcHJlZml4ZXMgLSBbMSwgMiwgMywgLi4uXSA9PT0gWzEsIDIsIDMsIC4uLl1cblx0XHR3aGlsZSAoaSA8IGwgJiYgcGF0aFtpXSA9PT0gY3VycmVudFtpXSkgaSArPSAxO1xuXG5cdFx0aWYgKHBhdGhbaV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG5cdFx0Ly8gcmVwbGFjZSB0aXRsZSBpZlxuXHRcdC8vIC0gaW5jb21pbmcgcGF0aCBpcyBsb25nZXIgLSBbNywgOCwgOV0gPiBbNywgOF1cblx0XHQvLyAtIGluY29taW5nIHBhdGggaXMgbGF0ZXIgIC0gWzcsIDgsIDldID4gWzcsIDgsIDhdXG5cdFx0aWYgKGN1cnJlbnRbaV0gPT09IHVuZGVmaW5lZCB8fCBwYXRoW2ldID4gY3VycmVudFtpXSkge1xuXHRcdFx0dGhpcy4jdGl0bGUucGF0aCA9IHBhdGg7XG5cdFx0XHR0aGlzLiN0aXRsZS52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblx0fVxufVxuIiwgImltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaGFzaCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWwodmFsdWUpIHtcblx0dmFyIGh0bWwgPSBTdHJpbmcodmFsdWUgPz8gJycpO1xuXHR2YXIgb3BlbiA9IERFViA/IGA8IS0tJHtoYXNoKGh0bWwpfS0tPmAgOiAnPCEtLS0tPic7XG5cdHJldHVybiBvcGVuICsgaHRtbCArICc8IS0tLS0+Jztcbn1cbiIsICIvKipcbiAqIE1hcCBvZiBlbGVtZW50cyB0aGF0IGhhdmUgY2VydGFpbiBlbGVtZW50cyB0aGF0IGFyZSBub3QgYWxsb3dlZCBpbnNpZGUgdGhlbSwgaW4gdGhlIHNlbnNlIHRoYXQgdGhleSB3aWxsIGF1dG8tY2xvc2UgdGhlIHBhcmVudC9hbmNlc3RvciBlbGVtZW50LlxuICogVGhlb3JldGljYWxseSBvbmUgY291bGQgdGFrZSBhZHZhbnRhZ2Ugb2YgaXQgYnV0IG1vc3Qgb2YgdGhlIHRpbWUgaXQgd2lsbCBqdXN0IHJlc3VsdCBpbiBjb25mdXNpbmcgYmVoYXZpb3IgYW5kIGJyZWFrIHdoZW4gU1NSJ2QuXG4gKiBUaGVyZSBhcmUgbW9yZSBlbGVtZW50cyB0aGF0IGFyZSBpbnZhbGlkIGluc2lkZSBvdGhlciBlbGVtZW50cywgYnV0IHRoZXkncmUgbm90IGF1dG8tY2xvc2VkIGFuZCBzbyBkb24ndCBicmVhayBTU1IgYW5kIGFyZSB0aGVyZWZvcmUgbm90IGxpc3RlZCBoZXJlLlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIHsgZGlyZWN0OiBzdHJpbmdbXX0gfCB7IGRlc2NlbmRhbnQ6IHN0cmluZ1tdOyByZXNldF9ieT86IHN0cmluZ1tdIH0+fVxuICovXG5jb25zdCBhdXRvY2xvc2luZ19jaGlsZHJlbiA9IHtcblx0Ly8gYmFzZWQgb24gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtdGFnLW9taXNzaW9uXG5cdGxpOiB7IGRpcmVjdDogWydsaSddIH0sXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9kdCN0ZWNobmljYWxfc3VtbWFyeVxuXHRkdDogeyBkZXNjZW5kYW50OiBbJ2R0JywgJ2RkJ10sIHJlc2V0X2J5OiBbJ2RsJ10gfSxcblx0ZGQ6IHsgZGVzY2VuZGFudDogWydkdCcsICdkZCddLCByZXNldF9ieTogWydkbCddIH0sXG5cdHA6IHtcblx0XHRkZXNjZW5kYW50OiBbXG5cdFx0XHQnYWRkcmVzcycsXG5cdFx0XHQnYXJ0aWNsZScsXG5cdFx0XHQnYXNpZGUnLFxuXHRcdFx0J2Jsb2NrcXVvdGUnLFxuXHRcdFx0J2RpdicsXG5cdFx0XHQnZGwnLFxuXHRcdFx0J2ZpZWxkc2V0Jyxcblx0XHRcdCdmb290ZXInLFxuXHRcdFx0J2Zvcm0nLFxuXHRcdFx0J2gxJyxcblx0XHRcdCdoMicsXG5cdFx0XHQnaDMnLFxuXHRcdFx0J2g0Jyxcblx0XHRcdCdoNScsXG5cdFx0XHQnaDYnLFxuXHRcdFx0J2hlYWRlcicsXG5cdFx0XHQnaGdyb3VwJyxcblx0XHRcdCdocicsXG5cdFx0XHQnbWFpbicsXG5cdFx0XHQnbWVudScsXG5cdFx0XHQnbmF2Jyxcblx0XHRcdCdvbCcsXG5cdFx0XHQncCcsXG5cdFx0XHQncHJlJyxcblx0XHRcdCdzZWN0aW9uJyxcblx0XHRcdCd0YWJsZScsXG5cdFx0XHQndWwnXG5cdFx0XVxuXHR9LFxuXHRydDogeyBkZXNjZW5kYW50OiBbJ3J0JywgJ3JwJ10gfSxcblx0cnA6IHsgZGVzY2VuZGFudDogWydydCcsICdycCddIH0sXG5cdG9wdGdyb3VwOiB7IGRlc2NlbmRhbnQ6IFsnb3B0Z3JvdXAnXSB9LFxuXHRvcHRpb246IHsgZGVzY2VuZGFudDogWydvcHRpb24nLCAnb3B0Z3JvdXAnXSB9LFxuXHR0aGVhZDogeyBkaXJlY3Q6IFsndGJvZHknLCAndGZvb3QnXSB9LFxuXHR0Ym9keTogeyBkaXJlY3Q6IFsndGJvZHknLCAndGZvb3QnXSB9LFxuXHR0Zm9vdDogeyBkaXJlY3Q6IFsndGJvZHknXSB9LFxuXHR0cjogeyBkaXJlY3Q6IFsndHInLCAndGJvZHknXSB9LFxuXHR0ZDogeyBkaXJlY3Q6IFsndGQnLCAndGgnLCAndHInXSB9LFxuXHR0aDogeyBkaXJlY3Q6IFsndGQnLCAndGgnLCAndHInXSB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGlzIGVpdGhlciB0aGUgbGFzdCBpbiB0aGUgbGlzdCBvZiBzaWJsaW5ncyBhbmQgd2lsbCBiZSBhdXRvY2xvc2VkLFxuICogb3Igbm90IGFsbG93ZWQgaW5zaWRlIHRoZSBwYXJlbnQgdGFnIHN1Y2ggdGhhdCBpdCB3aWxsIGF1dG8tY2xvc2UgaXQuIFRoZSBsYXR0ZXIgcmVzdWx0c1xuICogaW4gdGhlIGJyb3dzZXIgcmVwYWlyaW5nIHRoZSBIVE1MLCB3aGljaCB3aWxsIGxpa2VseSByZXN1bHQgaW4gYW4gZXJyb3IgZHVyaW5nIGh5ZHJhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW25leHRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zaW5nX3RhZ19vbWl0dGVkKGN1cnJlbnQsIG5leHQpIHtcblx0Y29uc3QgZGlzYWxsb3dlZCA9IGF1dG9jbG9zaW5nX2NoaWxkcmVuW2N1cnJlbnRdO1xuXHRpZiAoZGlzYWxsb3dlZCkge1xuXHRcdGlmIChcblx0XHRcdCFuZXh0IHx8XG5cdFx0XHQoJ2RpcmVjdCcgaW4gZGlzYWxsb3dlZCA/IGRpc2FsbG93ZWQuZGlyZWN0IDogZGlzYWxsb3dlZC5kZXNjZW5kYW50KS5pbmNsdWRlcyhuZXh0KVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBNYXAgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGNlcnRhaW4gZWxlbWVudHMgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW5zaWRlIHRoZW0sIGluIHRoZSBzZW5zZSB0aGF0IHRoZSBicm93c2VyIHdpbGwgc29tZWhvdyByZXBhaXIgdGhlIEhUTUwuXG4gKiBUaGVyZSBhcmUgbW9yZSBlbGVtZW50cyB0aGF0IGFyZSBpbnZhbGlkIGluc2lkZSBvdGhlciBlbGVtZW50cywgYnV0IHRoZXkncmUgbm90IHJlcGFpcmVkIGFuZCBzbyBkb24ndCBicmVhayBTU1IgYW5kIGFyZSB0aGVyZWZvcmUgbm90IGxpc3RlZCBoZXJlLlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIHsgZGlyZWN0OiBzdHJpbmdbXX0gfCB7IGRlc2NlbmRhbnQ6IHN0cmluZ1tdOyByZXNldF9ieT86IHN0cmluZ1tdOyBvbmx5Pzogc3RyaW5nW10gfSB8IHsgb25seTogc3RyaW5nW10gfT59XG4gKi9cbmNvbnN0IGRpc2FsbG93ZWRfY2hpbGRyZW4gPSB7XG5cdC4uLmF1dG9jbG9zaW5nX2NoaWxkcmVuLFxuXHRvcHRncm91cDogeyBvbmx5OiBbJ29wdGlvbicsICcjdGV4dCddIH0sXG5cdC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD4sIGJ1dCB3ZSBhc3N1bWUgaXQgaGVyZVxuXHRvcHRpb246IHsgb25seTogWycjdGV4dCddIH0sXG5cdGZvcm06IHsgZGVzY2VuZGFudDogWydmb3JtJ10gfSxcblx0YTogeyBkZXNjZW5kYW50OiBbJ2EnXSB9LFxuXHRidXR0b246IHsgZGVzY2VuZGFudDogWydidXR0b24nXSB9LFxuXHRoMTogeyBkZXNjZW5kYW50OiBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2J10gfSxcblx0aDI6IHsgZGVzY2VuZGFudDogWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddIH0sXG5cdGgzOiB7IGRlc2NlbmRhbnQ6IFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnXSB9LFxuXHRoNDogeyBkZXNjZW5kYW50OiBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2J10gfSxcblx0aDU6IHsgZGVzY2VuZGFudDogWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddIH0sXG5cdGg2OiB7IGRlc2NlbmRhbnQ6IFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnXSB9LFxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3Rcblx0c2VsZWN0OiB7IG9ubHk6IFsnb3B0aW9uJywgJ29wdGdyb3VwJywgJyN0ZXh0JywgJ2hyJywgJ3NjcmlwdCcsICd0ZW1wbGF0ZSddIH0sXG5cblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuXHQvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuXHQvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG5cdHRyOiB7IG9ubHk6IFsndGgnLCAndGQnLCAnc3R5bGUnLCAnc2NyaXB0JywgJ3RlbXBsYXRlJ10gfSxcblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcblx0dGJvZHk6IHsgb25seTogWyd0cicsICdzdHlsZScsICdzY3JpcHQnLCAndGVtcGxhdGUnXSB9LFxuXHR0aGVhZDogeyBvbmx5OiBbJ3RyJywgJ3N0eWxlJywgJ3NjcmlwdCcsICd0ZW1wbGF0ZSddIH0sXG5cdHRmb290OiB7IG9ubHk6IFsndHInLCAnc3R5bGUnLCAnc2NyaXB0JywgJ3RlbXBsYXRlJ10gfSxcblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcblx0Y29sZ3JvdXA6IHsgb25seTogWydjb2wnLCAndGVtcGxhdGUnXSB9LFxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuXHR0YWJsZToge1xuXHRcdG9ubHk6IFsnY2FwdGlvbicsICdjb2xncm91cCcsICd0Ym9keScsICd0aGVhZCcsICd0Zm9vdCcsICdzdHlsZScsICdzY3JpcHQnLCAndGVtcGxhdGUnXVxuXHR9LFxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG5cdGhlYWQ6IHtcblx0XHRvbmx5OiBbXG5cdFx0XHQnYmFzZScsXG5cdFx0XHQnYmFzZWZvbnQnLFxuXHRcdFx0J2Jnc291bmQnLFxuXHRcdFx0J2xpbmsnLFxuXHRcdFx0J21ldGEnLFxuXHRcdFx0J3RpdGxlJyxcblx0XHRcdCdub3NjcmlwdCcsXG5cdFx0XHQnbm9mcmFtZXMnLFxuXHRcdFx0J3N0eWxlJyxcblx0XHRcdCdzY3JpcHQnLFxuXHRcdFx0J3RlbXBsYXRlJ1xuXHRcdF1cblx0fSxcblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuXHRodG1sOiB7IG9ubHk6IFsnaGVhZCcsICdib2R5JywgJ2ZyYW1lc2V0J10gfSxcblx0ZnJhbWVzZXQ6IHsgb25seTogWydmcmFtZSddIH0sXG5cdCcjZG9jdW1lbnQnOiB7IG9ubHk6IFsnaHRtbCddIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciBtZXNzYWdlIGlmIHRoZSB0YWcgaXMgbm90IGFsbG93ZWQgaW5zaWRlIHRoZSBhbmNlc3RvciB0YWcgKHdoaWNoIGlzIGdyYW5kcGFyZW50IGFuZCBhYm92ZSkgc3VjaCB0aGF0IGl0IHdpbGwgcmVzdWx0XG4gKiBpbiB0aGUgYnJvd3NlciByZXBhaXJpbmcgdGhlIEhUTUwsIHdoaWNoIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiBhbiBlcnJvciBkdXJpbmcgaHlkcmF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkX3RhZ1xuICogQHBhcmFtIHtzdHJpbmdbXX0gYW5jZXN0b3JzIEFsbCBub2RlcyBzdGFydGluZyB3aXRoIHRoZSBwYXJlbnQsIHVwIHVudGlsIHRoZSBhbmNlc3Rvciwgd2hpY2ggbWVhbnMgdHdvIGVudHJpZXMgbWluaW11bVxuICogQHBhcmFtIHtzdHJpbmd9IFtjaGlsZF9sb2NdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FuY2VzdG9yX2xvY11cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfdGFnX3ZhbGlkX3dpdGhfYW5jZXN0b3IoY2hpbGRfdGFnLCBhbmNlc3RvcnMsIGNoaWxkX2xvYywgYW5jZXN0b3JfbG9jKSB7XG5cdGlmIChjaGlsZF90YWcuaW5jbHVkZXMoJy0nKSkgcmV0dXJuIG51bGw7IC8vIGN1c3RvbSBlbGVtZW50cyBjYW4gYmUgYW55dGhpbmdcblxuXHRjb25zdCBhbmNlc3Rvcl90YWcgPSBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuXHRjb25zdCBkaXNhbGxvd2VkID0gZGlzYWxsb3dlZF9jaGlsZHJlblthbmNlc3Rvcl90YWddO1xuXHRpZiAoIWRpc2FsbG93ZWQpIHJldHVybiBudWxsO1xuXG5cdGlmICgncmVzZXRfYnknIGluIGRpc2FsbG93ZWQgJiYgZGlzYWxsb3dlZC5yZXNldF9ieSkge1xuXHRcdGZvciAobGV0IGkgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXHRcdFx0aWYgKGFuY2VzdG9yLmluY2x1ZGVzKCctJykpIHJldHVybiBudWxsOyAvLyBjdXN0b20gZWxlbWVudHMgY2FuIGJlIGFueXRoaW5nXG5cblx0XHRcdC8vIEEgcmVzZXQgbWVhbnMgdGhhdCBmb3JiaWRkZW4gZGVzY2VuZGFudHMgYXJlIGFsbG93ZWQgYWdhaW5cblx0XHRcdGlmIChkaXNhbGxvd2VkLnJlc2V0X2J5LmluY2x1ZGVzKGFuY2VzdG9yc1tpXSkpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCdkZXNjZW5kYW50JyBpbiBkaXNhbGxvd2VkICYmIGRpc2FsbG93ZWQuZGVzY2VuZGFudC5pbmNsdWRlcyhjaGlsZF90YWcpKSB7XG5cdFx0Y29uc3QgY2hpbGQgPSBjaGlsZF9sb2MgPyBgXFxgPCR7Y2hpbGRfdGFnfT5cXGAgKCR7Y2hpbGRfbG9jfSlgIDogYFxcYDwke2NoaWxkX3RhZ30+XFxgYDtcblx0XHRjb25zdCBhbmNlc3RvciA9IGFuY2VzdG9yX2xvY1xuXHRcdFx0PyBgXFxgPCR7YW5jZXN0b3JfdGFnfT5cXGAgKCR7YW5jZXN0b3JfbG9jfSlgXG5cdFx0XHQ6IGBcXGA8JHthbmNlc3Rvcl90YWd9PlxcYGA7XG5cblx0XHRyZXR1cm4gYCR7Y2hpbGR9IGNhbm5vdCBiZSBhIGRlc2NlbmRhbnQgb2YgJHthbmNlc3Rvcn1gO1xuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciBtZXNzYWdlIGlmIHRoZSB0YWcgaXMgbm90IGFsbG93ZWQgaW5zaWRlIHRoZSBwYXJlbnQgdGFnIHN1Y2ggdGhhdCBpdCB3aWxsIHJlc3VsdFxuICogaW4gdGhlIGJyb3dzZXIgcmVwYWlyaW5nIHRoZSBIVE1MLCB3aGljaCB3aWxsIGxpa2VseSByZXN1bHQgaW4gYW4gZXJyb3IgZHVyaW5nIGh5ZHJhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZF90YWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRfdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NoaWxkX2xvY11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyZW50X2xvY11cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfdGFnX3ZhbGlkX3dpdGhfcGFyZW50KGNoaWxkX3RhZywgcGFyZW50X3RhZywgY2hpbGRfbG9jLCBwYXJlbnRfbG9jKSB7XG5cdGlmIChjaGlsZF90YWcuaW5jbHVkZXMoJy0nKSB8fCBwYXJlbnRfdGFnPy5pbmNsdWRlcygnLScpKSByZXR1cm4gbnVsbDsgLy8gY3VzdG9tIGVsZW1lbnRzIGNhbiBiZSBhbnl0aGluZ1xuXG5cdGlmIChwYXJlbnRfdGFnID09PSAndGVtcGxhdGUnKSByZXR1cm4gbnVsbDsgLy8gbm8gZXJyb3JzIG9yIHdhcm5pbmcgc2hvdWxkIGJlIHRocm93biBpbiBpbW1lZGlhdGUgY2hpbGRyZW4gb2YgdGVtcGxhdGUgdGFnc1xuXG5cdGNvbnN0IGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkX2NoaWxkcmVuW3BhcmVudF90YWddO1xuXG5cdGNvbnN0IGNoaWxkID0gY2hpbGRfbG9jID8gYFxcYDwke2NoaWxkX3RhZ30+XFxgICgke2NoaWxkX2xvY30pYCA6IGBcXGA8JHtjaGlsZF90YWd9PlxcYGA7XG5cdGNvbnN0IHBhcmVudCA9IHBhcmVudF9sb2MgPyBgXFxgPCR7cGFyZW50X3RhZ30+XFxgICgke3BhcmVudF9sb2N9KWAgOiBgXFxgPCR7cGFyZW50X3RhZ30+XFxgYDtcblxuXHRpZiAoZGlzYWxsb3dlZCkge1xuXHRcdGlmICgnZGlyZWN0JyBpbiBkaXNhbGxvd2VkICYmIGRpc2FsbG93ZWQuZGlyZWN0LmluY2x1ZGVzKGNoaWxkX3RhZykpIHtcblx0XHRcdHJldHVybiBgJHtjaGlsZH0gY2Fubm90IGJlIGEgZGlyZWN0IGNoaWxkIG9mICR7cGFyZW50fWA7XG5cdFx0fVxuXG5cdFx0aWYgKCdkZXNjZW5kYW50JyBpbiBkaXNhbGxvd2VkICYmIGRpc2FsbG93ZWQuZGVzY2VuZGFudC5pbmNsdWRlcyhjaGlsZF90YWcpKSB7XG5cdFx0XHRyZXR1cm4gYCR7Y2hpbGR9IGNhbm5vdCBiZSBhIGNoaWxkIG9mICR7cGFyZW50fWA7XG5cdFx0fVxuXG5cdFx0aWYgKCdvbmx5JyBpbiBkaXNhbGxvd2VkICYmIGRpc2FsbG93ZWQub25seSkge1xuXHRcdFx0aWYgKGRpc2FsbG93ZWQub25seS5pbmNsdWRlcyhjaGlsZF90YWcpKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGAke2NoaWxkfSBjYW5ub3QgYmUgYSBjaGlsZCBvZiAke3BhcmVudH0uIFxcYDwke3BhcmVudF90YWd9PlxcYCBvbmx5IGFsbG93cyB0aGVzZSBjaGlsZHJlbjogJHtkaXNhbGxvd2VkLm9ubHkubWFwKChkKSA9PiBgXFxgPCR7ZH0+XFxgYCkuam9pbignLCAnKX1gO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG5cdC8vIHBhcnNpbmcgcnVsZXMgLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuXHQvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcblx0Ly8gY2FzZXMgYXJlIGludmFsaWQgKGFuZCB3ZSBvbmx5IGdldCBpbnRvIHRoaXMgZnVuY3Rpb24gaWYgd2Uga25vdyB0aGUgcGFyZW50KS5cblx0c3dpdGNoIChjaGlsZF90YWcpIHtcblx0XHRjYXNlICdib2R5Jzpcblx0XHRjYXNlICdjYXB0aW9uJzpcblx0XHRjYXNlICdjb2wnOlxuXHRcdGNhc2UgJ2NvbGdyb3VwJzpcblx0XHRjYXNlICdmcmFtZXNldCc6XG5cdFx0Y2FzZSAnZnJhbWUnOlxuXHRcdGNhc2UgJ2hlYWQnOlxuXHRcdGNhc2UgJ2h0bWwnOlxuXHRcdFx0cmV0dXJuIGAke2NoaWxkfSBjYW5ub3QgYmUgYSBjaGlsZCBvZiAke3BhcmVudH1gO1xuXHRcdGNhc2UgJ3RoZWFkJzpcblx0XHRjYXNlICd0Ym9keSc6XG5cdFx0Y2FzZSAndGZvb3QnOlxuXHRcdFx0cmV0dXJuIGAke2NoaWxkfSBtdXN0IGJlIHRoZSBjaGlsZCBvZiBhIFxcYDx0YWJsZT5cXGAsIG5vdCBhICR7cGFyZW50fWA7XG5cdFx0Y2FzZSAndGQnOlxuXHRcdGNhc2UgJ3RoJzpcblx0XHRcdHJldHVybiBgJHtjaGlsZH0gbXVzdCBiZSB0aGUgY2hpbGQgb2YgYSBcXGA8dHI+XFxgLCBub3QgYSAke3BhcmVudH1gO1xuXHRcdGNhc2UgJ3RyJzpcblx0XHRcdHJldHVybiBgXFxgPHRyPlxcYCBtdXN0IGJlIHRoZSBjaGlsZCBvZiBhIFxcYDx0aGVhZD5cXGAsIFxcYDx0Ym9keT5cXGAsIG9yIFxcYDx0Zm9vdD5cXGAsIG5vdCBhICR7cGFyZW50fWA7XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cbiIsICIvKiogQGltcG9ydCB7IFNTUkNvbnRleHQgfSBmcm9tICcjc2VydmVyJyAqL1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0aXNfdGFnX3ZhbGlkX3dpdGhfYW5jZXN0b3IsXG5cdGlzX3RhZ192YWxpZF93aXRoX3BhcmVudFxufSBmcm9tICcuLi8uLi9odG1sLXRyZWUtdmFsaWRhdGlvbi5qcyc7XG5pbXBvcnQgeyBnZXRfc3RhY2sgfSBmcm9tICcuLi9zaGFyZWQvZGV2LmpzJztcbmltcG9ydCB7IHNldF9zc3JfY29udGV4dCwgc3NyX2NvbnRleHQgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyZXIuanMnO1xuXG4vLyBUT0RPIG1vdmUgdGhpc1xuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogXHR0YWc6IHN0cmluZztcbiAqIFx0cGFyZW50OiB1bmRlZmluZWQgfCBFbGVtZW50O1xuICogIGZpbGVuYW1lOiB1bmRlZmluZWQgfCBzdHJpbmc7XG4gKiAgbGluZTogbnVtYmVyO1xuICogIGNvbHVtbjogbnVtYmVyO1xuICogfX0gRWxlbWVudFxuICovXG5cbi8qKlxuICogVGhpcyBpcyBleHBvcnRlZCBzbyB0aGF0IGl0IGNhbiBiZSBjbGVhcmVkIGJldHdlZW4gdGVzdHNcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGxldCBzZWVuO1xuXG4vKipcbiAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5mdW5jdGlvbiBwcmludF9lcnJvcihyZW5kZXJlciwgbWVzc2FnZSkge1xuXHRtZXNzYWdlID1cblx0XHRgbm9kZV9pbnZhbGlkX3BsYWNlbWVudF9zc3I6ICR7bWVzc2FnZX1cXG5cXG5gICtcblx0XHQnVGhpcyBjYW4gY2F1c2UgY29udGVudCB0byBzaGlmdCBhcm91bmQgYXMgdGhlIGJyb3dzZXIgcmVwYWlycyB0aGUgSFRNTCwgYW5kIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiBhIGBoeWRyYXRpb25fbWlzbWF0Y2hgIHdhcm5pbmcuJztcblxuXHRpZiAoKHNlZW4gPz89IG5ldyBTZXQoKSkuaGFzKG1lc3NhZ2UpKSByZXR1cm47XG5cdHNlZW4uYWRkKG1lc3NhZ2UpO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG5cdHJlbmRlcmVyLmhlYWQoKHIpID0+IHIucHVzaChgPHNjcmlwdD5jb25zb2xlLmVycm9yKCR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9KTwvc2NyaXB0PmApKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICogQHBhcmFtIHtudW1iZXJ9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1c2hfZWxlbWVudChyZW5kZXJlciwgdGFnLCBsaW5lLCBjb2x1bW4pIHtcblx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge1NTUkNvbnRleHR9ICovIChzc3JfY29udGV4dCk7XG5cdHZhciBmaWxlbmFtZSA9IGNvbnRleHQuZnVuY3Rpb25bRklMRU5BTUVdO1xuXHR2YXIgcGFyZW50ID0gY29udGV4dC5lbGVtZW50O1xuXHR2YXIgZWxlbWVudCA9IHsgdGFnLCBwYXJlbnQsIGZpbGVuYW1lLCBsaW5lLCBjb2x1bW4gfTtcblxuXHRpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgYW5jZXN0b3IgPSBwYXJlbnQucGFyZW50O1xuXHRcdHZhciBhbmNlc3RvcnMgPSBbcGFyZW50LnRhZ107XG5cblx0XHRjb25zdCBjaGlsZF9sb2MgPSBmaWxlbmFtZSA/IGAke2ZpbGVuYW1lfToke2xpbmV9OiR7Y29sdW1ufWAgOiB1bmRlZmluZWQ7XG5cdFx0Y29uc3QgcGFyZW50X2xvYyA9IHBhcmVudC5maWxlbmFtZVxuXHRcdFx0PyBgJHtwYXJlbnQuZmlsZW5hbWV9OiR7cGFyZW50LmxpbmV9OiR7cGFyZW50LmNvbHVtbn1gXG5cdFx0XHQ6IHVuZGVmaW5lZDtcblxuXHRcdGNvbnN0IG1lc3NhZ2UgPSBpc190YWdfdmFsaWRfd2l0aF9wYXJlbnQodGFnLCBwYXJlbnQudGFnLCBjaGlsZF9sb2MsIHBhcmVudF9sb2MpO1xuXHRcdGlmIChtZXNzYWdlKSBwcmludF9lcnJvcihyZW5kZXJlciwgbWVzc2FnZSk7XG5cblx0XHR3aGlsZSAoYW5jZXN0b3IgIT0gbnVsbCkge1xuXHRcdFx0YW5jZXN0b3JzLnB1c2goYW5jZXN0b3IudGFnKTtcblx0XHRcdGNvbnN0IGFuY2VzdG9yX2xvYyA9IGFuY2VzdG9yLmZpbGVuYW1lXG5cdFx0XHRcdD8gYCR7YW5jZXN0b3IuZmlsZW5hbWV9OiR7YW5jZXN0b3IubGluZX06JHthbmNlc3Rvci5jb2x1bW59YFxuXHRcdFx0XHQ6IHVuZGVmaW5lZDtcblxuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGlzX3RhZ192YWxpZF93aXRoX2FuY2VzdG9yKHRhZywgYW5jZXN0b3JzLCBjaGlsZF9sb2MsIGFuY2VzdG9yX2xvYyk7XG5cdFx0XHRpZiAobWVzc2FnZSkgcHJpbnRfZXJyb3IocmVuZGVyZXIsIG1lc3NhZ2UpO1xuXG5cdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcblx0XHR9XG5cdH1cblxuXHRzZXRfc3NyX2NvbnRleHQoeyAuLi5jb250ZXh0LCBwOiBjb250ZXh0LCBlbGVtZW50IH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wX2VsZW1lbnQoKSB7XG5cdHNldF9zc3JfY29udGV4dCgvKiogQHR5cGUge1NTUkNvbnRleHR9ICovIChzc3JfY29udGV4dCkucCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3NuaXBwZXRfYXJncyhyZW5kZXJlcikge1xuXHRpZiAoXG5cdFx0dHlwZW9mIHJlbmRlcmVyICE9PSAnb2JqZWN0JyB8fFxuXHRcdC8vIGZvciBzb21lIHJlYXNvbiB0eXBlc2NyaXB0IGNvbnNpZGVyIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFzIG5ldmVyIGFmdGVyIHRoZSBmaXJzdCBpbnN0YW5jZW9mXG5cdFx0IShyZW5kZXJlciBpbnN0YW5jZW9mIFJlbmRlcmVyKVxuXHQpIHtcblx0XHRlLmludmFsaWRfc25pcHBldF9hcmd1bWVudHMoKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3VzZXJfY29kZV9sb2NhdGlvbigpIHtcblx0Y29uc3Qgc3RhY2sgPSBnZXRfc3RhY2soKTtcblxuXHRyZXR1cm4gc3RhY2tcblx0XHQuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnRyaW0oKS5zdGFydHNXaXRoKCdhdCAnKSlcblx0XHQubWFwKChsaW5lKSA9PiBsaW5lLnJlcGxhY2UoL1xcKCguKik6XFxkKzpcXGQrXFwpJC8sIChfLCBmaWxlKSA9PiBgKCR7ZmlsZX0pYCkpXG5cdFx0LmpvaW4oJ1xcbicpO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50VHlwZSwgU3ZlbHRlQ29tcG9uZW50LCBDb21wb25lbnQgfSBmcm9tICdzdmVsdGUnICovXG4vKiogQGltcG9ydCB7IFJlbmRlck91dHB1dCB9IGZyb20gJyNzZXJ2ZXInICovXG4vKiogQGltcG9ydCB7IFN0b3JlIH0gZnJvbSAnI3NoYXJlZCcgKi9cbi8qKiBAaW1wb3J0IHsgQWNjdW11bGF0ZWRDb250ZW50IH0gZnJvbSAnLi9yZW5kZXJlci5qcycgKi9cbmV4cG9ydCB7IEZJTEVOQU1FLCBITVIgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYXR0ciwgY2xzeCwgdG9fY2xhc3MsIHRvX3N0eWxlIH0gZnJvbSAnLi4vc2hhcmVkL2F0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgaXNfcHJvbWlzZSwgbm9vcCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBzdWJzY3JpYmVfdG9fc3RvcmUgfSBmcm9tICcuLi8uLi9zdG9yZS91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRVTklOSVRJQUxJWkVELFxuXHRFTEVNRU5UX1BSRVNFUlZFX0FUVFJJQlVURV9DQVNFLFxuXHRFTEVNRU5UX0lTX05BTUVTUEFDRUQsXG5cdEVMRU1FTlRfSVNfSU5QVVRcbn0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGVzY2FwZV9odG1sIH0gZnJvbSAnLi4vLi4vZXNjYXBpbmcuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBFTVBUWV9DT01NRU5ULCBCTE9DS19DTE9TRSwgQkxPQ0tfT1BFTiwgQkxPQ0tfT1BFTl9FTFNFIH0gZnJvbSAnLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVfc3RvcmUgfSBmcm9tICcuLi9zaGFyZWQvdmFsaWRhdGUuanMnO1xuaW1wb3J0IHsgaXNfYm9vbGVhbl9hdHRyaWJ1dGUsIGlzX3Jhd190ZXh0X2VsZW1lbnQsIGlzX3ZvaWQgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyZXIuanMnO1xuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNub25jaGFyYWN0ZXJcbmNvbnN0IElOVkFMSURfQVRUUl9OQU1FX0NIQVJfUkVHRVggPVxuXHQvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGF0dHJpYnV0ZXNfZm5cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2hpbGRyZW5fZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudChyZW5kZXJlciwgdGFnLCBhdHRyaWJ1dGVzX2ZuID0gbm9vcCwgY2hpbGRyZW5fZm4gPSBub29wKSB7XG5cdHJlbmRlcmVyLnB1c2goJzwhLS0tLT4nKTtcblxuXHRpZiAodGFnKSB7XG5cdFx0cmVuZGVyZXIucHVzaChgPCR7dGFnfWApO1xuXHRcdGF0dHJpYnV0ZXNfZm4oKTtcblx0XHRyZW5kZXJlci5wdXNoKGA+YCk7XG5cblx0XHRpZiAoIWlzX3ZvaWQodGFnKSkge1xuXHRcdFx0Y2hpbGRyZW5fZm4oKTtcblx0XHRcdGlmICghaXNfcmF3X3RleHRfZWxlbWVudCh0YWcpKSB7XG5cdFx0XHRcdHJlbmRlcmVyLnB1c2goRU1QVFlfQ09NTUVOVCk7XG5cdFx0XHR9XG5cdFx0XHRyZW5kZXJlci5wdXNoKGA8LyR7dGFnfT5gKTtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXJlci5wdXNoKCc8IS0tLS0+Jyk7XG59XG5cbi8qKlxuICogT25seSBhdmFpbGFibGUgb24gdGhlIHNlcnZlciBhbmQgd2hlbiBjb21waWxpbmcgd2l0aCB0aGUgYHNlcnZlcmAgb3B0aW9uLlxuICogVGFrZXMgYSBjb21wb25lbnQgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYGJvZHlgIGFuZCBgaGVhZGAgcHJvcGVydGllcyBvbiBpdCwgd2hpY2ggeW91IGNhbiB1c2UgdG8gcG9wdWxhdGUgdGhlIEhUTUwgd2hlbiBzZXJ2ZXItcmVuZGVyaW5nIHlvdXIgYXBwLlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHBhcmFtIHtDb21wb25lbnQ8UHJvcHM+IHwgQ29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHM+Pn0gY29tcG9uZW50XG4gKiBAcGFyYW0ge3sgcHJvcHM/OiBPbWl0PFByb3BzLCAnJCRzbG90cycgfCAnJCRldmVudHMnPjsgY29udGV4dD86IE1hcDxhbnksIGFueT47IGlkUHJlZml4Pzogc3RyaW5nIH19IFtvcHRpb25zXVxuICogQHJldHVybnMge1JlbmRlck91dHB1dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihjb21wb25lbnQsIG9wdGlvbnMgPSB7fSkge1xuXHRyZXR1cm4gUmVuZGVyZXIucmVuZGVyKC8qKiBAdHlwZSB7Q29tcG9uZW50PFByb3BzPn0gKi8gKGNvbXBvbmVudCksIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICogQHBhcmFtIHsocmVuZGVyZXI6IFJlbmRlcmVyKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZH0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZChoYXNoLCByZW5kZXJlciwgZm4pIHtcblx0cmVuZGVyZXIuaGVhZCgocmVuZGVyZXIpID0+IHtcblx0XHRyZW5kZXJlci5wdXNoKGA8IS0tJHtoYXNofS0tPmApO1xuXHRcdHJlbmRlcmVyLmNoaWxkKGZuKTtcblx0XHRyZW5kZXJlci5wdXNoKEVNUFRZX0NPTU1FTlQpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICogQHBhcmFtIHtib29sZWFufSBpc19odG1sXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IHByb3BzXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtib29sZWFufSBkeW5hbWljXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNzc19wcm9wcyhyZW5kZXJlciwgaXNfaHRtbCwgcHJvcHMsIGNvbXBvbmVudCwgZHluYW1pYyA9IGZhbHNlKSB7XG5cdGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcocHJvcHMpO1xuXG5cdGlmIChpc19odG1sKSB7XG5cdFx0cmVuZGVyZXIucHVzaChgPHN2ZWx0ZS1jc3Mtd3JhcHBlciBzdHlsZT1cImRpc3BsYXk6IGNvbnRlbnRzOyAke3N0eWxlc31cIj5gKTtcblx0fSBlbHNlIHtcblx0XHRyZW5kZXJlci5wdXNoKGA8ZyBzdHlsZT1cIiR7c3R5bGVzfVwiPmApO1xuXHR9XG5cblx0aWYgKGR5bmFtaWMpIHtcblx0XHRyZW5kZXJlci5wdXNoKCc8IS0tLS0+Jyk7XG5cdH1cblxuXHRjb21wb25lbnQoKTtcblxuXHRpZiAoaXNfaHRtbCkge1xuXHRcdHJlbmRlcmVyLnB1c2goYDwhLS0tLT48L3N2ZWx0ZS1jc3Mtd3JhcHBlcj5gKTtcblx0fSBlbHNlIHtcblx0XHRyZW5kZXJlci5wdXNoKGA8IS0tLS0+PC9nPmApO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gYXR0cnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY3NzX2hhc2hdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSBbY2xhc3Nlc11cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gW3N0eWxlc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZmxhZ3NdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlcyhhdHRycywgY3NzX2hhc2gsIGNsYXNzZXMsIHN0eWxlcywgZmxhZ3MgPSAwKSB7XG5cdGlmIChzdHlsZXMpIHtcblx0XHRhdHRycy5zdHlsZSA9IHRvX3N0eWxlKGF0dHJzLnN0eWxlLCBzdHlsZXMpO1xuXHR9XG5cblx0aWYgKGF0dHJzLmNsYXNzKSB7XG5cdFx0YXR0cnMuY2xhc3MgPSBjbHN4KGF0dHJzLmNsYXNzKTtcblx0fVxuXG5cdGlmIChjc3NfaGFzaCB8fCBjbGFzc2VzKSB7XG5cdFx0YXR0cnMuY2xhc3MgPSB0b19jbGFzcyhhdHRycy5jbGFzcywgY3NzX2hhc2gsIGNsYXNzZXMpO1xuXHR9XG5cblx0bGV0IGF0dHJfc3RyID0gJyc7XG5cdGxldCBuYW1lO1xuXG5cdGNvbnN0IGlzX2h0bWwgPSAoZmxhZ3MgJiBFTEVNRU5UX0lTX05BTUVTUEFDRUQpID09PSAwO1xuXHRjb25zdCBsb3dlcmNhc2UgPSAoZmxhZ3MgJiBFTEVNRU5UX1BSRVNFUlZFX0FUVFJJQlVURV9DQVNFKSA9PT0gMDtcblx0Y29uc3QgaXNfaW5wdXQgPSAoZmxhZ3MgJiBFTEVNRU5UX0lTX0lOUFVUKSAhPT0gMDtcblxuXHRmb3IgKG5hbWUgaW4gYXR0cnMpIHtcblx0XHQvLyBvbWl0IGZ1bmN0aW9ucywgaW50ZXJuYWwgc3ZlbHRlIHByb3BlcnRpZXMgYW5kIGludmFsaWQgYXR0cmlidXRlIG5hbWVzXG5cdFx0aWYgKHR5cGVvZiBhdHRyc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG5cdFx0aWYgKG5hbWVbMF0gPT09ICckJyAmJiBuYW1lWzFdID09PSAnJCcpIGNvbnRpbnVlOyAvLyBmYXN0ZXIgdGhhbiBuYW1lLnN0YXJ0c1dpdGgoJyQkJylcblx0XHRpZiAoSU5WQUxJRF9BVFRSX05BTUVfQ0hBUl9SRUdFWC50ZXN0KG5hbWUpKSBjb250aW51ZTtcblxuXHRcdHZhciB2YWx1ZSA9IGF0dHJzW25hbWVdO1xuXG5cdFx0aWYgKGxvd2VyY2FzZSkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfaW5wdXQpIHtcblx0XHRcdGlmIChuYW1lID09PSAnZGVmYXVsdHZhbHVlJyB8fCBuYW1lID09PSAnZGVmYXVsdGNoZWNrZWQnKSB7XG5cdFx0XHRcdG5hbWUgPSBuYW1lID09PSAnZGVmYXVsdHZhbHVlJyA/ICd2YWx1ZScgOiAnY2hlY2tlZCc7XG5cdFx0XHRcdGlmIChhdHRyc1tuYW1lXSkgY29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXR0cl9zdHIgKz0gYXR0cihuYW1lLCB2YWx1ZSwgaXNfaHRtbCAmJiBpc19ib29sZWFuX2F0dHJpYnV0ZShuYW1lKSk7XG5cdH1cblxuXHRyZXR1cm4gYXR0cl9zdHI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdfSBwcm9wc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHVua25vd24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkX3Byb3BzKHByb3BzKSB7XG5cdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICovXG5cdGNvbnN0IG1lcmdlZF9wcm9wcyA9IHt9O1xuXHRsZXQga2V5O1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBvYmogPSBwcm9wc1tpXTtcblx0XHRmb3IgKGtleSBpbiBvYmopIHtcblx0XHRcdGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblx0XHRcdGlmIChkZXNjKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXJnZWRfcHJvcHMsIGtleSwgZGVzYyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZXJnZWRfcHJvcHNba2V5XSA9IG9ialtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWVyZ2VkX3Byb3BzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlICsgJyc7XG59XG5cbi8qKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IHN0eWxlX29iamVjdCAqL1xuZnVuY3Rpb24gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlX29iamVjdClcblx0XHQuZmlsdGVyKC8qKiBAcGFyYW0ge2FueX0ga2V5ICovIChrZXkpID0+IHN0eWxlX29iamVjdFtrZXldICE9IG51bGwgJiYgc3R5bGVfb2JqZWN0W2tleV0gIT09ICcnKVxuXHRcdC5tYXAoLyoqIEBwYXJhbSB7YW55fSBrZXkgKi8gKGtleSkgPT4gYCR7a2V5fTogJHtlc2NhcGVfaHRtbChzdHlsZV9vYmplY3Rba2V5XSwgdHJ1ZSl9O2ApXG5cdFx0LmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbaGFzaF1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59IFtkaXJlY3RpdmVzXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cl9jbGFzcyh2YWx1ZSwgaGFzaCwgZGlyZWN0aXZlcykge1xuXHR2YXIgcmVzdWx0ID0gdG9fY2xhc3ModmFsdWUsIGhhc2gsIGRpcmVjdGl2ZXMpO1xuXHRyZXR1cm4gcmVzdWx0ID8gYCBjbGFzcz1cIiR7ZXNjYXBlX2h0bWwocmVzdWx0LCB0cnVlKX1cImAgOiAnJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyxhbnk+fFtSZWNvcmQ8c3RyaW5nLGFueT4sUmVjb3JkPHN0cmluZyxhbnk+XX0gW2RpcmVjdGl2ZXNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyX3N0eWxlKHZhbHVlLCBkaXJlY3RpdmVzKSB7XG5cdHZhciByZXN1bHQgPSB0b19zdHlsZSh2YWx1ZSwgZGlyZWN0aXZlcyk7XG5cdHJldHVybiByZXN1bHQgPyBgIHN0eWxlPVwiJHtlc2NhcGVfaHRtbChyZXN1bHQsIHRydWUpfVwiYCA6ICcnO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIFthbnksIGFueSwgYW55XT59IHN0b3JlX3ZhbHVlc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmU8Vj4gfCBudWxsIHwgdW5kZWZpbmVkfSBzdG9yZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9nZXQoc3RvcmVfdmFsdWVzLCBzdG9yZV9uYW1lLCBzdG9yZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0dmFsaWRhdGVfc3RvcmUoc3RvcmUsIHN0b3JlX25hbWUuc2xpY2UoMSkpO1xuXHR9XG5cblx0Ly8gaXQgY291bGQgYmUgdGhhdCBzb21lb25lIGVhZ2VybHkgdXBkYXRlcyB0aGUgc3RvcmUgaW4gdGhlIGluc3RhbmNlIHNjcmlwdCwgc29cblx0Ly8gd2Ugc2hvdWxkIG9ubHkgcmV1c2UgdGhlIHN0b3JlIHZhbHVlIGluIHRoZSB0ZW1wbGF0ZVxuXHRpZiAoc3RvcmVfbmFtZSBpbiBzdG9yZV92YWx1ZXMgJiYgc3RvcmVfdmFsdWVzW3N0b3JlX25hbWVdWzBdID09PSBzdG9yZSkge1xuXHRcdHJldHVybiBzdG9yZV92YWx1ZXNbc3RvcmVfbmFtZV1bMl07XG5cdH1cblxuXHRzdG9yZV92YWx1ZXNbc3RvcmVfbmFtZV0/LlsxXSgpOyAvLyBpZiBzdG9yZSB3YXMgc3dpdGNoZWQsIHVuc3Vic2NyaWJlIGZyb20gb2xkIHN0b3JlXG5cdHN0b3JlX3ZhbHVlc1tzdG9yZV9uYW1lXSA9IFtzdG9yZSwgbnVsbCwgdW5kZWZpbmVkXTtcblx0Y29uc3QgdW5zdWIgPSBzdWJzY3JpYmVfdG9fc3RvcmUoXG5cdFx0c3RvcmUsXG5cdFx0LyoqIEBwYXJhbSB7YW55fSB2ICovICh2KSA9PiAoc3RvcmVfdmFsdWVzW3N0b3JlX25hbWVdWzJdID0gdilcblx0KTtcblx0c3RvcmVfdmFsdWVzW3N0b3JlX25hbWVdWzFdID0gdW5zdWI7XG5cdHJldHVybiBzdG9yZV92YWx1ZXNbc3RvcmVfbmFtZV1bMl07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbmV3IHZhbHVlIG9mIGEgc3RvcmUgYW5kIHJldHVybnMgdGhhdCB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1N0b3JlPFY+fSBzdG9yZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9zZXQoc3RvcmUsIHZhbHVlKSB7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgc3RvcmUgd2l0aCBhIG5ldyB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIFthbnksIGFueSwgYW55XT59IHN0b3JlX3ZhbHVlc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmU8Vj59IHN0b3JlXG4gKiBAcGFyYW0ge2FueX0gZXhwcmVzc2lvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfbXV0YXRlKHN0b3JlX3ZhbHVlcywgc3RvcmVfbmFtZSwgc3RvcmUsIGV4cHJlc3Npb24pIHtcblx0c3RvcmVfc2V0KHN0b3JlLCBzdG9yZV9nZXQoc3RvcmVfdmFsdWVzLCBzdG9yZV9uYW1lLCBzdG9yZSkpO1xuXHRyZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIFthbnksIGFueSwgYW55XT59IHN0b3JlX3ZhbHVlc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmU8bnVtYmVyPn0gc3RvcmVcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc3RvcmUoc3RvcmVfdmFsdWVzLCBzdG9yZV9uYW1lLCBzdG9yZSwgZCA9IDEpIHtcblx0bGV0IHN0b3JlX3ZhbHVlID0gc3RvcmVfZ2V0KHN0b3JlX3ZhbHVlcywgc3RvcmVfbmFtZSwgc3RvcmUpO1xuXHRzdG9yZS5zZXQoc3RvcmVfdmFsdWUgKyBkKTtcblx0cmV0dXJuIHN0b3JlX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgW2FueSwgYW55LCBhbnldPn0gc3RvcmVfdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICogQHBhcmFtIHtTdG9yZTxudW1iZXI+fSBzdG9yZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zdG9yZV9wcmUoc3RvcmVfdmFsdWVzLCBzdG9yZV9uYW1lLCBzdG9yZSwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBzdG9yZV9nZXQoc3RvcmVfdmFsdWVzLCBzdG9yZV9uYW1lLCBzdG9yZSkgKyBkO1xuXHRzdG9yZS5zZXQodmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIFthbnksIGFueSwgYW55XT59IHN0b3JlX3ZhbHVlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuc3Vic2NyaWJlX3N0b3JlcyhzdG9yZV92YWx1ZXMpIHtcblx0Zm9yIChjb25zdCBzdG9yZV9uYW1lIGluIHN0b3JlX3ZhbHVlcykge1xuXHRcdHN0b3JlX3ZhbHVlc1tzdG9yZV9uYW1lXVsxXSgpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gJCRwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHNsb3RfcHJvcHNcbiAqIEBwYXJhbSB7bnVsbCB8ICgoKSA9PiB2b2lkKX0gZmFsbGJhY2tfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xvdChyZW5kZXJlciwgJCRwcm9wcywgbmFtZSwgc2xvdF9wcm9wcywgZmFsbGJhY2tfZm4pIHtcblx0dmFyIHNsb3RfZm4gPSAkJHByb3BzLiQkc2xvdHM/LltuYW1lXTtcblx0Ly8gSW50ZXJvcDogQ2FuIHVzZSBzbmlwcGV0cyB0byBmaWxsIHNsb3RzXG5cdGlmIChzbG90X2ZuID09PSB0cnVlKSB7XG5cdFx0c2xvdF9mbiA9ICQkcHJvcHNbbmFtZSA9PT0gJ2RlZmF1bHQnID8gJ2NoaWxkcmVuJyA6IG5hbWVdO1xuXHR9XG5cblx0aWYgKHNsb3RfZm4gIT09IHVuZGVmaW5lZCkge1xuXHRcdHNsb3RfZm4ocmVuZGVyZXIsIHNsb3RfcHJvcHMpO1xuXHR9IGVsc2Uge1xuXHRcdGZhbGxiYWNrX2ZuPy4oKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSByZXN0XG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN0X3Byb3BzKHByb3BzLCByZXN0KSB7XG5cdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICovXG5cdGNvbnN0IHJlc3RfcHJvcHMgPSB7fTtcblx0bGV0IGtleTtcblx0Zm9yIChrZXkgaW4gcHJvcHMpIHtcblx0XHRpZiAoIXJlc3QuaW5jbHVkZXMoa2V5KSkge1xuXHRcdFx0cmVzdF9wcm9wc1trZXldID0gcHJvcHNba2V5XTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3RfcHJvcHM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplX3Byb3BzKHByb3BzKSB7XG5cdGNvbnN0IHsgY2hpbGRyZW4sICQkc2xvdHMsIC4uLnNhbml0aXplZCB9ID0gcHJvcHM7XG5cdHJldHVybiBzYW5pdGl6ZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBwcm9wc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVfc2xvdHMocHJvcHMpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn0gKi9cblx0Y29uc3Qgc2FuaXRpemVkID0ge307XG5cdGlmIChwcm9wcy5jaGlsZHJlbikgc2FuaXRpemVkLmRlZmF1bHQgPSB0cnVlO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBwcm9wcy4kJHNsb3RzKSB7XG5cdFx0c2FuaXRpemVkW2tleV0gPSB0cnVlO1xuXHR9XG5cdHJldHVybiBzYW5pdGl6ZWQ7XG59XG5cbi8qKlxuICogTGVnYWN5IG1vZGU6IElmIHRoZSBwcm9wIGhhcyBhIGZhbGxiYWNrIGFuZCBpcyBib3VuZCBpbiB0aGVcbiAqIHBhcmVudCBjb21wb25lbnQsIHByb3BhZ2F0ZSB0aGUgZmFsbGJhY2sgdmFsdWUgdXB3YXJkcy5cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzX3BhcmVudFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNfbm93XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3Byb3BzKHByb3BzX3BhcmVudCwgcHJvcHNfbm93KSB7XG5cdGZvciAoY29uc3Qga2V5IGluIHByb3BzX25vdykge1xuXHRcdGNvbnN0IGluaXRpYWxfdmFsdWUgPSBwcm9wc19wYXJlbnRba2V5XTtcblx0XHRjb25zdCB2YWx1ZSA9IHByb3BzX25vd1trZXldO1xuXHRcdGlmIChcblx0XHRcdGluaXRpYWxfdmFsdWUgPT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0dmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9wc19wYXJlbnQsIGtleSk/LnNldFxuXHRcdCkge1xuXHRcdFx0cHJvcHNfcGFyZW50W2tleV0gPSB2YWx1ZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAqIEBwYXJhbSB7UHJvbWlzZTxWPn0gcHJvbWlzZVxuICogQHBhcmFtIHtudWxsIHwgKCgpID0+IHZvaWQpfSBwZW5kaW5nX2ZuXG4gKiBAcGFyYW0geyh2YWx1ZTogVikgPT4gdm9pZH0gdGhlbl9mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGF3YWl0X2Jsb2NrKHJlbmRlcmVyLCBwcm9taXNlLCBwZW5kaW5nX2ZuLCB0aGVuX2ZuKSB7XG5cdGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG5cdFx0cmVuZGVyZXIucHVzaChCTE9DS19PUEVOKTtcblx0XHRwcm9taXNlLnRoZW4obnVsbCwgbm9vcCk7XG5cdFx0aWYgKHBlbmRpbmdfZm4gIT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmdfZm4oKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodGhlbl9mbiAhPT0gbnVsbCkge1xuXHRcdHJlbmRlcmVyLnB1c2goQkxPQ0tfT1BFTl9FTFNFKTtcblx0XHR0aGVuX2ZuKHByb21pc2UpO1xuXHR9XG59XG5cbmV4cG9ydCB7IGF3YWl0X2Jsb2NrIGFzIGF3YWl0IH07XG5cbi8qKiBAcGFyYW0ge2FueX0gYXJyYXlfbGlrZV9vcl9pdGVyYXRvciAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZV9hcnJheV9saWtlKGFycmF5X2xpa2Vfb3JfaXRlcmF0b3IpIHtcblx0aWYgKGFycmF5X2xpa2Vfb3JfaXRlcmF0b3IpIHtcblx0XHRyZXR1cm4gYXJyYXlfbGlrZV9vcl9pdGVyYXRvci5sZW5ndGggIT09IHVuZGVmaW5lZFxuXHRcdFx0PyBhcnJheV9saWtlX29yX2l0ZXJhdG9yXG5cdFx0XHQ6IEFycmF5LmZyb20oYXJyYXlfbGlrZV9vcl9pdGVyYXRvcik7XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0geygpID0+IFZ9IGdldF92YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25jZShnZXRfdmFsdWUpIHtcblx0bGV0IHZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAoVU5JTklUSUFMSVpFRCk7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKHZhbHVlID09PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0XHR2YWx1ZSA9IGdldF92YWx1ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIHVuaXF1ZSBJRFxuICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19pZChyZW5kZXJlcikge1xuXHRjb25zdCB1aWQgPSByZW5kZXJlci5nbG9iYWwudWlkKCk7XG5cdHJlbmRlcmVyLnB1c2goJzwhLS0kJyArIHVpZCArICctLT4nKTtcblx0cmV0dXJuIHVpZDtcbn1cblxuZXhwb3J0IHsgYXR0ciwgY2xzeCB9O1xuXG5leHBvcnQgeyBodG1sIH0gZnJvbSAnLi9ibG9ja3MvaHRtbC5qcyc7XG5cbmV4cG9ydCB7IHNhdmUgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuXG5leHBvcnQgeyBwdXNoX2VsZW1lbnQsIHBvcF9lbGVtZW50LCB2YWxpZGF0ZV9zbmlwcGV0X2FyZ3MgfSBmcm9tICcuL2Rldi5qcyc7XG5cbmV4cG9ydCB7IHNuYXBzaG90IH0gZnJvbSAnLi4vc2hhcmVkL2Nsb25lLmpzJztcblxuZXhwb3J0IHsgZmFsbGJhY2ssIHRvX2FycmF5IH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuZXhwb3J0IHtcblx0aW52YWxpZF9kZWZhdWx0X3NuaXBwZXQsXG5cdHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudF90YWcsXG5cdHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50LFxuXHRwcmV2ZW50X3NuaXBwZXRfc3RyaW5naWZpY2F0aW9uXG59IGZyb20gJy4uL3NoYXJlZC92YWxpZGF0ZS5qcyc7XG5cbmV4cG9ydCB7IGVzY2FwZV9odG1sIGFzIGVzY2FwZSB9O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpPT5UfSBmblxuICogQHJldHVybnMgeyhuZXdfdmFsdWU/OiBUKSA9PiAoVCB8IHZvaWQpfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChmbikge1xuXHRjb25zdCBnZXRfdmFsdWUgPSBvbmNlKGZuKTtcblx0LyoqXG5cdCAqIEB0eXBlIHtUIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0bGV0IHVwZGF0ZWRfdmFsdWU7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChuZXdfdmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHVwZGF0ZWRfdmFsdWUgPz8gZ2V0X3ZhbHVlKCk7XG5cdFx0fVxuXHRcdHVwZGF0ZWRfdmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0cmV0dXJuIHVwZGF0ZWRfdmFsdWU7XG5cdH07XG59XG4iLCAiZXhwb3J0IHsgcmVuZGVyIH0gZnJvbSAnLi4vaW50ZXJuYWwvc2VydmVyL2luZGV4LmpzJztcbiIsICIvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG5leHBvcnQgY29uc3QgZXNjYXBlZCA9IHtcblx0JzwnOiAnXFxcXHUwMDNDJyxcblx0J1xcXFwnOiAnXFxcXFxcXFwnLFxuXHQnXFxiJzogJ1xcXFxiJyxcblx0J1xcZic6ICdcXFxcZicsXG5cdCdcXG4nOiAnXFxcXG4nLFxuXHQnXFxyJzogJ1xcXFxyJyxcblx0J1xcdCc6ICdcXFxcdCcsXG5cdCdcXHUyMDI4JzogJ1xcXFx1MjAyOCcsXG5cdCdcXHUyMDI5JzogJ1xcXFx1MjAyOSdcbn07XG5cbmV4cG9ydCBjbGFzcyBEZXZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBrZXlzKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gJ0RldmFsdWVFcnJvcic7XG5cdFx0dGhpcy5wYXRoID0ga2V5cy5qb2luKCcnKTtcblx0fVxufVxuXG4vKiogQHBhcmFtIHthbnl9IHRoaW5nICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJpbWl0aXZlKHRoaW5nKSB7XG5cdHJldHVybiBPYmplY3QodGhpbmcpICE9PSB0aGluZztcbn1cblxuY29uc3Qgb2JqZWN0X3Byb3RvX25hbWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFxuXHRPYmplY3QucHJvdG90eXBlXG4pXG5cdC5zb3J0KClcblx0LmpvaW4oJ1xcMCcpO1xuXG4vKiogQHBhcmFtIHthbnl9IHRoaW5nICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcGxhaW5fb2JqZWN0KHRoaW5nKSB7XG5cdGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaW5nKTtcblxuXHRyZXR1cm4gKFxuXHRcdHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8XG5cdFx0cHJvdG8gPT09IG51bGwgfHxcblx0XHRPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pID09PSBudWxsIHx8XG5cdFx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLnNvcnQoKS5qb2luKCdcXDAnKSA9PT0gb2JqZWN0X3Byb3RvX25hbWVzXG5cdCk7XG59XG5cbi8qKiBAcGFyYW0ge2FueX0gdGhpbmcgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfdHlwZSh0aGluZykge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaW5nKS5zbGljZSg4LCAtMSk7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gY2hhciAqL1xuZnVuY3Rpb24gZ2V0X2VzY2FwZWRfY2hhcihjaGFyKSB7XG5cdHN3aXRjaCAoY2hhcikge1xuXHRcdGNhc2UgJ1wiJzpcblx0XHRcdHJldHVybiAnXFxcXFwiJztcblx0XHRjYXNlICc8Jzpcblx0XHRcdHJldHVybiAnXFxcXHUwMDNDJztcblx0XHRjYXNlICdcXFxcJzpcblx0XHRcdHJldHVybiAnXFxcXFxcXFwnO1xuXHRcdGNhc2UgJ1xcbic6XG5cdFx0XHRyZXR1cm4gJ1xcXFxuJztcblx0XHRjYXNlICdcXHInOlxuXHRcdFx0cmV0dXJuICdcXFxccic7XG5cdFx0Y2FzZSAnXFx0Jzpcblx0XHRcdHJldHVybiAnXFxcXHQnO1xuXHRcdGNhc2UgJ1xcYic6XG5cdFx0XHRyZXR1cm4gJ1xcXFxiJztcblx0XHRjYXNlICdcXGYnOlxuXHRcdFx0cmV0dXJuICdcXFxcZic7XG5cdFx0Y2FzZSAnXFx1MjAyOCc6XG5cdFx0XHRyZXR1cm4gJ1xcXFx1MjAyOCc7XG5cdFx0Y2FzZSAnXFx1MjAyOSc6XG5cdFx0XHRyZXR1cm4gJ1xcXFx1MjAyOSc7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBjaGFyIDwgJyAnXG5cdFx0XHRcdD8gYFxcXFx1JHtjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDQsICcwJyl9YFxuXHRcdFx0XHQ6ICcnO1xuXHR9XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gc3RyICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5X3N0cmluZyhzdHIpIHtcblx0bGV0IHJlc3VsdCA9ICcnO1xuXHRsZXQgbGFzdF9wb3MgPSAwO1xuXHRjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRjb25zdCBjaGFyID0gc3RyW2ldO1xuXHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0X2VzY2FwZWRfY2hhcihjaGFyKTtcblx0XHRpZiAocmVwbGFjZW1lbnQpIHtcblx0XHRcdHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdF9wb3MsIGkpICsgcmVwbGFjZW1lbnQ7XG5cdFx0XHRsYXN0X3BvcyA9IGkgKyAxO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBgXCIke2xhc3RfcG9zID09PSAwID8gc3RyIDogcmVzdWx0ICsgc3RyLnNsaWNlKGxhc3RfcG9zKX1cImA7XG59XG5cbi8qKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT59IG9iamVjdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmFibGVfc3ltYm9scyhvYmplY3QpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KS5maWx0ZXIoXG5cdFx0KHN5bWJvbCkgPT4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bWJvbCkuZW51bWVyYWJsZVxuXHQpO1xufVxuXG5jb25zdCBpc19pZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBrZXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlfa2V5KGtleSkge1xuXHRyZXR1cm4gaXNfaWRlbnRpZmllci50ZXN0KGtleSkgPyAnLicgKyBrZXkgOiAnWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nO1xufVxuIiwgImltcG9ydCB7XG5cdERldmFsdWVFcnJvcixcblx0ZW51bWVyYWJsZV9zeW1ib2xzLFxuXHRlc2NhcGVkLFxuXHRnZXRfdHlwZSxcblx0aXNfcGxhaW5fb2JqZWN0LFxuXHRpc19wcmltaXRpdmUsXG5cdHN0cmluZ2lmeV9rZXksXG5cdHN0cmluZ2lmeV9zdHJpbmdcbn0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IGNoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfJCc7XG5jb25zdCB1bnNhZmVfY2hhcnMgPSAvWzxcXGJcXGZcXG5cXHJcXHRcXDBcXHUyMDI4XFx1MjAyOV0vZztcbmNvbnN0IHJlc2VydmVkID1cblx0L14oPzpkb3xpZnxpbnxmb3J8aW50fGxldHxuZXd8dHJ5fHZhcnxieXRlfGNhc2V8Y2hhcnxlbHNlfGVudW18Z290b3xsb25nfHRoaXN8dm9pZHx3aXRofGF3YWl0fGJyZWFrfGNhdGNofGNsYXNzfGNvbnN0fGZpbmFsfGZsb2F0fHNob3J0fHN1cGVyfHRocm93fHdoaWxlfHlpZWxkfGRlbGV0ZXxkb3VibGV8ZXhwb3J0fGltcG9ydHxuYXRpdmV8cmV0dXJufHN3aXRjaHx0aHJvd3N8dHlwZW9mfGJvb2xlYW58ZGVmYXVsdHxleHRlbmRzfGZpbmFsbHl8cGFja2FnZXxwcml2YXRlfGFic3RyYWN0fGNvbnRpbnVlfGRlYnVnZ2VyfGZ1bmN0aW9ufHZvbGF0aWxlfGludGVyZmFjZXxwcm90ZWN0ZWR8dHJhbnNpZW50fGltcGxlbWVudHN8aW5zdGFuY2VvZnxzeW5jaHJvbml6ZWQpJC87XG5cbi8qKlxuICogVHVybiBhIHZhbHVlIGludG8gdGhlIEphdmFTY3JpcHQgdGhhdCBjcmVhdGVzIGFuIGVxdWl2YWxlbnQgdmFsdWVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHsodmFsdWU6IGFueSwgdW5ldmFsOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nKSA9PiBzdHJpbmcgfCB2b2lkfSBbcmVwbGFjZXJdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmV2YWwodmFsdWUsIHJlcGxhY2VyKSB7XG5cdGNvbnN0IGNvdW50cyA9IG5ldyBNYXAoKTtcblxuXHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRjb25zdCBrZXlzID0gW107XG5cblx0Y29uc3QgY3VzdG9tID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBAcGFyYW0ge2FueX0gdGhpbmcgKi9cblx0ZnVuY3Rpb24gd2Fsayh0aGluZykge1xuXHRcdGlmICghaXNfcHJpbWl0aXZlKHRoaW5nKSkge1xuXHRcdFx0aWYgKGNvdW50cy5oYXModGhpbmcpKSB7XG5cdFx0XHRcdGNvdW50cy5zZXQodGhpbmcsIGNvdW50cy5nZXQodGhpbmcpICsgMSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y291bnRzLnNldCh0aGluZywgMSk7XG5cblx0XHRcdGlmIChyZXBsYWNlcikge1xuXHRcdFx0XHRjb25zdCBzdHIgPSByZXBsYWNlcih0aGluZywgKHZhbHVlKSA9PiB1bmV2YWwodmFsdWUsIHJlcGxhY2VyKSk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Y3VzdG9tLnNldCh0aGluZywgc3RyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRGV2YWx1ZUVycm9yKGBDYW5ub3Qgc3RyaW5naWZ5IGEgZnVuY3Rpb25gLCBrZXlzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHlwZSA9IGdldF90eXBlKHRoaW5nKTtcblxuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdGNhc2UgJ0JpZ0ludCc6XG5cdFx0XHRcdGNhc2UgJ1N0cmluZyc6XG5cdFx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRjYXNlICdEYXRlJzpcblx0XHRcdFx0Y2FzZSAnUmVnRXhwJzpcblx0XHRcdFx0Y2FzZSAnVVJMJzpcblx0XHRcdFx0Y2FzZSAnVVJMU2VhcmNoUGFyYW1zJzpcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7YW55W119ICovICh0aGluZykuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcblx0XHRcdFx0XHRcdGtleXMucHVzaChgWyR7aX1dYCk7XG5cdFx0XHRcdFx0XHR3YWxrKHZhbHVlKTtcblx0XHRcdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU2V0Jzpcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaW5nKS5mb3JFYWNoKHdhbGspO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hcCc6XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpbmcpIHtcblx0XHRcdFx0XHRcdGtleXMucHVzaChcblx0XHRcdFx0XHRcdFx0YC5nZXQoJHtpc19wcmltaXRpdmUoa2V5KSA/IHN0cmluZ2lmeV9wcmltaXRpdmUoa2V5KSA6ICcuLi4nfSlgXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0d2Fsayh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdJbnQ4QXJyYXknOlxuXHRcdFx0XHRjYXNlICdVaW50OEFycmF5Jzpcblx0XHRcdFx0Y2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuXHRcdFx0XHRjYXNlICdJbnQxNkFycmF5Jzpcblx0XHRcdFx0Y2FzZSAnVWludDE2QXJyYXknOlxuXHRcdFx0XHRjYXNlICdJbnQzMkFycmF5Jzpcblx0XHRcdFx0Y2FzZSAnVWludDMyQXJyYXknOlxuXHRcdFx0XHRjYXNlICdGbG9hdDMyQXJyYXknOlxuXHRcdFx0XHRjYXNlICdGbG9hdDY0QXJyYXknOlxuXHRcdFx0XHRjYXNlICdCaWdJbnQ2NEFycmF5Jzpcblx0XHRcdFx0Y2FzZSAnQmlnVWludDY0QXJyYXknOlxuXHRcdFx0XHRcdHdhbGsodGhpbmcuYnVmZmVyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0Y2FzZSAnQXJyYXlCdWZmZXInOlxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRjYXNlICdUZW1wb3JhbC5EdXJhdGlvbic6XG5cdFx0XHRcdGNhc2UgJ1RlbXBvcmFsLkluc3RhbnQnOlxuXHRcdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpbkRhdGUnOlxuXHRcdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpblRpbWUnOlxuXHRcdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJzpcblx0XHRcdFx0Y2FzZSAnVGVtcG9yYWwuUGxhaW5Nb250aERheSc6XG5cdFx0XHRcdGNhc2UgJ1RlbXBvcmFsLlBsYWluWWVhck1vbnRoJzpcblx0XHRcdFx0Y2FzZSAnVGVtcG9yYWwuWm9uZWREYXRlVGltZSc6XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYgKCFpc19wbGFpbl9vYmplY3QodGhpbmcpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRGV2YWx1ZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRgQ2Fubm90IHN0cmluZ2lmeSBhcmJpdHJhcnkgbm9uLVBPSk9zYCxcblx0XHRcdFx0XHRcdFx0a2V5c1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZW51bWVyYWJsZV9zeW1ib2xzKHRoaW5nKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRGV2YWx1ZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRgQ2Fubm90IHN0cmluZ2lmeSBQT0pPcyB3aXRoIHN5bWJvbGljIGtleXNgLFxuXHRcdFx0XHRcdFx0XHRrZXlzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIHRoaW5nKSB7XG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goc3RyaW5naWZ5X2tleShrZXkpKTtcblx0XHRcdFx0XHRcdHdhbGsodGhpbmdba2V5XSk7XG5cdFx0XHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR3YWxrKHZhbHVlKTtcblxuXHRjb25zdCBuYW1lcyA9IG5ldyBNYXAoKTtcblxuXHRBcnJheS5mcm9tKGNvdW50cylcblx0XHQuZmlsdGVyKChlbnRyeSkgPT4gZW50cnlbMV0gPiAxKVxuXHRcdC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlcblx0XHQuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcblx0XHRcdG5hbWVzLnNldChlbnRyeVswXSwgZ2V0X25hbWUoaSkpO1xuXHRcdH0pO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gdGhpbmdcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeSh0aGluZykge1xuXHRcdGlmIChuYW1lcy5oYXModGhpbmcpKSB7XG5cdFx0XHRyZXR1cm4gbmFtZXMuZ2V0KHRoaW5nKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfcHJpbWl0aXZlKHRoaW5nKSkge1xuXHRcdFx0cmV0dXJuIHN0cmluZ2lmeV9wcmltaXRpdmUodGhpbmcpO1xuXHRcdH1cblxuXHRcdGlmIChjdXN0b20uaGFzKHRoaW5nKSkge1xuXHRcdFx0cmV0dXJuIGN1c3RvbS5nZXQodGhpbmcpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHR5cGUgPSBnZXRfdHlwZSh0aGluZyk7XG5cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRjYXNlICdTdHJpbmcnOlxuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiBgT2JqZWN0KCR7c3RyaW5naWZ5KHRoaW5nLnZhbHVlT2YoKSl9KWA7XG5cblx0XHRcdGNhc2UgJ1JlZ0V4cCc6XG5cdFx0XHRcdHJldHVybiBgbmV3IFJlZ0V4cCgke3N0cmluZ2lmeV9zdHJpbmcodGhpbmcuc291cmNlKX0sIFwiJHtcblx0XHRcdFx0XHR0aGluZy5mbGFnc1xuXHRcdFx0XHR9XCIpYDtcblxuXHRcdFx0Y2FzZSAnRGF0ZSc6XG5cdFx0XHRcdHJldHVybiBgbmV3IERhdGUoJHt0aGluZy5nZXRUaW1lKCl9KWA7XG5cblx0XHRcdGNhc2UgJ1VSTCc6XG5cdFx0XHRcdHJldHVybiBgbmV3IFVSTCgke3N0cmluZ2lmeV9zdHJpbmcodGhpbmcudG9TdHJpbmcoKSl9KWA7XG5cblx0XHRcdGNhc2UgJ1VSTFNlYXJjaFBhcmFtcyc6XG5cdFx0XHRcdHJldHVybiBgbmV3IFVSTFNlYXJjaFBhcmFtcygke3N0cmluZ2lmeV9zdHJpbmcodGhpbmcudG9TdHJpbmcoKSl9KWA7XG5cblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0Y29uc3QgbWVtYmVycyA9IC8qKiBAdHlwZSB7YW55W119ICovICh0aGluZykubWFwKCh2LCBpKSA9PlxuXHRcdFx0XHRcdGkgaW4gdGhpbmcgPyBzdHJpbmdpZnkodikgOiAnJ1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zdCB0YWlsID0gdGhpbmcubGVuZ3RoID09PSAwIHx8IHRoaW5nLmxlbmd0aCAtIDEgaW4gdGhpbmcgPyAnJyA6ICcsJztcblx0XHRcdFx0cmV0dXJuIGBbJHttZW1iZXJzLmpvaW4oJywnKX0ke3RhaWx9XWA7XG5cblx0XHRcdGNhc2UgJ1NldCc6XG5cdFx0XHRjYXNlICdNYXAnOlxuXHRcdFx0XHRyZXR1cm4gYG5ldyAke3R5cGV9KFske0FycmF5LmZyb20odGhpbmcpLm1hcChzdHJpbmdpZnkpLmpvaW4oJywnKX1dKWA7XG5cblx0XHRcdGNhc2UgJ0ludDhBcnJheSc6XG5cdFx0XHRjYXNlICdVaW50OEFycmF5Jzpcblx0XHRcdGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5Jzpcblx0XHRcdGNhc2UgJ0ludDE2QXJyYXknOlxuXHRcdFx0Y2FzZSAnVWludDE2QXJyYXknOlxuXHRcdFx0Y2FzZSAnSW50MzJBcnJheSc6XG5cdFx0XHRjYXNlICdVaW50MzJBcnJheSc6XG5cdFx0XHRjYXNlICdGbG9hdDMyQXJyYXknOlxuXHRcdFx0Y2FzZSAnRmxvYXQ2NEFycmF5Jzpcblx0XHRcdGNhc2UgJ0JpZ0ludDY0QXJyYXknOlxuXHRcdFx0Y2FzZSAnQmlnVWludDY0QXJyYXknOiB7XG5cdFx0XHRcdGxldCBzdHIgPSBgbmV3ICR7dHlwZX1gO1xuXG5cdFx0XHRcdGlmIChjb3VudHMuZ2V0KHRoaW5nLmJ1ZmZlcikgPT09IDEpIHtcblx0XHRcdFx0XHRjb25zdCBhcnJheSA9IG5ldyB0aGluZy5jb25zdHJ1Y3Rvcih0aGluZy5idWZmZXIpO1xuXHRcdFx0XHRcdHN0ciArPSBgKFske2FycmF5fV0pYDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHIgKz0gYChbJHtzdHJpbmdpZnkodGhpbmcuYnVmZmVyKX1dKWA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBhID0gdGhpbmcuYnl0ZU9mZnNldDtcblx0XHRcdFx0Y29uc3QgYiA9IGEgKyB0aGluZy5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdC8vIGhhbmRsZSBzdWJhcnJheXNcblx0XHRcdFx0aWYgKGEgPiAwIHx8IGIgIT09IHRoaW5nLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29uc3QgbSA9ICsvKFxcZCspLy5leGVjKHR5cGUpWzFdIC8gODtcblx0XHRcdFx0XHRzdHIgKz0gYC5zdWJhcnJheSgke2EgLyBtfSwke2IgLyBtfSlgO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHN0cjtcblx0XHRcdH1cblxuXHRcdFx0Y2FzZSAnQXJyYXlCdWZmZXInOiB7XG5cdFx0XHRcdGNvbnN0IHVpOCA9IG5ldyBVaW50OEFycmF5KHRoaW5nKTtcblx0XHRcdFx0cmV0dXJuIGBuZXcgVWludDhBcnJheShbJHt1aTgudG9TdHJpbmcoKX1dKS5idWZmZXJgO1xuXHRcdFx0fVxuXG5cdFx0XHRjYXNlICdUZW1wb3JhbC5EdXJhdGlvbic6XG5cdFx0XHRjYXNlICdUZW1wb3JhbC5JbnN0YW50Jzpcblx0XHRcdGNhc2UgJ1RlbXBvcmFsLlBsYWluRGF0ZSc6XG5cdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpblRpbWUnOlxuXHRcdFx0Y2FzZSAnVGVtcG9yYWwuUGxhaW5EYXRlVGltZSc6XG5cdFx0XHRjYXNlICdUZW1wb3JhbC5QbGFpbk1vbnRoRGF5Jzpcblx0XHRcdGNhc2UgJ1RlbXBvcmFsLlBsYWluWWVhck1vbnRoJzpcblx0XHRcdGNhc2UgJ1RlbXBvcmFsLlpvbmVkRGF0ZVRpbWUnOlxuXHRcdFx0XHRyZXR1cm4gYCR7dHlwZX0uZnJvbSgke3N0cmluZ2lmeV9zdHJpbmcodGhpbmcudG9TdHJpbmcoKSl9KWA7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGluZyk7XG5cdFx0XHRcdGNvbnN0IG9iaiA9IGtleXNcblx0XHRcdFx0XHQubWFwKChrZXkpID0+IGAke3NhZmVfa2V5KGtleSl9OiR7c3RyaW5naWZ5KHRoaW5nW2tleV0pfWApXG5cdFx0XHRcdFx0LmpvaW4oJywnKTtcblx0XHRcdFx0Y29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpO1xuXHRcdFx0XHRpZiAocHJvdG8gPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4ga2V5cy5sZW5ndGggPiAwXG5cdFx0XHRcdFx0XHQ/IGB7JHtvYmp9LF9fcHJvdG9fXzpudWxsfWBcblx0XHRcdFx0XHRcdDogYHtfX3Byb3RvX186bnVsbH1gO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGB7JHtvYmp9fWA7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgc3RyID0gc3RyaW5naWZ5KHZhbHVlKTtcblxuXHRpZiAobmFtZXMuc2l6ZSkge1xuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cblx0XHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRcdGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcblxuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRuYW1lcy5mb3JFYWNoKChuYW1lLCB0aGluZykgPT4ge1xuXHRcdFx0cGFyYW1zLnB1c2gobmFtZSk7XG5cblx0XHRcdGlmIChjdXN0b20uaGFzKHRoaW5nKSkge1xuXHRcdFx0XHR2YWx1ZXMucHVzaCgvKiogQHR5cGUge3N0cmluZ30gKi8gKGN1c3RvbS5nZXQodGhpbmcpKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzX3ByaW1pdGl2ZSh0aGluZykpIHtcblx0XHRcdFx0dmFsdWVzLnB1c2goc3RyaW5naWZ5X3ByaW1pdGl2ZSh0aGluZykpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHR5cGUgPSBnZXRfdHlwZSh0aGluZyk7XG5cblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdTdHJpbmcnOlxuXHRcdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChgT2JqZWN0KCR7c3RyaW5naWZ5KHRoaW5nLnZhbHVlT2YoKSl9KWApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1JlZ0V4cCc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2godGhpbmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRGF0ZSc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYG5ldyBEYXRlKCR7dGhpbmcuZ2V0VGltZSgpfSlgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYEFycmF5KCR7dGhpbmcubGVuZ3RofSlgKTtcblx0XHRcdFx0XHQvKiogQHR5cGUge2FueVtdfSAqLyAodGhpbmcpLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0XHRcdHN0YXRlbWVudHMucHVzaChgJHtuYW1lfVske2l9XT0ke3N0cmluZ2lmeSh2KX1gKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTZXQnOlxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKGBuZXcgU2V0YCk7XG5cdFx0XHRcdFx0c3RhdGVtZW50cy5wdXNoKFxuXHRcdFx0XHRcdFx0YCR7bmFtZX0uJHtBcnJheS5mcm9tKHRoaW5nKVxuXHRcdFx0XHRcdFx0XHQubWFwKCh2KSA9PiBgYWRkKCR7c3RyaW5naWZ5KHYpfSlgKVxuXHRcdFx0XHRcdFx0XHQuam9pbignLicpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hcCc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYG5ldyBNYXBgKTtcblx0XHRcdFx0XHRzdGF0ZW1lbnRzLnB1c2goXG5cdFx0XHRcdFx0XHRgJHtuYW1lfS4ke0FycmF5LmZyb20odGhpbmcpXG5cdFx0XHRcdFx0XHRcdC5tYXAoKFtrLCB2XSkgPT4gYHNldCgke3N0cmluZ2lmeShrKX0sICR7c3RyaW5naWZ5KHYpfSlgKVxuXHRcdFx0XHRcdFx0XHQuam9pbignLicpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0FycmF5QnVmZmVyJzpcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChcblx0XHRcdFx0XHRcdGBuZXcgVWludDhBcnJheShbJHtuZXcgVWludDhBcnJheSh0aGluZykuam9pbignLCcpfV0pLmJ1ZmZlcmBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goXG5cdFx0XHRcdFx0XHRPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpID09PSBudWxsID8gJ09iamVjdC5jcmVhdGUobnVsbCknIDogJ3t9J1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXModGhpbmcpLmZvckVhY2goKGtleSkgPT4ge1xuXHRcdFx0XHRcdFx0c3RhdGVtZW50cy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRgJHtuYW1lfSR7c2FmZV9wcm9wKGtleSl9PSR7c3RyaW5naWZ5KHRoaW5nW2tleV0pfWBcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRzdGF0ZW1lbnRzLnB1c2goYHJldHVybiAke3N0cn1gKTtcblxuXHRcdHJldHVybiBgKGZ1bmN0aW9uKCR7cGFyYW1zLmpvaW4oJywnKX0peyR7c3RhdGVtZW50cy5qb2luKFxuXHRcdFx0JzsnXG5cdFx0KX19KCR7dmFsdWVzLmpvaW4oJywnKX0pKWA7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxufVxuXG4vKiogQHBhcmFtIHtudW1iZXJ9IG51bSAqL1xuZnVuY3Rpb24gZ2V0X25hbWUobnVtKSB7XG5cdGxldCBuYW1lID0gJyc7XG5cblx0ZG8ge1xuXHRcdG5hbWUgPSBjaGFyc1tudW0gJSBjaGFycy5sZW5ndGhdICsgbmFtZTtcblx0XHRudW0gPSB+fihudW0gLyBjaGFycy5sZW5ndGgpIC0gMTtcblx0fSB3aGlsZSAobnVtID49IDApO1xuXG5cdHJldHVybiByZXNlcnZlZC50ZXN0KG5hbWUpID8gYCR7bmFtZX0wYCA6IG5hbWU7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gYyAqL1xuZnVuY3Rpb24gZXNjYXBlX3Vuc2FmZV9jaGFyKGMpIHtcblx0cmV0dXJuIGVzY2FwZWRbY10gfHwgYztcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzdHIgKi9cbmZ1bmN0aW9uIGVzY2FwZV91bnNhZmVfY2hhcnMoc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSh1bnNhZmVfY2hhcnMsIGVzY2FwZV91bnNhZmVfY2hhcik7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30ga2V5ICovXG5mdW5jdGlvbiBzYWZlX2tleShrZXkpIHtcblx0cmV0dXJuIC9eW18kYS16QS1aXVtfJGEtekEtWjAtOV0qJC8udGVzdChrZXkpXG5cdFx0PyBrZXlcblx0XHQ6IGVzY2FwZV91bnNhZmVfY2hhcnMoSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30ga2V5ICovXG5mdW5jdGlvbiBzYWZlX3Byb3Aoa2V5KSB7XG5cdHJldHVybiAvXltfJGEtekEtWl1bXyRhLXpBLVowLTldKiQvLnRlc3Qoa2V5KVxuXHRcdD8gYC4ke2tleX1gXG5cdFx0OiBgWyR7ZXNjYXBlX3Vuc2FmZV9jaGFycyhKU09OLnN0cmluZ2lmeShrZXkpKX1dYDtcbn1cblxuLyoqIEBwYXJhbSB7YW55fSB0aGluZyAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5X3ByaW1pdGl2ZSh0aGluZykge1xuXHRpZiAodHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJykgcmV0dXJuIHN0cmluZ2lmeV9zdHJpbmcodGhpbmcpO1xuXHRpZiAodGhpbmcgPT09IHZvaWQgMCkgcmV0dXJuICd2b2lkIDAnO1xuXHRpZiAodGhpbmcgPT09IDAgJiYgMSAvIHRoaW5nIDwgMCkgcmV0dXJuICctMCc7XG5cdGNvbnN0IHN0ciA9IFN0cmluZyh0aGluZyk7XG5cdGlmICh0eXBlb2YgdGhpbmcgPT09ICdudW1iZXInKSByZXR1cm4gc3RyLnJlcGxhY2UoL14oLSk/MFxcLi8sICckMS4nKTtcblx0aWYgKHR5cGVvZiB0aGluZyA9PT0gJ2JpZ2ludCcpIHJldHVybiB0aGluZyArICduJztcblx0cmV0dXJuIHN0cjtcbn1cbiIsICJleHBvcnQgeyB1bmV2YWwgfSBmcm9tICcuL3NyYy91bmV2YWwuanMnO1xuZXhwb3J0IHsgcGFyc2UsIHVuZmxhdHRlbiB9IGZyb20gJy4vc3JjL3BhcnNlLmpzJztcbmV4cG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3JjL3N0cmluZ2lmeS5qcyc7XG4iLCAiLyoqIEBpbXBvcnQgeyBIeWRyYXRhYmxlTG9va3VwRW50cnkgfSBmcm9tICcjc2VydmVyJyAqL1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgZ2V0X3JlbmRlcl9jb250ZXh0IH0gZnJvbSAnLi9yZW5kZXItY29udGV4dC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIGRldmFsdWUgZnJvbSAnZGV2YWx1ZSc7XG5pbXBvcnQgeyBnZXRfc3RhY2sgfSBmcm9tICcuLi9zaGFyZWQvZGV2LmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0X3VzZXJfY29kZV9sb2NhdGlvbiB9IGZyb20gJy4vZGV2LmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRhYmxlKGtleSwgZm4pIHtcblx0aWYgKCFhc3luY19tb2RlX2ZsYWcpIHtcblx0XHRlLmV4cGVyaW1lbnRhbF9hc3luY19yZXF1aXJlZCgnaHlkcmF0YWJsZScpO1xuXHR9XG5cblx0Y29uc3QgeyBoeWRyYXRhYmxlIH0gPSBnZXRfcmVuZGVyX2NvbnRleHQoKTtcblxuXHRsZXQgZW50cnkgPSBoeWRyYXRhYmxlLmxvb2t1cC5nZXQoa2V5KTtcblxuXHRpZiAoZW50cnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdGNvbnN0IGNvbXBhcmlzb24gPSBjb21wYXJlKGtleSwgZW50cnksIGVuY29kZShrZXksIGZuKCkpKTtcblx0XHRcdGNvbXBhcmlzb24uY2F0Y2goKCkgPT4ge30pO1xuXHRcdFx0aHlkcmF0YWJsZS5jb21wYXJpc29ucy5wdXNoKGNvbXBhcmlzb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiAvKiogQHR5cGUge1R9ICovIChlbnRyeS52YWx1ZSk7XG5cdH1cblxuXHRjb25zdCB2YWx1ZSA9IGZuKCk7XG5cblx0ZW50cnkgPSBlbmNvZGUoa2V5LCB2YWx1ZSwgaHlkcmF0YWJsZS51bnJlc29sdmVkX3Byb21pc2VzKTtcblx0aHlkcmF0YWJsZS5sb29rdXAuc2V0KGtleSwgZW50cnkpO1xuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7TWFwPFByb21pc2U8YW55Piwgc3RyaW5nPn0gW3VucmVzb2x2ZWRdXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShrZXksIHZhbHVlLCB1bnJlc29sdmVkKSB7XG5cdC8qKiBAdHlwZSB7SHlkcmF0YWJsZUxvb2t1cEVudHJ5fSAqL1xuXHRjb25zdCBlbnRyeSA9IHsgdmFsdWUsIHNlcmlhbGl6ZWQ6ICcnIH07XG5cblx0aWYgKERFVikge1xuXHRcdGVudHJ5LnN0YWNrID0gZ2V0X3VzZXJfY29kZV9sb2NhdGlvbigpO1xuXHR9XG5cblx0bGV0IHVpZCA9IDE7XG5cblx0ZW50cnkuc2VyaWFsaXplZCA9IGRldmFsdWUudW5ldmFsKGVudHJ5LnZhbHVlLCAodmFsdWUsIHVuZXZhbCkgPT4ge1xuXHRcdGlmIChpc19wcm9taXNlKHZhbHVlKSkge1xuXHRcdFx0Y29uc3QgcCA9IHZhbHVlXG5cdFx0XHRcdC50aGVuKCh2KSA9PiBgcigke3VuZXZhbCh2KX0pYClcblx0XHRcdFx0LmNhdGNoKChkZXZhbHVlX2Vycm9yKSA9PlxuXHRcdFx0XHRcdGUuaHlkcmF0YWJsZV9zZXJpYWxpemF0aW9uX2ZhaWxlZChcblx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdHNlcmlhbGl6YXRpb25fc3RhY2soZW50cnkuc3RhY2ssIGRldmFsdWVfZXJyb3I/LnN0YWNrKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gcHJldmVudCB1bmhhbmRsZWQgcmVqZWN0aW9ucyBmcm9tIGNyYXNoaW5nIHRoZSBzZXJ2ZXJcblx0XHRcdHAuY2F0Y2goKCkgPT4ge30pO1xuXG5cdFx0XHQvLyB0cmFjayB3aGljaCBwcm9taXNlcyBhcmUgc3RpbGwgcmVzb2x2aW5nIHdoZW4gcmVuZGVyIGlzIGNvbXBsZXRlXG5cdFx0XHR1bnJlc29sdmVkPy5zZXQocCwga2V5KTtcblx0XHRcdHAuZmluYWxseSgoKSA9PiB1bnJlc29sdmVkPy5kZWxldGUocCkpO1xuXG5cdFx0XHQvLyB3ZSBzZXJpYWxpemUgcHJvbWlzZXMgYXMgYFwiJHtpfVwiYCwgYmVjYXVzZSBpdCdzIGltcG9zc2libGUgZm9yIHRoYXQgc3RyaW5nXG5cdFx0XHQvLyB0byBvY2N1ciAnbmF0dXJhbGx5JyAoc2luY2UgdGhlIHF1b3RlIG1hcmtzIHdvdWxkIGhhdmUgdG8gYmUgZXNjYXBlZClcblx0XHRcdGNvbnN0IHBsYWNlaG9sZGVyID0gYFwiJHt1aWQrK31cImA7XG5cblx0XHRcdChlbnRyeS5wcm9taXNlcyA/Pz0gW10pLnB1c2goXG5cdFx0XHRcdHAudGhlbigocykgPT4ge1xuXHRcdFx0XHRcdGVudHJ5LnNlcmlhbGl6ZWQgPSBlbnRyeS5zZXJpYWxpemVkLnJlcGxhY2UocGxhY2Vob2xkZXIsIHMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHBsYWNlaG9sZGVyO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVudHJ5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2U8YW55Pn1cbiAqL1xuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHQvLyB3ZSB1c2UgdGhpcyBjaGVjayByYXRoZXIgdGhhbiBgaW5zdGFuY2VvZiBQcm9taXNlYFxuXHQvLyBiZWNhdXNlIGl0IHdvcmtzIGNyb3NzLXJlYWxtXG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBQcm9taXNlXSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtIeWRyYXRhYmxlTG9va3VwRW50cnl9IGFcbiAqIEBwYXJhbSB7SHlkcmF0YWJsZUxvb2t1cEVudHJ5fSBiXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbXBhcmUoa2V5LCBhLCBiKSB7XG5cdC8vIG5vdGU6IHRoZXNlIG5lZWQgdG8gYmUgbG9vcHMgKGFzIG9wcG9zZWQgdG8gUHJvbWlzZS5hbGwpIGJlY2F1c2Vcblx0Ly8gYWRkaXRpb25hbCBwcm9taXNlcyBjYW4gZ2V0IHB1c2hlZCB0byB0aGVtIHdoaWxlIHdlJ3JlIGF3YWl0aW5nXG5cdC8vIGFuIGVhcmxpZXIgb25lXG5cdGZvciAoY29uc3QgcCBvZiBhPy5wcm9taXNlcyA/PyBbXSkge1xuXHRcdGF3YWl0IHA7XG5cdH1cblxuXHRmb3IgKGNvbnN0IHAgb2YgYj8ucHJvbWlzZXMgPz8gW10pIHtcblx0XHRhd2FpdCBwO1xuXHR9XG5cblx0aWYgKGEuc2VyaWFsaXplZCAhPT0gYi5zZXJpYWxpemVkKSB7XG5cdFx0Y29uc3QgYV9zdGFjayA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoYS5zdGFjayk7XG5cdFx0Y29uc3QgYl9zdGFjayA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoYi5zdGFjayk7XG5cblx0XHRjb25zdCBzdGFjayA9XG5cdFx0XHRhX3N0YWNrID09PSBiX3N0YWNrXG5cdFx0XHRcdD8gYE9jY3VycmVkIGF0OlxcbiR7YV9zdGFja31gXG5cdFx0XHRcdDogYEZpcnN0IG9jY3VycmVuY2UgYXQ6XFxuJHthX3N0YWNrfVxcblxcblNlY29uZCBvY2N1cnJlbmNlIGF0OlxcbiR7Yl9zdGFja31gO1xuXG5cdFx0ZS5oeWRyYXRhYmxlX2Nsb2JiZXJpbmcoa2V5LCBzdGFjayk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gcm9vdF9zdGFja1xuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHVuZXZhbF9zdGFja1xuICovXG5mdW5jdGlvbiBzZXJpYWxpemF0aW9uX3N0YWNrKHJvb3Rfc3RhY2ssIHVuZXZhbF9zdGFjaykge1xuXHRsZXQgb3V0ID0gJyc7XG5cdGlmIChyb290X3N0YWNrKSB7XG5cdFx0b3V0ICs9IHJvb3Rfc3RhY2sgKyAnXFxuJztcblx0fVxuXHRpZiAodW5ldmFsX3N0YWNrKSB7XG5cdFx0b3V0ICs9ICdDYXVzZWQgYnk6XFxuJyArIHVuZXZhbF9zdGFjayArICdcXG4nO1xuXHR9XG5cdHJldHVybiBvdXQgfHwgJzxtaXNzaW5nIHN0YWNrIHRyYWNlPic7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTbmlwcGV0IH0gZnJvbSAnc3ZlbHRlJyAqL1xuLyoqIEBpbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJy4uL3JlbmRlcmVyJyAqL1xuLyoqIEBpbXBvcnQgeyBHZXR0ZXJzIH0gZnJvbSAnI3NoYXJlZCcgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBzbmlwcGV0IHByb2dyYW1tYXRpY2FsbHlcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bltdfSBQYXJhbXNcbiAqIEBwYXJhbSB7KC4uLnBhcmFtczogR2V0dGVyczxQYXJhbXM+KSA9PiB7XG4gKiAgIHJlbmRlcjogKCkgPT4gc3RyaW5nXG4gKiAgIHNldHVwPzogKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHZvaWQgfCAoKCkgPT4gdm9pZClcbiAqIH19IGZuXG4gKiBAcmV0dXJucyB7U25pcHBldDxQYXJhbXM+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF3U25pcHBldChmbikge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSB0eXBlcyBhcmUgYSBsaWVcblx0cmV0dXJuICgvKiogQHR5cGUge1JlbmRlcmVyfSAqLyByZW5kZXJlciwgLyoqIEB0eXBlIHtQYXJhbXN9ICovIC4uLmFyZ3MpID0+IHtcblx0XHR2YXIgZ2V0dGVycyA9IC8qKiBAdHlwZSB7R2V0dGVyczxQYXJhbXM+fSAqLyAoYXJncy5tYXAoKHZhbHVlKSA9PiAoKSA9PiB2YWx1ZSkpO1xuXHRcdHJlbmRlcmVyLnB1c2goXG5cdFx0XHRmbiguLi5nZXR0ZXJzKVxuXHRcdFx0XHQucmVuZGVyKClcblx0XHRcdFx0LnRyaW0oKVxuXHRcdCk7XG5cdH07XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTU1JDb250ZXh0IH0gZnJvbSAnI3NlcnZlcicgKi9cbi8qKiBAaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICcuL2ludGVybmFsL3NlcnZlci9yZW5kZXJlci5qcycgKi9cbmltcG9ydCB7IHNzcl9jb250ZXh0IH0gZnJvbSAnLi9pbnRlcm5hbC9zZXJ2ZXIvY29udGV4dC5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2ludGVybmFsL3NlcnZlci9lcnJvcnMuanMnO1xuXG4vKiogQHBhcmFtIHsoKSA9PiB2b2lkfSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuXHQvKiogQHR5cGUge1JlbmRlcmVyfSAqLyAoLyoqIEB0eXBlIHtTU1JDb250ZXh0fSAqLyAoc3NyX2NvbnRleHQpLnIpLm9uX2Rlc3Ryb3koZm4pO1xufVxuXG5leHBvcnQge1xuXHRub29wIGFzIGJlZm9yZVVwZGF0ZSxcblx0bm9vcCBhcyBhZnRlclVwZGF0ZSxcblx0bm9vcCBhcyBvbk1vdW50LFxuXHRub29wIGFzIGZsdXNoU3luYyxcblx0cnVuIGFzIHVudHJhY2tcbn0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRyZXR1cm4gbm9vcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50KCkge1xuXHRlLmxpZmVjeWNsZV9mdW5jdGlvbl91bmF2YWlsYWJsZSgnbW91bnQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUoKSB7XG5cdGUubGlmZWN5Y2xlX2Z1bmN0aW9uX3VuYXZhaWxhYmxlKCdoeWRyYXRlJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KCkge1xuXHRlLmxpZmVjeWNsZV9mdW5jdGlvbl91bmF2YWlsYWJsZSgndW5tb3VudCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yaygpIHtcblx0ZS5saWZlY3ljbGVfZnVuY3Rpb25fdW5hdmFpbGFibGUoJ2ZvcmsnKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRpY2soKSB7fVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dGxlZCgpIHt9XG5cbmV4cG9ydCB7IGdldEFib3J0U2lnbmFsIH0gZnJvbSAnLi9pbnRlcm5hbC9zZXJ2ZXIvYWJvcnQtc2lnbmFsLmpzJztcblxuZXhwb3J0IHtcblx0Y3JlYXRlQ29udGV4dCxcblx0Z2V0QWxsQ29udGV4dHMsXG5cdGdldENvbnRleHQsXG5cdGhhc0NvbnRleHQsXG5cdHNldENvbnRleHRcbn0gZnJvbSAnLi9pbnRlcm5hbC9zZXJ2ZXIvY29udGV4dC5qcyc7XG5cbmV4cG9ydCB7IGh5ZHJhdGFibGUgfSBmcm9tICcuL2ludGVybmFsL3NlcnZlci9oeWRyYXRhYmxlLmpzJztcblxuZXhwb3J0IHsgY3JlYXRlUmF3U25pcHBldCB9IGZyb20gJy4vaW50ZXJuYWwvc2VydmVyL2Jsb2Nrcy9zbmlwcGV0LmpzJztcbiIsICJleHBvcnQge2dldFJlbmRlcn0gZnJvbSBcIi4vcmVuZGVyXCJcbmV4cG9ydCB7Z2V0SG9va3N9IGZyb20gXCIuL2hvb2tzLnN2ZWx0ZVwiXG4iLCAiZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb21wb25lbnRzLmRlZmF1bHQpIHx8ICFBcnJheS5pc0FycmF5KGNvbXBvbmVudHMuZmlsZW5hbWVzKSkgcmV0dXJuIGNvbXBvbmVudHNcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fVxuICAgIGZvciAoY29uc3QgW2luZGV4LCBtb2R1bGVdIG9mIGNvbXBvbmVudHMuZGVmYXVsdC5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gbW9kdWxlLmRlZmF1bHRcbiAgICAgICAgY29uc3QgbmFtZSA9IGNvbXBvbmVudHMuZmlsZW5hbWVzW2luZGV4XS5yZXBsYWNlKFwiLi4vc3ZlbHRlL1wiLCBcIlwiKS5yZXBsYWNlKFwiLnN2ZWx0ZVwiLCBcIlwiKVxuICAgICAgICBub3JtYWxpemVkW25hbWVdID0gQ29tcG9uZW50XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkXG59XG4iLCAiaW1wb3J0IHtub3JtYWxpemVDb21wb25lbnRzfSBmcm9tIFwiLi91dGlsc1wiXG5pbXBvcnQge3JlbmRlcn0gZnJvbSBcInN2ZWx0ZS9zZXJ2ZXJcIlxuaW1wb3J0IHtjcmVhdGVSYXdTbmlwcGV0fSBmcm9tIFwic3ZlbHRlXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlcihjb21wb25lbnRzKSB7XG4gICAgY29tcG9uZW50cyA9IG5vcm1hbGl6ZUNvbXBvbmVudHMoY29tcG9uZW50cylcblxuICAgIHJldHVybiBmdW5jdGlvbiByKG5hbWUsIHByb3BzLCBzbG90cykge1xuICAgICAgICBjb25zdCBzbmlwcGV0cyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHNsb3RzKS5tYXAoKFtzbG90TmFtZSwgdl0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbmlwcGV0ID0gY3JlYXRlUmF3U25pcHBldChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcjogKCkgPT4gdixcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgaWYgKHNsb3ROYW1lID09PSBcImRlZmF1bHRcIikgcmV0dXJuIFtcImNoaWxkcmVuXCIsIHNuaXBwZXRdXG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gW3Nsb3ROYW1lLCBzbmlwcGV0XVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiByZW5kZXIoY29tcG9uZW50c1tuYW1lXSwge3Byb3BzOiB7Li4ucHJvcHMsIC4uLnNuaXBwZXRzfX0pXG4gICAgfVxufVxuIiwgImltcG9ydCB7bm9ybWFsaXplQ29tcG9uZW50c30gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHttb3VudCwgaHlkcmF0ZSwgdW5tb3VudCwgY3JlYXRlUmF3U25pcHBldH0gZnJvbSBcInN2ZWx0ZVwiXG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZUpzb24ocmVmLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgZGF0YSA9IHJlZi5lbC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSlcbiAgICByZXR1cm4gZGF0YSA/IEpTT04ucGFyc2UoZGF0YSkgOiB7fVxufVxuXG5mdW5jdGlvbiBnZXRTbG90cyhyZWYpIHtcbiAgICBsZXQgc25pcHBldHMgPSB7fVxuXG4gICAgZm9yIChjb25zdCBzbG90TmFtZSBpbiBnZXRBdHRyaWJ1dGVKc29uKHJlZiwgXCJkYXRhLXNsb3RzXCIpKSB7XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGdldEF0dHJpYnV0ZUpzb24ocmVmLCBcImRhdGEtc2xvdHNcIilbc2xvdE5hbWVdXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gYXRvYihiYXNlNjQpLnRyaW0oKVxuXG4gICAgICAgIGNvbnN0IHNuaXBwZXQgPSBjcmVhdGVSYXdTbmlwcGV0KG5hbWUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZW5kZXI6ICgpID0+IGVsZW1lbnQub3V0ZXJIVE1MLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChzbG90TmFtZSA9PT0gXCJkZWZhdWx0XCIpIHNuaXBwZXRzW1wiY2hpbGRyZW5cIl0gPSBzbmlwcGV0XG4gICAgICAgIGVsc2Ugc25pcHBldHNbc2xvdE5hbWVdID0gc25pcHBldFxuICAgIH1cblxuICAgIHJldHVybiBzbmlwcGV0c1xufVxuXG5mdW5jdGlvbiBnZXRMaXZlSnNvblByb3BzKHJlZikge1xuICAgIGNvbnN0IGpzb24gPSBnZXRBdHRyaWJ1dGVKc29uKHJlZiwgXCJkYXRhLWxpdmUtanNvblwiKVxuXG4gICAgLy8gT24gU1NSLCBkYXRhLWxpdmUtanNvbiBpcyB0aGUgZnVsbCBvYmplY3Qgd2Ugd2FudFxuICAgIC8vIEFmdGVyIFNTUiwgZGF0YS1saXZlLWpzb24gaXMgYW4gYXJyYXkgb2Yga2V5cywgYW5kIHdlJ2xsIGdldCB0aGUgZGF0YSBmcm9tIHRoZSB3aW5kb3dcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpIHJldHVybiBqc29uXG5cbiAgICBjb25zdCBsaXZlSnNvbkRhdGEgPSB7fVxuICAgIGZvciAoY29uc3QgbGl2ZUpzb25WYXJpYWJsZSBvZiBqc29uKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB3aW5kb3dbbGl2ZUpzb25WYXJpYWJsZV1cbiAgICAgICAgaWYgKGRhdGEpIGxpdmVKc29uRGF0YVtsaXZlSnNvblZhcmlhYmxlXSA9IGRhdGFcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVKc29uRGF0YVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wcyhyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nZXRBdHRyaWJ1dGVKc29uKHJlZiwgXCJkYXRhLXByb3BzXCIpLFxuICAgICAgICAuLi5nZXRMaXZlSnNvblByb3BzKHJlZiksXG4gICAgICAgIC4uLmdldFNsb3RzKHJlZiksXG4gICAgICAgIGxpdmU6IHJlZixcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRTbG90Q3R4KGNvbXBvbmVudCkge1xuICAgIC8vIFRoZSBkZWZhdWx0IHNsb3QgYWx3YXlzIGV4aXN0cyBpZiB0aGVyZSdzIGEgc2xvdCBzZXRcbiAgICAvLyBldmVuIGlmIG5vIHNsb3QgaXMgc2V0IGZvciB0aGUgZXhwbGljaXQgZGVmYXVsdCBzbG90XG4gICAgcmV0dXJuIGNvbXBvbmVudC4kJC5jdHguZmluZChjdHhFbGVtZW50ID0+IGN0eEVsZW1lbnQ/LmRlZmF1bHQpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZV9zdGF0ZShyZWYpIHtcbiAgICBjb25zdCBuZXdQcm9wcyA9IGdldFByb3BzKHJlZilcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICByZWYuX2luc3RhbmNlLnN0YXRlW2tleV0gPSBuZXdQcm9wc1trZXldXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9va3MoY29tcG9uZW50cykge1xuICAgIGNvbXBvbmVudHMgPSBub3JtYWxpemVDb21wb25lbnRzKGNvbXBvbmVudHMpXG5cbiAgICBjb25zdCBTdmVsdGVIb29rID0ge1xuICAgICAgICBtb3VudGVkKCkge1xuICAgICAgICAgICAgbGV0IHN0YXRlID0gJHN0YXRlKGdldFByb3BzKHRoaXMpKVxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1uYW1lXCIpXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudE5hbWUpIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCBuYW1lIG11c3QgYmUgcHJvdmlkZWRcIilcblxuICAgICAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnROYW1lXVxuICAgICAgICAgICAgaWYgKCFDb21wb25lbnQpIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgJHtjb21wb25lbnROYW1lfSBjb21wb25lbnQuYClcblxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXZlSnNvbkVsZW1lbnQgb2YgT2JqZWN0LmtleXMoZ2V0QXR0cmlidXRlSnNvbih0aGlzLCBcImRhdGEtbGl2ZS1qc29uXCIpKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGAke2xpdmVKc29uRWxlbWVudH1faW5pdGlhbGl6ZWRgLCBfZXZlbnQgPT4gdXBkYXRlX3N0YXRlKHRoaXMpLCBmYWxzZSlcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgJHtsaXZlSnNvbkVsZW1lbnR9X3BhdGNoZWRgLCBfZXZlbnQgPT4gdXBkYXRlX3N0YXRlKHRoaXMpLCBmYWxzZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBmb3IgdGhlIGxvYWRpbmcgc2xvdCB0byBiZSBjbGVhcmVkIG9uY2Ugd2UgbW91bnQgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgaWYgKCF0aGlzLmVsLmhhc0F0dHJpYnV0ZShcImRhdGEtc3NyXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVPck1vdW50ID0gdGhpcy5lbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXNzclwiKSA/IGh5ZHJhdGUgOiBtb3VudFxuXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGh5ZHJhdGVPck1vdW50KENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5lbCxcbiAgICAgICAgICAgICAgICBwcm9wczogc3RhdGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc3RhdGUgPSBzdGF0ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZWQoKSB7XG4gICAgICAgICAgICB1cGRhdGVfc3RhdGUodGhpcylcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95ZWQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsICgpID0+IHVubW91bnQodGhpcy5faW5zdGFuY2UpLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH0sXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgU3ZlbHRlSG9vayxcbiAgICB9XG59XG4iLCAiaW1wb3J0ICogYXMgQ29tcG9uZW50cyBmcm9tIFwiLi4vc3ZlbHRlLyoqLyouc3ZlbHRlXCJcbmltcG9ydCB7Z2V0UmVuZGVyfSBmcm9tIFwibGl2ZV9zdmVsdGVcIlxuXG5leHBvcnQgY29uc3QgcmVuZGVyID0gZ2V0UmVuZGVyKENvbXBvbmVudHMpXG4iLCAiXG4gICAgICAgIGltcG9ydCAqIGFzIG1vZHVsZTAgZnJvbSAnLi4vc3ZlbHRlL0F1dGhNb2RhbC5zdmVsdGUnO2ltcG9ydCAqIGFzIG1vZHVsZTEgZnJvbSAnLi4vc3ZlbHRlL0NvZGVTbmlwcGV0Q2FyZC5zdmVsdGUnO2ltcG9ydCAqIGFzIG1vZHVsZTIgZnJvbSAnLi4vc3ZlbHRlL0NvdW50ZXIuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGUzIGZyb20gJy4uL3N2ZWx0ZS9OYXZiYXIuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGU0IGZyb20gJy4uL3N2ZWx0ZS9TdWJOYXYuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGU1IGZyb20gJy4uL3N2ZWx0ZS9UaGVtZVNlbGVjdG9yLnN2ZWx0ZSc7aW1wb3J0ICogYXMgbW9kdWxlNiBmcm9tICcuLi9zdmVsdGUvVGhlbWVUb2dnbGUuc3ZlbHRlJztpbXBvcnQgKiBhcyBtb2R1bGU3IGZyb20gJy4uL3N2ZWx0ZS9Vc2VyTWVudS5zdmVsdGUnO2ltcG9ydCAqIGFzIG1vZHVsZTggZnJvbSAnLi4vc3ZlbHRlL1dvcmtmbG93U3RhdHVzQ2FyZC5zdmVsdGUnXG5cbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IFttb2R1bGUwLG1vZHVsZTEsbW9kdWxlMixtb2R1bGUzLG1vZHVsZTQsbW9kdWxlNSxtb2R1bGU2LG1vZHVsZTcsbW9kdWxlOF07XG5cbiAgICAgICAgZXhwb3J0IGRlZmF1bHQgbW9kdWxlcztcbiAgICAgICAgZXhwb3J0IGNvbnN0IGZpbGVuYW1lcyA9IFsnLi4vc3ZlbHRlL0F1dGhNb2RhbC5zdmVsdGUnLCcuLi9zdmVsdGUvQ29kZVNuaXBwZXRDYXJkLnN2ZWx0ZScsJy4uL3N2ZWx0ZS9Db3VudGVyLnN2ZWx0ZScsJy4uL3N2ZWx0ZS9OYXZiYXIuc3ZlbHRlJywnLi4vc3ZlbHRlL1N1Yk5hdi5zdmVsdGUnLCcuLi9zdmVsdGUvVGhlbWVTZWxlY3Rvci5zdmVsdGUnLCcuLi9zdmVsdGUvVGhlbWVUb2dnbGUuc3ZlbHRlJywnLi4vc3ZlbHRlL1VzZXJNZW51LnN2ZWx0ZScsJy4uL3N2ZWx0ZS9Xb3JrZmxvd1N0YXR1c0NhcmQuc3ZlbHRlJ11cbiAgICAgICIsICI8c2NyaXB0PlxuICBsZXQgeyBpc09wZW4gPSAkYmluZGFibGUoZmFsc2UpIH0gPSAkcHJvcHMoKVxuXG4gIGNvbnN0IHByb3ZpZGVycyA9IFtcbiAgICB7XG4gICAgICBuYW1lOiAnR29vZ2xlJyxcbiAgICAgIGljb246ICfwn5SNJyxcbiAgICAgIHBhdGg6ICcvYXV0aC9nb29nbGUnLFxuICAgICAgY29sb3JDbGFzczogJ2J0bi1uZXV0cmFsJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ1R3aXR0ZXInLFxuICAgICAgaWNvbjogJ/CdlY8nLFxuICAgICAgcGF0aDogJy9hdXRoL3R3aXR0ZXInLFxuICAgICAgY29sb3JDbGFzczogJ2J0bi1pbmZvJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0ZhY2Vib29rJyxcbiAgICAgIGljb246ICdmJyxcbiAgICAgIHBhdGg6ICcvYXV0aC9mYWNlYm9vaycsXG4gICAgICBjb2xvckNsYXNzOiAnYnRuLXByaW1hcnknXG4gICAgfVxuICBdXG5cbiAgZnVuY3Rpb24gaGFuZGxlT0F1dGhMb2dpbihwcm92aWRlclBhdGgpIHtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHByb3ZpZGVyUGF0aFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VNb2RhbCgpIHtcbiAgICBpc09wZW4gPSBmYWxzZVxuICB9XG48L3NjcmlwdD5cblxuPGRpYWxvZyBjbGFzcz1cIm1vZGFsXCIgY2xhc3M6bW9kYWwtb3Blbj17aXNPcGVufT5cbiAgPGRpdiBjbGFzcz1cIm1vZGFsLWJveCBiZy1iYXNlLTIwMCBtYXgtdy1tZFwiPlxuICAgIDxmb3JtIG1ldGhvZD1cImRpYWxvZ1wiPlxuICAgICAgPGJ1dHRvblxuICAgICAgICBvbmNsaWNrPXtjbG9zZU1vZGFsfVxuICAgICAgICBjbGFzcz1cImJ0biBidG4tc20gYnRuLWNpcmNsZSBidG4tZ2hvc3QgYWJzb2x1dGUgcmlnaHQtMiB0b3AtMlwiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJDbG9zZVwiXG4gICAgICA+XG4gICAgICAgIOKclVxuICAgICAgPC9idXR0b24+XG4gICAgPC9mb3JtPlxuXG4gICAgPGgzIGNsYXNzPVwiZm9udC1ib2xkIHRleHQtMnhsIG1iLTJcIj5XZWxjb21lIEJhY2s8L2gzPlxuICAgIDxwIGNsYXNzPVwidGV4dC1iYXNlLWNvbnRlbnQvNzAgbWItNlwiPlNpZ24gaW4gdG8gc2F2ZSBwcm9tcHRzLCBsZWF2ZSBjb21tZW50cywgYW5kIG1vcmU8L3A+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWNvbCBnYXAtM1wiPlxuICAgICAgeyNlYWNoIHByb3ZpZGVycyBhcyBwcm92aWRlcn1cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIG9uY2xpY2s9eygpID0+IGhhbmRsZU9BdXRoTG9naW4ocHJvdmlkZXIucGF0aCl9XG4gICAgICAgICAgY2xhc3M9XCJidG4ge3Byb3ZpZGVyLmNvbG9yQ2xhc3N9IGJ0bi1sZyB3LWZ1bGwganVzdGlmeS1zdGFydCBnYXAtNFwiXG4gICAgICAgID5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInRleHQtMnhsXCI+e3Byb3ZpZGVyLmljb259PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmxleC0xIHRleHQtbGVmdFwiPkNvbnRpbnVlIHdpdGgge3Byb3ZpZGVyLm5hbWV9PC9zcGFuPlxuICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgY2xhc3M9XCJoLTUgdy01XCJcbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05IDVsNyA3LTcgN1wiIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgey9lYWNofVxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm10LTYgdGV4dC14cyB0ZXh0LWJhc2UtY29udGVudC81MCB0ZXh0LWNlbnRlclwiPlxuICAgICAgQnkgY29udGludWluZywgeW91IGFncmVlIHRvIG91ciBUZXJtcyBvZiBTZXJ2aWNlIGFuZCBQcml2YWN5IFBvbGljeVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgPGZvcm0gbWV0aG9kPVwiZGlhbG9nXCIgY2xhc3M9XCJtb2RhbC1iYWNrZHJvcFwiPlxuICAgIDxidXR0b24gb25jbGljaz17Y2xvc2VNb2RhbH0+Y2xvc2U8L2J1dHRvbj5cbiAgPC9mb3JtPlxuPC9kaWFsb2c+XG4iLCAiPHNjcmlwdD5cbiAgbGV0IHsgZGVsYXkgPSAwIH0gPSAkcHJvcHMoKVxuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgY2xhc3M9XCJhYnNvbHV0ZSBoaWRkZW4gbGc6YmxvY2sgdG9wLTEvNCBsZWZ0LTEwIHhsOmxlZnQtMzIgdy02NCBiZy1iYXNlLTIwMC85MCBiYWNrZHJvcC1ibHVyLXhsIGJvcmRlciBib3JkZXItYmFzZS0zMDAgc2hhZG93LVswXzIwcHhfNDBweF8tMTVweF9yZ2JhKDAsMCwwLDAuMSldIHJvdW5kZWQtMnhsIHAtNCBhbmltYXRlLWZsb2F0IHJvdGF0ZS1bLTNkZWddXCJcbiAgc3R5bGU9XCJhbmltYXRpb24tZGVsYXk6IHtkZWxheX1zXCJcbj5cbiAgPGRpdiBjbGFzcz1cImZvbnQtbW9ubyB0ZXh0LVsxMHB4XSB0ZXh0LWJhc2UtY29udGVudC83MCBsZWFkaW5nLXJlbGF4ZWRcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZmxleCBnYXAtMiBtYi0yIGJvcmRlci1iIGJvcmRlci1iYXNlLTMwMCBwYi0yXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidy0yIGgtMiByb3VuZGVkLWZ1bGwgYmctcmVkLTUwMFwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInctMiBoLTIgcm91bmRlZC1mdWxsIGJnLXllbGxvdy01MDBcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ3LTIgaC0yIHJvdW5kZWQtZnVsbCBiZy1ncmVlbi01MDBcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidGV4dC1ibHVlLTQwMFwiPlxuICAgICAgY29uc3QgPHNwYW4gY2xhc3M9XCJ0ZXh0LXllbGxvdy0yMDBcIj5hdXRvbWF0ZTwvc3Bhbj4gPSA8c3BhbiBjbGFzcz1cInRleHQtcHVycGxlLTQwMFwiPmFzeW5jPC9zcGFuPiAoKSA9PiB7J3snfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwbC00XCI+XG4gICAgICBhd2FpdCA8c3BhbiBjbGFzcz1cInRleHQtZ3JlZW4tMzAwXCI+bjhuPC9zcGFuPi50cmlnZ2VyKCk7XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInBsLTRcIj5cbiAgICAgIHJldHVybiA8c3BhbiBjbGFzcz1cInRleHQtb3JhbmdlLTMwMFwiPlwiRnJlZWRvbVwiPC9zcGFuPjtcbiAgICA8L2Rpdj5cbiAgICA8ZGl2PnsnfSd9PC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG4iLCAiPHNjcmlwdD5cbiAgbGV0IHsgY291bnQgPSAwLCBsaXZlIH0gPSAkcHJvcHMoKVxuXG4gIGZ1bmN0aW9uIGluY3JlbWVudCgpIHtcbiAgICBsaXZlLnB1c2hFdmVudCgnaW5jcmVtZW50Jywge30pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNyZW1lbnQoKSB7XG4gICAgbGl2ZS5wdXNoRXZlbnQoJ2RlY3JlbWVudCcsIHt9KVxuICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGdhcC00IHAtOFwiPlxuICA8aDIgY2xhc3M9XCJ0ZXh0LTN4bCBmb250LWJvbGRcIj5Db3VudGVyOiB7Y291bnR9PC9oMj5cblxuICA8ZGl2IGNsYXNzPVwiZmxleCBnYXAtMlwiPlxuICAgIDxidXR0b25cbiAgICAgIG9uY2xpY2s9e2RlY3JlbWVudH1cbiAgICAgIGNsYXNzPVwiYnRuIGJ0bi1lcnJvclwiXG4gICAgPlxuICAgICAgRGVjcmVtZW50XG4gICAgPC9idXR0b24+XG5cbiAgICA8YnV0dG9uXG4gICAgICBvbmNsaWNrPXtpbmNyZW1lbnR9XG4gICAgICBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiXG4gICAgPlxuICAgICAgSW5jcmVtZW50XG4gICAgPC9idXR0b24+XG4gIDwvZGl2PlxuPC9kaXY+XG4iLCAiPHNjcmlwdD5cbiAgbGV0IHsgY3VycmVudFVzZXIgfSA9ICRwcm9wcygpXG5cbiAgbGV0IGlzT3BlbiA9ICRzdGF0ZShmYWxzZSlcblxuICBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xuICAgIGlzT3BlbiA9ICFpc09wZW5cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlTWVudSgpIHtcbiAgICBpc09wZW4gPSBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQuY2xvc2VzdCgnLmRyb3Bkb3duJykpIHtcbiAgICAgIGNsb3NlTWVudSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTG9nb3V0KCkge1xuICAgIC8vIENyZWF0ZSBhIGZvcm0gYW5kIHN1Ym1pdCBpdCB0byBwZXJmb3JtIERFTEVURSByZXF1ZXN0XG4gICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKVxuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnXG4gICAgZm9ybS5hY3Rpb24gPSAnL2F1dGgvbG9nb3V0J1xuXG4gICAgY29uc3QgY3NyZlRva2VuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpPy5jb250ZW50XG4gICAgaWYgKGNzcmZUb2tlbikge1xuICAgICAgY29uc3QgY3NyZklucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgY3NyZklucHV0LnR5cGUgPSAnaGlkZGVuJ1xuICAgICAgY3NyZklucHV0Lm5hbWUgPSAnX2NzcmZfdG9rZW4nXG4gICAgICBjc3JmSW5wdXQudmFsdWUgPSBjc3JmVG9rZW5cbiAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZklucHV0KVxuICAgIH1cblxuICAgIGNvbnN0IG1ldGhvZElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgIG1ldGhvZElucHV0LnR5cGUgPSAnaGlkZGVuJ1xuICAgIG1ldGhvZElucHV0Lm5hbWUgPSAnX21ldGhvZCdcbiAgICBtZXRob2RJbnB1dC52YWx1ZSA9ICdERUxFVEUnXG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2RJbnB1dClcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSlcbiAgICBmb3JtLnN1Ym1pdCgpXG4gIH1cblxuICAkZWZmZWN0KCgpID0+IHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrT3V0c2lkZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGlja091dHNpZGUpXG4gICAgfVxuICB9KVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJkcm9wZG93biBkcm9wZG93bi1lbmRcIiBjbGFzczpkcm9wZG93bi1vcGVuPXtpc09wZW59PlxuICA8YnV0dG9uXG4gICAgb25jbGljaz17dG9nZ2xlTWVudX1cbiAgICBjbGFzcz1cImJ0biBidG4tZ2hvc3QgYnRuLWNpcmNsZSBhdmF0YXIgb25saW5lXCJcbiAgICBhcmlhLWxhYmVsPVwiVXNlciBtZW51XCJcbiAgPlxuICAgIHsjaWYgY3VycmVudFVzZXIuYXZhdGFyVXJsfVxuICAgICAgPGRpdiBjbGFzcz1cInctMTAgcm91bmRlZC1mdWxsIHJpbmcgcmluZy1wcmltYXJ5IHJpbmctb2Zmc2V0LWJhc2UtMTAwIHJpbmctb2Zmc2V0LTJcIj5cbiAgICAgICAgPGltZ1xuICAgICAgICAgIHNyYz17Y3VycmVudFVzZXIuYXZhdGFyVXJsfVxuICAgICAgICAgIGFsdD17Y3VycmVudFVzZXIubmFtZSB8fCBjdXJyZW50VXNlci5lbWFpbH1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIHs6ZWxzZX1cbiAgICAgIDxkaXYgY2xhc3M9XCJ3LTEwIGgtMTAgcm91bmRlZC1mdWxsIGJnLXByaW1hcnkgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdGV4dC1wcmltYXJ5LWNvbnRlbnQgZm9udC1ib2xkIHJpbmcgcmluZy1wcmltYXJ5IHJpbmctb2Zmc2V0LWJhc2UtMTAwIHJpbmctb2Zmc2V0LTJcIj5cbiAgICAgICAge2N1cnJlbnRVc2VyLm5hbWU/LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpIHx8IGN1cnJlbnRVc2VyLmVtYWlsPy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSB8fCAnVSd9XG4gICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuICA8L2J1dHRvbj5cblxuICB7I2lmIGlzT3Blbn1cbiAgICA8dWwgY2xhc3M9XCJtZW51IGRyb3Bkb3duLWNvbnRlbnQgYmctYmFzZS0yMDAgcm91bmRlZC1ib3ggei1bMV0gdy01MiBwLTIgc2hhZG93LXhsIGJvcmRlciBib3JkZXItYmFzZS0zMDAgbXQtM1wiPlxuICAgICAgPGxpIGNsYXNzPVwibWVudS10aXRsZSBweC00IHB5LTJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggZmxleC1jb2xcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImZvbnQtc2VtaWJvbGQgdGV4dC1iYXNlLWNvbnRlbnRcIj57Y3VycmVudFVzZXIubmFtZSB8fCAnVXNlcid9PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC14cyB0ZXh0LWJhc2UtY29udGVudC82MFwiPntjdXJyZW50VXNlci5lbWFpbH08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9saT5cbiAgICAgIDxsaT5cbiAgICAgICAgPGEgaHJlZj1cIi9zYXZlZFwiIG9uY2xpY2s9e2Nsb3NlTWVudX0+XG4gICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJoLTUgdy01XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01IDVhMiAyIDAgMDEyLTJoMTBhMiAyIDAgMDEyIDJ2MTZsLTctMy41TDUgMjFWNXpcIiAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIE15IFNhdmVkXG4gICAgICAgIDwvYT5cbiAgICAgIDwvbGk+XG4gICAgICA8bGk+XG4gICAgICAgIDxidXR0b24gb25jbGljaz17aGFuZGxlTG9nb3V0fT5cbiAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImgtNSB3LTVcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE3IDE2bDQtNG0wIDBsLTQtNG00IDRIN202IDR2MWEzIDMgMCAwMS0zIDNINmEzIDMgMCAwMS0zLTNWN2EzIDMgMCAwMTMtM2g0YTMgMyAwIDAxMyAzdjFcIiAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIFNpZ24gT3V0XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICB7L2lmfVxuPC9kaXY+XG4iLCAiPHNjcmlwdD5cbiAgaW1wb3J0IEF1dGhNb2RhbCBmcm9tICcuL0F1dGhNb2RhbC5zdmVsdGUnO1xuICBpbXBvcnQgVXNlck1lbnUgZnJvbSAnLi9Vc2VyTWVudS5zdmVsdGUnO1xuXG4gIGxldCB7IGN1cnJlbnRQYWdlID0gJycsIGN1cnJlbnRVc2VyID0gbnVsbCB9ID0gJHByb3BzKClcblxuICBsZXQgaXNTY3JvbGxlZCA9ICRzdGF0ZShmYWxzZSlcbiAgbGV0IGlzTWVudU9wZW4gPSAkc3RhdGUoZmFsc2UpXG4gIGxldCBzaG93QXV0aE1vZGFsID0gJHN0YXRlKGZhbHNlKVxuICBsZXQgZHJvcGRvd25SZWZcblxuICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XG4gICAgaXNTY3JvbGxlZCA9IHdpbmRvdy5zY3JvbGxZID4gMjBcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZU1lbnUoKSB7XG4gICAgaXNNZW51T3BlbiA9ICFpc01lbnVPcGVuXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZU1lbnUoKSB7XG4gICAgaXNNZW51T3BlbiA9IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBvcGVuQXV0aE1vZGFsKCkge1xuICAgIHNob3dBdXRoTW9kYWwgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGlja091dHNpZGUoZXZlbnQpIHtcbiAgICBpZiAoZHJvcGRvd25SZWYgJiYgIWRyb3Bkb3duUmVmLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIGNsb3NlTWVudSgpXG4gICAgfVxuICB9XG5cbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgLy8gcnVuIG9uY2Ugb24gbW91bnQ7IHJlLXJ1biBpZiBoYW5kbGVycyBjaGFuZ2UgKHRoZXkgZG9uJ3QpXG4gICAgaGFuZGxlU2Nyb2xsKClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2tPdXRzaWRlKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKVxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGlja091dHNpZGUpXG4gICAgfVxuICB9KVxuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgY2xhc3M9e2BuYXZiYXIgZml4ZWQgdG9wLTAgbGVmdC0wIHJpZ2h0LTAgei01MCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgJHtcbiAgICBpc1Njcm9sbGVkID8gJ2JnLWJhc2UtMTAwLzgwIGJhY2tkcm9wLWJsdXItbWQgYm9yZGVyLWIgYm9yZGVyLWJhc2UtMzAwJyA6ICdiZy10cmFuc3BhcmVudCdcbiAgfWB9XG4+XG4gIDxkaXYgY2xhc3M9XCJuYXZiYXItc3RhcnRcIj5cbiAgICA8IS0tIE1vYmlsZSBEcm9wZG93biAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24gbGc6aGlkZGVuXCIgY2xhc3M6ZHJvcGRvd24tb3Blbj17aXNNZW51T3Blbn0gYmluZDp0aGlzPXtkcm9wZG93blJlZn0+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIG9uY2xpY2s9e3RvZ2dsZU1lbnV9XG4gICAgICAgIGFyaWEtbGFiZWw9XCJUb2dnbGUgbmF2aWdhdGlvbiBtZW51XCJcbiAgICAgICAgYXJpYS1leHBhbmRlZD17aXNNZW51T3Blbn1cbiAgICAgICAgYXJpYS1jb250cm9scz1cIm1vYmlsZS1uYXZcIlxuICAgICAgICBjbGFzcz1cImJ0biBidG4tZ2hvc3RcIlxuICAgICAgPlxuICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cImgtNSB3LTVcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk00IDZoMTZNNCAxMmgxNk00IDE4aDE2XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIHsjaWYgaXNNZW51T3Blbn1cbiAgICAgICAgPHVsIGlkPVwibW9iaWxlLW5hdlwiIGNsYXNzPVwibWVudSBtZW51LXNtIGRyb3Bkb3duLWNvbnRlbnQgYmctYmFzZS0xMDAgcm91bmRlZC1ib3ggei1bMV0gbXQtMyB3LTUyIHAtMiBzaGFkb3dcIj5cbiAgICAgICAgICA8bGk+PGEgaHJlZj1cIi9cIiBjbGFzczphY3RpdmU9e2N1cnJlbnRQYWdlID09PSAnaG9tZSd9IG9uY2xpY2s9e2Nsb3NlTWVudX0+SG9tZTwvYT48L2xpPlxuICAgICAgICAgIDxsaT48YSBocmVmPVwiL3JlZmVyZW5jZXM/Y2F0ZWdvcnk9Y29kaW5nXCIgb25jbGljaz17Y2xvc2VNZW51fT5Db2Rpbmc8L2E+PC9saT5cbiAgICAgICAgICA8bGk+PGEgaHJlZj1cIi9yZWZlcmVuY2VzP2NhdGVnb3J5PWFpXCIgb25jbGljaz17Y2xvc2VNZW51fT5BSTwvYT48L2xpPlxuICAgICAgICAgIDxsaT48YSBocmVmPVwiL3JlZmVyZW5jZXM/Y2F0ZWdvcnk9bjhuXCIgb25jbGljaz17Y2xvc2VNZW51fT5uOG48L2E+PC9saT5cbiAgICAgICAgICA8bGk+PGEgaHJlZj1cIi9yZWZlcmVuY2VzP2NhdGVnb3J5PXRvb2xzXCIgb25jbGljaz17Y2xvc2VNZW51fT5Ub29sczwvYT48L2xpPlxuICAgICAgICAgIDxsaT48YSBocmVmPVwiL3JlZmVyZW5jZXNcIiBjbGFzczphY3RpdmU9e2N1cnJlbnRQYWdlID09PSAncmVmZXJlbmNlcyd9IG9uY2xpY2s9e2Nsb3NlTWVudX0+UHJvbXB0czwvYT48L2xpPlxuICAgICAgICA8L3VsPlxuICAgICAgey9pZn1cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gTG9nbyAtLT5cbiAgICA8YSBocmVmPVwiL1wiIGNsYXNzPVwiYnRuIGJ0bi1naG9zdCB0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgdHJhY2tpbmctdGlnaHRcIj5cbiAgICAgIFVyaWVsTTxzcGFuIGNsYXNzPVwidGV4dC1iYXNlLWNvbnRlbnQvNTBcIj4uZGV2PC9zcGFuPlxuICAgIDwvYT5cbiAgPC9kaXY+XG5cbiAgPCEtLSBEZXNrdG9wIE5hdmlnYXRpb24gLSBDZW50ZXIgLS0+XG4gIDxkaXYgY2xhc3M9XCJuYXZiYXItY2VudGVyIGhpZGRlbiBsZzpmbGV4XCI+XG4gICAgPGRpdiBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyIGdhcC04XCI+XG4gICAgICA8YVxuICAgICAgICBocmVmPVwiL1wiXG4gICAgICAgIGNsYXNzPXtgZm9udC1tZWRpdW0gdHJhbnNpdGlvbi1jb2xvcnMgJHtjdXJyZW50UGFnZSA9PT0gJ2hvbWUnID8gJ3RleHQtcHJpbWFyeSBmb250LWJvbGQnIDogJ3RleHQtYmFzZS1jb250ZW50IGhvdmVyOnRleHQtcHJpbWFyeSd9YH1cbiAgICAgID5cbiAgICAgICAgSG9tZVxuICAgICAgPC9hPlxuICAgICAgPGFcbiAgICAgICAgaHJlZj1cIi9yZWZlcmVuY2VzP2NhdGVnb3J5PWNvZGluZ1wiXG4gICAgICAgIGNsYXNzPVwiZm9udC1tZWRpdW0gdGV4dC1iYXNlLWNvbnRlbnQgaG92ZXI6dGV4dC1wcmltYXJ5IHRyYW5zaXRpb24tY29sb3JzXCJcbiAgICAgID5cbiAgICAgICAgQ29kaW5nXG4gICAgICA8L2E+XG4gICAgICA8YVxuICAgICAgICBocmVmPVwiL3JlZmVyZW5jZXM/Y2F0ZWdvcnk9YWlcIlxuICAgICAgICBjbGFzcz1cImZvbnQtbWVkaXVtIHRleHQtYmFzZS1jb250ZW50IGhvdmVyOnRleHQtcHJpbWFyeSB0cmFuc2l0aW9uLWNvbG9yc1wiXG4gICAgICA+XG4gICAgICAgIEFJXG4gICAgICA8L2E+XG4gICAgICA8YVxuICAgICAgICBocmVmPVwiL3JlZmVyZW5jZXM/Y2F0ZWdvcnk9bjhuXCJcbiAgICAgICAgY2xhc3M9XCJmb250LW1lZGl1bSB0ZXh0LWJhc2UtY29udGVudCBob3Zlcjp0ZXh0LXByaW1hcnkgdHJhbnNpdGlvbi1jb2xvcnNcIlxuICAgICAgPlxuICAgICAgICBuOG5cbiAgICAgIDwvYT5cbiAgICAgIDxhXG4gICAgICAgIGhyZWY9XCIvcmVmZXJlbmNlcz9jYXRlZ29yeT10b29sc1wiXG4gICAgICAgIGNsYXNzPVwiZm9udC1tZWRpdW0gdGV4dC1iYXNlLWNvbnRlbnQgaG92ZXI6dGV4dC1wcmltYXJ5IHRyYW5zaXRpb24tY29sb3JzXCJcbiAgICAgID5cbiAgICAgICAgVG9vbHNcbiAgICAgIDwvYT5cbiAgICAgIDxhXG4gICAgICAgIGhyZWY9XCIvcmVmZXJlbmNlc1wiXG4gICAgICAgIGNsYXNzPXtgZm9udC1tZWRpdW0gdHJhbnNpdGlvbi1jb2xvcnMgJHtjdXJyZW50UGFnZSA9PT0gJ3JlZmVyZW5jZXMnID8gJ3RleHQtcHJpbWFyeSBmb250LWJvbGQnIDogJ3RleHQtYmFzZS1jb250ZW50IGhvdmVyOnRleHQtcHJpbWFyeSd9YH1cbiAgICAgID5cbiAgICAgICAgUHJvbXB0c1xuICAgICAgPC9hPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cblxuICA8IS0tIENUQSBCdXR0b24gLSBSaWdodCAtLT5cbiAgPGRpdiBjbGFzcz1cIm5hdmJhci1lbmQgZ2FwLTJcIj5cbiAgICB7I2lmIGN1cnJlbnRVc2VyfVxuICAgICAgPFVzZXJNZW51IHtjdXJyZW50VXNlcn0gLz5cbiAgICB7OmVsc2V9XG4gICAgICA8YnV0dG9uXG4gICAgICAgIG9uY2xpY2s9e29wZW5BdXRoTW9kYWx9XG4gICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tcHJpbWFyeSByb3VuZGVkLWZ1bGwgcHgtNlwiXG4gICAgICA+XG4gICAgICAgIFNpZ24gSW5cbiAgICAgIDwvYnV0dG9uPlxuICAgIHsvaWZ9XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxBdXRoTW9kYWwgYmluZDppc09wZW49e3Nob3dBdXRoTW9kYWx9IC8+XG4iLCAiPHNjcmlwdD5cbiAgbGV0IHsgYWN0aXZlRmlsdGVyID0gJ2FsbCcsIGNhdGVnb3JpZXMgPSBbXSwgbGl2ZSB9ID0gJHByb3BzKClcblxuICBmdW5jdGlvbiBzZWxlY3RGaWx0ZXIoZmlsdGVyKSB7XG4gICAgbGl2ZS5wdXNoRXZlbnQoJ2ZpbHRlcl9jaGFuZ2VkJywgeyBjYXRlZ29yeTogZmlsdGVyIH0pXG4gIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiYmctYmFzZS0xMDAgYm9yZGVyLWIgYm9yZGVyLWJhc2UtMzAwXCI+XG4gIDxkaXYgY2xhc3M9XCJjb250YWluZXIgbXgtYXV0byBweC00XCI+XG4gICAgPGRpdiBjbGFzcz1cInRhYnMgdGFicy1ib3JkZXJlZCBvdmVyZmxvdy14LWF1dG8gc2Nyb2xsYmFyLWhpZGVcIiBhcmlhLWxhYmVsPVwiUmVmZXJlbmNlIGZpbHRlcnNcIiByb2xlPVwidGFibGlzdFwiPlxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgb25jbGljaz17KCkgPT4gc2VsZWN0RmlsdGVyKCdhbGwnKX1cbiAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgIGFyaWEtc2VsZWN0ZWQ9e2FjdGl2ZUZpbHRlciA9PT0gJ2FsbCd9XG4gICAgICAgIGNsYXNzPXtgdGFiIHRhYi1zbSBzbTp0YWItbWQgd2hpdGVzcGFjZS1ub3dyYXAgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGhvdmVyOnRleHQtcHJpbWFyeSAke2FjdGl2ZUZpbHRlciA9PT0gJ2FsbCcgPyAndGFiLWFjdGl2ZScgOiAnJ31gfVxuICAgICAgPlxuICAgICAgICBBbGxcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgeyNlYWNoIGNhdGVnb3JpZXMgYXMgY2F0ZWdvcnl9XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbmNsaWNrPXsoKSA9PiBzZWxlY3RGaWx0ZXIoY2F0ZWdvcnkpfVxuICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9e2FjdGl2ZUZpbHRlciA9PT0gY2F0ZWdvcnl9XG4gICAgICAgICAgY2xhc3M9e2B0YWIgdGFiLXNtIHNtOnRhYi1tZCB3aGl0ZXNwYWNlLW5vd3JhcCBjYXBpdGFsaXplIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBob3Zlcjp0ZXh0LXByaW1hcnkgJHthY3RpdmVGaWx0ZXIgPT09IGNhdGVnb3J5ID8gJ3RhYi1hY3RpdmUnIDogJyd9YH1cbiAgICAgICAgPlxuICAgICAgICAgIHtjYXRlZ29yeX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICBcbjwvZGl2PlxuIiwgIjxzY3JpcHQ+XG4gIGNvbnN0IHRoZW1lcyA9IFtcbiAgICB7IHZhbHVlOiAnbGlnaHQnLCBsYWJlbDogJ0xpZ2h0JywgaWNvbjogJ+KYgO+4jycgfSxcbiAgICB7IHZhbHVlOiAnZGFyaycsIGxhYmVsOiAnRGFyaycsIGljb246ICfwn4yZJyB9LFxuICAgIHsgdmFsdWU6ICdkcmFjdWxhJywgbGFiZWw6ICdEcmFjdWxhJywgaWNvbjogJ/Cfp5snIH0sXG4gICAgeyB2YWx1ZTogJ3N5bnRod2F2ZScsIGxhYmVsOiAnU3ludGh3YXZlJywgaWNvbjogJ/CfjIYnIH0sXG4gICAgeyB2YWx1ZTogJ2J1c2luZXNzJywgbGFiZWw6ICdCdXNpbmVzcycsIGljb246ICfwn5K8JyB9LFxuICAgIHsgdmFsdWU6ICdkaW0nLCBsYWJlbDogJ0RpbScsIGljb246ICfwn4yRJyB9XG4gIF1cblxuICBsZXQgY3VycmVudFRoZW1lID0gJHN0YXRlKCdkYXJrJylcbiAgbGV0IGlzT3BlbiA9ICRzdGF0ZShmYWxzZSlcblxuICBmdW5jdGlvbiBhcHBseVRoZW1lKHRoZW1lKSB7XG4gICAgY3VycmVudFRoZW1lID0gdGhlbWVcbiAgICBpZiAodGhlbWUgPT09ICdzeXN0ZW0nKSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRoZW1lJylcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwaHg6dGhlbWUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJywgdGhlbWUpXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgc3RvcmFnZSBrZXkgYXMgUGhvZW5peCArIG90aGVyIHRvZ2dsZXNcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwaHg6dGhlbWUnLCB0aGVtZSlcbiAgICB9XG4gICAgLy8gTm90aWZ5IGxpc3RlbmVycyAoZS5nLiwgUGhvZW5peCBoZWFkIHNjcmlwdClcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3BoeDpzZXQtdGhlbWUnLCB7IGRldGFpbDogeyB0aGVtZSB9IH0pKVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0VGhlbWUodGhlbWUpIHtcbiAgICBhcHBseVRoZW1lKHRoZW1lKVxuICAgIGlzT3BlbiA9IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVEcm9wZG93bigpIHtcbiAgICBpc09wZW4gPSAhaXNPcGVuXG4gIH1cblxuICAvLyBDbG9zZSBkcm9wZG93biB3aGVuIGNsaWNraW5nIG91dHNpZGVcbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQuY2xvc2VzdCgnLnRoZW1lLXNlbGVjdG9yJykpIHtcbiAgICAgIGlzT3BlbiA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgJGVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3luYyBmcm9tIHBhZ2UvaGVhZCBpbml0aWFsaXphdGlvblxuICAgIGNvbnN0IHNhdmVkVGhlbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGh4OnRoZW1lJykgfHwgJ3N5c3RlbSdcbiAgICBpZiAoc2F2ZWRUaGVtZSA9PT0gJ3N5c3RlbScpIHtcbiAgICAgIGN1cnJlbnRUaGVtZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKSB8fCAnbGlnaHQnXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRUaGVtZSA9IHNhdmVkVGhlbWVcbiAgICB9XG5cbiAgICAvLyBLZWVwIGluIHN5bmMgd2l0aCBvdGhlciBjb250cm9scyAoTGF5b3V0cy50aGVtZV90b2dnbGUsIG90aGVyIHRhYnMpXG4gICAgY29uc3Qgc3RvcmFnZUhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSAncGh4OnRoZW1lJykge1xuICAgICAgICBjb25zdCBuZXh0ID0gZS5uZXdWYWx1ZSB8fCAnc3lzdGVtJ1xuICAgICAgICBjdXJyZW50VGhlbWUgPSBuZXh0ID09PSAnc3lzdGVtJyA/IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJykgfHwgJ2xpZ2h0JykgOiBuZXh0XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRoZW1lRXZlbnRIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLmRldGFpbD8udGhlbWUgPz8gZS50YXJnZXQ/LmRhdGFzZXQ/LnBoeFRoZW1lID8/ICdzeXN0ZW0nXG4gICAgICBjdXJyZW50VGhlbWUgPSBuZXh0ID09PSAnc3lzdGVtJyA/IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJykgfHwgJ2xpZ2h0JykgOiBuZXh0XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGlja091dHNpZGUpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBzdG9yYWdlSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGh4OnNldC10aGVtZScsIHRoZW1lRXZlbnRIYW5kbGVyKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrT3V0c2lkZSlcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgc3RvcmFnZUhhbmRsZXIpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGh4OnNldC10aGVtZScsIHRoZW1lRXZlbnRIYW5kbGVyKVxuICAgIH1cbiAgfSlcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwidGhlbWUtc2VsZWN0b3IgcmVsYXRpdmVcIj5cbiAgPGJ1dHRvblxuICAgIG9uY2xpY2s9e3RvZ2dsZURyb3Bkb3dufVxuICAgIGNsYXNzPVwiYnRuIGJ0bi1naG9zdCBidG4tc20gZ2FwLTJcIlxuICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgdGhlbWVcIlxuICA+XG4gICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LWxnXCI+e3RoZW1lcy5maW5kKHQgPT4gdC52YWx1ZSA9PT0gY3VycmVudFRoZW1lKT8uaWNvbiB8fCAn8J+MmSd9PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiaGlkZGVuIG1kOmlubGluZVwiPlRoZW1lPC9zcGFuPlxuICAgIDxzdmdcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgY2xhc3M9XCJoLTQgdy00IHRyYW5zaXRpb24tdHJhbnNmb3JtIHtpc09wZW4gPyAncm90YXRlLTE4MCcgOiAnJ31cIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgID5cbiAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE5IDlsLTcgNy03LTdcIiAvPlxuICAgIDwvc3ZnPlxuICA8L2J1dHRvbj5cblxuICB7I2lmIGlzT3Blbn1cbiAgICA8ZGl2IGNsYXNzPVwiYWJzb2x1dGUgcmlnaHQtMCBtdC0yIHctNDggYmctYmFzZS0yMDAgcm91bmRlZC1sZyBzaGFkb3cteGwgYm9yZGVyIGJvcmRlci1iYXNlLTMwMCB6LTUwXCI+XG4gICAgICA8dWwgY2xhc3M9XCJtZW51IHAtMlwiPlxuICAgICAgICB7I2VhY2ggdGhlbWVzIGFzIHRoZW1lfVxuICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgb25jbGljaz17KCkgPT4gc2VsZWN0VGhlbWUodGhlbWUudmFsdWUpfVxuICAgICAgICAgICAgICBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zIHtjdXJyZW50VGhlbWUgPT09IHRoZW1lLnZhbHVlID8gJ2FjdGl2ZSBiZy1wcmltYXJ5IHRleHQtcHJpbWFyeS1jb250ZW50JyA6ICcnfVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC1sZ1wiPnt0aGVtZS5pY29ufTwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4+e3RoZW1lLmxhYmVsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgeyNpZiBjdXJyZW50VGhlbWUgPT09IHRoZW1lLnZhbHVlfVxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoLTQgdy00IG1sLWF1dG9cIlxuICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUgMTNsNCA0TDE5IDdcIiAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgey9lYWNofVxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgey9pZn1cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC50aGVtZS1zZWxlY3RvciB7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iLCAiPHNjcmlwdD5cbiAgbGV0IGN1cnJlbnRUaGVtZSA9ICRzdGF0ZSgnbGlnaHQnKVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZVRoZW1lKCkge1xuICAgIGNvbnN0IG5ld1RoZW1lID0gY3VycmVudFRoZW1lID09PSAnbGlnaHQnID8gJ2RhcmsnIDogJ2xpZ2h0J1xuICAgIGN1cnJlbnRUaGVtZSA9IG5ld1RoZW1lXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS10aGVtZScsIG5ld1RoZW1lKVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwaHg6dGhlbWUnLCBuZXdUaGVtZSlcblxuICAgIC8vIERpc3BhdGNoIGV2ZW50IGZvciBvdGhlciBjb21wb25lbnRzXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdwaHg6c2V0LXRoZW1lJywge1xuICAgICAgZGV0YWlsOiB7IHRoZW1lOiBuZXdUaGVtZSB9XG4gICAgfSkpXG4gIH1cblxuICAkZWZmZWN0KCgpID0+IHtcbiAgICAvLyBHZXQgaW5pdGlhbCB0aGVtZVxuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwaHg6dGhlbWUnKVxuICAgIGNvbnN0IHByZWZlcnNEYXJrID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzXG4gICAgY3VycmVudFRoZW1lID0gc3RvcmVkIHx8IChwcmVmZXJzRGFyayA/ICdkYXJrJyA6ICdsaWdodCcpXG5cbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKSkge1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS10aGVtZScsIGN1cnJlbnRUaGVtZSlcbiAgICB9XG4gIH0pXG48L3NjcmlwdD5cblxuPGJ1dHRvblxuICBvbmNsaWNrPXt0b2dnbGVUaGVtZX1cbiAgY2xhc3M9XCJidG4gYnRuLWdob3N0IGJ0bi1jaXJjbGUgYnRuLXNtXCJcbiAgYXJpYS1sYWJlbD1cIlRvZ2dsZSB0aGVtZVwiXG4+XG4gIHsjaWYgY3VycmVudFRoZW1lID09PSAnbGlnaHQnfVxuICAgIDwhLS0gTW9vbiBpY29uIC0tPlxuICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjAgMjBcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk03LjQ1NSAyLjAwNGEuNzUuNzUgMCAwMS4yNi43NyA3IDcgMCAwMDkuOTU4IDcuOTY3Ljc1Ljc1IDAgMDExLjA2Ny44NTNBOC41IDguNSAwIDExNi42NDcgMS45MjFhLjc1Ljc1IDAgMDEuODA4LjA4M3pcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICA8L3N2Zz5cbiAgezplbHNlfVxuICAgIDwhLS0gU3VuIGljb24gLS0+XG4gICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyMCAyMFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTAgMmEuNzUuNzUgMCAwMS43NS43NXYxLjVhLjc1Ljc1IDAgMDEtMS41IDB2LTEuNUEuNzUuNzUgMCAwMTEwIDJ6TTEwIDE1YS43NS43NSAwIDAxLjc1Ljc1djEuNWEuNzUuNzUgMCAwMS0xLjUgMHYtMS41QS43NS43NSAwIDAxMTAgMTV6TTEwIDdhMyAzIDAgMTAwIDYgMyAzIDAgMDAwLTZ6TTE1LjY1NyA1LjQwNGEuNzUuNzUgMCAxMC0xLjA2LTEuMDZsLTEuMDYxIDEuMDZhLjc1Ljc1IDAgMDAxLjA2IDEuMDZsMS4wNi0xLjA2ek02LjQ2NCAxNC41OTZhLjc1Ljc1IDAgMTAtMS4wNi0xLjA2bC0xLjA2IDEuMDZhLjc1Ljc1IDAgMDAxLjA2IDEuMDZsMS4wNi0xLjA2ek0xOCAxMGEuNzUuNzUgMCAwMS0uNzUuNzVoLTEuNWEuNzUuNzUgMCAwMTAtMS41aDEuNUEuNzUuNzUgMCAwMTE4IDEwek01IDEwYS43NS43NSAwIDAxLS43NS43NWgtMS41YS43NS43NSAwIDAxMC0xLjVoMS41QS43NS43NSAwIDAxNSAxMHpNMTQuNTk2IDE1LjY1N2EuNzUuNzUgMCAwMDEuMDYtMS4wNmwtMS4wNi0xLjA2MWEuNzUuNzUgMCAxMC0xLjA2IDEuMDZsMS4wNiAxLjA2ek01LjQwNCA2LjQ2NGEuNzUuNzUgMCAwMDEuMDYtMS4wNmwtMS4wNi0xLjA2YS43NS43NSAwIDEwLTEuMDYxIDEuMDZsMS4wNiAxLjA2elwiIC8+XG4gICAgPC9zdmc+XG4gIHsvaWZ9XG48L2J1dHRvbj5cbiIsICI8c2NyaXB0PlxuICBsZXQgeyBkZWxheSA9IDAgfSA9ICRwcm9wcygpXG48L3NjcmlwdD5cblxuPGRpdlxuICBjbGFzcz1cImFic29sdXRlIGhpZGRlbiBsZzpibG9jayBib3R0b20tMjAgcmlnaHQtMTAgeGw6cmlnaHQtMzIgdy1hdXRvIGJnLWJhc2UtMTAwLzQwIGJhY2tkcm9wLWJsdXIteGwgYm9yZGVyIGJvcmRlci1iYXNlLTMwMC81MCBzaGFkb3ctWzBfMjBweF80MHB4Xy0xNXB4X3JnYmEoMCwwLDAsMC4xKV0gcm91bmRlZC0yeGwgcC00IGFuaW1hdGUtZmxvYXQgcm90YXRlLVszZGVnXVwiXG4gIHN0eWxlPVwiYW5pbWF0aW9uLWRlbGF5OiB7ZGVsYXl9c1wiXG4+XG4gIDxkaXYgY2xhc3M9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTMgcHItMlwiPlxuICAgIDxkaXYgY2xhc3M9XCJ3LTEwIGgtMTAgcm91bmRlZC14bCBiZy1bI0VBNEI3MV0gZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdGV4dC13aGl0ZSBzaGFkb3ctbGcgc2hhZG93LXBpbmstNTAwLzIwXCI+XG4gICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0xNS4zMTIgMTEuNDI0YTUuNSA1LjUgMCAwMS05LjIwMSAyLjQ2NmwtLjMxMi0uMzExaDIuNDMzYS43NS43NSAwIDAwMC0xLjVIMy45ODlhLjc1Ljc1IDAgMDAtLjc1Ljc1djQuMjQyYS43NS43NSAwIDAwMS41IDB2LTIuNDNsLjMxLjMxYTcgNyAwIDAwMTEuNzEyLTMuMTM4Ljc1Ljc1IDAgMDAtMS40NDktLjM5em0xLjIzLTMuNzIzYS43NS43NSAwIDAwLjIxOS0uNTNWMi45MjlhLjc1Ljc1IDAgMDAtMS41IDBWNS4zNmwtLjMxLS4zMUE3IDcgMCAwMDMuMjM5IDguMTg4YS43NS43NSAwIDEwMS40NDguMzg5QTUuNSA1LjUgMCAwMTEzLjg5IDYuMTFsLjMxMS4zMWgtMi40MzJhLjc1Ljc1IDAgMDAwIDEuNWg0LjI0M2EuNzUuNzUgMCAwMC41My0uMjE5elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInRleHQtbGVmdFwiPlxuICAgICAgPGRpdiBjbGFzcz1cInRleHQteHMgdGV4dC1iYXNlLWNvbnRlbnQvNjAgZm9udC1tZWRpdW1cIj5BY3RpdmUgV29ya2Zsb3c8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LXNtIGZvbnQtYm9sZCB0ZXh0LWJhc2UtY29udGVudFwiPkxlYWQgR2VuIEJvdCDCtyBSdW5uaW5nPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQWEsb0JBQ0EscUJBRUEsb0JBQ0Esa0JBQ0EscUJBRUEsb0JBQ0EsZ0JBQ0Esa0JBQ0EsbUJBQ0EsdUJBRUEsZUFDQSxnQkFDQSxtQkFFQSxtQkFDQSwwQkFDQSxrQkFDQSxxQkFFQSxpQkFFQSxzQkFDQSxlQUNBLGlCQUVBLHVCQUNBLGlDQUNBLGtCQUVBLGVBR0EsVUFDQSxLQUVBLGdCQUNBLGVBQ0Esa0JBdUJBO0FBL0RiO0FBQUE7QUFBTyxJQUFNLHFCQUFxQjtBQUMzQixJQUFNLHNCQUFzQixLQUFLO0FBRWpDLElBQU0scUJBQXFCLEtBQUs7QUFDaEMsSUFBTSxtQkFBbUIsS0FBSztBQUM5QixJQUFNLHNCQUFzQixLQUFLO0FBRWpDLElBQU0scUJBQXFCO0FBQzNCLElBQU0saUJBQWlCLEtBQUs7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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHVCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFBQztBQUNBO0FBQ0E7QUFDQSxJQUFBQztBQUNBO0FBQ0E7QUFDQTtB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Im5hbWVzIjogWyJlc2NhcGVkIiwgImNsc3giLCAiaGFzaCIsICJrZXkiLCAiZmFsbGJhY2siLCAiZWxlbWVudCIsICJpbml0X2NvbnN0YW50cyIsICJjb21wb25lbnQiLCAia2V5IiwgImluaXRfZXJyb3JzIiwgImh0bWwiLCAicHJvcCIsICJjaGlsZCIsICJuZXh0IiwgImluaXRfY29uc3RhbnRzIiwgInRhZyIsICJib2xkIiwgIm5vcm1hbCIsICJpbml0X3dhcm5pbmdzIiwgImVsZW1lbnQiLCAia2V5IiwgImluaXRfd2FybmluZ3MiLCAidHJhY2UiLCAic291cmNlIiwgImluaXRfY29uc3RhbnRzIiwgInN0YWNrIiwgImNvbnRleHQiLCAic3RhY2siLCAiY29tcG9uZW50IiwgImluaXRfZXJyb3JzIiwgImluaXRfY29uc3RhbnRzIiwgImVmZmVjdCIsICJjb250ZXh0IiwgImluaXRfY29uc3RhbnRzIiwgInNvdXJjZSIsICJzdGFjayIsICJ1cGRhdGUiLCAiZWZmZWN0IiwgImUiLCAiZmxhZ3MiLCAiaW5pdF9jb25zdGFudHMiLCAiaW5pdF9lcnJvcnMiLCAiY2hpbGQiLCAiYm91bmRhcnkiLCAiaW5pdF9jb25zdGFudHMiLCAiaW5pdF9lcnJvcnMiLCAiY29tbWVudCIsICJwZW5kaW5nIiwgInJlc2V0IiwgImVycm9yIiwgInN0YXRlIiwgImkiLCAiZmxhZ3MiLCAiZmFsbGJhY2siLCAiZWZmZWN0IiwgImtleSIsICJpdGVtIiwgInNlZW4iLCAibmV4dCIsICJpbmRleCIsICJpbml0X2NvbnN0YW50cyIsICJhc3luYyIsICJydW4iLCAicHJldmlvdXNfYmF0Y2giLCAiYm91bmRhcnkiLCAiaGFuZGxlX2Vycm9yIiwgImluaXRfY29uc3RhbnRzIiwgImZsYWdzIiwgImJvdW5kYXJ5IiwgImQiLCAibmV4dCIsICJkZXJpdmVkIiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfZXJyb3JzIiwgInN0YWNrIiwgInNvdXJjZSIsICJlZmZlY3QiLCAiZmxhZ3MiLCAiZGVyaXZlZCIsICJpbml0X2NvbnN0YW50cyIsICJpbml0X2Vycm9ycyIsICJzdGFjayIsICJ2ZXJzaW9uIiwgInByb3AiLCAic291cmNlIiwgInMiLCAidmFsdWUiLCAia2V5IiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfZXJyb3JzIiwgImFycmF5X3Byb3RvdHlwZSIsICJpbmRleCIsICJlcXVhbHMiLCAiaW5pdF9lcXVhbGl0eSIsICJpbml0X29wZXJhdGlvbnMiLCAiY2hpbGQiLCAidGV4dCIsICJmbGFncyIsICJ0YWciLCAiaXMiLCAiZWxlbWVudCIsICJrZXkiLCAiaW5pdF9lcXVhbGl0eSIsICJpbml0X2NvbnN0YW50cyIsICJuYW1lIiwgImVsZW1lbnQiLCAiZXZlbnQiLCAiZWZmZWN0IiwgImUiLCAiZGVyaXZlZCIsICJmbGFncyIsICJjb250ZXh0IiwgImFzeW5jIiwgInRlYXJkb3duIiwgImNvbnRyb2xsZXIiLCAibmV4dCIsICJ0cmFuc2l0aW9uIiwgImNoaWxkIiwgInNpYmxpbmciLCAiaW5pdF9jb25zdGFudHMiLCAiaW5pdF9lcnJvcnMiLCAiZWZmZWN0IiwgImZsYWdzIiwgImluZGV4IiwgInRlYXJkb3duIiwgInRyYWNlIiwgImRlcml2ZWQiLCAia2V5IiwgInByb3AiLCAiZ2V0IiwgImluaXRfY29uc3RhbnRzIiwgImhhc2giLCAiaW5pdF91dGlscyIsICJpbml0X3V0aWxzIiwgImhhc2giLCAiZWxlbWVudCIsICJjb21tZW50IiwgImluaXRfY29uc3RhbnRzIiwgImV2ZW50IiwgImNhcHR1cmUiLCAicGFzc2l2ZSIsICJlbGVtZW50IiwgImNvbXBvbmVudCIsICJodG1sIiwgImVmZmVjdCIsICJmbGFncyIsICJjbG9uZSIsICJhdHRyaWJ1dGVzIiwgImVsZW1lbnQiLCAia2V5IiwgImluaXRfY29uc3RhbnRzIiwgInRleHQiLCAiY29tcG9uZW50IiwgImluaXRfb3BlcmF0aW9ucyIsICJjb250ZXh0IiwgImV2ZW50cyIsICJwYXNzaXZlIiwgInVubW91bnQiLCAiYW5jaG9yX25vZGUiLCAiaW5pdF9lcnJvcnMiLCAiaW5pdF91dGlscyIsICJpbml0X2NvbnN0YW50cyIsICJlZmZlY3QiLCAic291cmNlIiwgImNvbXBvbmVudCIsICJpbml0X2NvbnN0YW50cyIsICJjb21wb25lbnQiLCAicHJvcCIsICJrZXkiLCAiaW5pdF9jb25zdGFudHMiLCAiaW5pdF91dGlscyIsICJjb21wb25lbnQiLCAiaW5pdF9sZWdhY3kiLCAiaW5pdF9lcnJvcnMiLCAic3RhY2siLCAiYm91bmRhcnkiLCAiaW5pdF9hc3luYyIsICJpbml0X2Vycm9ycyIsICJ0cmFuc2l0aW9uIiwgImtleSIsICJvZmZzY3JlZW4iLCAiZWZmZWN0IiwgImJyYW5jaCIsICJ2IiwgImZsYWdzIiwgImZuIiwgImluaXRfY29uc3RhbnRzIiwgImtleSIsICJlbGVtZW50IiwgImtleSIsICJlbGVtZW50IiwgImVmZmVjdCIsICJoYXNoIiwgIm5leHQiLCAiaHRtbCIsICJub2RlIiwgImluaXRfdXRpbHMiLCAiaW5pdF9jb25zdGFudHMiLCAia2V5IiwgInRhZyIsICJpbml0X3V0aWxzIiwgImluaXRfd2FybmluZ3MiLCAic25pcHBldCIsICJjb21wb25lbnQiLCAiaW5pdF9jb25zdGFudHMiLCAiaW5pdF9lcnJvcnMiLCAiY29tcG9uZW50IiwgImluaXRfY29uc3RhbnRzIiwgImVsZW1lbnQiLCAiYW5jaG9yIiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfdXRpbHMiLCAiaGFzaCIsICJpbml0X2NvbnN0YW50cyIsICJhcHBlbmRfc3R5bGVzIiwgImluaXRfY3NzIiwgImFjdGlvbiIsICJpbml0X2F0dGFjaG1lbnRzIiwgImhhc2giLCAia2V5IiwgIm5leHQiLCAia2V5IiwgImluaXRfc2VsZWN0IiwgImdldCIsICJzZXQiLCAiYmF0Y2hlcyIsICJzZXRfYXR0cmlidXRlIiwgImVsZW1lbnQiLCAiYXR0cmlidXRlcyIsICJwcm9wIiwgIm5leHQiLCAia2V5IiwgImNsc3giLCAiaW5wdXQiLCAiYXN5bmMiLCAiaW5pdF9zZWxlY3QiLCAiaW5pdF9hdHRyaWJ1dGVzIiwgImluaXRfY29uc3RhbnRzIiwgImluaXRfdXRpbHMiLCAiaW5pdF9hdHRhY2htZW50cyIsICJub3ciLCAiZWxlbWVudCIsICJhbmltYXRpb24iLCAidG8iLCAiZmxhZ3MiLCAidHJhbnNpdGlvbiIsICJydW4iLCAiYmxvY2siLCAiYWJvcnRlZCIsICJ0aWNrIiwgImtleWZyYW1lcyIsICJzdHlsZXMiLCAidCIsICJpbml0X2NvbnN0YW50cyIsICJ1cGRhdGUiLCAiZXZlbnQiLCAiZ2V0IiwgInNldCIsICJiYXRjaGVzIiwgImh5ZHJhdGlvbl9taXNtYXRjaCIsICJpbmRleCIsICJwZW5kaW5nIiwgImlucHV0IiwgImluaXRfZXJyb3JzIiwgImdldCIsICJzZXQiLCAidXBkYXRlIiwgInVwZGF0ZSIsICJwcm9wIiwgImVsZW1lbnQiLCAic2V0IiwgImxpc3RlbmVycyIsICJ1cGRhdGUiLCAiaW5pdF9jb25zdGFudHMiLCAiZWxlbWVudCIsICJnZXQiLCAic2V0IiwgImdldCIsICJzZXQiLCAiZXZlbnQiLCAiY29udGV4dCIsICJwcm9wcyIsICJrZXkiLCAiZXZlbnQiLCAia2V5IiwgImluaXRfbWlzYyIsICJnZXQiLCAiaW5pdF9zaGFyZWQiLCAiaW5pdF91dGlscyIsICJnZXQiLCAiaW5pdF91dGlscyIsICJpbml0X3NoYXJlZCIsICJrZXkiLCAiZmxhZ3MiLCAiZmFsbGJhY2siLCAiaW5pdF9wcm9wcyIsICJpbml0X2Vycm9ycyIsICJpbml0X2NvbnN0YW50cyIsICJrZXkiLCAiZWZmZWN0IiwgImluaXRfdmFsaWRhdGUiLCAiaW5pdF9lcnJvcnMiLCAiaW5pdF9jb25zdGFudHMiLCAiaW5pdF9lcnJvcnMiLCAia2V5IiwgInByb3AiLCAibmV4dCIsICJldmVudCIsICJwcm9wIiwgImVsZW1lbnQiLCAiZXhwb3J0cyIsICJrZXkiLCAiY29tcG9uZW50IiwgInNsb3QiLCAiYXR0ciIsICJpbml0X2NvbnN0YW50cyIsICJhcHBlbmRfc3R5bGVzIiwgImNsc3giLCAiZXF1YWxzIiwgImluaXRfc2VsZWN0IiwgInJ1biIsICJzZXRfYXR0cmlidXRlIiwgImluaXRfbGVnYWN5IiwgImluaXRfYXN5bmMiLCAiaW5pdF9jc3MiLCAiaW5pdF9hdHRhY2htZW50cyIsICJpbml0X2F0dHJpYnV0ZXMiLCAiaW5pdF9taXNjIiwgImluaXRfcHJvcHMiLCAiaW5pdF92YWxpZGF0ZSIsICJpbml0X2VxdWFsaXR5IiwgImluaXRfZXJyb3JzIiwgImluaXRfZXJyb3JzIiwgInJ1biIsICJpbml0X3V0aWxzIiwgImluaXRfaHlkcmF0aW9uIiwgImluaXRfY29uc3RhbnRzIiwgImtleSIsICJzdGFjayIsICJpbml0X2Vycm9ycyIsICJjcmVhdGVDb250ZXh0IiwgImtleSIsICJnZXRDb250ZXh0IiwgImNvbnRleHQiLCAic2V0Q29udGV4dCIsICJoYXNDb250ZXh0IiwgImdldEFsbENvbnRleHRzIiwgInB1c2giLCAicG9wIiwgInNzcl9jb250ZXh0IiwgImluaXRfY29udGV4dCIsICJpbml0X2Vycm9ycyIsICJrZXkiLCAic3RhY2siLCAiYm9sZCIsICJub3JtYWwiLCAiaW5pdF93YXJuaW5ncyIsICJpbml0X3JlbmRlcl9jb250ZXh0IiwgImluaXRfZXJyb3JzIiwgImluaXRfY29udGV4dCIsICJpbml0X2Vycm9ycyIsICJpbml0X3dhcm5pbmdzIiwgImluaXRfaHlkcmF0aW9uIiwgImhlYWQiLCAiY29udGV4dCIsICJjaGlsZCIsICJwdXNoIiwgInBvcCIsICJmbGFncyIsICJib2R5IiwgInIiLCAiY29tcG9uZW50IiwgImFzeW5jIiwgInJlc3VsdCIsICJpbml0X3JlbmRlcl9jb250ZXh0IiwgImtleSIsICJoYXNoIiwgImluaXRfaHRtbCIsICJpbml0X3V0aWxzIiwgImNoaWxkIiwgInIiLCAidGFnIiwgImNvbnRleHQiLCAiZWxlbWVudCIsICJtZXNzYWdlIiwgInN0YWNrIiwgImluaXRfZGV2IiwgImluaXRfY29udGV4dCIsICJpbml0X2Vycm9ycyIsICJjb21wb25lbnQiLCAiZmxhZ3MiLCAiY2xzeCIsICJoYXNoIiwgImtleSIsICJpbml0X3V0aWxzIiwgImluaXRfaHlkcmF0aW9uIiwgImluaXRfaHRtbCIsICJpbml0X2NvbnRleHQiLCAiaW5pdF9kZXYiLCAic2VydmVyX2V4cG9ydHMiLCAiaW5pdF9zZXJ2ZXIiLCAiZ2V0X3R5cGUiLCAia2V5IiwgImluaXRfdXRpbHMiLCAic3RyIiwgInZhbHVlIiwgImdldF90eXBlIiwgImtleSIsICJzdHJpbmdpZnkiLCAia2V5cyIsICJpbml0X3V0aWxzIiwgImh5ZHJhdGFibGUiLCAia2V5IiwgImNvbXBhcmUiLCAidmFsdWUiLCAidW5ldmFsIiwgImlzX3Byb21pc2UiLCAic3RhY2siLCAiaW5pdF9oeWRyYXRhYmxlIiwgImluaXRfZXJyb3JzIiwgImluaXRfZGV2IiwgImNyZWF0ZVJhd1NuaXBwZXQiLCAiaW5pdF9zbmlwcGV0IiwgImNyZWF0ZUNvbnRleHQiLCAiY3JlYXRlUmF3U25pcHBldCIsICJmb3JrIiwgImdldEFsbENvbnRleHRzIiwgImdldENvbnRleHQiLCAiaGFzQ29udGV4dCIsICJoeWRyYXRhYmxlIiwgImh5ZHJhdGUiLCAibW91bnQiLCAic2V0Q29udGV4dCIsICJzZXR0bGVkIiwgInRpY2siLCAidW5tb3VudCIsICJpbml0X2NvbnRleHQiLCAiaW5pdF9lcnJvcnMiLCAiaW5pdF9oeWRyYXRhYmxlIiwgImluaXRfc25pcHBldCIsICJfX2V4cG9ydCIsICJnZXRSZW5kZXIiLCAibW9kdWxlIiwgIl9fdG9Db21tb25KUyIsICJpbmRleCIsICJpbXBvcnRfc2VydmVyIiwgInIiLCAic25pcHBldCIsICJuYW1lIiwgImVsZW1lbnQiLCAia2V5IiwgInN0YXRlIiwgInNlcnZlcl9leHBvcnRzIiwgInJlbmRlciIsICJpbmNyZW1lbnQiLCAiZXZlbnQiLCAiZXZlbnQiLCAiZXZlbnQiLCAicmVuZGVyIl0KfQo=
